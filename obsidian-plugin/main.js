/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports, module2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var ReactVersion = "18.3.1";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: null
        };
        var ReactCurrentActQueue = {
          current: null,
          // Used to reproduce behavior of `batchedUpdates` in legacy mode.
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false
        };
        var ReactCurrentOwner = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
          ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
        }
        function warn(format2) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format2, args);
            }
          }
        }
        function error2(format2) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format2, args);
            }
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error2("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          /**
           * Checks whether or not this composite component is mounted.
           * @param {ReactClass} publicInstance The instance we want to test.
           * @return {boolean} True if mounted, false otherwise.
           * @protected
           * @final
           */
          isMounted: function(publicInstance) {
            return false;
          },
          /**
           * Forces an update. This should only be invoked when it is known with
           * certainty that we are **not** in a DOM transaction.
           *
           * You may want to call this when you know that some deeper aspect of the
           * component's state has changed but `setState` was not called.
           *
           * This will not invoke `shouldComponentUpdate`, but it will invoke
           * `componentWillUpdate` and `componentDidUpdate`.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          /**
           * Replaces all of the state. Always use this or `setState` to mutate state.
           * You should treat `this.state` as immutable.
           *
           * There is no guarantee that `this.state` will be immediately updated, so
           * accessing `this.state` after calling this method may return the old value.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} completeState Next state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          /**
           * Sets a subset of the state. This only exists because _pendingState is
           * internal. This provides a merging strategy that is not available to deep
           * properties which is confusing. TODO: Expose pendingState or don't use it
           * during the merge.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} partialState Next partial state to be merged with state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} Name of the calling function in the public API.
           * @internal
           */
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var assign3 = Object.assign;
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
            throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        assign3(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
          return isArrayImpl(a);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config2) {
          {
            if (hasOwnProperty.call(config2, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config2.ref !== void 0;
        }
        function hasValidKey(config2) {
          {
            if (hasOwnProperty.call(config2, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config2.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config2) {
          {
            if (typeof config2.ref === "string" && ReactCurrentOwner.current && config2.__self && ReactCurrentOwner.current.stateNode !== config2.__self) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config2.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement(type, config2, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config2 != null) {
            if (hasValidRef(config2)) {
              ref = config2.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config2);
              }
            }
            if (hasValidKey(config2)) {
              {
                checkKeyStringCoercion(config2.key);
              }
              key = "" + config2.key;
            }
            self2 = config2.__self === void 0 ? null : config2.__self;
            source = config2.__source === void 0 ? null : config2.__source;
            for (propName in config2) {
              if (hasOwnProperty.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config2[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config2, children) {
          if (element === null || element === void 0) {
            throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
          }
          var propName;
          var props = assign3({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config2 != null) {
            if (hasValidRef(config2)) {
              ref = config2.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config2)) {
              {
                checkKeyStringCoercion(config2.key);
              }
              key = "" + config2.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config2) {
              if (hasOwnProperty.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config2[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config2[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self2, source, owner, props);
        }
        function isValidElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape3(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key.replace(escapeRegex, function(match2) {
            return escaperLookup[match2];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text2) {
          return text2.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index) {
          if (typeof element === "object" && element !== null && element.key != null) {
            {
              checkKeyStringCoercion(element.key);
            }
            return escape3("" + element.key);
          }
          return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (isArray(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                return c;
              });
            } else if (mappedChild != null) {
              if (isValidElement(mappedChild)) {
                {
                  if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                    checkKeyStringCoercion(mappedChild.key);
                  }
                }
                mappedChild = cloneAndReplaceKey(
                  mappedChild,
                  // Keep both the (mapped) and old keys if they differ, just as
                  // traverseAllChildren used to do for objects as children
                  escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                  (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
                    // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                    // eslint-disable-next-line react-internal/safe-string-coercion
                    escapeUserProvidedKey("" + mappedChild.key) + "/"
                  ) : "") + childKey
                );
              }
              array.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              child = children[i];
              nextName = nextNamePrefix + getElementKey(child, i);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else if (type === "object") {
              var childrenString = String(children);
              throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function countChildren(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement(children)) {
            throw new Error("React.Children.only expected to receive a single React element child.");
          }
          return children;
        }
        function createContext(defaultValue) {
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            // As a workaround to support multiple concurrent renderers, we categorize
            // some renderers as primary and others as secondary. We only expect
            // there to be two concurrent renderers at most: React Native (primary) and
            // Fabric (secondary); React DOM (primary) and React ART (secondary).
            // Secondary renderers store their context values on separate fields.
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            // Used to track how many concurrent renderers this context currently
            // supports within in a single renderer. Such as parallel server rendering.
            _threadCount: 0,
            // These are circular
            Provider: null,
            Consumer: null,
            // Add these to use same hidden class in VM as ServerContext
            _defaultValue: null,
            _globalName: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error2("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error2("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            thenable.then(function(moduleObject2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = moduleObject2;
              }
            }, function(error3) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error3;
              }
            });
            if (payload._status === Uninitialized) {
              var pending = payload;
              pending._status = Pending;
              pending._result = thenable;
            }
          }
          if (payload._status === Resolved) {
            var moduleObject = payload._result;
            {
              if (moduleObject === void 0) {
                error2("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
              }
            }
            {
              if (!("default" in moduleObject)) {
                error2("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
              }
            }
            return moduleObject.default;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            // We use these fields to store the result.
            _status: Uninitialized,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error2("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error2("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error2("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error2("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error2("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error2("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name2) {
                ownName = name2;
                if (!render.name && !render.displayName) {
                  render.displayName = name2;
                }
              }
            });
          }
          return elementType;
        }
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function memo(type, compare) {
          {
            if (!isValidElementType(type)) {
              error2("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare === void 0 ? null : compare
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name2) {
                ownName = name2;
                if (!type.name && !type.displayName) {
                  type.displayName = name2;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          {
            if (dispatcher === null) {
              error2("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext(Context) {
          var dispatcher = resolveDispatcher();
          {
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error2("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error2("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context);
        }
        function useState8(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef3(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect7(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useInsertionEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useInsertionEffect(create, deps);
        }
        function useLayoutEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo2(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        function useTransition() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useTransition();
        }
        function useDeferredValue(value) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDeferredValue(value);
        }
        function useId() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useId();
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign3({}, props, {
                  value: prevLog
                }),
                info: assign3({}, props, {
                  value: prevInfo
                }),
                warn: assign3({}, props, {
                  value: prevWarn
                }),
                error: assign3({}, props, {
                  value: prevError
                }),
                group: assign3({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign3({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign3({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name2, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match2 = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match2 && match2[1] || "";
              }
            }
            return "\n" + prefix + name2;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name2 = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has2 = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has2(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error2("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name2 = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (name2) {
              return "\n\nCheck the render method of `" + name2 + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name2 = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name2, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error2("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error2("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], type);
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        function startTransition(scope, options) {
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = {};
          var currentTransition = ReactCurrentBatchConfig.transition;
          {
            ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            scope();
          } finally {
            ReactCurrentBatchConfig.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        var didWarnAboutMessageChannel = false;
        var enqueueTaskImpl = null;
        function enqueueTask(task) {
          if (enqueueTaskImpl === null) {
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              var nodeRequire = module2 && module2[requireString];
              enqueueTaskImpl = nodeRequire.call(module2, "timers").setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                {
                  if (didWarnAboutMessageChannel === false) {
                    didWarnAboutMessageChannel = true;
                    if (typeof MessageChannel === "undefined") {
                      error2("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                    }
                  }
                }
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          }
          return enqueueTaskImpl(task);
        }
        var actScopeDepth = 0;
        var didWarnNoAwaitAct = false;
        function act(callback) {
          {
            var prevActScopeDepth = actScopeDepth;
            actScopeDepth++;
            if (ReactCurrentActQueue.current === null) {
              ReactCurrentActQueue.current = [];
            }
            var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
            var result;
            try {
              ReactCurrentActQueue.isBatchingLegacy = true;
              result = callback();
              if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                var queue = ReactCurrentActQueue.current;
                if (queue !== null) {
                  ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                  flushActQueue(queue);
                }
              }
            } catch (error3) {
              popActScope(prevActScopeDepth);
              throw error3;
            } finally {
              ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
            }
            if (result !== null && typeof result === "object" && typeof result.then === "function") {
              var thenableResult = result;
              var wasAwaited = false;
              var thenable = {
                then: function(resolve, reject) {
                  wasAwaited = true;
                  thenableResult.then(function(returnValue2) {
                    popActScope(prevActScopeDepth);
                    if (actScopeDepth === 0) {
                      recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                    } else {
                      resolve(returnValue2);
                    }
                  }, function(error3) {
                    popActScope(prevActScopeDepth);
                    reject(error3);
                  });
                }
              };
              {
                if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                  Promise.resolve().then(function() {
                  }).then(function() {
                    if (!wasAwaited) {
                      didWarnNoAwaitAct = true;
                      error2("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                    }
                  });
                }
              }
              return thenable;
            } else {
              var returnValue = result;
              popActScope(prevActScopeDepth);
              if (actScopeDepth === 0) {
                var _queue = ReactCurrentActQueue.current;
                if (_queue !== null) {
                  flushActQueue(_queue);
                  ReactCurrentActQueue.current = null;
                }
                var _thenable = {
                  then: function(resolve, reject) {
                    if (ReactCurrentActQueue.current === null) {
                      ReactCurrentActQueue.current = [];
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    } else {
                      resolve(returnValue);
                    }
                  }
                };
                return _thenable;
              } else {
                var _thenable2 = {
                  then: function(resolve, reject) {
                    resolve(returnValue);
                  }
                };
                return _thenable2;
              }
            }
          }
        }
        function popActScope(prevActScopeDepth) {
          {
            if (prevActScopeDepth !== actScopeDepth - 1) {
              error2("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
            }
            actScopeDepth = prevActScopeDepth;
          }
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          {
            var queue = ReactCurrentActQueue.current;
            if (queue !== null) {
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  if (queue.length === 0) {
                    ReactCurrentActQueue.current = null;
                    resolve(returnValue);
                  } else {
                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  }
                });
              } catch (error3) {
                reject(error3);
              }
            } else {
              resolve(returnValue);
            }
          }
        }
        var isFlushing = false;
        function flushActQueue(queue) {
          {
            if (!isFlushing) {
              isFlushing = true;
              var i = 0;
              try {
                for (; i < queue.length; i++) {
                  var callback = queue[i];
                  do {
                    callback = callback(true);
                  } while (callback !== null);
                }
                queue.length = 0;
              } catch (error3) {
                queue = queue.slice(i + 1);
                throw error3;
              } finally {
                isFlushing = false;
              }
            }
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.act = act;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.startTransition = startTransition;
        exports.unstable_act = act;
        exports.useCallback = useCallback;
        exports.useContext = useContext;
        exports.useDebugValue = useDebugValue;
        exports.useDeferredValue = useDeferredValue;
        exports.useEffect = useEffect7;
        exports.useId = useId;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useInsertionEffect = useInsertionEffect;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo2;
        exports.useReducer = useReducer;
        exports.useRef = useRef3;
        exports.useState = useState8;
        exports.useSyncExternalStore = useSyncExternalStore;
        exports.useTransition = useTransition;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_development();
    }
  }
});

// node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
  "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var enableSchedulerDebugging = false;
        var enableProfiling = false;
        var frameYieldMs = 5;
        function push(heap, node) {
          var index = heap.length;
          heap.push(node);
          siftUp(heap, node, index);
        }
        function peek(heap) {
          return heap.length === 0 ? null : heap[0];
        }
        function pop(heap) {
          if (heap.length === 0) {
            return null;
          }
          var first = heap[0];
          var last = heap.pop();
          if (last !== first) {
            heap[0] = last;
            siftDown(heap, last, 0);
          }
          return first;
        }
        function siftUp(heap, node, i) {
          var index = i;
          while (index > 0) {
            var parentIndex = index - 1 >>> 1;
            var parent = heap[parentIndex];
            if (compare(parent, node) > 0) {
              heap[parentIndex] = node;
              heap[index] = parent;
              index = parentIndex;
            } else {
              return;
            }
          }
        }
        function siftDown(heap, node, i) {
          var index = i;
          var length = heap.length;
          var halfLength = length >>> 1;
          while (index < halfLength) {
            var leftIndex = (index + 1) * 2 - 1;
            var left = heap[leftIndex];
            var rightIndex = leftIndex + 1;
            var right = heap[rightIndex];
            if (compare(left, node) < 0) {
              if (rightIndex < length && compare(right, left) < 0) {
                heap[index] = right;
                heap[rightIndex] = node;
                index = rightIndex;
              } else {
                heap[index] = left;
                heap[leftIndex] = node;
                index = leftIndex;
              }
            } else if (rightIndex < length && compare(right, node) < 0) {
              heap[index] = right;
              heap[rightIndex] = node;
              index = rightIndex;
            } else {
              return;
            }
          }
        }
        function compare(a, b) {
          var diff = a.sortIndex - b.sortIndex;
          return diff !== 0 ? diff : a.id - b.id;
        }
        var ImmediatePriority = 1;
        var UserBlockingPriority = 2;
        var NormalPriority = 3;
        var LowPriority = 4;
        var IdlePriority = 5;
        function markTaskErrored(task, ms) {
        }
        var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
        if (hasPerformanceNow) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          var initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var maxSigned31BitInt = 1073741823;
        var IMMEDIATE_PRIORITY_TIMEOUT = -1;
        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
        var NORMAL_PRIORITY_TIMEOUT = 5e3;
        var LOW_PRIORITY_TIMEOUT = 1e4;
        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
        var taskQueue = [];
        var timerQueue = [];
        var taskIdCounter = 1;
        var currentTask = null;
        var currentPriorityLevel = NormalPriority;
        var isPerformingWork = false;
        var isHostCallbackScheduled = false;
        var isHostTimeoutScheduled = false;
        var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
        var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
        var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
        var isInputPending = typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
        function advanceTimers(currentTime) {
          var timer = peek(timerQueue);
          while (timer !== null) {
            if (timer.callback === null) {
              pop(timerQueue);
            } else if (timer.startTime <= currentTime) {
              pop(timerQueue);
              timer.sortIndex = timer.expirationTime;
              push(taskQueue, timer);
            } else {
              return;
            }
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled) {
            if (peek(taskQueue) !== null) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
            }
          }
        }
        function flushWork(hasTimeRemaining, initialTime2) {
          isHostCallbackScheduled = false;
          if (isHostTimeoutScheduled) {
            isHostTimeoutScheduled = false;
            cancelHostTimeout();
          }
          isPerformingWork = true;
          var previousPriorityLevel = currentPriorityLevel;
          try {
            if (enableProfiling) {
              try {
                return workLoop(hasTimeRemaining, initialTime2);
              } catch (error2) {
                if (currentTask !== null) {
                  var currentTime = exports.unstable_now();
                  markTaskErrored(currentTask, currentTime);
                  currentTask.isQueued = false;
                }
                throw error2;
              }
            } else {
              return workLoop(hasTimeRemaining, initialTime2);
            }
          } finally {
            currentTask = null;
            currentPriorityLevel = previousPriorityLevel;
            isPerformingWork = false;
          }
        }
        function workLoop(hasTimeRemaining, initialTime2) {
          var currentTime = initialTime2;
          advanceTimers(currentTime);
          currentTask = peek(taskQueue);
          while (currentTask !== null && !enableSchedulerDebugging) {
            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
              break;
            }
            var callback = currentTask.callback;
            if (typeof callback === "function") {
              currentTask.callback = null;
              currentPriorityLevel = currentTask.priorityLevel;
              var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
              var continuationCallback = callback(didUserCallbackTimeout);
              currentTime = exports.unstable_now();
              if (typeof continuationCallback === "function") {
                currentTask.callback = continuationCallback;
              } else {
                if (currentTask === peek(taskQueue)) {
                  pop(taskQueue);
                }
              }
              advanceTimers(currentTime);
            } else {
              pop(taskQueue);
            }
            currentTask = peek(taskQueue);
          }
          if (currentTask !== null) {
            return true;
          } else {
            var firstTimer = peek(timerQueue);
            if (firstTimer !== null) {
              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
            return false;
          }
        }
        function unstable_runWithPriority(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
            case LowPriority:
            case IdlePriority:
              break;
            default:
              priorityLevel = NormalPriority;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_next(eventHandler) {
          var priorityLevel;
          switch (currentPriorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
              priorityLevel = NormalPriority;
              break;
            default:
              priorityLevel = currentPriorityLevel;
              break;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_wrapCallback(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        }
        function unstable_scheduleCallback(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          var startTime2;
          if (typeof options === "object" && options !== null) {
            var delay = options.delay;
            if (typeof delay === "number" && delay > 0) {
              startTime2 = currentTime + delay;
            } else {
              startTime2 = currentTime;
            }
          } else {
            startTime2 = currentTime;
          }
          var timeout;
          switch (priorityLevel) {
            case ImmediatePriority:
              timeout = IMMEDIATE_PRIORITY_TIMEOUT;
              break;
            case UserBlockingPriority:
              timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
              break;
            case IdlePriority:
              timeout = IDLE_PRIORITY_TIMEOUT;
              break;
            case LowPriority:
              timeout = LOW_PRIORITY_TIMEOUT;
              break;
            case NormalPriority:
            default:
              timeout = NORMAL_PRIORITY_TIMEOUT;
              break;
          }
          var expirationTime = startTime2 + timeout;
          var newTask = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: startTime2,
            expirationTime,
            sortIndex: -1
          };
          if (startTime2 > currentTime) {
            newTask.sortIndex = startTime2;
            push(timerQueue, newTask);
            if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
              if (isHostTimeoutScheduled) {
                cancelHostTimeout();
              } else {
                isHostTimeoutScheduled = true;
              }
              requestHostTimeout(handleTimeout, startTime2 - currentTime);
            }
          } else {
            newTask.sortIndex = expirationTime;
            push(taskQueue, newTask);
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          return newTask;
        }
        function unstable_pauseExecution() {
        }
        function unstable_continueExecution() {
          if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
          }
        }
        function unstable_getFirstCallbackNode() {
          return peek(taskQueue);
        }
        function unstable_cancelCallback(task) {
          task.callback = null;
        }
        function unstable_getCurrentPriorityLevel() {
          return currentPriorityLevel;
        }
        var isMessageLoopRunning = false;
        var scheduledHostCallback = null;
        var taskTimeoutID = -1;
        var frameInterval = frameYieldMs;
        var startTime = -1;
        function shouldYieldToHost() {
          var timeElapsed = exports.unstable_now() - startTime;
          if (timeElapsed < frameInterval) {
            return false;
          }
          return true;
        }
        function requestPaint() {
        }
        function forceFrameRate(fps) {
          if (fps < 0 || fps > 125) {
            console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
            return;
          }
          if (fps > 0) {
            frameInterval = Math.floor(1e3 / fps);
          } else {
            frameInterval = frameYieldMs;
          }
        }
        var performWorkUntilDeadline = function() {
          if (scheduledHostCallback !== null) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasTimeRemaining = true;
            var hasMoreWork = true;
            try {
              hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
            } finally {
              if (hasMoreWork) {
                schedulePerformWorkUntilDeadline();
              } else {
                isMessageLoopRunning = false;
                scheduledHostCallback = null;
              }
            }
          } else {
            isMessageLoopRunning = false;
          }
        };
        var schedulePerformWorkUntilDeadline;
        if (typeof localSetImmediate === "function") {
          schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        } else if (typeof MessageChannel !== "undefined") {
          var channel = new MessageChannel();
          var port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else {
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        }
        function requestHostCallback(callback) {
          scheduledHostCallback = callback;
          if (!isMessageLoopRunning) {
            isMessageLoopRunning = true;
            schedulePerformWorkUntilDeadline();
          }
        }
        function requestHostTimeout(callback, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
          }, ms);
        }
        function cancelHostTimeout() {
          localClearTimeout(taskTimeoutID);
          taskTimeoutID = -1;
        }
        var unstable_requestPaint = requestPaint;
        var unstable_Profiling = null;
        exports.unstable_IdlePriority = IdlePriority;
        exports.unstable_ImmediatePriority = ImmediatePriority;
        exports.unstable_LowPriority = LowPriority;
        exports.unstable_NormalPriority = NormalPriority;
        exports.unstable_Profiling = unstable_Profiling;
        exports.unstable_UserBlockingPriority = UserBlockingPriority;
        exports.unstable_cancelCallback = unstable_cancelCallback;
        exports.unstable_continueExecution = unstable_continueExecution;
        exports.unstable_forceFrameRate = forceFrameRate;
        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
        exports.unstable_next = unstable_next;
        exports.unstable_pauseExecution = unstable_pauseExecution;
        exports.unstable_requestPaint = unstable_requestPaint;
        exports.unstable_runWithPriority = unstable_runWithPriority;
        exports.unstable_scheduleCallback = unstable_scheduleCallback;
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = unstable_wrapCallback;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/scheduler/index.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_scheduler_development();
    }
  }
});

// node_modules/react-dom/cjs/react-dom.development.js
var require_react_dom_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React12 = require_react();
        var Scheduler = require_scheduler();
        var ReactSharedInternals = React12.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        var suppressWarning = false;
        function setSuppressWarning(newSuppressWarning) {
          {
            suppressWarning = newSuppressWarning;
          }
        }
        function warn(format2) {
          {
            if (!suppressWarning) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format2, args);
            }
          }
        }
        function error2(format2) {
          {
            if (!suppressWarning) {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format2, args);
            }
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var FunctionComponent = 0;
        var ClassComponent = 1;
        var IndeterminateComponent = 2;
        var HostRoot = 3;
        var HostPortal = 4;
        var HostComponent = 5;
        var HostText = 6;
        var Fragment = 7;
        var Mode = 8;
        var ContextConsumer = 9;
        var ContextProvider = 10;
        var ForwardRef = 11;
        var Profiler = 12;
        var SuspenseComponent = 13;
        var MemoComponent = 14;
        var SimpleMemoComponent = 15;
        var LazyComponent = 16;
        var IncompleteClassComponent = 17;
        var DehydratedFragment = 18;
        var SuspenseListComponent = 19;
        var ScopeComponent = 21;
        var OffscreenComponent = 22;
        var LegacyHiddenComponent = 23;
        var CacheComponent = 24;
        var TracingMarkerComponent = 25;
        var enableClientRenderFallbackOnTextMismatch = true;
        var enableNewReconciler = false;
        var enableLazyContextPropagation = false;
        var enableLegacyHidden = false;
        var enableSuspenseAvoidThisFallback = false;
        var disableCommentsAsDOMContainers = true;
        var enableCustomElementPropertySupport = false;
        var warnAboutStringRefs = true;
        var enableSchedulingProfiler = true;
        var enableProfilerTimer = true;
        var enableProfilerCommitHooks = true;
        var allNativeEvents = /* @__PURE__ */ new Set();
        var registrationNameDependencies = {};
        var possibleRegistrationNames = {};
        function registerTwoPhaseEvent(registrationName, dependencies) {
          registerDirectEvent(registrationName, dependencies);
          registerDirectEvent(registrationName + "Capture", dependencies);
        }
        function registerDirectEvent(registrationName, dependencies) {
          {
            if (registrationNameDependencies[registrationName]) {
              error2("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
            }
          }
          registrationNameDependencies[registrationName] = dependencies;
          {
            var lowerCasedName = registrationName.toLowerCase();
            possibleRegistrationNames[lowerCasedName] = registrationName;
            if (registrationName === "onDoubleClick") {
              possibleRegistrationNames.ondblclick = registrationName;
            }
          }
          for (var i = 0; i < dependencies.length; i++) {
            allNativeEvents.add(dependencies[i]);
          }
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkPropStringCoercion(value, propName) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkHtmlStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkFormFieldValueStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error2("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error2("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldIgnoreAttribute(name2, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null) {
            return propertyInfo.type === RESERVED;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (name2.length > 2 && (name2[0] === "o" || name2[0] === "O") && (name2[1] === "n" || name2[1] === "N")) {
            return true;
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name2, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix2 = name2.toLowerCase().slice(0, 5);
                return prefix2 !== "data-" && prefix2 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function shouldRemoveAttribute(name2, value, propertyInfo, isCustomComponentTag) {
          if (value === null || typeof value === "undefined") {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name2, value, propertyInfo, isCustomComponentTag)) {
            return true;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (propertyInfo !== null) {
            switch (propertyInfo.type) {
              case BOOLEAN:
                return !value;
              case OVERLOADED_BOOLEAN:
                return value === false;
              case NUMERIC:
                return isNaN(value);
              case POSITIVE_NUMERIC:
                return isNaN(value) || value < 1;
            }
          }
          return false;
        }
        function getPropertyInfo(name2) {
          return properties.hasOwnProperty(name2) ? properties[name2] : null;
        }
        function PropertyInfoRecord(name2, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name2;
          this.type = type;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          // TODO: This prevents the assignment of defaultValue to regular
          // elements (not just inputs). Now that ReactDOMInput assigns to the
          // defaultValue property -- do we need this?
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            RESERVED,
            false,
            // mustUseProperty
            name2,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
          var name2 = _ref[0], attributeName = _ref[1];
          properties[name2] = new PropertyInfoRecord(
            name2,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name2.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name2,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "allowFullScreen",
          "async",
          // Note: there is a special case that prevents it from being written to the DOM
          // on the client side because the browsers are inconsistent. Instead we call focus().
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          // Microdata
          "itemScope"
        ].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            BOOLEAN,
            false,
            // mustUseProperty
            name2.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "checked",
          // Note: `option.selected` is not updated if `select.multiple` is
          // disabled with `removeAttribute`. We have special logic for handling this.
          "multiple",
          "muted",
          "selected"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            BOOLEAN,
            true,
            // mustUseProperty
            name2,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "capture",
          "download"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            OVERLOADED_BOOLEAN,
            false,
            // mustUseProperty
            name2,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "cols",
          "rows",
          "size",
          "span"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            POSITIVE_NUMERIC,
            false,
            // mustUseProperty
            name2,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["rowSpan", "start"].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            NUMERIC,
            false,
            // mustUseProperty
            name2.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token) {
          return token[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name2 = attributeName.replace(CAMELIZE, capitalize);
          properties[name2] = new PropertyInfoRecord(
            name2,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name2 = attributeName.replace(CAMELIZE, capitalize);
          properties[name2] = new PropertyInfoRecord(
            name2,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/1999/xlink",
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name2 = attributeName.replace(CAMELIZE, capitalize);
          properties[name2] = new PropertyInfoRecord(
            name2,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/XML/1998/namespace",
            false,
            // sanitizeURL
            false
          );
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord(
          "xlinkHref",
          STRING,
          false,
          // mustUseProperty
          "xlink:href",
          "http://www.w3.org/1999/xlink",
          true,
          // sanitizeURL
          false
        );
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            true,
            // sanitizeURL
            true
          );
        });
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error2("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        function getValueForProperty(node, name2, expected, propertyInfo) {
          {
            if (propertyInfo.mustUseProperty) {
              var propertyName = propertyInfo.propertyName;
              return node[propertyName];
            } else {
              {
                checkAttributeStringCoercion(expected, name2);
              }
              if (propertyInfo.sanitizeURL) {
                sanitizeURL("" + expected);
              }
              var attributeName = propertyInfo.attributeName;
              var stringValue = null;
              if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                if (node.hasAttribute(attributeName)) {
                  var value = node.getAttribute(attributeName);
                  if (value === "") {
                    return true;
                  }
                  if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                    return value;
                  }
                  if (value === "" + expected) {
                    return expected;
                  }
                  return value;
                }
              } else if (node.hasAttribute(attributeName)) {
                if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                  return node.getAttribute(attributeName);
                }
                if (propertyInfo.type === BOOLEAN) {
                  return expected;
                }
                stringValue = node.getAttribute(attributeName);
              }
              if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                return stringValue === null ? expected : stringValue;
              } else if (stringValue === "" + expected) {
                return expected;
              } else {
                return stringValue;
              }
            }
          }
        }
        function getValueForAttribute(node, name2, expected, isCustomComponentTag) {
          {
            if (!isAttributeNameSafe(name2)) {
              return;
            }
            if (!node.hasAttribute(name2)) {
              return expected === void 0 ? void 0 : null;
            }
            var value = node.getAttribute(name2);
            {
              checkAttributeStringCoercion(expected, name2);
            }
            if (value === "" + expected) {
              return expected;
            }
            return value;
          }
        }
        function setValueForProperty(node, name2, value, isCustomComponentTag) {
          var propertyInfo = getPropertyInfo(name2);
          if (shouldIgnoreAttribute(name2, propertyInfo, isCustomComponentTag)) {
            return;
          }
          if (shouldRemoveAttribute(name2, value, propertyInfo, isCustomComponentTag)) {
            value = null;
          }
          if (isCustomComponentTag || propertyInfo === null) {
            if (isAttributeNameSafe(name2)) {
              var _attributeName = name2;
              if (value === null) {
                node.removeAttribute(_attributeName);
              } else {
                {
                  checkAttributeStringCoercion(value, name2);
                }
                node.setAttribute(_attributeName, "" + value);
              }
            }
            return;
          }
          var mustUseProperty = propertyInfo.mustUseProperty;
          if (mustUseProperty) {
            var propertyName = propertyInfo.propertyName;
            if (value === null) {
              var type = propertyInfo.type;
              node[propertyName] = type === BOOLEAN ? false : "";
            } else {
              node[propertyName] = value;
            }
            return;
          }
          var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
          if (value === null) {
            node.removeAttribute(attributeName);
          } else {
            var _type = propertyInfo.type;
            var attributeValue;
            if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
              attributeValue = "";
            } else {
              {
                {
                  checkAttributeStringCoercion(value, attributeName);
                }
                attributeValue = "" + value;
              }
              if (propertyInfo.sanitizeURL) {
                sanitizeURL(attributeValue.toString());
              }
            }
            if (attributeNamespace) {
              node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
            } else {
              node.setAttribute(attributeName, attributeValue);
            }
          }
        }
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_SCOPE_TYPE = Symbol.for("react.scope");
        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
        var REACT_CACHE_TYPE = Symbol.for("react.cache");
        var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var assign3 = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign3({}, props, {
                  value: prevLog
                }),
                info: assign3({}, props, {
                  value: prevInfo
                }),
                warn: assign3({}, props, {
                  value: prevWarn
                }),
                error: assign3({}, props, {
                  value: prevError
                }),
                group: assign3({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign3({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign3({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name2, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match2 = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match2 && match2[1] || "";
              }
            }
            return "\n" + prefix + name2;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name2 = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, source, ownerFn) {
          {
            return describeNativeComponentFrame(ctor, true);
          }
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        function describeFiber(fiber) {
          var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
          var source = fiber._debugSource;
          switch (fiber.tag) {
            case HostComponent:
              return describeBuiltInComponentFrame(fiber.type);
            case LazyComponent:
              return describeBuiltInComponentFrame("Lazy");
            case SuspenseComponent:
              return describeBuiltInComponentFrame("Suspense");
            case SuspenseListComponent:
              return describeBuiltInComponentFrame("SuspenseList");
            case FunctionComponent:
            case IndeterminateComponent:
            case SimpleMemoComponent:
              return describeFunctionComponentFrame(fiber.type);
            case ForwardRef:
              return describeFunctionComponentFrame(fiber.type.render);
            case ClassComponent:
              return describeClassComponentFrame(fiber.type);
            default:
              return "";
          }
        }
        function getStackByFiberInDevAndProd(workInProgress2) {
          try {
            var info = "";
            var node = workInProgress2;
            do {
              info += describeFiber(node);
              node = node.return;
            } while (node);
            return info;
          } catch (x) {
            return "\nError generating stack: " + x.message + "\n" + x.stack;
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        function getWrappedName$1(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName$1(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromFiber(fiber) {
          var tag = fiber.tag, type = fiber.type;
          switch (tag) {
            case CacheComponent:
              return "Cache";
            case ContextConsumer:
              var context = type;
              return getContextName$1(context) + ".Consumer";
            case ContextProvider:
              var provider = type;
              return getContextName$1(provider._context) + ".Provider";
            case DehydratedFragment:
              return "DehydratedFragment";
            case ForwardRef:
              return getWrappedName$1(type, type.render, "ForwardRef");
            case Fragment:
              return "Fragment";
            case HostComponent:
              return type;
            case HostPortal:
              return "Portal";
            case HostRoot:
              return "Root";
            case HostText:
              return "Text";
            case LazyComponent:
              return getComponentNameFromType(type);
            case Mode:
              if (type === REACT_STRICT_MODE_TYPE) {
                return "StrictMode";
              }
              return "Mode";
            case OffscreenComponent:
              return "Offscreen";
            case Profiler:
              return "Profiler";
            case ScopeComponent:
              return "Scope";
            case SuspenseComponent:
              return "Suspense";
            case SuspenseListComponent:
              return "SuspenseList";
            case TracingMarkerComponent:
              return "TracingMarker";
            case ClassComponent:
            case FunctionComponent:
            case IncompleteClassComponent:
            case IndeterminateComponent:
            case MemoComponent:
            case SimpleMemoComponent:
              if (typeof type === "function") {
                return type.displayName || type.name || null;
              }
              if (typeof type === "string") {
                return type;
              }
              break;
          }
          return null;
        }
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var current = null;
        var isRendering = false;
        function getCurrentFiberOwnerNameInDevOrNull() {
          {
            if (current === null) {
              return null;
            }
            var owner = current._debugOwner;
            if (owner !== null && typeof owner !== "undefined") {
              return getComponentNameFromFiber(owner);
            }
          }
          return null;
        }
        function getCurrentFiberStackInDev() {
          {
            if (current === null) {
              return "";
            }
            return getStackByFiberInDevAndProd(current);
          }
        }
        function resetCurrentFiber() {
          {
            ReactDebugCurrentFrame.getCurrentStack = null;
            current = null;
            isRendering = false;
          }
        }
        function setCurrentFiber(fiber) {
          {
            ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
            current = fiber;
            isRendering = false;
          }
        }
        function getCurrentFiber() {
          {
            return current;
          }
        }
        function setIsRendering(rendering) {
          {
            isRendering = rendering;
          }
        }
        function toString(value) {
          return "" + value;
        }
        function getToStringValue(value) {
          switch (typeof value) {
            case "boolean":
            case "number":
            case "string":
            case "undefined":
              return value;
            case "object":
              {
                checkFormFieldValueStringCoercion(value);
              }
              return value;
            default:
              return "";
          }
        }
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props) {
          {
            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
              error2("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
              error2("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        function isCheckable(elem) {
          var type = elem.type;
          var nodeName = elem.nodeName;
          return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
        }
        function getTracker(node) {
          return node._valueTracker;
        }
        function detachTracker(node) {
          node._valueTracker = null;
        }
        function getValueFromNode(node) {
          var value = "";
          if (!node) {
            return value;
          }
          if (isCheckable(node)) {
            value = node.checked ? "true" : "false";
          } else {
            value = node.value;
          }
          return value;
        }
        function trackValueOnNode(node) {
          var valueField = isCheckable(node) ? "checked" : "value";
          var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
          {
            checkFormFieldValueStringCoercion(node[valueField]);
          }
          var currentValue = "" + node[valueField];
          if (node.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
            return;
          }
          var get2 = descriptor.get, set3 = descriptor.set;
          Object.defineProperty(node, valueField, {
            configurable: true,
            get: function() {
              return get2.call(this);
            },
            set: function(value) {
              {
                checkFormFieldValueStringCoercion(value);
              }
              currentValue = "" + value;
              set3.call(this, value);
            }
          });
          Object.defineProperty(node, valueField, {
            enumerable: descriptor.enumerable
          });
          var tracker = {
            getValue: function() {
              return currentValue;
            },
            setValue: function(value) {
              {
                checkFormFieldValueStringCoercion(value);
              }
              currentValue = "" + value;
            },
            stopTracking: function() {
              detachTracker(node);
              delete node[valueField];
            }
          };
          return tracker;
        }
        function track(node) {
          if (getTracker(node)) {
            return;
          }
          node._valueTracker = trackValueOnNode(node);
        }
        function updateValueIfChanged(node) {
          if (!node) {
            return false;
          }
          var tracker = getTracker(node);
          if (!tracker) {
            return true;
          }
          var lastValue = tracker.getValue();
          var nextValue = getValueFromNode(node);
          if (nextValue !== lastValue) {
            tracker.setValue(nextValue);
            return true;
          }
          return false;
        }
        function getActiveElement(doc) {
          doc = doc || (typeof document !== "undefined" ? document : void 0);
          if (typeof doc === "undefined") {
            return null;
          }
          try {
            return doc.activeElement || doc.body;
          } catch (e) {
            return doc.body;
          }
        }
        var didWarnValueDefaultValue = false;
        var didWarnCheckedDefaultChecked = false;
        var didWarnControlledToUncontrolled = false;
        var didWarnUncontrolledToControlled = false;
        function isControlled(props) {
          var usesChecked = props.type === "checkbox" || props.type === "radio";
          return usesChecked ? props.checked != null : props.value != null;
        }
        function getHostProps(element, props) {
          var node = element;
          var checked = props.checked;
          var hostProps = assign3({}, props, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: checked != null ? checked : node._wrapperState.initialChecked
          });
          return hostProps;
        }
        function initWrapperState(element, props) {
          {
            checkControlledValueProps("input", props);
            if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
              error2("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
              didWarnCheckedDefaultChecked = true;
            }
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
              error2("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
              didWarnValueDefaultValue = true;
            }
          }
          var node = element;
          var defaultValue = props.defaultValue == null ? "" : props.defaultValue;
          node._wrapperState = {
            initialChecked: props.checked != null ? props.checked : props.defaultChecked,
            initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
            controlled: isControlled(props)
          };
        }
        function updateChecked(element, props) {
          var node = element;
          var checked = props.checked;
          if (checked != null) {
            setValueForProperty(node, "checked", checked, false);
          }
        }
        function updateWrapper(element, props) {
          var node = element;
          {
            var controlled = isControlled(props);
            if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
              error2("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
              didWarnUncontrolledToControlled = true;
            }
            if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
              error2("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
              didWarnControlledToUncontrolled = true;
            }
          }
          updateChecked(element, props);
          var value = getToStringValue(props.value);
          var type = props.type;
          if (value != null) {
            if (type === "number") {
              if (value === 0 && node.value === "" || // We explicitly want to coerce to number here if possible.
              // eslint-disable-next-line
              node.value != value) {
                node.value = toString(value);
              }
            } else if (node.value !== toString(value)) {
              node.value = toString(value);
            }
          } else if (type === "submit" || type === "reset") {
            node.removeAttribute("value");
            return;
          }
          {
            if (props.hasOwnProperty("value")) {
              setDefaultValue(node, props.type, value);
            } else if (props.hasOwnProperty("defaultValue")) {
              setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
            }
          }
          {
            if (props.checked == null && props.defaultChecked != null) {
              node.defaultChecked = !!props.defaultChecked;
            }
          }
        }
        function postMountWrapper(element, props, isHydrating2) {
          var node = element;
          if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
            var type = props.type;
            var isButton = type === "submit" || type === "reset";
            if (isButton && (props.value === void 0 || props.value === null)) {
              return;
            }
            var initialValue = toString(node._wrapperState.initialValue);
            if (!isHydrating2) {
              {
                if (initialValue !== node.value) {
                  node.value = initialValue;
                }
              }
            }
            {
              node.defaultValue = initialValue;
            }
          }
          var name2 = node.name;
          if (name2 !== "") {
            node.name = "";
          }
          {
            node.defaultChecked = !node.defaultChecked;
            node.defaultChecked = !!node._wrapperState.initialChecked;
          }
          if (name2 !== "") {
            node.name = name2;
          }
        }
        function restoreControlledState(element, props) {
          var node = element;
          updateWrapper(node, props);
          updateNamedCousins(node, props);
        }
        function updateNamedCousins(rootNode, props) {
          var name2 = props.name;
          if (props.type === "radio" && name2 != null) {
            var queryRoot = rootNode;
            while (queryRoot.parentNode) {
              queryRoot = queryRoot.parentNode;
            }
            {
              checkAttributeStringCoercion(name2, "name");
            }
            var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name2) + '][type="radio"]');
            for (var i = 0; i < group.length; i++) {
              var otherNode = group[i];
              if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                continue;
              }
              var otherProps = getFiberCurrentPropsFromNode(otherNode);
              if (!otherProps) {
                throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
              }
              updateValueIfChanged(otherNode);
              updateWrapper(otherNode, otherProps);
            }
          }
        }
        function setDefaultValue(node, type, value) {
          if (
            // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
            type !== "number" || getActiveElement(node.ownerDocument) !== node
          ) {
            if (value == null) {
              node.defaultValue = toString(node._wrapperState.initialValue);
            } else if (node.defaultValue !== toString(value)) {
              node.defaultValue = toString(value);
            }
          }
        }
        var didWarnSelectedSetOnOption = false;
        var didWarnInvalidChild = false;
        var didWarnInvalidInnerHTML = false;
        function validateProps(element, props) {
          {
            if (props.value == null) {
              if (typeof props.children === "object" && props.children !== null) {
                React12.Children.forEach(props.children, function(child) {
                  if (child == null) {
                    return;
                  }
                  if (typeof child === "string" || typeof child === "number") {
                    return;
                  }
                  if (!didWarnInvalidChild) {
                    didWarnInvalidChild = true;
                    error2("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                  }
                });
              } else if (props.dangerouslySetInnerHTML != null) {
                if (!didWarnInvalidInnerHTML) {
                  didWarnInvalidInnerHTML = true;
                  error2("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                }
              }
            }
            if (props.selected != null && !didWarnSelectedSetOnOption) {
              error2("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
              didWarnSelectedSetOnOption = true;
            }
          }
        }
        function postMountWrapper$1(element, props) {
          if (props.value != null) {
            element.setAttribute("value", toString(getToStringValue(props.value)));
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
          return isArrayImpl(a);
        }
        var didWarnValueDefaultValue$1;
        {
          didWarnValueDefaultValue$1 = false;
        }
        function getDeclarationErrorAddendum() {
          var ownerName = getCurrentFiberOwnerNameInDevOrNull();
          if (ownerName) {
            return "\n\nCheck the render method of `" + ownerName + "`.";
          }
          return "";
        }
        var valuePropNames = ["value", "defaultValue"];
        function checkSelectPropTypes(props) {
          {
            checkControlledValueProps("select", props);
            for (var i = 0; i < valuePropNames.length; i++) {
              var propName = valuePropNames[i];
              if (props[propName] == null) {
                continue;
              }
              var propNameIsArray = isArray(props[propName]);
              if (props.multiple && !propNameIsArray) {
                error2("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
              } else if (!props.multiple && propNameIsArray) {
                error2("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
              }
            }
          }
        }
        function updateOptions(node, multiple, propValue, setDefaultSelected) {
          var options2 = node.options;
          if (multiple) {
            var selectedValues = propValue;
            var selectedValue = {};
            for (var i = 0; i < selectedValues.length; i++) {
              selectedValue["$" + selectedValues[i]] = true;
            }
            for (var _i = 0; _i < options2.length; _i++) {
              var selected = selectedValue.hasOwnProperty("$" + options2[_i].value);
              if (options2[_i].selected !== selected) {
                options2[_i].selected = selected;
              }
              if (selected && setDefaultSelected) {
                options2[_i].defaultSelected = true;
              }
            }
          } else {
            var _selectedValue = toString(getToStringValue(propValue));
            var defaultSelected = null;
            for (var _i2 = 0; _i2 < options2.length; _i2++) {
              if (options2[_i2].value === _selectedValue) {
                options2[_i2].selected = true;
                if (setDefaultSelected) {
                  options2[_i2].defaultSelected = true;
                }
                return;
              }
              if (defaultSelected === null && !options2[_i2].disabled) {
                defaultSelected = options2[_i2];
              }
            }
            if (defaultSelected !== null) {
              defaultSelected.selected = true;
            }
          }
        }
        function getHostProps$1(element, props) {
          return assign3({}, props, {
            value: void 0
          });
        }
        function initWrapperState$1(element, props) {
          var node = element;
          {
            checkSelectPropTypes(props);
          }
          node._wrapperState = {
            wasMultiple: !!props.multiple
          };
          {
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
              error2("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnValueDefaultValue$1 = true;
            }
          }
        }
        function postMountWrapper$2(element, props) {
          var node = element;
          node.multiple = !!props.multiple;
          var value = props.value;
          if (value != null) {
            updateOptions(node, !!props.multiple, value, false);
          } else if (props.defaultValue != null) {
            updateOptions(node, !!props.multiple, props.defaultValue, true);
          }
        }
        function postUpdateWrapper(element, props) {
          var node = element;
          var wasMultiple = node._wrapperState.wasMultiple;
          node._wrapperState.wasMultiple = !!props.multiple;
          var value = props.value;
          if (value != null) {
            updateOptions(node, !!props.multiple, value, false);
          } else if (wasMultiple !== !!props.multiple) {
            if (props.defaultValue != null) {
              updateOptions(node, !!props.multiple, props.defaultValue, true);
            } else {
              updateOptions(node, !!props.multiple, props.multiple ? [] : "", false);
            }
          }
        }
        function restoreControlledState$1(element, props) {
          var node = element;
          var value = props.value;
          if (value != null) {
            updateOptions(node, !!props.multiple, value, false);
          }
        }
        var didWarnValDefaultVal = false;
        function getHostProps$2(element, props) {
          var node = element;
          if (props.dangerouslySetInnerHTML != null) {
            throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
          }
          var hostProps = assign3({}, props, {
            value: void 0,
            defaultValue: void 0,
            children: toString(node._wrapperState.initialValue)
          });
          return hostProps;
        }
        function initWrapperState$2(element, props) {
          var node = element;
          {
            checkControlledValueProps("textarea", props);
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
              error2("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
              didWarnValDefaultVal = true;
            }
          }
          var initialValue = props.value;
          if (initialValue == null) {
            var children = props.children, defaultValue = props.defaultValue;
            if (children != null) {
              {
                error2("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
              }
              {
                if (defaultValue != null) {
                  throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                }
                if (isArray(children)) {
                  if (children.length > 1) {
                    throw new Error("<textarea> can only have at most one child.");
                  }
                  children = children[0];
                }
                defaultValue = children;
              }
            }
            if (defaultValue == null) {
              defaultValue = "";
            }
            initialValue = defaultValue;
          }
          node._wrapperState = {
            initialValue: getToStringValue(initialValue)
          };
        }
        function updateWrapper$1(element, props) {
          var node = element;
          var value = getToStringValue(props.value);
          var defaultValue = getToStringValue(props.defaultValue);
          if (value != null) {
            var newValue = toString(value);
            if (newValue !== node.value) {
              node.value = newValue;
            }
            if (props.defaultValue == null && node.defaultValue !== newValue) {
              node.defaultValue = newValue;
            }
          }
          if (defaultValue != null) {
            node.defaultValue = toString(defaultValue);
          }
        }
        function postMountWrapper$3(element, props) {
          var node = element;
          var textContent = node.textContent;
          if (textContent === node._wrapperState.initialValue) {
            if (textContent !== "" && textContent !== null) {
              node.value = textContent;
            }
          }
        }
        function restoreControlledState$2(element, props) {
          updateWrapper$1(element, props);
        }
        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
        var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        function getIntrinsicNamespace(type) {
          switch (type) {
            case "svg":
              return SVG_NAMESPACE;
            case "math":
              return MATH_NAMESPACE;
            default:
              return HTML_NAMESPACE;
          }
        }
        function getChildNamespace(parentNamespace, type) {
          if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
            return getIntrinsicNamespace(type);
          }
          if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
            return HTML_NAMESPACE;
          }
          return parentNamespace;
        }
        var createMicrosoftUnsafeLocalFunction = function(func) {
          if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
            return function(arg0, arg1, arg2, arg3) {
              MSApp.execUnsafeLocalFunction(function() {
                return func(arg0, arg1, arg2, arg3);
              });
            };
          } else {
            return func;
          }
        };
        var reusableSVGContainer;
        var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
          if (node.namespaceURI === SVG_NAMESPACE) {
            if (!("innerHTML" in node)) {
              reusableSVGContainer = reusableSVGContainer || document.createElement("div");
              reusableSVGContainer.innerHTML = "<svg>" + html.valueOf().toString() + "</svg>";
              var svgNode = reusableSVGContainer.firstChild;
              while (node.firstChild) {
                node.removeChild(node.firstChild);
              }
              while (svgNode.firstChild) {
                node.appendChild(svgNode.firstChild);
              }
              return;
            }
          }
          node.innerHTML = html;
        });
        var ELEMENT_NODE = 1;
        var TEXT_NODE = 3;
        var COMMENT_NODE = 8;
        var DOCUMENT_NODE = 9;
        var DOCUMENT_FRAGMENT_NODE = 11;
        var setTextContent = function(node, text2) {
          if (text2) {
            var firstChild = node.firstChild;
            if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
              firstChild.nodeValue = text2;
              return;
            }
          }
          node.textContent = text2;
        };
        var shorthandToLonghand = {
          animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
          background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
          backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
          border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
          borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
          borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
          borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
          borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
          borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
          borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
          borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
          borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
          borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
          borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
          borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
          columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
          columns: ["columnCount", "columnWidth"],
          flex: ["flexBasis", "flexGrow", "flexShrink"],
          flexFlow: ["flexDirection", "flexWrap"],
          font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
          fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
          gap: ["columnGap", "rowGap"],
          grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
          gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
          gridColumn: ["gridColumnEnd", "gridColumnStart"],
          gridColumnGap: ["columnGap"],
          gridGap: ["columnGap", "rowGap"],
          gridRow: ["gridRowEnd", "gridRowStart"],
          gridRowGap: ["rowGap"],
          gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
          listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
          margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
          marker: ["markerEnd", "markerMid", "markerStart"],
          mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
          maskPosition: ["maskPositionX", "maskPositionY"],
          outline: ["outlineColor", "outlineStyle", "outlineWidth"],
          overflow: ["overflowX", "overflowY"],
          padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
          placeContent: ["alignContent", "justifyContent"],
          placeItems: ["alignItems", "justifyItems"],
          placeSelf: ["alignSelf", "justifySelf"],
          textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
          textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
          transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
          wordWrap: ["overflowWrap"]
        };
        var isUnitlessNumber = {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related properties
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix2, key) {
          return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix2) {
            isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
          });
        });
        function dangerousStyleValue(name2, value, isCustomProperty) {
          var isEmpty2 = value == null || typeof value === "boolean" || value === "";
          if (isEmpty2) {
            return "";
          }
          if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name2) && isUnitlessNumber[name2])) {
            return value + "px";
          }
          {
            checkCSSPropertyStringCoercion(value, name2);
          }
          return ("" + value).trim();
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern = /^ms-/;
        function hyphenateStyleName(name2) {
          return name2.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern$1 = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string) {
            return string.replace(hyphenPattern, function(_, character) {
              return character.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name2) {
            if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
              return;
            }
            warnedStyleNames[name2] = true;
            error2(
              "Unsupported style property %s. Did you mean %s?",
              name2,
              // As Andi Smith suggests
              // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
              // is converted to lowercase `ms`.
              camelize(name2.replace(msPattern$1, "ms-"))
            );
          };
          var warnBadVendoredStyleName = function(name2) {
            if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
              return;
            }
            warnedStyleNames[name2] = true;
            error2("Unsupported vendor-prefixed style property %s. Did you mean %s?", name2, name2.charAt(0).toUpperCase() + name2.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name2, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error2(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name2, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name2, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error2("`NaN` is an invalid value for the `%s` css style property.", name2);
          };
          var warnStyleValueIsInfinity = function(name2, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error2("`Infinity` is an invalid value for the `%s` css style property.", name2);
          };
          warnValidStyle = function(name2, value) {
            if (name2.indexOf("-") > -1) {
              warnHyphenatedStyleName(name2);
            } else if (badVendoredStyleNamePattern.test(name2)) {
              warnBadVendoredStyleName(name2);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name2, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name2, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name2, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        function createDangerousStringForStyles(styles) {
          {
            var serialized = "";
            var delimiter2 = "";
            for (var styleName in styles) {
              if (!styles.hasOwnProperty(styleName)) {
                continue;
              }
              var styleValue = styles[styleName];
              if (styleValue != null) {
                var isCustomProperty = styleName.indexOf("--") === 0;
                serialized += delimiter2 + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
                serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                delimiter2 = ";";
              }
            }
            return serialized || null;
          }
        }
        function setValueForStyles(node, styles) {
          var style2 = node.style;
          for (var styleName in styles) {
            if (!styles.hasOwnProperty(styleName)) {
              continue;
            }
            var isCustomProperty = styleName.indexOf("--") === 0;
            {
              if (!isCustomProperty) {
                warnValidStyle$1(styleName, styles[styleName]);
              }
            }
            var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
            if (styleName === "float") {
              styleName = "cssFloat";
            }
            if (isCustomProperty) {
              style2.setProperty(styleName, styleValue);
            } else {
              style2[styleName] = styleValue;
            }
          }
        }
        function isValueEmpty(value) {
          return value == null || typeof value === "boolean" || value === "";
        }
        function expandShorthandMap(styles) {
          var expanded = {};
          for (var key in styles) {
            var longhands = shorthandToLonghand[key] || [key];
            for (var i = 0; i < longhands.length; i++) {
              expanded[longhands[i]] = key;
            }
          }
          return expanded;
        }
        function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
          {
            if (!nextStyles) {
              return;
            }
            var expandedUpdates = expandShorthandMap(styleUpdates);
            var expandedStyles = expandShorthandMap(nextStyles);
            var warnedAbout = {};
            for (var key in expandedUpdates) {
              var originalKey = expandedUpdates[key];
              var correctOriginalKey = expandedStyles[key];
              if (correctOriginalKey && originalKey !== correctOriginalKey) {
                var warningKey = originalKey + "," + correctOriginalKey;
                if (warnedAbout[warningKey]) {
                  continue;
                }
                warnedAbout[warningKey] = true;
                error2("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
              }
            }
          }
        }
        var omittedCloseTags = {
          area: true,
          base: true,
          br: true,
          col: true,
          embed: true,
          hr: true,
          img: true,
          input: true,
          keygen: true,
          link: true,
          meta: true,
          param: true,
          source: true,
          track: true,
          wbr: true
          // NOTE: menuitem's close tag should be omitted, but that causes problems.
        };
        var voidElementTags = assign3({
          menuitem: true
        }, omittedCloseTags);
        var HTML = "__html";
        function assertValidProps(tag, props) {
          if (!props) {
            return;
          }
          if (voidElementTags[tag]) {
            if (props.children != null || props.dangerouslySetInnerHTML != null) {
              throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            }
          }
          if (props.dangerouslySetInnerHTML != null) {
            if (props.children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof props.dangerouslySetInnerHTML !== "object" || !(HTML in props.dangerouslySetInnerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
          }
          {
            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
              error2("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
          }
          if (props.style != null && typeof props.style !== "object") {
            throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
          }
        }
        function isCustomComponent(tagName, props) {
          if (tagName.indexOf("-") === -1) {
            return typeof props.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var possibleStandardNames = {
          // HTML
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          // SVG
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var ariaProperties = {
          "aria-current": 0,
          // state
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          // state
          "aria-hidden": 0,
          // state
          "aria-invalid": 0,
          // state
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          // Widget Attributes
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          // Live Region Attributes
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          // Drag-and-Drop Attributes
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          // Relationship Attributes
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        function validateProperty(tagName, name2) {
          {
            if (hasOwnProperty.call(warnedProperties, name2) && warnedProperties[name2]) {
              return true;
            }
            if (rARIACamel.test(name2)) {
              var ariaName = "aria-" + name2.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error2("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name2);
                warnedProperties[name2] = true;
                return true;
              }
              if (name2 !== correctName) {
                error2("Invalid ARIA attribute `%s`. Did you mean `%s`?", name2, correctName);
                warnedProperties[name2] = true;
                return true;
              }
            }
            if (rARIA.test(name2)) {
              var lowerCasedName = name2.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name2] = true;
                return false;
              }
              if (name2 !== standardName) {
                error2("Unknown ARIA attribute `%s`. Did you mean `%s`?", name2, standardName);
                warnedProperties[name2] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type, props) {
          {
            var invalidProps = [];
            for (var key in props) {
              var isValid = validateProperty(type, key);
              if (!isValid) {
                invalidProps.push(key);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error2("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            } else if (invalidProps.length > 1) {
              error2("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            }
          }
        }
        function validateProperties(type, props) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnInvalidARIAProps(type, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type, props) {
          {
            if (type !== "input" && type !== "textarea" && type !== "select") {
              return;
            }
            if (props != null && props.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type === "select" && props.multiple) {
                error2("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
              } else {
                error2("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
              }
            }
          }
        }
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name2, value, eventRegistry) {
            if (hasOwnProperty.call(warnedProperties$1, name2) && warnedProperties$1[name2]) {
              return true;
            }
            var lowerCasedName = name2.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error2("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name2] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies2.hasOwnProperty(name2)) {
                return true;
              }
              var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
              if (registrationName != null) {
                error2("Invalid event handler property `%s`. Did you mean `%s`?", name2, registrationName);
                warnedProperties$1[name2] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name2)) {
                error2("Unknown event handler property `%s`. It will be ignored.", name2);
                warnedProperties$1[name2] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name2)) {
              if (INVALID_EVENT_NAME_REGEX.test(name2)) {
                error2("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name2);
              }
              warnedProperties$1[name2] = true;
              return true;
            }
            if (rARIA$1.test(name2) || rARIACamel$1.test(name2)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error2("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name2] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error2("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name2] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error2("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name2] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error2("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name2);
              warnedProperties$1[name2] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name2);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name2) {
                error2("Invalid DOM property `%s`. Did you mean `%s`?", name2, standardName);
                warnedProperties$1[name2] = true;
                return true;
              }
            } else if (!isReserved && name2 !== lowerCasedName) {
              error2("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name2, lowerCasedName);
              warnedProperties$1[name2] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name2, value, propertyInfo, false)) {
              if (value) {
                error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name2, name2, value, name2);
              } else {
                error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name2, name2, value, name2, name2, name2);
              }
              warnedProperties$1[name2] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name2, value, propertyInfo, false)) {
              warnedProperties$1[name2] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error2("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name2, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name2, value);
              warnedProperties$1[name2] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type, props, eventRegistry) {
          {
            var unknownProps = [];
            for (var key in props) {
              var isValid = validateProperty$1(type, key, props[key], eventRegistry);
              if (!isValid) {
                unknownProps.push(key);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error2("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            } else if (unknownProps.length > 1) {
              error2("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            }
          }
        };
        function validateProperties$2(type, props, eventRegistry) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnUnknownProperties(type, props, eventRegistry);
        }
        var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
        var IS_NON_DELEGATED = 1 << 1;
        var IS_CAPTURE_PHASE = 1 << 2;
        var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
        var currentReplayingEvent = null;
        function setReplayingEvent(event) {
          {
            if (currentReplayingEvent !== null) {
              error2("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          currentReplayingEvent = event;
        }
        function resetReplayingEvent() {
          {
            if (currentReplayingEvent === null) {
              error2("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          currentReplayingEvent = null;
        }
        function isReplayingEvent(event) {
          return event === currentReplayingEvent;
        }
        function getEventTarget(nativeEvent) {
          var target = nativeEvent.target || nativeEvent.srcElement || window;
          if (target.correspondingUseElement) {
            target = target.correspondingUseElement;
          }
          return target.nodeType === TEXT_NODE ? target.parentNode : target;
        }
        var restoreImpl = null;
        var restoreTarget = null;
        var restoreQueue = null;
        function restoreStateOfTarget(target) {
          var internalInstance = getInstanceFromNode(target);
          if (!internalInstance) {
            return;
          }
          if (typeof restoreImpl !== "function") {
            throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
          }
          var stateNode = internalInstance.stateNode;
          if (stateNode) {
            var _props = getFiberCurrentPropsFromNode(stateNode);
            restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
          }
        }
        function setRestoreImplementation(impl) {
          restoreImpl = impl;
        }
        function enqueueStateRestore(target) {
          if (restoreTarget) {
            if (restoreQueue) {
              restoreQueue.push(target);
            } else {
              restoreQueue = [target];
            }
          } else {
            restoreTarget = target;
          }
        }
        function needsStateRestore() {
          return restoreTarget !== null || restoreQueue !== null;
        }
        function restoreStateIfNeeded() {
          if (!restoreTarget) {
            return;
          }
          var target = restoreTarget;
          var queuedTargets = restoreQueue;
          restoreTarget = null;
          restoreQueue = null;
          restoreStateOfTarget(target);
          if (queuedTargets) {
            for (var i = 0; i < queuedTargets.length; i++) {
              restoreStateOfTarget(queuedTargets[i]);
            }
          }
        }
        var batchedUpdatesImpl = function(fn, bookkeeping) {
          return fn(bookkeeping);
        };
        var flushSyncImpl = function() {
        };
        var isInsideEventHandler = false;
        function finishEventHandler() {
          var controlledComponentsHavePendingUpdates = needsStateRestore();
          if (controlledComponentsHavePendingUpdates) {
            flushSyncImpl();
            restoreStateIfNeeded();
          }
        }
        function batchedUpdates(fn, a, b) {
          if (isInsideEventHandler) {
            return fn(a, b);
          }
          isInsideEventHandler = true;
          try {
            return batchedUpdatesImpl(fn, a, b);
          } finally {
            isInsideEventHandler = false;
            finishEventHandler();
          }
        }
        function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {
          batchedUpdatesImpl = _batchedUpdatesImpl;
          flushSyncImpl = _flushSyncImpl;
        }
        function isInteractive(tag) {
          return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
        }
        function shouldPreventMouseEvent(name2, type, props) {
          switch (name2) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              return !!(props.disabled && isInteractive(type));
            default:
              return false;
          }
        }
        function getListener(inst, registrationName) {
          var stateNode = inst.stateNode;
          if (stateNode === null) {
            return null;
          }
          var props = getFiberCurrentPropsFromNode(stateNode);
          if (props === null) {
            return null;
          }
          var listener = props[registrationName];
          if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
            return null;
          }
          if (listener && typeof listener !== "function") {
            throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
          }
          return listener;
        }
        var passiveBrowserEventsSupported = false;
        if (canUseDOM) {
          try {
            var options = {};
            Object.defineProperty(options, "passive", {
              get: function() {
                passiveBrowserEventsSupported = true;
              }
            });
            window.addEventListener("test", options, options);
            window.removeEventListener("test", options, options);
          } catch (e) {
            passiveBrowserEventsSupported = false;
          }
        }
        function invokeGuardedCallbackProd(name2, func, context, a, b, c, d, e, f) {
          var funcArgs = Array.prototype.slice.call(arguments, 3);
          try {
            func.apply(context, funcArgs);
          } catch (error3) {
            this.onError(error3);
          }
        }
        var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
        {
          if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
            var fakeNode = document.createElement("react");
            invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name2, func, context, a, b, c, d, e, f) {
              if (typeof document === "undefined" || document === null) {
                throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
              }
              var evt = document.createEvent("Event");
              var didCall = false;
              var didError = true;
              var windowEvent = window.event;
              var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
              function restoreAfterDispatch() {
                fakeNode.removeEventListener(evtType, callCallback2, false);
                if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                  window.event = windowEvent;
                }
              }
              var funcArgs = Array.prototype.slice.call(arguments, 3);
              function callCallback2() {
                didCall = true;
                restoreAfterDispatch();
                func.apply(context, funcArgs);
                didError = false;
              }
              var error3;
              var didSetError = false;
              var isCrossOriginError = false;
              function handleWindowError(event) {
                error3 = event.error;
                didSetError = true;
                if (error3 === null && event.colno === 0 && event.lineno === 0) {
                  isCrossOriginError = true;
                }
                if (event.defaultPrevented) {
                  if (error3 != null && typeof error3 === "object") {
                    try {
                      error3._suppressLogging = true;
                    } catch (inner) {
                    }
                  }
                }
              }
              var evtType = "react-" + (name2 ? name2 : "invokeguardedcallback");
              window.addEventListener("error", handleWindowError);
              fakeNode.addEventListener(evtType, callCallback2, false);
              evt.initEvent(evtType, false, false);
              fakeNode.dispatchEvent(evt);
              if (windowEventDescriptor) {
                Object.defineProperty(window, "event", windowEventDescriptor);
              }
              if (didCall && didError) {
                if (!didSetError) {
                  error3 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
                } else if (isCrossOriginError) {
                  error3 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                }
                this.onError(error3);
              }
              window.removeEventListener("error", handleWindowError);
              if (!didCall) {
                restoreAfterDispatch();
                return invokeGuardedCallbackProd.apply(this, arguments);
              }
            };
          }
        }
        var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
        var hasError = false;
        var caughtError = null;
        var hasRethrowError = false;
        var rethrowError = null;
        var reporter = {
          onError: function(error3) {
            hasError = true;
            caughtError = error3;
          }
        };
        function invokeGuardedCallback(name2, func, context, a, b, c, d, e, f) {
          hasError = false;
          caughtError = null;
          invokeGuardedCallbackImpl$1.apply(reporter, arguments);
        }
        function invokeGuardedCallbackAndCatchFirstError(name2, func, context, a, b, c, d, e, f) {
          invokeGuardedCallback.apply(this, arguments);
          if (hasError) {
            var error3 = clearCaughtError();
            if (!hasRethrowError) {
              hasRethrowError = true;
              rethrowError = error3;
            }
          }
        }
        function rethrowCaughtError() {
          if (hasRethrowError) {
            var error3 = rethrowError;
            hasRethrowError = false;
            rethrowError = null;
            throw error3;
          }
        }
        function hasCaughtError() {
          return hasError;
        }
        function clearCaughtError() {
          if (hasError) {
            var error3 = caughtError;
            hasError = false;
            caughtError = null;
            return error3;
          } else {
            throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        function get(key) {
          return key._reactInternals;
        }
        function has2(key) {
          return key._reactInternals !== void 0;
        }
        function set2(key, value) {
          key._reactInternals = value;
        }
        var NoFlags = (
          /*                      */
          0
        );
        var PerformedWork = (
          /*                */
          1
        );
        var Placement = (
          /*                    */
          2
        );
        var Update = (
          /*                       */
          4
        );
        var ChildDeletion = (
          /*                */
          16
        );
        var ContentReset = (
          /*                 */
          32
        );
        var Callback = (
          /*                     */
          64
        );
        var DidCapture = (
          /*                   */
          128
        );
        var ForceClientRender = (
          /*            */
          256
        );
        var Ref = (
          /*                          */
          512
        );
        var Snapshot = (
          /*                     */
          1024
        );
        var Passive = (
          /*                      */
          2048
        );
        var Hydrating = (
          /*                    */
          4096
        );
        var Visibility = (
          /*                   */
          8192
        );
        var StoreConsistency = (
          /*             */
          16384
        );
        var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency;
        var HostEffectMask = (
          /*               */
          32767
        );
        var Incomplete = (
          /*                   */
          32768
        );
        var ShouldCapture = (
          /*                */
          65536
        );
        var ForceUpdateForLegacySuspense = (
          /* */
          131072
        );
        var Forked = (
          /*                       */
          1048576
        );
        var RefStatic = (
          /*                    */
          2097152
        );
        var LayoutStatic = (
          /*                 */
          4194304
        );
        var PassiveStatic = (
          /*                */
          8388608
        );
        var MountLayoutDev = (
          /*               */
          16777216
        );
        var MountPassiveDev = (
          /*              */
          33554432
        );
        var BeforeMutationMask = (
          // TODO: Remove Update flag from before mutation phase by re-landing Visibility
          // flag logic (see #20043)
          Update | Snapshot | 0
        );
        var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;
        var LayoutMask = Update | Callback | Ref | Visibility;
        var PassiveMask = Passive | ChildDeletion;
        var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        function getNearestMountedFiber(fiber) {
          var node = fiber;
          var nearestMounted = fiber;
          if (!fiber.alternate) {
            var nextNode = node;
            do {
              node = nextNode;
              if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
                nearestMounted = node.return;
              }
              nextNode = node.return;
            } while (nextNode);
          } else {
            while (node.return) {
              node = node.return;
            }
          }
          if (node.tag === HostRoot) {
            return nearestMounted;
          }
          return null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
          if (fiber.tag === SuspenseComponent) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState === null) {
              var current2 = fiber.alternate;
              if (current2 !== null) {
                suspenseState = current2.memoizedState;
              }
            }
            if (suspenseState !== null) {
              return suspenseState.dehydrated;
            }
          }
          return null;
        }
        function getContainerFromFiber(fiber) {
          return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
        }
        function isFiberMounted(fiber) {
          return getNearestMountedFiber(fiber) === fiber;
        }
        function isMounted(component) {
          {
            var owner = ReactCurrentOwner.current;
            if (owner !== null && owner.tag === ClassComponent) {
              var ownerFiber = owner;
              var instance = ownerFiber.stateNode;
              if (!instance._warnedAboutRefsInRender) {
                error2("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component");
              }
              instance._warnedAboutRefsInRender = true;
            }
          }
          var fiber = get(component);
          if (!fiber) {
            return false;
          }
          return getNearestMountedFiber(fiber) === fiber;
        }
        function assertIsMounted(fiber) {
          if (getNearestMountedFiber(fiber) !== fiber) {
            throw new Error("Unable to find node on an unmounted component.");
          }
        }
        function findCurrentFiberUsingSlowPath(fiber) {
          var alternate = fiber.alternate;
          if (!alternate) {
            var nearestMounted = getNearestMountedFiber(fiber);
            if (nearestMounted === null) {
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (nearestMounted !== fiber) {
              return null;
            }
            return fiber;
          }
          var a = fiber;
          var b = alternate;
          while (true) {
            var parentA = a.return;
            if (parentA === null) {
              break;
            }
            var parentB = parentA.alternate;
            if (parentB === null) {
              var nextParent = parentA.return;
              if (nextParent !== null) {
                a = b = nextParent;
                continue;
              }
              break;
            }
            if (parentA.child === parentB.child) {
              var child = parentA.child;
              while (child) {
                if (child === a) {
                  assertIsMounted(parentA);
                  return fiber;
                }
                if (child === b) {
                  assertIsMounted(parentA);
                  return alternate;
                }
                child = child.sibling;
              }
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (a.return !== b.return) {
              a = parentA;
              b = parentB;
            } else {
              var didFindChild = false;
              var _child = parentA.child;
              while (_child) {
                if (_child === a) {
                  didFindChild = true;
                  a = parentA;
                  b = parentB;
                  break;
                }
                if (_child === b) {
                  didFindChild = true;
                  b = parentA;
                  a = parentB;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                _child = parentB.child;
                while (_child) {
                  if (_child === a) {
                    didFindChild = true;
                    a = parentB;
                    b = parentA;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentB;
                    a = parentA;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                }
              }
            }
            if (a.alternate !== b) {
              throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          if (a.tag !== HostRoot) {
            throw new Error("Unable to find node on an unmounted component.");
          }
          if (a.stateNode.current === a) {
            return fiber;
          }
          return alternate;
        }
        function findCurrentHostFiber(parent) {
          var currentParent = findCurrentFiberUsingSlowPath(parent);
          return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
        }
        function findCurrentHostFiberImpl(node) {
          if (node.tag === HostComponent || node.tag === HostText) {
            return node;
          }
          var child = node.child;
          while (child !== null) {
            var match2 = findCurrentHostFiberImpl(child);
            if (match2 !== null) {
              return match2;
            }
            child = child.sibling;
          }
          return null;
        }
        function findCurrentHostFiberWithNoPortals(parent) {
          var currentParent = findCurrentFiberUsingSlowPath(parent);
          return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
        }
        function findCurrentHostFiberWithNoPortalsImpl(node) {
          if (node.tag === HostComponent || node.tag === HostText) {
            return node;
          }
          var child = node.child;
          while (child !== null) {
            if (child.tag !== HostPortal) {
              var match2 = findCurrentHostFiberWithNoPortalsImpl(child);
              if (match2 !== null) {
                return match2;
              }
            }
            child = child.sibling;
          }
          return null;
        }
        var scheduleCallback = Scheduler.unstable_scheduleCallback;
        var cancelCallback = Scheduler.unstable_cancelCallback;
        var shouldYield = Scheduler.unstable_shouldYield;
        var requestPaint = Scheduler.unstable_requestPaint;
        var now = Scheduler.unstable_now;
        var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
        var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
        var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
        var NormalPriority = Scheduler.unstable_NormalPriority;
        var LowPriority = Scheduler.unstable_LowPriority;
        var IdlePriority = Scheduler.unstable_IdlePriority;
        var unstable_yieldValue = Scheduler.unstable_yieldValue;
        var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
        var rendererID = null;
        var injectedHook = null;
        var injectedProfilingHooks = null;
        var hasLoggedError = false;
        var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
        function injectInternals(internals) {
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
            return false;
          }
          var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook.isDisabled) {
            return true;
          }
          if (!hook.supportsFiber) {
            {
              error2("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
            }
            return true;
          }
          try {
            if (enableSchedulingProfiler) {
              internals = assign3({}, internals, {
                getLaneLabelMap,
                injectProfilingHooks
              });
            }
            rendererID = hook.inject(internals);
            injectedHook = hook;
          } catch (err) {
            {
              error2("React instrumentation encountered an error: %s.", err);
            }
          }
          if (hook.checkDCE) {
            return true;
          } else {
            return false;
          }
        }
        function onScheduleRoot(root2, children) {
          {
            if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
              try {
                injectedHook.onScheduleFiberRoot(rendererID, root2, children);
              } catch (err) {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error2("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function onCommitRoot(root2, eventPriority) {
          if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
            try {
              var didError = (root2.current.flags & DidCapture) === DidCapture;
              if (enableProfilerTimer) {
                var schedulerPriority;
                switch (eventPriority) {
                  case DiscreteEventPriority:
                    schedulerPriority = ImmediatePriority;
                    break;
                  case ContinuousEventPriority:
                    schedulerPriority = UserBlockingPriority;
                    break;
                  case DefaultEventPriority:
                    schedulerPriority = NormalPriority;
                    break;
                  case IdleEventPriority:
                    schedulerPriority = IdlePriority;
                    break;
                  default:
                    schedulerPriority = NormalPriority;
                    break;
                }
                injectedHook.onCommitFiberRoot(rendererID, root2, schedulerPriority, didError);
              } else {
                injectedHook.onCommitFiberRoot(rendererID, root2, void 0, didError);
              }
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error2("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function onPostCommitRoot(root2) {
          if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function") {
            try {
              injectedHook.onPostCommitFiberRoot(rendererID, root2);
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error2("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function onCommitUnmount(fiber) {
          if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
            try {
              injectedHook.onCommitFiberUnmount(rendererID, fiber);
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error2("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function setIsStrictModeForDevtools(newIsStrictMode) {
          {
            if (typeof unstable_yieldValue === "function") {
              unstable_setDisableYieldValue(newIsStrictMode);
              setSuppressWarning(newIsStrictMode);
            }
            if (injectedHook && typeof injectedHook.setStrictMode === "function") {
              try {
                injectedHook.setStrictMode(rendererID, newIsStrictMode);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error2("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
        }
        function injectProfilingHooks(profilingHooks) {
          injectedProfilingHooks = profilingHooks;
        }
        function getLaneLabelMap() {
          {
            var map2 = /* @__PURE__ */ new Map();
            var lane = 1;
            for (var index2 = 0; index2 < TotalLanes; index2++) {
              var label = getLabelForLane(lane);
              map2.set(lane, label);
              lane *= 2;
            }
            return map2;
          }
        }
        function markCommitStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function") {
              injectedProfilingHooks.markCommitStarted(lanes);
            }
          }
        }
        function markCommitStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function") {
              injectedProfilingHooks.markCommitStopped();
            }
          }
        }
        function markComponentRenderStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function") {
              injectedProfilingHooks.markComponentRenderStarted(fiber);
            }
          }
        }
        function markComponentRenderStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function") {
              injectedProfilingHooks.markComponentRenderStopped();
            }
          }
        }
        function markComponentPassiveEffectMountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function") {
              injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
            }
          }
        }
        function markComponentPassiveEffectMountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function") {
              injectedProfilingHooks.markComponentPassiveEffectMountStopped();
            }
          }
        }
        function markComponentPassiveEffectUnmountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function") {
              injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
            }
          }
        }
        function markComponentPassiveEffectUnmountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function") {
              injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
            }
          }
        }
        function markComponentLayoutEffectMountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function") {
              injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
            }
          }
        }
        function markComponentLayoutEffectMountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function") {
              injectedProfilingHooks.markComponentLayoutEffectMountStopped();
            }
          }
        }
        function markComponentLayoutEffectUnmountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function") {
              injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
            }
          }
        }
        function markComponentLayoutEffectUnmountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function") {
              injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
            }
          }
        }
        function markComponentErrored(fiber, thrownValue, lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function") {
              injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
            }
          }
        }
        function markComponentSuspended(fiber, wakeable, lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function") {
              injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
            }
          }
        }
        function markLayoutEffectsStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function") {
              injectedProfilingHooks.markLayoutEffectsStarted(lanes);
            }
          }
        }
        function markLayoutEffectsStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function") {
              injectedProfilingHooks.markLayoutEffectsStopped();
            }
          }
        }
        function markPassiveEffectsStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function") {
              injectedProfilingHooks.markPassiveEffectsStarted(lanes);
            }
          }
        }
        function markPassiveEffectsStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function") {
              injectedProfilingHooks.markPassiveEffectsStopped();
            }
          }
        }
        function markRenderStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function") {
              injectedProfilingHooks.markRenderStarted(lanes);
            }
          }
        }
        function markRenderYielded() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function") {
              injectedProfilingHooks.markRenderYielded();
            }
          }
        }
        function markRenderStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function") {
              injectedProfilingHooks.markRenderStopped();
            }
          }
        }
        function markRenderScheduled(lane) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function") {
              injectedProfilingHooks.markRenderScheduled(lane);
            }
          }
        }
        function markForceUpdateScheduled(fiber, lane) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function") {
              injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
            }
          }
        }
        function markStateUpdateScheduled(fiber, lane) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function") {
              injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
            }
          }
        }
        var NoMode = (
          /*                         */
          0
        );
        var ConcurrentMode = (
          /*                 */
          1
        );
        var ProfileMode = (
          /*                    */
          2
        );
        var StrictLegacyMode = (
          /*               */
          8
        );
        var StrictEffectsMode = (
          /*              */
          16
        );
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
        var log = Math.log;
        var LN2 = Math.LN2;
        function clz32Fallback(x) {
          var asUint = x >>> 0;
          if (asUint === 0) {
            return 32;
          }
          return 31 - (log(asUint) / LN2 | 0) | 0;
        }
        var TotalLanes = 31;
        var NoLanes = (
          /*                        */
          0
        );
        var NoLane = (
          /*                          */
          0
        );
        var SyncLane = (
          /*                        */
          1
        );
        var InputContinuousHydrationLane = (
          /*    */
          2
        );
        var InputContinuousLane = (
          /*             */
          4
        );
        var DefaultHydrationLane = (
          /*            */
          8
        );
        var DefaultLane = (
          /*                     */
          16
        );
        var TransitionHydrationLane = (
          /*                */
          32
        );
        var TransitionLanes = (
          /*                       */
          4194240
        );
        var TransitionLane1 = (
          /*                        */
          64
        );
        var TransitionLane2 = (
          /*                        */
          128
        );
        var TransitionLane3 = (
          /*                        */
          256
        );
        var TransitionLane4 = (
          /*                        */
          512
        );
        var TransitionLane5 = (
          /*                        */
          1024
        );
        var TransitionLane6 = (
          /*                        */
          2048
        );
        var TransitionLane7 = (
          /*                        */
          4096
        );
        var TransitionLane8 = (
          /*                        */
          8192
        );
        var TransitionLane9 = (
          /*                        */
          16384
        );
        var TransitionLane10 = (
          /*                       */
          32768
        );
        var TransitionLane11 = (
          /*                       */
          65536
        );
        var TransitionLane12 = (
          /*                       */
          131072
        );
        var TransitionLane13 = (
          /*                       */
          262144
        );
        var TransitionLane14 = (
          /*                       */
          524288
        );
        var TransitionLane15 = (
          /*                       */
          1048576
        );
        var TransitionLane16 = (
          /*                       */
          2097152
        );
        var RetryLanes = (
          /*                            */
          130023424
        );
        var RetryLane1 = (
          /*                             */
          4194304
        );
        var RetryLane2 = (
          /*                             */
          8388608
        );
        var RetryLane3 = (
          /*                             */
          16777216
        );
        var RetryLane4 = (
          /*                             */
          33554432
        );
        var RetryLane5 = (
          /*                             */
          67108864
        );
        var SomeRetryLane = RetryLane1;
        var SelectiveHydrationLane = (
          /*          */
          134217728
        );
        var NonIdleLanes = (
          /*                          */
          268435455
        );
        var IdleHydrationLane = (
          /*               */
          268435456
        );
        var IdleLane = (
          /*                        */
          536870912
        );
        var OffscreenLane = (
          /*                   */
          1073741824
        );
        function getLabelForLane(lane) {
          {
            if (lane & SyncLane) {
              return "Sync";
            }
            if (lane & InputContinuousHydrationLane) {
              return "InputContinuousHydration";
            }
            if (lane & InputContinuousLane) {
              return "InputContinuous";
            }
            if (lane & DefaultHydrationLane) {
              return "DefaultHydration";
            }
            if (lane & DefaultLane) {
              return "Default";
            }
            if (lane & TransitionHydrationLane) {
              return "TransitionHydration";
            }
            if (lane & TransitionLanes) {
              return "Transition";
            }
            if (lane & RetryLanes) {
              return "Retry";
            }
            if (lane & SelectiveHydrationLane) {
              return "SelectiveHydration";
            }
            if (lane & IdleHydrationLane) {
              return "IdleHydration";
            }
            if (lane & IdleLane) {
              return "Idle";
            }
            if (lane & OffscreenLane) {
              return "Offscreen";
            }
          }
        }
        var NoTimestamp = -1;
        var nextTransitionLane = TransitionLane1;
        var nextRetryLane = RetryLane1;
        function getHighestPriorityLanes(lanes) {
          switch (getHighestPriorityLane(lanes)) {
            case SyncLane:
              return SyncLane;
            case InputContinuousHydrationLane:
              return InputContinuousHydrationLane;
            case InputContinuousLane:
              return InputContinuousLane;
            case DefaultHydrationLane:
              return DefaultHydrationLane;
            case DefaultLane:
              return DefaultLane;
            case TransitionHydrationLane:
              return TransitionHydrationLane;
            case TransitionLane1:
            case TransitionLane2:
            case TransitionLane3:
            case TransitionLane4:
            case TransitionLane5:
            case TransitionLane6:
            case TransitionLane7:
            case TransitionLane8:
            case TransitionLane9:
            case TransitionLane10:
            case TransitionLane11:
            case TransitionLane12:
            case TransitionLane13:
            case TransitionLane14:
            case TransitionLane15:
            case TransitionLane16:
              return lanes & TransitionLanes;
            case RetryLane1:
            case RetryLane2:
            case RetryLane3:
            case RetryLane4:
            case RetryLane5:
              return lanes & RetryLanes;
            case SelectiveHydrationLane:
              return SelectiveHydrationLane;
            case IdleHydrationLane:
              return IdleHydrationLane;
            case IdleLane:
              return IdleLane;
            case OffscreenLane:
              return OffscreenLane;
            default:
              {
                error2("Should have found matching lanes. This is a bug in React.");
              }
              return lanes;
          }
        }
        function getNextLanes(root2, wipLanes) {
          var pendingLanes = root2.pendingLanes;
          if (pendingLanes === NoLanes) {
            return NoLanes;
          }
          var nextLanes = NoLanes;
          var suspendedLanes = root2.suspendedLanes;
          var pingedLanes = root2.pingedLanes;
          var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
          if (nonIdlePendingLanes !== NoLanes) {
            var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
            if (nonIdleUnblockedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
            } else {
              var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
              if (nonIdlePingedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
              }
            }
          } else {
            var unblockedLanes = pendingLanes & ~suspendedLanes;
            if (unblockedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(unblockedLanes);
            } else {
              if (pingedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(pingedLanes);
              }
            }
          }
          if (nextLanes === NoLanes) {
            return NoLanes;
          }
          if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
          // bother waiting until the root is complete.
          (wipLanes & suspendedLanes) === NoLanes) {
            var nextLane = getHighestPriorityLane(nextLanes);
            var wipLane = getHighestPriorityLane(wipLanes);
            if (
              // Tests whether the next lane is equal or lower priority than the wip
              // one. This works because the bits decrease in priority as you go left.
              nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The
              // only difference between default updates and transition updates is that
              // default updates do not support refresh transitions.
              nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes
            ) {
              return wipLanes;
            }
          }
          if ((nextLanes & InputContinuousLane) !== NoLanes) {
            nextLanes |= pendingLanes & DefaultLane;
          }
          var entangledLanes = root2.entangledLanes;
          if (entangledLanes !== NoLanes) {
            var entanglements = root2.entanglements;
            var lanes = nextLanes & entangledLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              nextLanes |= entanglements[index2];
              lanes &= ~lane;
            }
          }
          return nextLanes;
        }
        function getMostRecentEventTime(root2, lanes) {
          var eventTimes = root2.eventTimes;
          var mostRecentEventTime = NoTimestamp;
          while (lanes > 0) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            var eventTime = eventTimes[index2];
            if (eventTime > mostRecentEventTime) {
              mostRecentEventTime = eventTime;
            }
            lanes &= ~lane;
          }
          return mostRecentEventTime;
        }
        function computeExpirationTime(lane, currentTime) {
          switch (lane) {
            case SyncLane:
            case InputContinuousHydrationLane:
            case InputContinuousLane:
              return currentTime + 250;
            case DefaultHydrationLane:
            case DefaultLane:
            case TransitionHydrationLane:
            case TransitionLane1:
            case TransitionLane2:
            case TransitionLane3:
            case TransitionLane4:
            case TransitionLane5:
            case TransitionLane6:
            case TransitionLane7:
            case TransitionLane8:
            case TransitionLane9:
            case TransitionLane10:
            case TransitionLane11:
            case TransitionLane12:
            case TransitionLane13:
            case TransitionLane14:
            case TransitionLane15:
            case TransitionLane16:
              return currentTime + 5e3;
            case RetryLane1:
            case RetryLane2:
            case RetryLane3:
            case RetryLane4:
            case RetryLane5:
              return NoTimestamp;
            case SelectiveHydrationLane:
            case IdleHydrationLane:
            case IdleLane:
            case OffscreenLane:
              return NoTimestamp;
            default:
              {
                error2("Should have found matching lanes. This is a bug in React.");
              }
              return NoTimestamp;
          }
        }
        function markStarvedLanesAsExpired(root2, currentTime) {
          var pendingLanes = root2.pendingLanes;
          var suspendedLanes = root2.suspendedLanes;
          var pingedLanes = root2.pingedLanes;
          var expirationTimes = root2.expirationTimes;
          var lanes = pendingLanes;
          while (lanes > 0) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            var expirationTime = expirationTimes[index2];
            if (expirationTime === NoTimestamp) {
              if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                expirationTimes[index2] = computeExpirationTime(lane, currentTime);
              }
            } else if (expirationTime <= currentTime) {
              root2.expiredLanes |= lane;
            }
            lanes &= ~lane;
          }
        }
        function getHighestPriorityPendingLanes(root2) {
          return getHighestPriorityLanes(root2.pendingLanes);
        }
        function getLanesToRetrySynchronouslyOnError(root2) {
          var everythingButOffscreen = root2.pendingLanes & ~OffscreenLane;
          if (everythingButOffscreen !== NoLanes) {
            return everythingButOffscreen;
          }
          if (everythingButOffscreen & OffscreenLane) {
            return OffscreenLane;
          }
          return NoLanes;
        }
        function includesSyncLane(lanes) {
          return (lanes & SyncLane) !== NoLanes;
        }
        function includesNonIdleWork(lanes) {
          return (lanes & NonIdleLanes) !== NoLanes;
        }
        function includesOnlyRetries(lanes) {
          return (lanes & RetryLanes) === lanes;
        }
        function includesOnlyNonUrgentLanes(lanes) {
          var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
          return (lanes & UrgentLanes) === NoLanes;
        }
        function includesOnlyTransitions(lanes) {
          return (lanes & TransitionLanes) === lanes;
        }
        function includesBlockingLane(root2, lanes) {
          var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
          return (lanes & SyncDefaultLanes) !== NoLanes;
        }
        function includesExpiredLane(root2, lanes) {
          return (lanes & root2.expiredLanes) !== NoLanes;
        }
        function isTransitionLane(lane) {
          return (lane & TransitionLanes) !== NoLanes;
        }
        function claimNextTransitionLane() {
          var lane = nextTransitionLane;
          nextTransitionLane <<= 1;
          if ((nextTransitionLane & TransitionLanes) === NoLanes) {
            nextTransitionLane = TransitionLane1;
          }
          return lane;
        }
        function claimNextRetryLane() {
          var lane = nextRetryLane;
          nextRetryLane <<= 1;
          if ((nextRetryLane & RetryLanes) === NoLanes) {
            nextRetryLane = RetryLane1;
          }
          return lane;
        }
        function getHighestPriorityLane(lanes) {
          return lanes & -lanes;
        }
        function pickArbitraryLane(lanes) {
          return getHighestPriorityLane(lanes);
        }
        function pickArbitraryLaneIndex(lanes) {
          return 31 - clz32(lanes);
        }
        function laneToIndex(lane) {
          return pickArbitraryLaneIndex(lane);
        }
        function includesSomeLane(a, b) {
          return (a & b) !== NoLanes;
        }
        function isSubsetOfLanes(set3, subset) {
          return (set3 & subset) === subset;
        }
        function mergeLanes(a, b) {
          return a | b;
        }
        function removeLanes(set3, subset) {
          return set3 & ~subset;
        }
        function intersectLanes(a, b) {
          return a & b;
        }
        function laneToLanes(lane) {
          return lane;
        }
        function higherPriorityLane(a, b) {
          return a !== NoLane && a < b ? a : b;
        }
        function createLaneMap(initial) {
          var laneMap = [];
          for (var i = 0; i < TotalLanes; i++) {
            laneMap.push(initial);
          }
          return laneMap;
        }
        function markRootUpdated(root2, updateLane, eventTime) {
          root2.pendingLanes |= updateLane;
          if (updateLane !== IdleLane) {
            root2.suspendedLanes = NoLanes;
            root2.pingedLanes = NoLanes;
          }
          var eventTimes = root2.eventTimes;
          var index2 = laneToIndex(updateLane);
          eventTimes[index2] = eventTime;
        }
        function markRootSuspended(root2, suspendedLanes) {
          root2.suspendedLanes |= suspendedLanes;
          root2.pingedLanes &= ~suspendedLanes;
          var expirationTimes = root2.expirationTimes;
          var lanes = suspendedLanes;
          while (lanes > 0) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            expirationTimes[index2] = NoTimestamp;
            lanes &= ~lane;
          }
        }
        function markRootPinged(root2, pingedLanes, eventTime) {
          root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
        }
        function markRootFinished(root2, remainingLanes) {
          var noLongerPendingLanes = root2.pendingLanes & ~remainingLanes;
          root2.pendingLanes = remainingLanes;
          root2.suspendedLanes = NoLanes;
          root2.pingedLanes = NoLanes;
          root2.expiredLanes &= remainingLanes;
          root2.mutableReadLanes &= remainingLanes;
          root2.entangledLanes &= remainingLanes;
          var entanglements = root2.entanglements;
          var eventTimes = root2.eventTimes;
          var expirationTimes = root2.expirationTimes;
          var lanes = noLongerPendingLanes;
          while (lanes > 0) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            entanglements[index2] = NoLanes;
            eventTimes[index2] = NoTimestamp;
            expirationTimes[index2] = NoTimestamp;
            lanes &= ~lane;
          }
        }
        function markRootEntangled(root2, entangledLanes) {
          var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
          var entanglements = root2.entanglements;
          var lanes = rootEntangledLanes;
          while (lanes) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            if (
              // Is this one of the newly entangled lanes?
              lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?
              entanglements[index2] & entangledLanes
            ) {
              entanglements[index2] |= entangledLanes;
            }
            lanes &= ~lane;
          }
        }
        function getBumpedLaneForHydration(root2, renderLanes2) {
          var renderLane = getHighestPriorityLane(renderLanes2);
          var lane;
          switch (renderLane) {
            case InputContinuousLane:
              lane = InputContinuousHydrationLane;
              break;
            case DefaultLane:
              lane = DefaultHydrationLane;
              break;
            case TransitionLane1:
            case TransitionLane2:
            case TransitionLane3:
            case TransitionLane4:
            case TransitionLane5:
            case TransitionLane6:
            case TransitionLane7:
            case TransitionLane8:
            case TransitionLane9:
            case TransitionLane10:
            case TransitionLane11:
            case TransitionLane12:
            case TransitionLane13:
            case TransitionLane14:
            case TransitionLane15:
            case TransitionLane16:
            case RetryLane1:
            case RetryLane2:
            case RetryLane3:
            case RetryLane4:
            case RetryLane5:
              lane = TransitionHydrationLane;
              break;
            case IdleLane:
              lane = IdleHydrationLane;
              break;
            default:
              lane = NoLane;
              break;
          }
          if ((lane & (root2.suspendedLanes | renderLanes2)) !== NoLane) {
            return NoLane;
          }
          return lane;
        }
        function addFiberToLanesMap(root2, fiber, lanes) {
          if (!isDevToolsPresent) {
            return;
          }
          var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
          while (lanes > 0) {
            var index2 = laneToIndex(lanes);
            var lane = 1 << index2;
            var updaters = pendingUpdatersLaneMap[index2];
            updaters.add(fiber);
            lanes &= ~lane;
          }
        }
        function movePendingFibersToMemoized(root2, lanes) {
          if (!isDevToolsPresent) {
            return;
          }
          var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
          var memoizedUpdaters = root2.memoizedUpdaters;
          while (lanes > 0) {
            var index2 = laneToIndex(lanes);
            var lane = 1 << index2;
            var updaters = pendingUpdatersLaneMap[index2];
            if (updaters.size > 0) {
              updaters.forEach(function(fiber) {
                var alternate = fiber.alternate;
                if (alternate === null || !memoizedUpdaters.has(alternate)) {
                  memoizedUpdaters.add(fiber);
                }
              });
              updaters.clear();
            }
            lanes &= ~lane;
          }
        }
        function getTransitionsForLanes(root2, lanes) {
          {
            return null;
          }
        }
        var DiscreteEventPriority = SyncLane;
        var ContinuousEventPriority = InputContinuousLane;
        var DefaultEventPriority = DefaultLane;
        var IdleEventPriority = IdleLane;
        var currentUpdatePriority = NoLane;
        function getCurrentUpdatePriority() {
          return currentUpdatePriority;
        }
        function setCurrentUpdatePriority(newPriority) {
          currentUpdatePriority = newPriority;
        }
        function runWithPriority(priority, fn) {
          var previousPriority = currentUpdatePriority;
          try {
            currentUpdatePriority = priority;
            return fn();
          } finally {
            currentUpdatePriority = previousPriority;
          }
        }
        function higherEventPriority(a, b) {
          return a !== 0 && a < b ? a : b;
        }
        function lowerEventPriority(a, b) {
          return a === 0 || a > b ? a : b;
        }
        function isHigherEventPriority(a, b) {
          return a !== 0 && a < b;
        }
        function lanesToEventPriority(lanes) {
          var lane = getHighestPriorityLane(lanes);
          if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
            return DiscreteEventPriority;
          }
          if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
            return ContinuousEventPriority;
          }
          if (includesNonIdleWork(lane)) {
            return DefaultEventPriority;
          }
          return IdleEventPriority;
        }
        function isRootDehydrated(root2) {
          var currentState = root2.current.memoizedState;
          return currentState.isDehydrated;
        }
        var _attemptSynchronousHydration;
        function setAttemptSynchronousHydration(fn) {
          _attemptSynchronousHydration = fn;
        }
        function attemptSynchronousHydration(fiber) {
          _attemptSynchronousHydration(fiber);
        }
        var attemptContinuousHydration;
        function setAttemptContinuousHydration(fn) {
          attemptContinuousHydration = fn;
        }
        var attemptHydrationAtCurrentPriority;
        function setAttemptHydrationAtCurrentPriority(fn) {
          attemptHydrationAtCurrentPriority = fn;
        }
        var getCurrentUpdatePriority$1;
        function setGetCurrentUpdatePriority(fn) {
          getCurrentUpdatePriority$1 = fn;
        }
        var attemptHydrationAtPriority;
        function setAttemptHydrationAtPriority(fn) {
          attemptHydrationAtPriority = fn;
        }
        var hasScheduledReplayAttempt = false;
        var queuedDiscreteEvents = [];
        var queuedFocus = null;
        var queuedDrag = null;
        var queuedMouse = null;
        var queuedPointers = /* @__PURE__ */ new Map();
        var queuedPointerCaptures = /* @__PURE__ */ new Map();
        var queuedExplicitHydrationTargets = [];
        var discreteReplayableEvents = [
          "mousedown",
          "mouseup",
          "touchcancel",
          "touchend",
          "touchstart",
          "auxclick",
          "dblclick",
          "pointercancel",
          "pointerdown",
          "pointerup",
          "dragend",
          "dragstart",
          "drop",
          "compositionend",
          "compositionstart",
          "keydown",
          "keypress",
          "keyup",
          "input",
          "textInput",
          // Intentionally camelCase
          "copy",
          "cut",
          "paste",
          "click",
          "change",
          "contextmenu",
          "reset",
          "submit"
        ];
        function isDiscreteEventThatRequiresHydration(eventType) {
          return discreteReplayableEvents.indexOf(eventType) > -1;
        }
        function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          return {
            blockedOn,
            domEventName,
            eventSystemFlags,
            nativeEvent,
            targetContainers: [targetContainer]
          };
        }
        function clearIfContinuousEvent(domEventName, nativeEvent) {
          switch (domEventName) {
            case "focusin":
            case "focusout":
              queuedFocus = null;
              break;
            case "dragenter":
            case "dragleave":
              queuedDrag = null;
              break;
            case "mouseover":
            case "mouseout":
              queuedMouse = null;
              break;
            case "pointerover":
            case "pointerout": {
              var pointerId = nativeEvent.pointerId;
              queuedPointers.delete(pointerId);
              break;
            }
            case "gotpointercapture":
            case "lostpointercapture": {
              var _pointerId = nativeEvent.pointerId;
              queuedPointerCaptures.delete(_pointerId);
              break;
            }
          }
        }
        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
            var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (blockedOn !== null) {
              var _fiber2 = getInstanceFromNode(blockedOn);
              if (_fiber2 !== null) {
                attemptContinuousHydration(_fiber2);
              }
            }
            return queuedEvent;
          }
          existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
          var targetContainers = existingQueuedEvent.targetContainers;
          if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
            targetContainers.push(targetContainer);
          }
          return existingQueuedEvent;
        }
        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          switch (domEventName) {
            case "focusin": {
              var focusEvent = nativeEvent;
              queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
              return true;
            }
            case "dragenter": {
              var dragEvent = nativeEvent;
              queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
              return true;
            }
            case "mouseover": {
              var mouseEvent = nativeEvent;
              queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
              return true;
            }
            case "pointerover": {
              var pointerEvent = nativeEvent;
              var pointerId = pointerEvent.pointerId;
              queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
              return true;
            }
            case "gotpointercapture": {
              var _pointerEvent = nativeEvent;
              var _pointerId2 = _pointerEvent.pointerId;
              queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
              return true;
            }
          }
          return false;
        }
        function attemptExplicitHydrationTarget(queuedTarget) {
          var targetInst = getClosestInstanceFromNode(queuedTarget.target);
          if (targetInst !== null) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (nearestMounted !== null) {
              var tag = nearestMounted.tag;
              if (tag === SuspenseComponent) {
                var instance = getSuspenseInstanceFromFiber(nearestMounted);
                if (instance !== null) {
                  queuedTarget.blockedOn = instance;
                  attemptHydrationAtPriority(queuedTarget.priority, function() {
                    attemptHydrationAtCurrentPriority(nearestMounted);
                  });
                  return;
                }
              } else if (tag === HostRoot) {
                var root2 = nearestMounted.stateNode;
                if (isRootDehydrated(root2)) {
                  queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                  return;
                }
              }
            }
          }
          queuedTarget.blockedOn = null;
        }
        function queueExplicitHydrationTarget(target) {
          var updatePriority = getCurrentUpdatePriority$1();
          var queuedTarget = {
            blockedOn: null,
            target,
            priority: updatePriority
          };
          var i = 0;
          for (; i < queuedExplicitHydrationTargets.length; i++) {
            if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i].priority)) {
              break;
            }
          }
          queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);
          if (i === 0) {
            attemptExplicitHydrationTarget(queuedTarget);
          }
        }
        function attemptReplayContinuousQueuedEvent(queuedEvent) {
          if (queuedEvent.blockedOn !== null) {
            return false;
          }
          var targetContainers = queuedEvent.targetContainers;
          while (targetContainers.length > 0) {
            var targetContainer = targetContainers[0];
            var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
            if (nextBlockedOn === null) {
              {
                var nativeEvent = queuedEvent.nativeEvent;
                var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
                setReplayingEvent(nativeEventClone);
                nativeEvent.target.dispatchEvent(nativeEventClone);
                resetReplayingEvent();
              }
            } else {
              var _fiber3 = getInstanceFromNode(nextBlockedOn);
              if (_fiber3 !== null) {
                attemptContinuousHydration(_fiber3);
              }
              queuedEvent.blockedOn = nextBlockedOn;
              return false;
            }
            targetContainers.shift();
          }
          return true;
        }
        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map2) {
          if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
            map2.delete(key);
          }
        }
        function replayUnblockedEvents() {
          hasScheduledReplayAttempt = false;
          if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
            queuedFocus = null;
          }
          if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
            queuedDrag = null;
          }
          if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
            queuedMouse = null;
          }
          queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
          queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
        }
        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
          if (queuedEvent.blockedOn === unblocked) {
            queuedEvent.blockedOn = null;
            if (!hasScheduledReplayAttempt) {
              hasScheduledReplayAttempt = true;
              Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
            }
          }
        }
        function retryIfBlockedOn(unblocked) {
          if (queuedDiscreteEvents.length > 0) {
            scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
            for (var i = 1; i < queuedDiscreteEvents.length; i++) {
              var queuedEvent = queuedDiscreteEvents[i];
              if (queuedEvent.blockedOn === unblocked) {
                queuedEvent.blockedOn = null;
              }
            }
          }
          if (queuedFocus !== null) {
            scheduleCallbackIfUnblocked(queuedFocus, unblocked);
          }
          if (queuedDrag !== null) {
            scheduleCallbackIfUnblocked(queuedDrag, unblocked);
          }
          if (queuedMouse !== null) {
            scheduleCallbackIfUnblocked(queuedMouse, unblocked);
          }
          var unblock = function(queuedEvent2) {
            return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
          };
          queuedPointers.forEach(unblock);
          queuedPointerCaptures.forEach(unblock);
          for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
            var queuedTarget = queuedExplicitHydrationTargets[_i];
            if (queuedTarget.blockedOn === unblocked) {
              queuedTarget.blockedOn = null;
            }
          }
          while (queuedExplicitHydrationTargets.length > 0) {
            var nextExplicitTarget = queuedExplicitHydrationTargets[0];
            if (nextExplicitTarget.blockedOn !== null) {
              break;
            } else {
              attemptExplicitHydrationTarget(nextExplicitTarget);
              if (nextExplicitTarget.blockedOn === null) {
                queuedExplicitHydrationTargets.shift();
              }
            }
          }
        }
        var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
        var _enabled = true;
        function setEnabled(enabled) {
          _enabled = !!enabled;
        }
        function isEnabled() {
          return _enabled;
        }
        function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
          var eventPriority = getEventPriority(domEventName);
          var listenerWrapper;
          switch (eventPriority) {
            case DiscreteEventPriority:
              listenerWrapper = dispatchDiscreteEvent;
              break;
            case ContinuousEventPriority:
              listenerWrapper = dispatchContinuousEvent;
              break;
            case DefaultEventPriority:
            default:
              listenerWrapper = dispatchEvent;
              break;
          }
          return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
        }
        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var previousPriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = null;
          try {
            setCurrentUpdatePriority(DiscreteEventPriority);
            dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig.transition = prevTransition;
          }
        }
        function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var previousPriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = null;
          try {
            setCurrentUpdatePriority(ContinuousEventPriority);
            dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig.transition = prevTransition;
          }
        }
        function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (!_enabled) {
            return;
          }
          {
            dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);
          }
        }
        function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
          if (blockedOn === null) {
            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
            clearIfContinuousEvent(domEventName, nativeEvent);
            return;
          }
          if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
            nativeEvent.stopPropagation();
            return;
          }
          clearIfContinuousEvent(domEventName, nativeEvent);
          if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
            while (blockedOn !== null) {
              var fiber = getInstanceFromNode(blockedOn);
              if (fiber !== null) {
                attemptSynchronousHydration(fiber);
              }
              var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
              if (nextBlockedOn === null) {
                dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
              }
              if (nextBlockedOn === blockedOn) {
                break;
              }
              blockedOn = nextBlockedOn;
            }
            if (blockedOn !== null) {
              nativeEvent.stopPropagation();
            }
            return;
          }
          dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
        }
        var return_targetInst = null;
        function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          return_targetInst = null;
          var nativeEventTarget = getEventTarget(nativeEvent);
          var targetInst = getClosestInstanceFromNode(nativeEventTarget);
          if (targetInst !== null) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (nearestMounted === null) {
              targetInst = null;
            } else {
              var tag = nearestMounted.tag;
              if (tag === SuspenseComponent) {
                var instance = getSuspenseInstanceFromFiber(nearestMounted);
                if (instance !== null) {
                  return instance;
                }
                targetInst = null;
              } else if (tag === HostRoot) {
                var root2 = nearestMounted.stateNode;
                if (isRootDehydrated(root2)) {
                  return getContainerFromFiber(nearestMounted);
                }
                targetInst = null;
              } else if (nearestMounted !== targetInst) {
                targetInst = null;
              }
            }
          }
          return_targetInst = targetInst;
          return null;
        }
        function getEventPriority(domEventName) {
          switch (domEventName) {
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return DiscreteEventPriority;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "toggle":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return ContinuousEventPriority;
            case "message": {
              var schedulerPriority = getCurrentPriorityLevel();
              switch (schedulerPriority) {
                case ImmediatePriority:
                  return DiscreteEventPriority;
                case UserBlockingPriority:
                  return ContinuousEventPriority;
                case NormalPriority:
                case LowPriority:
                  return DefaultEventPriority;
                case IdlePriority:
                  return IdleEventPriority;
                default:
                  return DefaultEventPriority;
              }
            }
            default:
              return DefaultEventPriority;
          }
        }
        function addEventBubbleListener(target, eventType, listener) {
          target.addEventListener(eventType, listener, false);
          return listener;
        }
        function addEventCaptureListener(target, eventType, listener) {
          target.addEventListener(eventType, listener, true);
          return listener;
        }
        function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
          target.addEventListener(eventType, listener, {
            capture: true,
            passive
          });
          return listener;
        }
        function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
          target.addEventListener(eventType, listener, {
            passive
          });
          return listener;
        }
        var root = null;
        var startText = null;
        var fallbackText = null;
        function initialize(nativeEventTarget) {
          root = nativeEventTarget;
          startText = getText();
          return true;
        }
        function reset() {
          root = null;
          startText = null;
          fallbackText = null;
        }
        function getData() {
          if (fallbackText) {
            return fallbackText;
          }
          var start;
          var startValue = startText;
          var startLength = startValue.length;
          var end;
          var endValue = getText();
          var endLength = endValue.length;
          for (start = 0; start < startLength; start++) {
            if (startValue[start] !== endValue[start]) {
              break;
            }
          }
          var minEnd = startLength - start;
          for (end = 1; end <= minEnd; end++) {
            if (startValue[startLength - end] !== endValue[endLength - end]) {
              break;
            }
          }
          var sliceTail = end > 1 ? 1 - end : void 0;
          fallbackText = endValue.slice(start, sliceTail);
          return fallbackText;
        }
        function getText() {
          if ("value" in root) {
            return root.value;
          }
          return root.textContent;
        }
        function getEventCharCode(nativeEvent) {
          var charCode;
          var keyCode = nativeEvent.keyCode;
          if ("charCode" in nativeEvent) {
            charCode = nativeEvent.charCode;
            if (charCode === 0 && keyCode === 13) {
              charCode = 13;
            }
          } else {
            charCode = keyCode;
          }
          if (charCode === 10) {
            charCode = 13;
          }
          if (charCode >= 32 || charCode === 13) {
            return charCode;
          }
          return 0;
        }
        function functionThatReturnsTrue() {
          return true;
        }
        function functionThatReturnsFalse() {
          return false;
        }
        function createSyntheticEvent(Interface) {
          function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
            this._reactName = reactName;
            this._targetInst = targetInst;
            this.type = reactEventType;
            this.nativeEvent = nativeEvent;
            this.target = nativeEventTarget;
            this.currentTarget = null;
            for (var _propName in Interface) {
              if (!Interface.hasOwnProperty(_propName)) {
                continue;
              }
              var normalize3 = Interface[_propName];
              if (normalize3) {
                this[_propName] = normalize3(nativeEvent);
              } else {
                this[_propName] = nativeEvent[_propName];
              }
            }
            var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
            if (defaultPrevented) {
              this.isDefaultPrevented = functionThatReturnsTrue;
            } else {
              this.isDefaultPrevented = functionThatReturnsFalse;
            }
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
          }
          assign3(SyntheticBaseEvent.prototype, {
            preventDefault: function() {
              this.defaultPrevented = true;
              var event = this.nativeEvent;
              if (!event) {
                return;
              }
              if (event.preventDefault) {
                event.preventDefault();
              } else if (typeof event.returnValue !== "unknown") {
                event.returnValue = false;
              }
              this.isDefaultPrevented = functionThatReturnsTrue;
            },
            stopPropagation: function() {
              var event = this.nativeEvent;
              if (!event) {
                return;
              }
              if (event.stopPropagation) {
                event.stopPropagation();
              } else if (typeof event.cancelBubble !== "unknown") {
                event.cancelBubble = true;
              }
              this.isPropagationStopped = functionThatReturnsTrue;
            },
            /**
             * We release all dispatched `SyntheticEvent`s after each event loop, adding
             * them back into the pool. This allows a way to hold onto a reference that
             * won't be added back into the pool.
             */
            persist: function() {
            },
            /**
             * Checks if this event should be released back into the pool.
             *
             * @return {boolean} True if this should not be released, false otherwise.
             */
            isPersistent: functionThatReturnsTrue
          });
          return SyntheticBaseEvent;
        }
        var EventInterface = {
          eventPhase: 0,
          bubbles: 0,
          cancelable: 0,
          timeStamp: function(event) {
            return event.timeStamp || Date.now();
          },
          defaultPrevented: 0,
          isTrusted: 0
        };
        var SyntheticEvent = createSyntheticEvent(EventInterface);
        var UIEventInterface = assign3({}, EventInterface, {
          view: 0,
          detail: 0
        });
        var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
        var lastMovementX;
        var lastMovementY;
        var lastMouseEvent;
        function updateMouseMovementPolyfillState(event) {
          if (event !== lastMouseEvent) {
            if (lastMouseEvent && event.type === "mousemove") {
              lastMovementX = event.screenX - lastMouseEvent.screenX;
              lastMovementY = event.screenY - lastMouseEvent.screenY;
            } else {
              lastMovementX = 0;
              lastMovementY = 0;
            }
            lastMouseEvent = event;
          }
        }
        var MouseEventInterface = assign3({}, UIEventInterface, {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          getModifierState: getEventModifierState,
          button: 0,
          buttons: 0,
          relatedTarget: function(event) {
            if (event.relatedTarget === void 0)
              return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
            return event.relatedTarget;
          },
          movementX: function(event) {
            if ("movementX" in event) {
              return event.movementX;
            }
            updateMouseMovementPolyfillState(event);
            return lastMovementX;
          },
          movementY: function(event) {
            if ("movementY" in event) {
              return event.movementY;
            }
            return lastMovementY;
          }
        });
        var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
        var DragEventInterface = assign3({}, MouseEventInterface, {
          dataTransfer: 0
        });
        var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
        var FocusEventInterface = assign3({}, UIEventInterface, {
          relatedTarget: 0
        });
        var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
        var AnimationEventInterface = assign3({}, EventInterface, {
          animationName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        });
        var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
        var ClipboardEventInterface = assign3({}, EventInterface, {
          clipboardData: function(event) {
            return "clipboardData" in event ? event.clipboardData : window.clipboardData;
          }
        });
        var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
        var CompositionEventInterface = assign3({}, EventInterface, {
          data: 0
        });
        var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
        var SyntheticInputEvent = SyntheticCompositionEvent;
        var normalizeKey = {
          Esc: "Escape",
          Spacebar: " ",
          Left: "ArrowLeft",
          Up: "ArrowUp",
          Right: "ArrowRight",
          Down: "ArrowDown",
          Del: "Delete",
          Win: "OS",
          Menu: "ContextMenu",
          Apps: "ContextMenu",
          Scroll: "ScrollLock",
          MozPrintableKey: "Unidentified"
        };
        var translateToKey = {
          "8": "Backspace",
          "9": "Tab",
          "12": "Clear",
          "13": "Enter",
          "16": "Shift",
          "17": "Control",
          "18": "Alt",
          "19": "Pause",
          "20": "CapsLock",
          "27": "Escape",
          "32": " ",
          "33": "PageUp",
          "34": "PageDown",
          "35": "End",
          "36": "Home",
          "37": "ArrowLeft",
          "38": "ArrowUp",
          "39": "ArrowRight",
          "40": "ArrowDown",
          "45": "Insert",
          "46": "Delete",
          "112": "F1",
          "113": "F2",
          "114": "F3",
          "115": "F4",
          "116": "F5",
          "117": "F6",
          "118": "F7",
          "119": "F8",
          "120": "F9",
          "121": "F10",
          "122": "F11",
          "123": "F12",
          "144": "NumLock",
          "145": "ScrollLock",
          "224": "Meta"
        };
        function getEventKey(nativeEvent) {
          if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if (key !== "Unidentified") {
              return key;
            }
          }
          if (nativeEvent.type === "keypress") {
            var charCode = getEventCharCode(nativeEvent);
            return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
          }
          if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
            return translateToKey[nativeEvent.keyCode] || "Unidentified";
          }
          return "";
        }
        var modifierKeyToProp = {
          Alt: "altKey",
          Control: "ctrlKey",
          Meta: "metaKey",
          Shift: "shiftKey"
        };
        function modifierStateGetter(keyArg) {
          var syntheticEvent = this;
          var nativeEvent = syntheticEvent.nativeEvent;
          if (nativeEvent.getModifierState) {
            return nativeEvent.getModifierState(keyArg);
          }
          var keyProp = modifierKeyToProp[keyArg];
          return keyProp ? !!nativeEvent[keyProp] : false;
        }
        function getEventModifierState(nativeEvent) {
          return modifierStateGetter;
        }
        var KeyboardEventInterface = assign3({}, UIEventInterface, {
          key: getEventKey,
          code: 0,
          location: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          repeat: 0,
          locale: 0,
          getModifierState: getEventModifierState,
          // Legacy Interface
          charCode: function(event) {
            if (event.type === "keypress") {
              return getEventCharCode(event);
            }
            return 0;
          },
          keyCode: function(event) {
            if (event.type === "keydown" || event.type === "keyup") {
              return event.keyCode;
            }
            return 0;
          },
          which: function(event) {
            if (event.type === "keypress") {
              return getEventCharCode(event);
            }
            if (event.type === "keydown" || event.type === "keyup") {
              return event.keyCode;
            }
            return 0;
          }
        });
        var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
        var PointerEventInterface = assign3({}, MouseEventInterface, {
          pointerId: 0,
          width: 0,
          height: 0,
          pressure: 0,
          tangentialPressure: 0,
          tiltX: 0,
          tiltY: 0,
          twist: 0,
          pointerType: 0,
          isPrimary: 0
        });
        var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
        var TouchEventInterface = assign3({}, UIEventInterface, {
          touches: 0,
          targetTouches: 0,
          changedTouches: 0,
          altKey: 0,
          metaKey: 0,
          ctrlKey: 0,
          shiftKey: 0,
          getModifierState: getEventModifierState
        });
        var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
        var TransitionEventInterface = assign3({}, EventInterface, {
          propertyName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        });
        var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
        var WheelEventInterface = assign3({}, MouseEventInterface, {
          deltaX: function(event) {
            return "deltaX" in event ? event.deltaX : (
              // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
              "wheelDeltaX" in event ? -event.wheelDeltaX : 0
            );
          },
          deltaY: function(event) {
            return "deltaY" in event ? event.deltaY : (
              // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
              "wheelDeltaY" in event ? -event.wheelDeltaY : (
                // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
                "wheelDelta" in event ? -event.wheelDelta : 0
              )
            );
          },
          deltaZ: 0,
          // Browsers without "deltaMode" is reporting in raw wheel delta where one
          // notch on the scroll is always +/- 120, roughly equivalent to pixels.
          // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
          // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
          deltaMode: 0
        });
        var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
        var END_KEYCODES = [9, 13, 27, 32];
        var START_KEYCODE = 229;
        var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
        var documentMode = null;
        if (canUseDOM && "documentMode" in document) {
          documentMode = document.documentMode;
        }
        var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
        var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
        var SPACEBAR_CODE = 32;
        var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
        function registerEvents() {
          registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
          registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
        }
        var hasSpaceKeypress = false;
        function isKeypressCommand(nativeEvent) {
          return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
          !(nativeEvent.ctrlKey && nativeEvent.altKey);
        }
        function getCompositionEventType(domEventName) {
          switch (domEventName) {
            case "compositionstart":
              return "onCompositionStart";
            case "compositionend":
              return "onCompositionEnd";
            case "compositionupdate":
              return "onCompositionUpdate";
          }
        }
        function isFallbackCompositionStart(domEventName, nativeEvent) {
          return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
        }
        function isFallbackCompositionEnd(domEventName, nativeEvent) {
          switch (domEventName) {
            case "keyup":
              return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
            case "keydown":
              return nativeEvent.keyCode !== START_KEYCODE;
            case "keypress":
            case "mousedown":
            case "focusout":
              return true;
            default:
              return false;
          }
        }
        function getDataFromCustomEvent(nativeEvent) {
          var detail = nativeEvent.detail;
          if (typeof detail === "object" && "data" in detail) {
            return detail.data;
          }
          return null;
        }
        function isUsingKoreanIME(nativeEvent) {
          return nativeEvent.locale === "ko";
        }
        var isComposing = false;
        function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
          var eventType;
          var fallbackData;
          if (canUseCompositionEvent) {
            eventType = getCompositionEventType(domEventName);
          } else if (!isComposing) {
            if (isFallbackCompositionStart(domEventName, nativeEvent)) {
              eventType = "onCompositionStart";
            }
          } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
            eventType = "onCompositionEnd";
          }
          if (!eventType) {
            return null;
          }
          if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
            if (!isComposing && eventType === "onCompositionStart") {
              isComposing = initialize(nativeEventTarget);
            } else if (eventType === "onCompositionEnd") {
              if (isComposing) {
                fallbackData = getData();
              }
            }
          }
          var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
          if (listeners.length > 0) {
            var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event,
              listeners
            });
            if (fallbackData) {
              event.data = fallbackData;
            } else {
              var customData = getDataFromCustomEvent(nativeEvent);
              if (customData !== null) {
                event.data = customData;
              }
            }
          }
        }
        function getNativeBeforeInputChars(domEventName, nativeEvent) {
          switch (domEventName) {
            case "compositionend":
              return getDataFromCustomEvent(nativeEvent);
            case "keypress":
              var which = nativeEvent.which;
              if (which !== SPACEBAR_CODE) {
                return null;
              }
              hasSpaceKeypress = true;
              return SPACEBAR_CHAR;
            case "textInput":
              var chars = nativeEvent.data;
              if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                return null;
              }
              return chars;
            default:
              return null;
          }
        }
        function getFallbackBeforeInputChars(domEventName, nativeEvent) {
          if (isComposing) {
            if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
              var chars = getData();
              reset();
              isComposing = false;
              return chars;
            }
            return null;
          }
          switch (domEventName) {
            case "paste":
              return null;
            case "keypress":
              if (!isKeypressCommand(nativeEvent)) {
                if (nativeEvent.char && nativeEvent.char.length > 1) {
                  return nativeEvent.char;
                } else if (nativeEvent.which) {
                  return String.fromCharCode(nativeEvent.which);
                }
              }
              return null;
            case "compositionend":
              return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
            default:
              return null;
          }
        }
        function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
          var chars;
          if (canUseTextInputEvent) {
            chars = getNativeBeforeInputChars(domEventName, nativeEvent);
          } else {
            chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
          }
          if (!chars) {
            return null;
          }
          var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
          if (listeners.length > 0) {
            var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event,
              listeners
            });
            event.data = chars;
          }
        }
        function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        }
        var supportedInputTypes = {
          color: true,
          date: true,
          datetime: true,
          "datetime-local": true,
          email: true,
          month: true,
          number: true,
          password: true,
          range: true,
          search: true,
          tel: true,
          text: true,
          time: true,
          url: true,
          week: true
        };
        function isTextInputElement(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          if (nodeName === "input") {
            return !!supportedInputTypes[elem.type];
          }
          if (nodeName === "textarea") {
            return true;
          }
          return false;
        }
        function isEventSupported(eventNameSuffix) {
          if (!canUseDOM) {
            return false;
          }
          var eventName = "on" + eventNameSuffix;
          var isSupported = eventName in document;
          if (!isSupported) {
            var element = document.createElement("div");
            element.setAttribute(eventName, "return;");
            isSupported = typeof element[eventName] === "function";
          }
          return isSupported;
        }
        function registerEvents$1() {
          registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
        }
        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
          enqueueStateRestore(target);
          var listeners = accumulateTwoPhaseListeners(inst, "onChange");
          if (listeners.length > 0) {
            var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target);
            dispatchQueue.push({
              event,
              listeners
            });
          }
        }
        var activeElement = null;
        var activeElementInst = null;
        function shouldUseChangeEvent(elem) {
          var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName === "select" || nodeName === "input" && elem.type === "file";
        }
        function manualDispatchChangeEvent(nativeEvent) {
          var dispatchQueue = [];
          createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
          batchedUpdates(runEventInBatch, dispatchQueue);
        }
        function runEventInBatch(dispatchQueue) {
          processDispatchQueue(dispatchQueue, 0);
        }
        function getInstIfValueChanged(targetInst) {
          var targetNode = getNodeFromInstance(targetInst);
          if (updateValueIfChanged(targetNode)) {
            return targetInst;
          }
        }
        function getTargetInstForChangeEvent(domEventName, targetInst) {
          if (domEventName === "change") {
            return targetInst;
          }
        }
        var isInputEventSupported = false;
        if (canUseDOM) {
          isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
        }
        function startWatchingForValueChange(target, targetInst) {
          activeElement = target;
          activeElementInst = targetInst;
          activeElement.attachEvent("onpropertychange", handlePropertyChange);
        }
        function stopWatchingForValueChange() {
          if (!activeElement) {
            return;
          }
          activeElement.detachEvent("onpropertychange", handlePropertyChange);
          activeElement = null;
          activeElementInst = null;
        }
        function handlePropertyChange(nativeEvent) {
          if (nativeEvent.propertyName !== "value") {
            return;
          }
          if (getInstIfValueChanged(activeElementInst)) {
            manualDispatchChangeEvent(nativeEvent);
          }
        }
        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
          if (domEventName === "focusin") {
            stopWatchingForValueChange();
            startWatchingForValueChange(target, targetInst);
          } else if (domEventName === "focusout") {
            stopWatchingForValueChange();
          }
        }
        function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
          if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
            return getInstIfValueChanged(activeElementInst);
          }
        }
        function shouldUseClickEvent(elem) {
          var nodeName = elem.nodeName;
          return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
        }
        function getTargetInstForClickEvent(domEventName, targetInst) {
          if (domEventName === "click") {
            return getInstIfValueChanged(targetInst);
          }
        }
        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
          if (domEventName === "input" || domEventName === "change") {
            return getInstIfValueChanged(targetInst);
          }
        }
        function handleControlledInputBlur(node) {
          var state = node._wrapperState;
          if (!state || !state.controlled || node.type !== "number") {
            return;
          }
          {
            setDefaultValue(node, "number", node.value);
          }
        }
        function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
          var getTargetInstFunc, handleEventFunc;
          if (shouldUseChangeEvent(targetNode)) {
            getTargetInstFunc = getTargetInstForChangeEvent;
          } else if (isTextInputElement(targetNode)) {
            if (isInputEventSupported) {
              getTargetInstFunc = getTargetInstForInputOrChangeEvent;
            } else {
              getTargetInstFunc = getTargetInstForInputEventPolyfill;
              handleEventFunc = handleEventsForInputEventPolyfill;
            }
          } else if (shouldUseClickEvent(targetNode)) {
            getTargetInstFunc = getTargetInstForClickEvent;
          }
          if (getTargetInstFunc) {
            var inst = getTargetInstFunc(domEventName, targetInst);
            if (inst) {
              createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
              return;
            }
          }
          if (handleEventFunc) {
            handleEventFunc(domEventName, targetNode, targetInst);
          }
          if (domEventName === "focusout") {
            handleControlledInputBlur(targetNode);
          }
        }
        function registerEvents$2() {
          registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
          registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
          registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
          registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
        }
        function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
          var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
          if (isOverEvent && !isReplayingEvent(nativeEvent)) {
            var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
            if (related) {
              if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
                return;
              }
            }
          }
          if (!isOutEvent && !isOverEvent) {
            return;
          }
          var win;
          if (nativeEventTarget.window === nativeEventTarget) {
            win = nativeEventTarget;
          } else {
            var doc = nativeEventTarget.ownerDocument;
            if (doc) {
              win = doc.defaultView || doc.parentWindow;
            } else {
              win = window;
            }
          }
          var from;
          var to;
          if (isOutEvent) {
            var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
            from = targetInst;
            to = _related ? getClosestInstanceFromNode(_related) : null;
            if (to !== null) {
              var nearestMounted = getNearestMountedFiber(to);
              if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {
                to = null;
              }
            }
          } else {
            from = null;
            to = targetInst;
          }
          if (from === to) {
            return;
          }
          var SyntheticEventCtor = SyntheticMouseEvent;
          var leaveEventType = "onMouseLeave";
          var enterEventType = "onMouseEnter";
          var eventTypePrefix = "mouse";
          if (domEventName === "pointerout" || domEventName === "pointerover") {
            SyntheticEventCtor = SyntheticPointerEvent;
            leaveEventType = "onPointerLeave";
            enterEventType = "onPointerEnter";
            eventTypePrefix = "pointer";
          }
          var fromNode = from == null ? win : getNodeFromInstance(from);
          var toNode = to == null ? win : getNodeFromInstance(to);
          var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from, nativeEvent, nativeEventTarget);
          leave.target = fromNode;
          leave.relatedTarget = toNode;
          var enter = null;
          var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
          if (nativeTargetInst === targetInst) {
            var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to, nativeEvent, nativeEventTarget);
            enterEvent.target = toNode;
            enterEvent.relatedTarget = fromNode;
            enter = enterEvent;
          }
          accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        function shallowEqual(objA, objB) {
          if (objectIs(objA, objB)) {
            return true;
          }
          if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
            return false;
          }
          var keysA = Object.keys(objA);
          var keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) {
            return false;
          }
          for (var i = 0; i < keysA.length; i++) {
            var currentKey = keysA[i];
            if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
              return false;
            }
          }
          return true;
        }
        function getLeafNode(node) {
          while (node && node.firstChild) {
            node = node.firstChild;
          }
          return node;
        }
        function getSiblingNode(node) {
          while (node) {
            if (node.nextSibling) {
              return node.nextSibling;
            }
            node = node.parentNode;
          }
        }
        function getNodeForCharacterOffset(root2, offset) {
          var node = getLeafNode(root2);
          var nodeStart = 0;
          var nodeEnd = 0;
          while (node) {
            if (node.nodeType === TEXT_NODE) {
              nodeEnd = nodeStart + node.textContent.length;
              if (nodeStart <= offset && nodeEnd >= offset) {
                return {
                  node,
                  offset: offset - nodeStart
                };
              }
              nodeStart = nodeEnd;
            }
            node = getLeafNode(getSiblingNode(node));
          }
        }
        function getOffsets(outerNode) {
          var ownerDocument = outerNode.ownerDocument;
          var win = ownerDocument && ownerDocument.defaultView || window;
          var selection = win.getSelection && win.getSelection();
          if (!selection || selection.rangeCount === 0) {
            return null;
          }
          var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
          try {
            anchorNode.nodeType;
            focusNode.nodeType;
          } catch (e) {
            return null;
          }
          return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
        }
        function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
          var length = 0;
          var start = -1;
          var end = -1;
          var indexWithinAnchor = 0;
          var indexWithinFocus = 0;
          var node = outerNode;
          var parentNode = null;
          outer:
            while (true) {
              var next = null;
              while (true) {
                if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
                  start = length + anchorOffset;
                }
                if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
                  end = length + focusOffset;
                }
                if (node.nodeType === TEXT_NODE) {
                  length += node.nodeValue.length;
                }
                if ((next = node.firstChild) === null) {
                  break;
                }
                parentNode = node;
                node = next;
              }
              while (true) {
                if (node === outerNode) {
                  break outer;
                }
                if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                  start = length;
                }
                if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
                  end = length;
                }
                if ((next = node.nextSibling) !== null) {
                  break;
                }
                node = parentNode;
                parentNode = node.parentNode;
              }
              node = next;
            }
          if (start === -1 || end === -1) {
            return null;
          }
          return {
            start,
            end
          };
        }
        function setOffsets(node, offsets) {
          var doc = node.ownerDocument || document;
          var win = doc && doc.defaultView || window;
          if (!win.getSelection) {
            return;
          }
          var selection = win.getSelection();
          var length = node.textContent.length;
          var start = Math.min(offsets.start, length);
          var end = offsets.end === void 0 ? start : Math.min(offsets.end, length);
          if (!selection.extend && start > end) {
            var temp = end;
            end = start;
            start = temp;
          }
          var startMarker = getNodeForCharacterOffset(node, start);
          var endMarker = getNodeForCharacterOffset(node, end);
          if (startMarker && endMarker) {
            if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
              return;
            }
            var range = doc.createRange();
            range.setStart(startMarker.node, startMarker.offset);
            selection.removeAllRanges();
            if (start > end) {
              selection.addRange(range);
              selection.extend(endMarker.node, endMarker.offset);
            } else {
              range.setEnd(endMarker.node, endMarker.offset);
              selection.addRange(range);
            }
          }
        }
        function isTextNode(node) {
          return node && node.nodeType === TEXT_NODE;
        }
        function containsNode(outerNode, innerNode) {
          if (!outerNode || !innerNode) {
            return false;
          } else if (outerNode === innerNode) {
            return true;
          } else if (isTextNode(outerNode)) {
            return false;
          } else if (isTextNode(innerNode)) {
            return containsNode(outerNode, innerNode.parentNode);
          } else if ("contains" in outerNode) {
            return outerNode.contains(innerNode);
          } else if (outerNode.compareDocumentPosition) {
            return !!(outerNode.compareDocumentPosition(innerNode) & 16);
          } else {
            return false;
          }
        }
        function isInDocument(node) {
          return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
        }
        function isSameOriginFrame(iframe) {
          try {
            return typeof iframe.contentWindow.location.href === "string";
          } catch (err) {
            return false;
          }
        }
        function getActiveElementDeep() {
          var win = window;
          var element = getActiveElement();
          while (element instanceof win.HTMLIFrameElement) {
            if (isSameOriginFrame(element)) {
              win = element.contentWindow;
            } else {
              return element;
            }
            element = getActiveElement(win.document);
          }
          return element;
        }
        function hasSelectionCapabilities(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
        }
        function getSelectionInformation() {
          var focusedElem = getActiveElementDeep();
          return {
            focusedElem,
            selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
          };
        }
        function restoreSelection(priorSelectionInformation) {
          var curFocusedElem = getActiveElementDeep();
          var priorFocusedElem = priorSelectionInformation.focusedElem;
          var priorSelectionRange = priorSelectionInformation.selectionRange;
          if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
            if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
              setSelection(priorFocusedElem, priorSelectionRange);
            }
            var ancestors = [];
            var ancestor = priorFocusedElem;
            while (ancestor = ancestor.parentNode) {
              if (ancestor.nodeType === ELEMENT_NODE) {
                ancestors.push({
                  element: ancestor,
                  left: ancestor.scrollLeft,
                  top: ancestor.scrollTop
                });
              }
            }
            if (typeof priorFocusedElem.focus === "function") {
              priorFocusedElem.focus();
            }
            for (var i = 0; i < ancestors.length; i++) {
              var info = ancestors[i];
              info.element.scrollLeft = info.left;
              info.element.scrollTop = info.top;
            }
          }
        }
        function getSelection(input) {
          var selection;
          if ("selectionStart" in input) {
            selection = {
              start: input.selectionStart,
              end: input.selectionEnd
            };
          } else {
            selection = getOffsets(input);
          }
          return selection || {
            start: 0,
            end: 0
          };
        }
        function setSelection(input, offsets) {
          var start = offsets.start;
          var end = offsets.end;
          if (end === void 0) {
            end = start;
          }
          if ("selectionStart" in input) {
            input.selectionStart = start;
            input.selectionEnd = Math.min(end, input.value.length);
          } else {
            setOffsets(input, offsets);
          }
        }
        var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && document.documentMode <= 11;
        function registerEvents$3() {
          registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
        }
        var activeElement$1 = null;
        var activeElementInst$1 = null;
        var lastSelection = null;
        var mouseDown = false;
        function getSelection$1(node) {
          if ("selectionStart" in node && hasSelectionCapabilities(node)) {
            return {
              start: node.selectionStart,
              end: node.selectionEnd
            };
          } else {
            var win = node.ownerDocument && node.ownerDocument.defaultView || window;
            var selection = win.getSelection();
            return {
              anchorNode: selection.anchorNode,
              anchorOffset: selection.anchorOffset,
              focusNode: selection.focusNode,
              focusOffset: selection.focusOffset
            };
          }
        }
        function getEventTargetDocument(eventTarget) {
          return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
        }
        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
          var doc = getEventTargetDocument(nativeEventTarget);
          if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
            return;
          }
          var currentSelection = getSelection$1(activeElement$1);
          if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
            lastSelection = currentSelection;
            var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
            if (listeners.length > 0) {
              var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              event.target = activeElement$1;
            }
          }
        }
        function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
          switch (domEventName) {
            case "focusin":
              if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
                activeElement$1 = targetNode;
                activeElementInst$1 = targetInst;
                lastSelection = null;
              }
              break;
            case "focusout":
              activeElement$1 = null;
              activeElementInst$1 = null;
              lastSelection = null;
              break;
            case "mousedown":
              mouseDown = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = false;
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
              break;
            case "selectionchange":
              if (skipSelectionChangeEvent) {
                break;
              }
            case "keydown":
            case "keyup":
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          }
        }
        function makePrefixMap(styleProp, eventName) {
          var prefixes2 = {};
          prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
          prefixes2["Webkit" + styleProp] = "webkit" + eventName;
          prefixes2["Moz" + styleProp] = "moz" + eventName;
          return prefixes2;
        }
        var vendorPrefixes = {
          animationend: makePrefixMap("Animation", "AnimationEnd"),
          animationiteration: makePrefixMap("Animation", "AnimationIteration"),
          animationstart: makePrefixMap("Animation", "AnimationStart"),
          transitionend: makePrefixMap("Transition", "TransitionEnd")
        };
        var prefixedEventNames = {};
        var style = {};
        if (canUseDOM) {
          style = document.createElement("div").style;
          if (!("AnimationEvent" in window)) {
            delete vendorPrefixes.animationend.animation;
            delete vendorPrefixes.animationiteration.animation;
            delete vendorPrefixes.animationstart.animation;
          }
          if (!("TransitionEvent" in window)) {
            delete vendorPrefixes.transitionend.transition;
          }
        }
        function getVendorPrefixedEventName(eventName) {
          if (prefixedEventNames[eventName]) {
            return prefixedEventNames[eventName];
          } else if (!vendorPrefixes[eventName]) {
            return eventName;
          }
          var prefixMap = vendorPrefixes[eventName];
          for (var styleProp in prefixMap) {
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
              return prefixedEventNames[eventName] = prefixMap[styleProp];
            }
          }
          return eventName;
        }
        var ANIMATION_END = getVendorPrefixedEventName("animationend");
        var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
        var ANIMATION_START = getVendorPrefixedEventName("animationstart");
        var TRANSITION_END = getVendorPrefixedEventName("transitionend");
        var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
        var simpleEventPluginEvents = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
        function registerSimpleEvent(domEventName, reactName) {
          topLevelEventsToReactNames.set(domEventName, reactName);
          registerTwoPhaseEvent(reactName, [domEventName]);
        }
        function registerSimpleEvents() {
          for (var i = 0; i < simpleEventPluginEvents.length; i++) {
            var eventName = simpleEventPluginEvents[i];
            var domEventName = eventName.toLowerCase();
            var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
            registerSimpleEvent(domEventName, "on" + capitalizedEvent);
          }
          registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
          registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
          registerSimpleEvent(ANIMATION_START, "onAnimationStart");
          registerSimpleEvent("dblclick", "onDoubleClick");
          registerSimpleEvent("focusin", "onFocus");
          registerSimpleEvent("focusout", "onBlur");
          registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
        }
        function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (reactName === void 0) {
            return;
          }
          var SyntheticEventCtor = SyntheticEvent;
          var reactEventType = domEventName;
          switch (domEventName) {
            case "keypress":
              if (getEventCharCode(nativeEvent) === 0) {
                return;
              }
            case "keydown":
            case "keyup":
              SyntheticEventCtor = SyntheticKeyboardEvent;
              break;
            case "focusin":
              reactEventType = "focus";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "focusout":
              reactEventType = "blur";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "beforeblur":
            case "afterblur":
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "click":
              if (nativeEvent.button === 2) {
                return;
              }
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              SyntheticEventCtor = SyntheticMouseEvent;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              SyntheticEventCtor = SyntheticDragEvent;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              SyntheticEventCtor = SyntheticTouchEvent;
              break;
            case ANIMATION_END:
            case ANIMATION_ITERATION:
            case ANIMATION_START:
              SyntheticEventCtor = SyntheticAnimationEvent;
              break;
            case TRANSITION_END:
              SyntheticEventCtor = SyntheticTransitionEvent;
              break;
            case "scroll":
              SyntheticEventCtor = SyntheticUIEvent;
              break;
            case "wheel":
              SyntheticEventCtor = SyntheticWheelEvent;
              break;
            case "copy":
            case "cut":
            case "paste":
              SyntheticEventCtor = SyntheticClipboardEvent;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              SyntheticEventCtor = SyntheticPointerEvent;
              break;
          }
          var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
          {
            var accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from
            // nonDelegatedEvents list in DOMPluginEventSystem.
            // Then we can remove this special list.
            // This is a breaking change that can wait until React 18.
            domEventName === "scroll";
            var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
            if (_listeners.length > 0) {
              var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event: _event,
                listeners: _listeners
              });
            }
          }
        }
        registerSimpleEvents();
        registerEvents$2();
        registerEvents$1();
        registerEvents$3();
        registerEvents();
        function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
          var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
          if (shouldProcessPolyfillPlugins) {
            extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          }
        }
        var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
        var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
        function executeDispatch(event, listener, currentTarget) {
          var type = event.type || "unknown-event";
          event.currentTarget = currentTarget;
          invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
          event.currentTarget = null;
        }
        function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
          var previousInstance;
          if (inCapturePhase) {
            for (var i = dispatchListeners.length - 1; i >= 0; i--) {
              var _dispatchListeners$i = dispatchListeners[i], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped()) {
                return;
              }
              executeDispatch(event, listener, currentTarget);
              previousInstance = instance;
            }
          } else {
            for (var _i = 0; _i < dispatchListeners.length; _i++) {
              var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
              if (_instance !== previousInstance && event.isPropagationStopped()) {
                return;
              }
              executeDispatch(event, _listener, _currentTarget);
              previousInstance = _instance;
            }
          }
        }
        function processDispatchQueue(dispatchQueue, eventSystemFlags) {
          var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
          for (var i = 0; i < dispatchQueue.length; i++) {
            var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
            processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
          }
          rethrowCaughtError();
        }
        function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
          var nativeEventTarget = getEventTarget(nativeEvent);
          var dispatchQueue = [];
          extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
          processDispatchQueue(dispatchQueue, eventSystemFlags);
        }
        function listenToNonDelegatedEvent(domEventName, targetElement) {
          {
            if (!nonDelegatedEvents.has(domEventName)) {
              error2('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
            }
          }
          var isCapturePhaseListener = false;
          var listenerSet = getEventListenerSet(targetElement);
          var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
          if (!listenerSet.has(listenerSetKey)) {
            addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
            listenerSet.add(listenerSetKey);
          }
        }
        function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
          {
            if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
              error2('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
            }
          }
          var eventSystemFlags = 0;
          if (isCapturePhaseListener) {
            eventSystemFlags |= IS_CAPTURE_PHASE;
          }
          addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
        }
        var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
        function listenToAllSupportedEvents(rootContainerElement) {
          if (!rootContainerElement[listeningMarker]) {
            rootContainerElement[listeningMarker] = true;
            allNativeEvents.forEach(function(domEventName) {
              if (domEventName !== "selectionchange") {
                if (!nonDelegatedEvents.has(domEventName)) {
                  listenToNativeEvent(domEventName, false, rootContainerElement);
                }
                listenToNativeEvent(domEventName, true, rootContainerElement);
              }
            });
            var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
            if (ownerDocument !== null) {
              if (!ownerDocument[listeningMarker]) {
                ownerDocument[listeningMarker] = true;
                listenToNativeEvent("selectionchange", false, ownerDocument);
              }
            }
          }
        }
        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
          var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
          var isPassiveListener = void 0;
          if (passiveBrowserEventsSupported) {
            if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
              isPassiveListener = true;
            }
          }
          targetContainer = targetContainer;
          var unsubscribeListener;
          if (isCapturePhaseListener) {
            if (isPassiveListener !== void 0) {
              unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
            } else {
              unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
            }
          } else {
            if (isPassiveListener !== void 0) {
              unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
            } else {
              unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
            }
          }
        }
        function isMatchingRootContainer(grandContainer, targetContainer) {
          return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
        }
        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
          var ancestorInst = targetInst;
          if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
            var targetContainerNode = targetContainer;
            if (targetInst !== null) {
              var node = targetInst;
              mainLoop:
                while (true) {
                  if (node === null) {
                    return;
                  }
                  var nodeTag = node.tag;
                  if (nodeTag === HostRoot || nodeTag === HostPortal) {
                    var container = node.stateNode.containerInfo;
                    if (isMatchingRootContainer(container, targetContainerNode)) {
                      break;
                    }
                    if (nodeTag === HostPortal) {
                      var grandNode = node.return;
                      while (grandNode !== null) {
                        var grandTag = grandNode.tag;
                        if (grandTag === HostRoot || grandTag === HostPortal) {
                          var grandContainer = grandNode.stateNode.containerInfo;
                          if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                            return;
                          }
                        }
                        grandNode = grandNode.return;
                      }
                    }
                    while (container !== null) {
                      var parentNode = getClosestInstanceFromNode(container);
                      if (parentNode === null) {
                        return;
                      }
                      var parentTag = parentNode.tag;
                      if (parentTag === HostComponent || parentTag === HostText) {
                        node = ancestorInst = parentNode;
                        continue mainLoop;
                      }
                      container = container.parentNode;
                    }
                  }
                  node = node.return;
                }
            }
          }
          batchedUpdates(function() {
            return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
          });
        }
        function createDispatchListener(instance, listener, currentTarget) {
          return {
            instance,
            listener,
            currentTarget
          };
        }
        function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
          var captureName = reactName !== null ? reactName + "Capture" : null;
          var reactEventName = inCapturePhase ? captureName : reactName;
          var listeners = [];
          var instance = targetFiber;
          var lastHostComponent = null;
          while (instance !== null) {
            var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;
            if (tag === HostComponent && stateNode !== null) {
              lastHostComponent = stateNode;
              if (reactEventName !== null) {
                var listener = getListener(instance, reactEventName);
                if (listener != null) {
                  listeners.push(createDispatchListener(instance, listener, lastHostComponent));
                }
              }
            }
            if (accumulateTargetOnly) {
              break;
            }
            instance = instance.return;
          }
          return listeners;
        }
        function accumulateTwoPhaseListeners(targetFiber, reactName) {
          var captureName = reactName + "Capture";
          var listeners = [];
          var instance = targetFiber;
          while (instance !== null) {
            var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;
            if (tag === HostComponent && stateNode !== null) {
              var currentTarget = stateNode;
              var captureListener = getListener(instance, captureName);
              if (captureListener != null) {
                listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
              }
              var bubbleListener = getListener(instance, reactName);
              if (bubbleListener != null) {
                listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
              }
            }
            instance = instance.return;
          }
          return listeners;
        }
        function getParent(inst) {
          if (inst === null) {
            return null;
          }
          do {
            inst = inst.return;
          } while (inst && inst.tag !== HostComponent);
          if (inst) {
            return inst;
          }
          return null;
        }
        function getLowestCommonAncestor(instA, instB) {
          var nodeA = instA;
          var nodeB = instB;
          var depthA = 0;
          for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
            depthA++;
          }
          var depthB = 0;
          for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
            depthB++;
          }
          while (depthA - depthB > 0) {
            nodeA = getParent(nodeA);
            depthA--;
          }
          while (depthB - depthA > 0) {
            nodeB = getParent(nodeB);
            depthB--;
          }
          var depth = depthA;
          while (depth--) {
            if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
              return nodeA;
            }
            nodeA = getParent(nodeA);
            nodeB = getParent(nodeB);
          }
          return null;
        }
        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
          var registrationName = event._reactName;
          var listeners = [];
          var instance = target;
          while (instance !== null) {
            if (instance === common) {
              break;
            }
            var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
            if (alternate !== null && alternate === common) {
              break;
            }
            if (tag === HostComponent && stateNode !== null) {
              var currentTarget = stateNode;
              if (inCapturePhase) {
                var captureListener = getListener(instance, registrationName);
                if (captureListener != null) {
                  listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                }
              } else if (!inCapturePhase) {
                var bubbleListener = getListener(instance, registrationName);
                if (bubbleListener != null) {
                  listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                }
              }
            }
            instance = instance.return;
          }
          if (listeners.length !== 0) {
            dispatchQueue.push({
              event,
              listeners
            });
          }
        }
        function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {
          var common = from && to ? getLowestCommonAncestor(from, to) : null;
          if (from !== null) {
            accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);
          }
          if (to !== null && enterEvent !== null) {
            accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
          }
        }
        function getListenerSetKey(domEventName, capture) {
          return domEventName + "__" + (capture ? "capture" : "bubble");
        }
        var didWarnInvalidHydration = false;
        var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
        var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
        var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
        var AUTOFOCUS = "autoFocus";
        var CHILDREN = "children";
        var STYLE = "style";
        var HTML$1 = "__html";
        var warnedUnknownTags;
        var validatePropertiesInDevelopment;
        var warnForPropDifference;
        var warnForExtraAttributes;
        var warnForInvalidEventListener;
        var canDiffStyleForHydrationWarning;
        var normalizeHTML;
        {
          warnedUnknownTags = {
            // There are working polyfills for <dialog>. Let people use it.
            dialog: true,
            // Electron ships a custom <webview> tag to display external web content in
            // an isolated frame and process.
            // This tag is not present in non Electron environments such as JSDom which
            // is often used for testing purposes.
            // @see https://electronjs.org/docs/api/webview-tag
            webview: true
          };
          validatePropertiesInDevelopment = function(type, props) {
            validateProperties(type, props);
            validateProperties$1(type, props);
            validateProperties$2(type, props, {
              registrationNameDependencies,
              possibleRegistrationNames
            });
          };
          canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;
          warnForPropDifference = function(propName, serverValue, clientValue) {
            if (didWarnInvalidHydration) {
              return;
            }
            var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
            var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
            if (normalizedServerValue === normalizedClientValue) {
              return;
            }
            didWarnInvalidHydration = true;
            error2("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
          };
          warnForExtraAttributes = function(attributeNames) {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            var names = [];
            attributeNames.forEach(function(name2) {
              names.push(name2);
            });
            error2("Extra attributes from the server: %s", names);
          };
          warnForInvalidEventListener = function(registrationName, listener) {
            if (listener === false) {
              error2("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
            } else {
              error2("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
            }
          };
          normalizeHTML = function(parent, html) {
            var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
            testElement.innerHTML = html;
            return testElement.innerHTML;
          };
        }
        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
        var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
        function normalizeMarkupForTextOrAttribute(markup) {
          {
            checkHtmlStringCoercion(markup);
          }
          var markupString = typeof markup === "string" ? markup : "" + markup;
          return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
        }
        function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
          var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
          var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
          if (normalizedServerText === normalizedClientText) {
            return;
          }
          if (shouldWarnDev) {
            {
              if (!didWarnInvalidHydration) {
                didWarnInvalidHydration = true;
                error2('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
              }
            }
          }
          if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
            throw new Error("Text content does not match server-rendered HTML.");
          }
        }
        function getOwnerDocumentFromRootContainer(rootContainerElement) {
          return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
        }
        function noop() {
        }
        function trapClickOnNonInteractiveElement(node) {
          node.onclick = noop;
        }
        function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
          for (var propKey in nextProps) {
            if (!nextProps.hasOwnProperty(propKey)) {
              continue;
            }
            var nextProp = nextProps[propKey];
            if (propKey === STYLE) {
              {
                if (nextProp) {
                  Object.freeze(nextProp);
                }
              }
              setValueForStyles(domElement, nextProp);
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
              if (nextHtml != null) {
                setInnerHTML(domElement, nextHtml);
              }
            } else if (propKey === CHILDREN) {
              if (typeof nextProp === "string") {
                var canSetTextContent = tag !== "textarea" || nextProp !== "";
                if (canSetTextContent) {
                  setTextContent(domElement, nextProp);
                }
              } else if (typeof nextProp === "number") {
                setTextContent(domElement, "" + nextProp);
              }
            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
              ;
            else if (propKey === AUTOFOCUS)
              ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
            } else if (nextProp != null) {
              setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
            }
          }
        }
        function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
          for (var i = 0; i < updatePayload.length; i += 2) {
            var propKey = updatePayload[i];
            var propValue = updatePayload[i + 1];
            if (propKey === STYLE) {
              setValueForStyles(domElement, propValue);
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              setInnerHTML(domElement, propValue);
            } else if (propKey === CHILDREN) {
              setTextContent(domElement, propValue);
            } else {
              setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
            }
          }
        }
        function createElement(type, props, rootContainerElement, parentNamespace) {
          var isCustomComponentTag;
          var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
          var domElement;
          var namespaceURI = parentNamespace;
          if (namespaceURI === HTML_NAMESPACE) {
            namespaceURI = getIntrinsicNamespace(type);
          }
          if (namespaceURI === HTML_NAMESPACE) {
            {
              isCustomComponentTag = isCustomComponent(type, props);
              if (!isCustomComponentTag && type !== type.toLowerCase()) {
                error2("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
              }
            }
            if (type === "script") {
              var div = ownerDocument.createElement("div");
              div.innerHTML = "<script><\/script>";
              var firstChild = div.firstChild;
              domElement = div.removeChild(firstChild);
            } else if (typeof props.is === "string") {
              domElement = ownerDocument.createElement(type, {
                is: props.is
              });
            } else {
              domElement = ownerDocument.createElement(type);
              if (type === "select") {
                var node = domElement;
                if (props.multiple) {
                  node.multiple = true;
                } else if (props.size) {
                  node.size = props.size;
                }
              }
            }
          } else {
            domElement = ownerDocument.createElementNS(namespaceURI, type);
          }
          {
            if (namespaceURI === HTML_NAMESPACE) {
              if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !hasOwnProperty.call(warnedUnknownTags, type)) {
                warnedUnknownTags[type] = true;
                error2("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type);
              }
            }
          }
          return domElement;
        }
        function createTextNode(text2, rootContainerElement) {
          return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text2);
        }
        function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
          var isCustomComponentTag = isCustomComponent(tag, rawProps);
          {
            validatePropertiesInDevelopment(tag, rawProps);
          }
          var props;
          switch (tag) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              props = rawProps;
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", domElement);
              props = rawProps;
              break;
            case "video":
            case "audio":
              for (var i = 0; i < mediaEventTypes.length; i++) {
                listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
              }
              props = rawProps;
              break;
            case "source":
              listenToNonDelegatedEvent("error", domElement);
              props = rawProps;
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              props = rawProps;
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              props = rawProps;
              break;
            case "input":
              initWrapperState(domElement, rawProps);
              props = getHostProps(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "option":
              validateProps(domElement, rawProps);
              props = rawProps;
              break;
            case "select":
              initWrapperState$1(domElement, rawProps);
              props = getHostProps$1(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "textarea":
              initWrapperState$2(domElement, rawProps);
              props = getHostProps$2(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            default:
              props = rawProps;
          }
          assertValidProps(tag, props);
          setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
          switch (tag) {
            case "input":
              track(domElement);
              postMountWrapper(domElement, rawProps, false);
              break;
            case "textarea":
              track(domElement);
              postMountWrapper$3(domElement);
              break;
            case "option":
              postMountWrapper$1(domElement, rawProps);
              break;
            case "select":
              postMountWrapper$2(domElement, rawProps);
              break;
            default:
              if (typeof props.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
        }
        function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
          {
            validatePropertiesInDevelopment(tag, nextRawProps);
          }
          var updatePayload = null;
          var lastProps;
          var nextProps;
          switch (tag) {
            case "input":
              lastProps = getHostProps(domElement, lastRawProps);
              nextProps = getHostProps(domElement, nextRawProps);
              updatePayload = [];
              break;
            case "select":
              lastProps = getHostProps$1(domElement, lastRawProps);
              nextProps = getHostProps$1(domElement, nextRawProps);
              updatePayload = [];
              break;
            case "textarea":
              lastProps = getHostProps$2(domElement, lastRawProps);
              nextProps = getHostProps$2(domElement, nextRawProps);
              updatePayload = [];
              break;
            default:
              lastProps = lastRawProps;
              nextProps = nextRawProps;
              if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
          assertValidProps(tag, nextProps);
          var propKey;
          var styleName;
          var styleUpdates = null;
          for (propKey in lastProps) {
            if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
              continue;
            }
            if (propKey === STYLE) {
              var lastStyle = lastProps[propKey];
              for (styleName in lastStyle) {
                if (lastStyle.hasOwnProperty(styleName)) {
                  if (!styleUpdates) {
                    styleUpdates = {};
                  }
                  styleUpdates[styleName] = "";
                }
              }
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN)
              ;
            else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
              ;
            else if (propKey === AUTOFOCUS)
              ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (!updatePayload) {
                updatePayload = [];
              }
            } else {
              (updatePayload = updatePayload || []).push(propKey, null);
            }
          }
          for (propKey in nextProps) {
            var nextProp = nextProps[propKey];
            var lastProp = lastProps != null ? lastProps[propKey] : void 0;
            if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
              continue;
            }
            if (propKey === STYLE) {
              {
                if (nextProp) {
                  Object.freeze(nextProp);
                }
              }
              if (lastProp) {
                for (styleName in lastProp) {
                  if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = "";
                  }
                }
                for (styleName in nextProp) {
                  if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = nextProp[styleName];
                  }
                }
              } else {
                if (!styleUpdates) {
                  if (!updatePayload) {
                    updatePayload = [];
                  }
                  updatePayload.push(propKey, styleUpdates);
                }
                styleUpdates = nextProp;
              }
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
              var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
              if (nextHtml != null) {
                if (lastHtml !== nextHtml) {
                  (updatePayload = updatePayload || []).push(propKey, nextHtml);
                }
              }
            } else if (propKey === CHILDREN) {
              if (typeof nextProp === "string" || typeof nextProp === "number") {
                (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
              }
            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
              ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
              if (!updatePayload && lastProp !== nextProp) {
                updatePayload = [];
              }
            } else {
              (updatePayload = updatePayload || []).push(propKey, nextProp);
            }
          }
          if (styleUpdates) {
            {
              validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
            }
            (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
          }
          return updatePayload;
        }
        function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
          if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
            updateChecked(domElement, nextRawProps);
          }
          var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
          var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
          updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
          switch (tag) {
            case "input":
              updateWrapper(domElement, nextRawProps);
              break;
            case "textarea":
              updateWrapper$1(domElement, nextRawProps);
              break;
            case "select":
              postUpdateWrapper(domElement, nextRawProps);
              break;
          }
        }
        function getPossibleStandardName(propName) {
          {
            var lowerCasedName = propName.toLowerCase();
            if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              return null;
            }
            return possibleStandardNames[lowerCasedName] || null;
          }
        }
        function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {
          var isCustomComponentTag;
          var extraAttributeNames;
          {
            isCustomComponentTag = isCustomComponent(tag, rawProps);
            validatePropertiesInDevelopment(tag, rawProps);
          }
          switch (tag) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "video":
            case "audio":
              for (var i = 0; i < mediaEventTypes.length; i++) {
                listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
              }
              break;
            case "source":
              listenToNonDelegatedEvent("error", domElement);
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              break;
            case "input":
              initWrapperState(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "option":
              validateProps(domElement, rawProps);
              break;
            case "select":
              initWrapperState$1(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "textarea":
              initWrapperState$2(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
          }
          assertValidProps(tag, rawProps);
          {
            extraAttributeNames = /* @__PURE__ */ new Set();
            var attributes = domElement.attributes;
            for (var _i = 0; _i < attributes.length; _i++) {
              var name2 = attributes[_i].name.toLowerCase();
              switch (name2) {
                case "value":
                  break;
                case "checked":
                  break;
                case "selected":
                  break;
                default:
                  extraAttributeNames.add(attributes[_i].name);
              }
            }
          }
          var updatePayload = null;
          for (var propKey in rawProps) {
            if (!rawProps.hasOwnProperty(propKey)) {
              continue;
            }
            var nextProp = rawProps[propKey];
            if (propKey === CHILDREN) {
              if (typeof nextProp === "string") {
                if (domElement.textContent !== nextProp) {
                  if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                    checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                  }
                  updatePayload = [CHILDREN, nextProp];
                }
              } else if (typeof nextProp === "number") {
                if (domElement.textContent !== "" + nextProp) {
                  if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                    checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                  }
                  updatePayload = [CHILDREN, "" + nextProp];
                }
              }
            } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
            } else if (shouldWarnDev && true && // Convince Flow we've calculated it (it's DEV-only in this method.)
            typeof isCustomComponentTag === "boolean") {
              var serverValue = void 0;
              var propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);
              if (rawProps[SUPPRESS_HYDRATION_WARNING] === true)
                ;
              else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              propKey === "value" || propKey === "checked" || propKey === "selected")
                ;
              else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var serverHTML = domElement.innerHTML;
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  var expectedHTML = normalizeHTML(domElement, nextHtml);
                  if (expectedHTML !== serverHTML) {
                    warnForPropDifference(propKey, serverHTML, expectedHTML);
                  }
                }
              } else if (propKey === STYLE) {
                extraAttributeNames.delete(propKey);
                if (canDiffStyleForHydrationWarning) {
                  var expectedStyle = createDangerousStringForStyles(nextProp);
                  serverValue = domElement.getAttribute("style");
                  if (expectedStyle !== serverValue) {
                    warnForPropDifference(propKey, serverValue, expectedStyle);
                  }
                }
              } else if (isCustomComponentTag && !enableCustomElementPropertySupport) {
                extraAttributeNames.delete(propKey.toLowerCase());
                serverValue = getValueForAttribute(domElement, propKey, nextProp);
                if (nextProp !== serverValue) {
                  warnForPropDifference(propKey, serverValue, nextProp);
                }
              } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                var isMismatchDueToBadCasing = false;
                if (propertyInfo !== null) {
                  extraAttributeNames.delete(propertyInfo.attributeName);
                  serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                } else {
                  var ownNamespace = parentNamespace;
                  if (ownNamespace === HTML_NAMESPACE) {
                    ownNamespace = getIntrinsicNamespace(tag);
                  }
                  if (ownNamespace === HTML_NAMESPACE) {
                    extraAttributeNames.delete(propKey.toLowerCase());
                  } else {
                    var standardName = getPossibleStandardName(propKey);
                    if (standardName !== null && standardName !== propKey) {
                      isMismatchDueToBadCasing = true;
                      extraAttributeNames.delete(standardName);
                    }
                    extraAttributeNames.delete(propKey);
                  }
                  serverValue = getValueForAttribute(domElement, propKey, nextProp);
                }
                var dontWarnCustomElement = enableCustomElementPropertySupport;
                if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {
                  warnForPropDifference(propKey, serverValue, nextProp);
                }
              }
            }
          }
          {
            if (shouldWarnDev) {
              if (
                // $FlowFixMe - Should be inferred as not undefined.
                extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true
              ) {
                warnForExtraAttributes(extraAttributeNames);
              }
            }
          }
          switch (tag) {
            case "input":
              track(domElement);
              postMountWrapper(domElement, rawProps, true);
              break;
            case "textarea":
              track(domElement);
              postMountWrapper$3(domElement);
              break;
            case "select":
            case "option":
              break;
            default:
              if (typeof rawProps.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
          return updatePayload;
        }
        function diffHydratedText(textNode, text2, isConcurrentMode) {
          var isDifferent = textNode.nodeValue !== text2;
          return isDifferent;
        }
        function warnForDeletedHydratableElement(parentNode, child) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error2("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
          }
        }
        function warnForDeletedHydratableText(parentNode, child) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error2('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
          }
        }
        function warnForInsertedHydratedElement(parentNode, tag, props) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error2("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
          }
        }
        function warnForInsertedHydratedText(parentNode, text2) {
          {
            if (text2 === "") {
              return;
            }
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error2('Expected server HTML to contain a matching text node for "%s" in <%s>.', text2, parentNode.nodeName.toLowerCase());
          }
        }
        function restoreControlledState$3(domElement, tag, props) {
          switch (tag) {
            case "input":
              restoreControlledState(domElement, props);
              return;
            case "textarea":
              restoreControlledState$2(domElement, props);
              return;
            case "select":
              restoreControlledState$1(domElement, props);
              return;
          }
        }
        var validateDOMNesting = function() {
        };
        var updatedAncestorInfo = function() {
        };
        {
          var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
          var inScopeTags = [
            "applet",
            "caption",
            "html",
            "table",
            "td",
            "th",
            "marquee",
            "object",
            "template",
            // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
            // TODO: Distinguish by namespace here -- for <title>, including it here
            // errs on the side of fewer warnings
            "foreignObject",
            "desc",
            "title"
          ];
          var buttonScopeTags = inScopeTags.concat(["button"]);
          var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
          var emptyAncestorInfo = {
            current: null,
            formTag: null,
            aTagInScope: null,
            buttonTagInScope: null,
            nobrTagInScope: null,
            pTagInButtonScope: null,
            listItemTagAutoclosing: null,
            dlItemTagAutoclosing: null
          };
          updatedAncestorInfo = function(oldInfo, tag) {
            var ancestorInfo = assign3({}, oldInfo || emptyAncestorInfo);
            var info = {
              tag
            };
            if (inScopeTags.indexOf(tag) !== -1) {
              ancestorInfo.aTagInScope = null;
              ancestorInfo.buttonTagInScope = null;
              ancestorInfo.nobrTagInScope = null;
            }
            if (buttonScopeTags.indexOf(tag) !== -1) {
              ancestorInfo.pTagInButtonScope = null;
            }
            if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
              ancestorInfo.listItemTagAutoclosing = null;
              ancestorInfo.dlItemTagAutoclosing = null;
            }
            ancestorInfo.current = info;
            if (tag === "form") {
              ancestorInfo.formTag = info;
            }
            if (tag === "a") {
              ancestorInfo.aTagInScope = info;
            }
            if (tag === "button") {
              ancestorInfo.buttonTagInScope = info;
            }
            if (tag === "nobr") {
              ancestorInfo.nobrTagInScope = info;
            }
            if (tag === "p") {
              ancestorInfo.pTagInButtonScope = info;
            }
            if (tag === "li") {
              ancestorInfo.listItemTagAutoclosing = info;
            }
            if (tag === "dd" || tag === "dt") {
              ancestorInfo.dlItemTagAutoclosing = info;
            }
            return ancestorInfo;
          };
          var isTagValidWithParent = function(tag, parentTag) {
            switch (parentTag) {
              case "select":
                return tag === "option" || tag === "optgroup" || tag === "#text";
              case "optgroup":
                return tag === "option" || tag === "#text";
              case "option":
                return tag === "#text";
              case "tr":
                return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
              case "tbody":
              case "thead":
              case "tfoot":
                return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
              case "colgroup":
                return tag === "col" || tag === "template";
              case "table":
                return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
              case "head":
                return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
              case "html":
                return tag === "head" || tag === "body" || tag === "frameset";
              case "frameset":
                return tag === "frame";
              case "#document":
                return tag === "html";
            }
            switch (tag) {
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
                return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
              case "rp":
              case "rt":
                return impliedEndTags.indexOf(parentTag) === -1;
              case "body":
              case "caption":
              case "col":
              case "colgroup":
              case "frameset":
              case "frame":
              case "head":
              case "html":
              case "tbody":
              case "td":
              case "tfoot":
              case "th":
              case "thead":
              case "tr":
                return parentTag == null;
            }
            return true;
          };
          var findInvalidAncestorForTag = function(tag, ancestorInfo) {
            switch (tag) {
              case "address":
              case "article":
              case "aside":
              case "blockquote":
              case "center":
              case "details":
              case "dialog":
              case "dir":
              case "div":
              case "dl":
              case "fieldset":
              case "figcaption":
              case "figure":
              case "footer":
              case "header":
              case "hgroup":
              case "main":
              case "menu":
              case "nav":
              case "ol":
              case "p":
              case "section":
              case "summary":
              case "ul":
              case "pre":
              case "listing":
              case "table":
              case "hr":
              case "xmp":
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
                return ancestorInfo.pTagInButtonScope;
              case "form":
                return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
              case "li":
                return ancestorInfo.listItemTagAutoclosing;
              case "dd":
              case "dt":
                return ancestorInfo.dlItemTagAutoclosing;
              case "button":
                return ancestorInfo.buttonTagInScope;
              case "a":
                return ancestorInfo.aTagInScope;
              case "nobr":
                return ancestorInfo.nobrTagInScope;
            }
            return null;
          };
          var didWarn$1 = {};
          validateDOMNesting = function(childTag, childText, ancestorInfo) {
            ancestorInfo = ancestorInfo || emptyAncestorInfo;
            var parentInfo = ancestorInfo.current;
            var parentTag = parentInfo && parentInfo.tag;
            if (childText != null) {
              if (childTag != null) {
                error2("validateDOMNesting: when childText is passed, childTag should be null");
              }
              childTag = "#text";
            }
            var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
            var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
            var invalidParentOrAncestor = invalidParent || invalidAncestor;
            if (!invalidParentOrAncestor) {
              return;
            }
            var ancestorTag = invalidParentOrAncestor.tag;
            var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
            if (didWarn$1[warnKey]) {
              return;
            }
            didWarn$1[warnKey] = true;
            var tagDisplayName = childTag;
            var whitespaceInfo = "";
            if (childTag === "#text") {
              if (/\S/.test(childText)) {
                tagDisplayName = "Text nodes";
              } else {
                tagDisplayName = "Whitespace text nodes";
                whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
              }
            } else {
              tagDisplayName = "<" + childTag + ">";
            }
            if (invalidParent) {
              var info = "";
              if (ancestorTag === "table" && childTag === "tr") {
                info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
              }
              error2("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
            } else {
              error2("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
            }
          };
        }
        var SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
        var SUSPENSE_START_DATA = "$";
        var SUSPENSE_END_DATA = "/$";
        var SUSPENSE_PENDING_START_DATA = "$?";
        var SUSPENSE_FALLBACK_START_DATA = "$!";
        var STYLE$1 = "style";
        var eventsEnabled = null;
        var selectionInformation = null;
        function getRootHostContext(rootContainerInstance) {
          var type;
          var namespace;
          var nodeType = rootContainerInstance.nodeType;
          switch (nodeType) {
            case DOCUMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE: {
              type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
              var root2 = rootContainerInstance.documentElement;
              namespace = root2 ? root2.namespaceURI : getChildNamespace(null, "");
              break;
            }
            default: {
              var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
              var ownNamespace = container.namespaceURI || null;
              type = container.tagName;
              namespace = getChildNamespace(ownNamespace, type);
              break;
            }
          }
          {
            var validatedTag = type.toLowerCase();
            var ancestorInfo = updatedAncestorInfo(null, validatedTag);
            return {
              namespace,
              ancestorInfo
            };
          }
        }
        function getChildHostContext(parentHostContext, type, rootContainerInstance) {
          {
            var parentHostContextDev = parentHostContext;
            var namespace = getChildNamespace(parentHostContextDev.namespace, type);
            var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
            return {
              namespace,
              ancestorInfo
            };
          }
        }
        function getPublicInstance(instance) {
          return instance;
        }
        function prepareForCommit(containerInfo) {
          eventsEnabled = isEnabled();
          selectionInformation = getSelectionInformation();
          var activeInstance = null;
          setEnabled(false);
          return activeInstance;
        }
        function resetAfterCommit(containerInfo) {
          restoreSelection(selectionInformation);
          setEnabled(eventsEnabled);
          eventsEnabled = null;
          selectionInformation = null;
        }
        function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
          var parentNamespace;
          {
            var hostContextDev = hostContext;
            validateDOMNesting(type, null, hostContextDev.ancestorInfo);
            if (typeof props.children === "string" || typeof props.children === "number") {
              var string = "" + props.children;
              var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
              validateDOMNesting(null, string, ownAncestorInfo);
            }
            parentNamespace = hostContextDev.namespace;
          }
          var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
          precacheFiberNode(internalInstanceHandle, domElement);
          updateFiberProps(domElement, props);
          return domElement;
        }
        function appendInitialChild(parentInstance, child) {
          parentInstance.appendChild(child);
        }
        function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
          setInitialProperties(domElement, type, props, rootContainerInstance);
          switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              return !!props.autoFocus;
            case "img":
              return true;
            default:
              return false;
          }
        }
        function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
          {
            var hostContextDev = hostContext;
            if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
              var string = "" + newProps.children;
              var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
              validateDOMNesting(null, string, ownAncestorInfo);
            }
          }
          return diffProperties(domElement, type, oldProps, newProps);
        }
        function shouldSetTextContent(type, props) {
          return type === "textarea" || type === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
        }
        function createTextInstance(text2, rootContainerInstance, hostContext, internalInstanceHandle) {
          {
            var hostContextDev = hostContext;
            validateDOMNesting(null, text2, hostContextDev.ancestorInfo);
          }
          var textNode = createTextNode(text2, rootContainerInstance);
          precacheFiberNode(internalInstanceHandle, textNode);
          return textNode;
        }
        function getCurrentEventPriority() {
          var currentEvent = window.event;
          if (currentEvent === void 0) {
            return DefaultEventPriority;
          }
          return getEventPriority(currentEvent.type);
        }
        var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
        var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
        var noTimeout = -1;
        var localPromise = typeof Promise === "function" ? Promise : void 0;
        var scheduleMicrotask = typeof queueMicrotask === "function" ? queueMicrotask : typeof localPromise !== "undefined" ? function(callback) {
          return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
        } : scheduleTimeout;
        function handleErrorInNextTick(error3) {
          setTimeout(function() {
            throw error3;
          });
        }
        function commitMount(domElement, type, newProps, internalInstanceHandle) {
          switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              if (newProps.autoFocus) {
                domElement.focus();
              }
              return;
            case "img": {
              if (newProps.src) {
                domElement.src = newProps.src;
              }
              return;
            }
          }
        }
        function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
          updateProperties(domElement, updatePayload, type, oldProps, newProps);
          updateFiberProps(domElement, newProps);
        }
        function resetTextContent(domElement) {
          setTextContent(domElement, "");
        }
        function commitTextUpdate(textInstance, oldText, newText) {
          textInstance.nodeValue = newText;
        }
        function appendChild(parentInstance, child) {
          parentInstance.appendChild(child);
        }
        function appendChildToContainer(container, child) {
          var parentNode;
          if (container.nodeType === COMMENT_NODE) {
            parentNode = container.parentNode;
            parentNode.insertBefore(child, container);
          } else {
            parentNode = container;
            parentNode.appendChild(child);
          }
          var reactRootContainer = container._reactRootContainer;
          if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
            trapClickOnNonInteractiveElement(parentNode);
          }
        }
        function insertBefore(parentInstance, child, beforeChild) {
          parentInstance.insertBefore(child, beforeChild);
        }
        function insertInContainerBefore(container, child, beforeChild) {
          if (container.nodeType === COMMENT_NODE) {
            container.parentNode.insertBefore(child, beforeChild);
          } else {
            container.insertBefore(child, beforeChild);
          }
        }
        function removeChild(parentInstance, child) {
          parentInstance.removeChild(child);
        }
        function removeChildFromContainer(container, child) {
          if (container.nodeType === COMMENT_NODE) {
            container.parentNode.removeChild(child);
          } else {
            container.removeChild(child);
          }
        }
        function clearSuspenseBoundary(parentInstance, suspenseInstance) {
          var node = suspenseInstance;
          var depth = 0;
          do {
            var nextNode = node.nextSibling;
            parentInstance.removeChild(node);
            if (nextNode && nextNode.nodeType === COMMENT_NODE) {
              var data = nextNode.data;
              if (data === SUSPENSE_END_DATA) {
                if (depth === 0) {
                  parentInstance.removeChild(nextNode);
                  retryIfBlockedOn(suspenseInstance);
                  return;
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {
                depth++;
              }
            }
            node = nextNode;
          } while (node);
          retryIfBlockedOn(suspenseInstance);
        }
        function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {
          if (container.nodeType === COMMENT_NODE) {
            clearSuspenseBoundary(container.parentNode, suspenseInstance);
          } else if (container.nodeType === ELEMENT_NODE) {
            clearSuspenseBoundary(container, suspenseInstance);
          }
          retryIfBlockedOn(container);
        }
        function hideInstance(instance) {
          instance = instance;
          var style2 = instance.style;
          if (typeof style2.setProperty === "function") {
            style2.setProperty("display", "none", "important");
          } else {
            style2.display = "none";
          }
        }
        function hideTextInstance(textInstance) {
          textInstance.nodeValue = "";
        }
        function unhideInstance(instance, props) {
          instance = instance;
          var styleProp = props[STYLE$1];
          var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
          instance.style.display = dangerousStyleValue("display", display);
        }
        function unhideTextInstance(textInstance, text2) {
          textInstance.nodeValue = text2;
        }
        function clearContainer(container) {
          if (container.nodeType === ELEMENT_NODE) {
            container.textContent = "";
          } else if (container.nodeType === DOCUMENT_NODE) {
            if (container.documentElement) {
              container.removeChild(container.documentElement);
            }
          }
        }
        function canHydrateInstance(instance, type, props) {
          if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
            return null;
          }
          return instance;
        }
        function canHydrateTextInstance(instance, text2) {
          if (text2 === "" || instance.nodeType !== TEXT_NODE) {
            return null;
          }
          return instance;
        }
        function canHydrateSuspenseInstance(instance) {
          if (instance.nodeType !== COMMENT_NODE) {
            return null;
          }
          return instance;
        }
        function isSuspenseInstancePending(instance) {
          return instance.data === SUSPENSE_PENDING_START_DATA;
        }
        function isSuspenseInstanceFallback(instance) {
          return instance.data === SUSPENSE_FALLBACK_START_DATA;
        }
        function getSuspenseInstanceFallbackErrorDetails(instance) {
          var dataset = instance.nextSibling && instance.nextSibling.dataset;
          var digest, message, stack;
          if (dataset) {
            digest = dataset.dgst;
            {
              message = dataset.msg;
              stack = dataset.stck;
            }
          }
          {
            return {
              message,
              digest,
              stack
            };
          }
        }
        function registerSuspenseInstanceRetry(instance, callback) {
          instance._reactRetry = callback;
        }
        function getNextHydratable(node) {
          for (; node != null; node = node.nextSibling) {
            var nodeType = node.nodeType;
            if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
              break;
            }
            if (nodeType === COMMENT_NODE) {
              var nodeData = node.data;
              if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {
                break;
              }
              if (nodeData === SUSPENSE_END_DATA) {
                return null;
              }
            }
          }
          return node;
        }
        function getNextHydratableSibling(instance) {
          return getNextHydratable(instance.nextSibling);
        }
        function getFirstHydratableChild(parentInstance) {
          return getNextHydratable(parentInstance.firstChild);
        }
        function getFirstHydratableChildWithinContainer(parentContainer) {
          return getNextHydratable(parentContainer.firstChild);
        }
        function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
          return getNextHydratable(parentInstance.nextSibling);
        }
        function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {
          precacheFiberNode(internalInstanceHandle, instance);
          updateFiberProps(instance, props);
          var parentNamespace;
          {
            var hostContextDev = hostContext;
            parentNamespace = hostContextDev.namespace;
          }
          var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
          return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);
        }
        function hydrateTextInstance(textInstance, text2, internalInstanceHandle, shouldWarnDev) {
          precacheFiberNode(internalInstanceHandle, textInstance);
          var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
          return diffHydratedText(textInstance, text2);
        }
        function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
          precacheFiberNode(internalInstanceHandle, suspenseInstance);
        }
        function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
          var node = suspenseInstance.nextSibling;
          var depth = 0;
          while (node) {
            if (node.nodeType === COMMENT_NODE) {
              var data = node.data;
              if (data === SUSPENSE_END_DATA) {
                if (depth === 0) {
                  return getNextHydratableSibling(node);
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                depth++;
              }
            }
            node = node.nextSibling;
          }
          return null;
        }
        function getParentSuspenseInstance(targetInstance) {
          var node = targetInstance.previousSibling;
          var depth = 0;
          while (node) {
            if (node.nodeType === COMMENT_NODE) {
              var data = node.data;
              if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                if (depth === 0) {
                  return node;
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_END_DATA) {
                depth++;
              }
            }
            node = node.previousSibling;
          }
          return null;
        }
        function commitHydratedContainer(container) {
          retryIfBlockedOn(container);
        }
        function commitHydratedSuspenseInstance(suspenseInstance) {
          retryIfBlockedOn(suspenseInstance);
        }
        function shouldDeleteUnhydratedTailInstances(parentType) {
          return parentType !== "head" && parentType !== "body";
        }
        function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text2, isConcurrentMode) {
          var shouldWarnDev = true;
          checkForUnmatchedText(textInstance.nodeValue, text2, isConcurrentMode, shouldWarnDev);
        }
        function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text2, isConcurrentMode) {
          if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            var shouldWarnDev = true;
            checkForUnmatchedText(textInstance.nodeValue, text2, isConcurrentMode, shouldWarnDev);
          }
        }
        function didNotHydrateInstanceWithinContainer(parentContainer, instance) {
          {
            if (instance.nodeType === ELEMENT_NODE) {
              warnForDeletedHydratableElement(parentContainer, instance);
            } else if (instance.nodeType === COMMENT_NODE)
              ;
            else {
              warnForDeletedHydratableText(parentContainer, instance);
            }
          }
        }
        function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {
          {
            var parentNode = parentInstance.parentNode;
            if (parentNode !== null) {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentNode, instance);
              } else if (instance.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentNode, instance);
              }
            }
          }
        }
        function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {
          {
            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentInstance, instance);
              } else if (instance.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentInstance, instance);
              }
            }
          }
        }
        function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {
          {
            warnForInsertedHydratedElement(parentContainer, type);
          }
        }
        function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text2) {
          {
            warnForInsertedHydratedText(parentContainer, text2);
          }
        }
        function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {
          {
            var parentNode = parentInstance.parentNode;
            if (parentNode !== null)
              warnForInsertedHydratedElement(parentNode, type);
          }
        }
        function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text2) {
          {
            var parentNode = parentInstance.parentNode;
            if (parentNode !== null)
              warnForInsertedHydratedText(parentNode, text2);
          }
        }
        function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {
          {
            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForInsertedHydratedElement(parentInstance, type);
            }
          }
        }
        function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text2, isConcurrentMode) {
          {
            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForInsertedHydratedText(parentInstance, text2);
            }
          }
        }
        function errorHydratingContainer(parentContainer) {
          {
            error2("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", parentContainer.nodeName.toLowerCase());
          }
        }
        function preparePortalMount(portalInstance) {
          listenToAllSupportedEvents(portalInstance);
        }
        var randomKey = Math.random().toString(36).slice(2);
        var internalInstanceKey = "__reactFiber$" + randomKey;
        var internalPropsKey = "__reactProps$" + randomKey;
        var internalContainerInstanceKey = "__reactContainer$" + randomKey;
        var internalEventHandlersKey = "__reactEvents$" + randomKey;
        var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
        var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
        function detachDeletedInstance(node) {
          delete node[internalInstanceKey];
          delete node[internalPropsKey];
          delete node[internalEventHandlersKey];
          delete node[internalEventHandlerListenersKey];
          delete node[internalEventHandlesSetKey];
        }
        function precacheFiberNode(hostInst, node) {
          node[internalInstanceKey] = hostInst;
        }
        function markContainerAsRoot(hostRoot, node) {
          node[internalContainerInstanceKey] = hostRoot;
        }
        function unmarkContainerAsRoot(node) {
          node[internalContainerInstanceKey] = null;
        }
        function isContainerMarkedAsRoot(node) {
          return !!node[internalContainerInstanceKey];
        }
        function getClosestInstanceFromNode(targetNode) {
          var targetInst = targetNode[internalInstanceKey];
          if (targetInst) {
            return targetInst;
          }
          var parentNode = targetNode.parentNode;
          while (parentNode) {
            targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
            if (targetInst) {
              var alternate = targetInst.alternate;
              if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                var suspenseInstance = getParentSuspenseInstance(targetNode);
                while (suspenseInstance !== null) {
                  var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                  if (targetSuspenseInst) {
                    return targetSuspenseInst;
                  }
                  suspenseInstance = getParentSuspenseInstance(suspenseInstance);
                }
              }
              return targetInst;
            }
            targetNode = parentNode;
            parentNode = targetNode.parentNode;
          }
          return null;
        }
        function getInstanceFromNode(node) {
          var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
          if (inst) {
            if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
              return inst;
            } else {
              return null;
            }
          }
          return null;
        }
        function getNodeFromInstance(inst) {
          if (inst.tag === HostComponent || inst.tag === HostText) {
            return inst.stateNode;
          }
          throw new Error("getNodeFromInstance: Invalid argument.");
        }
        function getFiberCurrentPropsFromNode(node) {
          return node[internalPropsKey] || null;
        }
        function updateFiberProps(node, props) {
          node[internalPropsKey] = props;
        }
        function getEventListenerSet(node) {
          var elementListenerSet = node[internalEventHandlersKey];
          if (elementListenerSet === void 0) {
            elementListenerSet = node[internalEventHandlersKey] = /* @__PURE__ */ new Set();
          }
          return elementListenerSet;
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has3 = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has3(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error2("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var valueStack = [];
        var fiberStack;
        {
          fiberStack = [];
        }
        var index = -1;
        function createCursor(defaultValue) {
          return {
            current: defaultValue
          };
        }
        function pop(cursor, fiber) {
          if (index < 0) {
            {
              error2("Unexpected pop.");
            }
            return;
          }
          {
            if (fiber !== fiberStack[index]) {
              error2("Unexpected Fiber popped.");
            }
          }
          cursor.current = valueStack[index];
          valueStack[index] = null;
          {
            fiberStack[index] = null;
          }
          index--;
        }
        function push(cursor, value, fiber) {
          index++;
          valueStack[index] = cursor.current;
          {
            fiberStack[index] = fiber;
          }
          cursor.current = value;
        }
        var warnedAboutMissingGetChildContext;
        {
          warnedAboutMissingGetChildContext = {};
        }
        var emptyContextObject = {};
        {
          Object.freeze(emptyContextObject);
        }
        var contextStackCursor = createCursor(emptyContextObject);
        var didPerformWorkStackCursor = createCursor(false);
        var previousContext = emptyContextObject;
        function getUnmaskedContext(workInProgress2, Component, didPushOwnContextIfProvider) {
          {
            if (didPushOwnContextIfProvider && isContextProvider(Component)) {
              return previousContext;
            }
            return contextStackCursor.current;
          }
        }
        function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
          {
            var instance = workInProgress2.stateNode;
            instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
            instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
          }
        }
        function getMaskedContext(workInProgress2, unmaskedContext) {
          {
            var type = workInProgress2.type;
            var contextTypes = type.contextTypes;
            if (!contextTypes) {
              return emptyContextObject;
            }
            var instance = workInProgress2.stateNode;
            if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
              return instance.__reactInternalMemoizedMaskedChildContext;
            }
            var context = {};
            for (var key in contextTypes) {
              context[key] = unmaskedContext[key];
            }
            {
              var name2 = getComponentNameFromFiber(workInProgress2) || "Unknown";
              checkPropTypes(contextTypes, context, "context", name2);
            }
            if (instance) {
              cacheContext(workInProgress2, unmaskedContext, context);
            }
            return context;
          }
        }
        function hasContextChanged() {
          {
            return didPerformWorkStackCursor.current;
          }
        }
        function isContextProvider(type) {
          {
            var childContextTypes = type.childContextTypes;
            return childContextTypes !== null && childContextTypes !== void 0;
          }
        }
        function popContext(fiber) {
          {
            pop(didPerformWorkStackCursor, fiber);
            pop(contextStackCursor, fiber);
          }
        }
        function popTopLevelContextObject(fiber) {
          {
            pop(didPerformWorkStackCursor, fiber);
            pop(contextStackCursor, fiber);
          }
        }
        function pushTopLevelContextObject(fiber, context, didChange) {
          {
            if (contextStackCursor.current !== emptyContextObject) {
              throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
            }
            push(contextStackCursor, context, fiber);
            push(didPerformWorkStackCursor, didChange, fiber);
          }
        }
        function processChildContext(fiber, type, parentContext) {
          {
            var instance = fiber.stateNode;
            var childContextTypes = type.childContextTypes;
            if (typeof instance.getChildContext !== "function") {
              {
                var componentName = getComponentNameFromFiber(fiber) || "Unknown";
                if (!warnedAboutMissingGetChildContext[componentName]) {
                  warnedAboutMissingGetChildContext[componentName] = true;
                  error2("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                }
              }
              return parentContext;
            }
            var childContext = instance.getChildContext();
            for (var contextKey in childContext) {
              if (!(contextKey in childContextTypes)) {
                throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
              }
            }
            {
              var name2 = getComponentNameFromFiber(fiber) || "Unknown";
              checkPropTypes(childContextTypes, childContext, "child context", name2);
            }
            return assign3({}, parentContext, childContext);
          }
        }
        function pushContextProvider(workInProgress2) {
          {
            var instance = workInProgress2.stateNode;
            var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
            previousContext = contextStackCursor.current;
            push(contextStackCursor, memoizedMergedChildContext, workInProgress2);
            push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
            return true;
          }
        }
        function invalidateContextProvider(workInProgress2, type, didChange) {
          {
            var instance = workInProgress2.stateNode;
            if (!instance) {
              throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
            }
            if (didChange) {
              var mergedContext = processChildContext(workInProgress2, type, previousContext);
              instance.__reactInternalMemoizedMergedChildContext = mergedContext;
              pop(didPerformWorkStackCursor, workInProgress2);
              pop(contextStackCursor, workInProgress2);
              push(contextStackCursor, mergedContext, workInProgress2);
              push(didPerformWorkStackCursor, didChange, workInProgress2);
            } else {
              pop(didPerformWorkStackCursor, workInProgress2);
              push(didPerformWorkStackCursor, didChange, workInProgress2);
            }
          }
        }
        function findCurrentUnmaskedContext(fiber) {
          {
            if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
              throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
            }
            var node = fiber;
            do {
              switch (node.tag) {
                case HostRoot:
                  return node.stateNode.context;
                case ClassComponent: {
                  var Component = node.type;
                  if (isContextProvider(Component)) {
                    return node.stateNode.__reactInternalMemoizedMergedChildContext;
                  }
                  break;
                }
              }
              node = node.return;
            } while (node !== null);
            throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        var LegacyRoot = 0;
        var ConcurrentRoot = 1;
        var syncQueue = null;
        var includesLegacySyncCallbacks = false;
        var isFlushingSyncQueue = false;
        function scheduleSyncCallback(callback) {
          if (syncQueue === null) {
            syncQueue = [callback];
          } else {
            syncQueue.push(callback);
          }
        }
        function scheduleLegacySyncCallback(callback) {
          includesLegacySyncCallbacks = true;
          scheduleSyncCallback(callback);
        }
        function flushSyncCallbacksOnlyInLegacyMode() {
          if (includesLegacySyncCallbacks) {
            flushSyncCallbacks();
          }
        }
        function flushSyncCallbacks() {
          if (!isFlushingSyncQueue && syncQueue !== null) {
            isFlushingSyncQueue = true;
            var i = 0;
            var previousUpdatePriority = getCurrentUpdatePriority();
            try {
              var isSync = true;
              var queue = syncQueue;
              setCurrentUpdatePriority(DiscreteEventPriority);
              for (; i < queue.length; i++) {
                var callback = queue[i];
                do {
                  callback = callback(isSync);
                } while (callback !== null);
              }
              syncQueue = null;
              includesLegacySyncCallbacks = false;
            } catch (error3) {
              if (syncQueue !== null) {
                syncQueue = syncQueue.slice(i + 1);
              }
              scheduleCallback(ImmediatePriority, flushSyncCallbacks);
              throw error3;
            } finally {
              setCurrentUpdatePriority(previousUpdatePriority);
              isFlushingSyncQueue = false;
            }
          }
          return null;
        }
        var forkStack = [];
        var forkStackIndex = 0;
        var treeForkProvider = null;
        var treeForkCount = 0;
        var idStack = [];
        var idStackIndex = 0;
        var treeContextProvider = null;
        var treeContextId = 1;
        var treeContextOverflow = "";
        function isForkedChild(workInProgress2) {
          warnIfNotHydrating();
          return (workInProgress2.flags & Forked) !== NoFlags;
        }
        function getForksAtLevel(workInProgress2) {
          warnIfNotHydrating();
          return treeForkCount;
        }
        function getTreeId() {
          var overflow = treeContextOverflow;
          var idWithLeadingBit = treeContextId;
          var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
          return id.toString(32) + overflow;
        }
        function pushTreeFork(workInProgress2, totalChildren) {
          warnIfNotHydrating();
          forkStack[forkStackIndex++] = treeForkCount;
          forkStack[forkStackIndex++] = treeForkProvider;
          treeForkProvider = workInProgress2;
          treeForkCount = totalChildren;
        }
        function pushTreeId(workInProgress2, totalChildren, index2) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextProvider = workInProgress2;
          var baseIdWithLeadingBit = treeContextId;
          var baseOverflow = treeContextOverflow;
          var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
          var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
          var slot = index2 + 1;
          var length = getBitLength(totalChildren) + baseLength;
          if (length > 30) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            var newOverflowBits = (1 << numberOfOverflowBits) - 1;
            var newOverflow = (baseId & newOverflowBits).toString(32);
            var restOfBaseId = baseId >> numberOfOverflowBits;
            var restOfBaseLength = baseLength - numberOfOverflowBits;
            var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
            var restOfNewBits = slot << restOfBaseLength;
            var id = restOfNewBits | restOfBaseId;
            var overflow = newOverflow + baseOverflow;
            treeContextId = 1 << restOfLength | id;
            treeContextOverflow = overflow;
          } else {
            var newBits = slot << baseLength;
            var _id = newBits | baseId;
            var _overflow = baseOverflow;
            treeContextId = 1 << length | _id;
            treeContextOverflow = _overflow;
          }
        }
        function pushMaterializedTreeId(workInProgress2) {
          warnIfNotHydrating();
          var returnFiber = workInProgress2.return;
          if (returnFiber !== null) {
            var numberOfForks = 1;
            var slotIndex = 0;
            pushTreeFork(workInProgress2, numberOfForks);
            pushTreeId(workInProgress2, numberOfForks, slotIndex);
          }
        }
        function getBitLength(number) {
          return 32 - clz32(number);
        }
        function getLeadingBit(id) {
          return 1 << getBitLength(id) - 1;
        }
        function popTreeContext(workInProgress2) {
          while (workInProgress2 === treeForkProvider) {
            treeForkProvider = forkStack[--forkStackIndex];
            forkStack[forkStackIndex] = null;
            treeForkCount = forkStack[--forkStackIndex];
            forkStack[forkStackIndex] = null;
          }
          while (workInProgress2 === treeContextProvider) {
            treeContextProvider = idStack[--idStackIndex];
            idStack[idStackIndex] = null;
            treeContextOverflow = idStack[--idStackIndex];
            idStack[idStackIndex] = null;
            treeContextId = idStack[--idStackIndex];
            idStack[idStackIndex] = null;
          }
        }
        function getSuspendedTreeContext() {
          warnIfNotHydrating();
          if (treeContextProvider !== null) {
            return {
              id: treeContextId,
              overflow: treeContextOverflow
            };
          } else {
            return null;
          }
        }
        function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextId = suspendedContext.id;
          treeContextOverflow = suspendedContext.overflow;
          treeContextProvider = workInProgress2;
        }
        function warnIfNotHydrating() {
          {
            if (!getIsHydrating()) {
              error2("Expected to be hydrating. This is a bug in React. Please file an issue.");
            }
          }
        }
        var hydrationParentFiber = null;
        var nextHydratableInstance = null;
        var isHydrating = false;
        var didSuspendOrErrorDEV = false;
        var hydrationErrors = null;
        function warnIfHydrating() {
          {
            if (isHydrating) {
              error2("We should not be hydrating here. This is a bug in React. Please file a bug.");
            }
          }
        }
        function markDidThrowWhileHydratingDEV() {
          {
            didSuspendOrErrorDEV = true;
          }
        }
        function didSuspendOrErrorWhileHydratingDEV() {
          {
            return didSuspendOrErrorDEV;
          }
        }
        function enterHydrationState(fiber) {
          var parentInstance = fiber.stateNode.containerInfo;
          nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
          hydrationParentFiber = fiber;
          isHydrating = true;
          hydrationErrors = null;
          didSuspendOrErrorDEV = false;
          return true;
        }
        function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
          nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
          hydrationParentFiber = fiber;
          isHydrating = true;
          hydrationErrors = null;
          didSuspendOrErrorDEV = false;
          if (treeContext !== null) {
            restoreSuspendedTreeContext(fiber, treeContext);
          }
          return true;
        }
        function warnUnhydratedInstance(returnFiber, instance) {
          {
            switch (returnFiber.tag) {
              case HostRoot: {
                didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
                break;
              }
              case HostComponent: {
                var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                didNotHydrateInstance(
                  returnFiber.type,
                  returnFiber.memoizedProps,
                  returnFiber.stateNode,
                  instance,
                  // TODO: Delete this argument when we remove the legacy root API.
                  isConcurrentMode
                );
                break;
              }
              case SuspenseComponent: {
                var suspenseState = returnFiber.memoizedState;
                if (suspenseState.dehydrated !== null)
                  didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
                break;
              }
            }
          }
        }
        function deleteHydratableInstance(returnFiber, instance) {
          warnUnhydratedInstance(returnFiber, instance);
          var childToDelete = createFiberFromHostInstanceForDeletion();
          childToDelete.stateNode = instance;
          childToDelete.return = returnFiber;
          var deletions = returnFiber.deletions;
          if (deletions === null) {
            returnFiber.deletions = [childToDelete];
            returnFiber.flags |= ChildDeletion;
          } else {
            deletions.push(childToDelete);
          }
        }
        function warnNonhydratedInstance(returnFiber, fiber) {
          {
            if (didSuspendOrErrorDEV) {
              return;
            }
            switch (returnFiber.tag) {
              case HostRoot: {
                var parentContainer = returnFiber.stateNode.containerInfo;
                switch (fiber.tag) {
                  case HostComponent:
                    var type = fiber.type;
                    var props = fiber.pendingProps;
                    didNotFindHydratableInstanceWithinContainer(parentContainer, type);
                    break;
                  case HostText:
                    var text2 = fiber.pendingProps;
                    didNotFindHydratableTextInstanceWithinContainer(parentContainer, text2);
                    break;
                }
                break;
              }
              case HostComponent: {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;
                switch (fiber.tag) {
                  case HostComponent: {
                    var _type = fiber.type;
                    var _props = fiber.pendingProps;
                    var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotFindHydratableInstance(
                      parentType,
                      parentProps,
                      parentInstance,
                      _type,
                      _props,
                      // TODO: Delete this argument when we remove the legacy root API.
                      isConcurrentMode
                    );
                    break;
                  }
                  case HostText: {
                    var _text = fiber.pendingProps;
                    var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotFindHydratableTextInstance(
                      parentType,
                      parentProps,
                      parentInstance,
                      _text,
                      // TODO: Delete this argument when we remove the legacy root API.
                      _isConcurrentMode
                    );
                    break;
                  }
                }
                break;
              }
              case SuspenseComponent: {
                var suspenseState = returnFiber.memoizedState;
                var _parentInstance = suspenseState.dehydrated;
                if (_parentInstance !== null)
                  switch (fiber.tag) {
                    case HostComponent:
                      var _type2 = fiber.type;
                      var _props2 = fiber.pendingProps;
                      didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                      break;
                    case HostText:
                      var _text2 = fiber.pendingProps;
                      didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                      break;
                  }
                break;
              }
              default:
                return;
            }
          }
        }
        function insertNonHydratedInstance(returnFiber, fiber) {
          fiber.flags = fiber.flags & ~Hydrating | Placement;
          warnNonhydratedInstance(returnFiber, fiber);
        }
        function tryHydrate(fiber, nextInstance) {
          switch (fiber.tag) {
            case HostComponent: {
              var type = fiber.type;
              var props = fiber.pendingProps;
              var instance = canHydrateInstance(nextInstance, type);
              if (instance !== null) {
                fiber.stateNode = instance;
                hydrationParentFiber = fiber;
                nextHydratableInstance = getFirstHydratableChild(instance);
                return true;
              }
              return false;
            }
            case HostText: {
              var text2 = fiber.pendingProps;
              var textInstance = canHydrateTextInstance(nextInstance, text2);
              if (textInstance !== null) {
                fiber.stateNode = textInstance;
                hydrationParentFiber = fiber;
                nextHydratableInstance = null;
                return true;
              }
              return false;
            }
            case SuspenseComponent: {
              var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
              if (suspenseInstance !== null) {
                var suspenseState = {
                  dehydrated: suspenseInstance,
                  treeContext: getSuspendedTreeContext(),
                  retryLane: OffscreenLane
                };
                fiber.memoizedState = suspenseState;
                var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
                dehydratedFragment.return = fiber;
                fiber.child = dehydratedFragment;
                hydrationParentFiber = fiber;
                nextHydratableInstance = null;
                return true;
              }
              return false;
            }
            default:
              return false;
          }
        }
        function shouldClientRenderOnMismatch(fiber) {
          return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
        }
        function throwOnHydrationMismatch(fiber) {
          throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
        }
        function tryToClaimNextHydratableInstance(fiber) {
          if (!isHydrating) {
            return;
          }
          var nextInstance = nextHydratableInstance;
          if (!nextInstance) {
            if (shouldClientRenderOnMismatch(fiber)) {
              warnNonhydratedInstance(hydrationParentFiber, fiber);
              throwOnHydrationMismatch();
            }
            insertNonHydratedInstance(hydrationParentFiber, fiber);
            isHydrating = false;
            hydrationParentFiber = fiber;
            return;
          }
          var firstAttemptedInstance = nextInstance;
          if (!tryHydrate(fiber, nextInstance)) {
            if (shouldClientRenderOnMismatch(fiber)) {
              warnNonhydratedInstance(hydrationParentFiber, fiber);
              throwOnHydrationMismatch();
            }
            nextInstance = getNextHydratableSibling(firstAttemptedInstance);
            var prevHydrationParentFiber = hydrationParentFiber;
            if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
              insertNonHydratedInstance(hydrationParentFiber, fiber);
              isHydrating = false;
              hydrationParentFiber = fiber;
              return;
            }
            deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
          }
        }
        function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
          var instance = fiber.stateNode;
          var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
          var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
          fiber.updateQueue = updatePayload;
          if (updatePayload !== null) {
            return true;
          }
          return false;
        }
        function prepareToHydrateHostTextInstance(fiber) {
          var textInstance = fiber.stateNode;
          var textContent = fiber.memoizedProps;
          var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
          if (shouldUpdate) {
            var returnFiber = hydrationParentFiber;
            if (returnFiber !== null) {
              switch (returnFiber.tag) {
                case HostRoot: {
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotMatchHydratedContainerTextInstance(
                    parentContainer,
                    textInstance,
                    textContent,
                    // TODO: Delete this argument when we remove the legacy root API.
                    isConcurrentMode
                  );
                  break;
                }
                case HostComponent: {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotMatchHydratedTextInstance(
                    parentType,
                    parentProps,
                    parentInstance,
                    textInstance,
                    textContent,
                    // TODO: Delete this argument when we remove the legacy root API.
                    _isConcurrentMode2
                  );
                  break;
                }
              }
            }
          }
          return shouldUpdate;
        }
        function prepareToHydrateHostSuspenseInstance(fiber) {
          var suspenseState = fiber.memoizedState;
          var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
          if (!suspenseInstance) {
            throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
          }
          hydrateSuspenseInstance(suspenseInstance, fiber);
        }
        function skipPastDehydratedSuspenseInstance(fiber) {
          var suspenseState = fiber.memoizedState;
          var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
          if (!suspenseInstance) {
            throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
          }
          return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
        }
        function popToNextHostParent(fiber) {
          var parent = fiber.return;
          while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
            parent = parent.return;
          }
          hydrationParentFiber = parent;
        }
        function popHydrationState(fiber) {
          if (fiber !== hydrationParentFiber) {
            return false;
          }
          if (!isHydrating) {
            popToNextHostParent(fiber);
            isHydrating = true;
            return false;
          }
          if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
            var nextInstance = nextHydratableInstance;
            if (nextInstance) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnIfUnhydratedTailNodes(fiber);
                throwOnHydrationMismatch();
              } else {
                while (nextInstance) {
                  deleteHydratableInstance(fiber, nextInstance);
                  nextInstance = getNextHydratableSibling(nextInstance);
                }
              }
            }
          }
          popToNextHostParent(fiber);
          if (fiber.tag === SuspenseComponent) {
            nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
          } else {
            nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
          }
          return true;
        }
        function hasUnhydratedTailNodes() {
          return isHydrating && nextHydratableInstance !== null;
        }
        function warnIfUnhydratedTailNodes(fiber) {
          var nextInstance = nextHydratableInstance;
          while (nextInstance) {
            warnUnhydratedInstance(fiber, nextInstance);
            nextInstance = getNextHydratableSibling(nextInstance);
          }
        }
        function resetHydrationState() {
          hydrationParentFiber = null;
          nextHydratableInstance = null;
          isHydrating = false;
          didSuspendOrErrorDEV = false;
        }
        function upgradeHydrationErrorsToRecoverable() {
          if (hydrationErrors !== null) {
            queueRecoverableErrors(hydrationErrors);
            hydrationErrors = null;
          }
        }
        function getIsHydrating() {
          return isHydrating;
        }
        function queueHydrationError(error3) {
          if (hydrationErrors === null) {
            hydrationErrors = [error3];
          } else {
            hydrationErrors.push(error3);
          }
        }
        var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
        var NoTransition = null;
        function requestCurrentTransition() {
          return ReactCurrentBatchConfig$1.transition;
        }
        var ReactStrictModeWarnings = {
          recordUnsafeLifecycleWarnings: function(fiber, instance) {
          },
          flushPendingUnsafeLifecycleWarnings: function() {
          },
          recordLegacyContextWarning: function(fiber, instance) {
          },
          flushLegacyContextWarning: function() {
          },
          discardPendingWarnings: function() {
          }
        };
        {
          var findStrictRoot = function(fiber) {
            var maybeStrictRoot = null;
            var node = fiber;
            while (node !== null) {
              if (node.mode & StrictLegacyMode) {
                maybeStrictRoot = node;
              }
              node = node.return;
            }
            return maybeStrictRoot;
          };
          var setToSortedString = function(set3) {
            var array = [];
            set3.forEach(function(value) {
              array.push(value);
            });
            return array.sort().join(", ");
          };
          var pendingComponentWillMountWarnings = [];
          var pendingUNSAFE_ComponentWillMountWarnings = [];
          var pendingComponentWillReceivePropsWarnings = [];
          var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          var pendingComponentWillUpdateWarnings = [];
          var pendingUNSAFE_ComponentWillUpdateWarnings = [];
          var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
          ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
            if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
              return;
            }
            if (typeof instance.componentWillMount === "function" && // Don't warn about react-lifecycles-compat polyfilled components.
            instance.componentWillMount.__suppressDeprecationWarning !== true) {
              pendingComponentWillMountWarnings.push(fiber);
            }
            if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === "function") {
              pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
            }
            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              pendingComponentWillReceivePropsWarnings.push(fiber);
            }
            if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
            }
            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
              pendingComponentWillUpdateWarnings.push(fiber);
            }
            if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === "function") {
              pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
            }
          };
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
            var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
            if (pendingComponentWillMountWarnings.length > 0) {
              pendingComponentWillMountWarnings.forEach(function(fiber) {
                componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillMountWarnings = [];
            }
            var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
            if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
              pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillMountWarnings = [];
            }
            var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
            if (pendingComponentWillReceivePropsWarnings.length > 0) {
              pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillReceivePropsWarnings = [];
            }
            var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
            if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
              pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            }
            var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
            if (pendingComponentWillUpdateWarnings.length > 0) {
              pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillUpdateWarnings = [];
            }
            var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
            if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
              pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillUpdateWarnings = [];
            }
            if (UNSAFE_componentWillMountUniqueNames.size > 0) {
              var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
              error2("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
            }
            if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
              var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
              error2("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
            }
            if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
              var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
              error2("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
            }
            if (componentWillMountUniqueNames.size > 0) {
              var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
              warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
            }
            if (componentWillReceivePropsUniqueNames.size > 0) {
              var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
              warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
            }
            if (componentWillUpdateUniqueNames.size > 0) {
              var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
              warn("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
            }
          };
          var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
          var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
          ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
            var strictRoot = findStrictRoot(fiber);
            if (strictRoot === null) {
              error2("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
              return;
            }
            if (didWarnAboutLegacyContext.has(fiber.type)) {
              return;
            }
            var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
            if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
              if (warningsForRoot === void 0) {
                warningsForRoot = [];
                pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
              }
              warningsForRoot.push(fiber);
            }
          };
          ReactStrictModeWarnings.flushLegacyContextWarning = function() {
            pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
              if (fiberArray.length === 0) {
                return;
              }
              var firstFiber = fiberArray[0];
              var uniqueNames = /* @__PURE__ */ new Set();
              fiberArray.forEach(function(fiber) {
                uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutLegacyContext.add(fiber.type);
              });
              var sortedNames = setToSortedString(uniqueNames);
              try {
                setCurrentFiber(firstFiber);
                error2("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
              } finally {
                resetCurrentFiber();
              }
            });
          };
          ReactStrictModeWarnings.discardPendingWarnings = function() {
            pendingComponentWillMountWarnings = [];
            pendingUNSAFE_ComponentWillMountWarnings = [];
            pendingComponentWillReceivePropsWarnings = [];
            pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            pendingComponentWillUpdateWarnings = [];
            pendingUNSAFE_ComponentWillUpdateWarnings = [];
            pendingLegacyContextWarning = /* @__PURE__ */ new Map();
          };
        }
        var didWarnAboutMaps;
        var didWarnAboutGenerators;
        var didWarnAboutStringRefs;
        var ownerHasKeyUseWarning;
        var ownerHasFunctionTypeWarning;
        var warnForMissingKey = function(child, returnFiber) {
        };
        {
          didWarnAboutMaps = false;
          didWarnAboutGenerators = false;
          didWarnAboutStringRefs = {};
          ownerHasKeyUseWarning = {};
          ownerHasFunctionTypeWarning = {};
          warnForMissingKey = function(child, returnFiber) {
            if (child === null || typeof child !== "object") {
              return;
            }
            if (!child._store || child._store.validated || child.key != null) {
              return;
            }
            if (typeof child._store !== "object") {
              throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
            }
            child._store.validated = true;
            var componentName = getComponentNameFromFiber(returnFiber) || "Component";
            if (ownerHasKeyUseWarning[componentName]) {
              return;
            }
            ownerHasKeyUseWarning[componentName] = true;
            error2('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
          };
        }
        function isReactClass(type) {
          return type.prototype && type.prototype.isReactComponent;
        }
        function coerceRef(returnFiber, current2, element) {
          var mixedRef = element.ref;
          if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
            {
              if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
              // because these cannot be automatically converted to an arrow function
              // using a codemod. Therefore, we don't have to warn about string refs again.
              !(element._owner && element._self && element._owner.stateNode !== element._self) && // Will already throw with "Function components cannot have string refs"
              !(element._owner && element._owner.tag !== ClassComponent) && // Will already warn with "Function components cannot be given refs"
              !(typeof element.type === "function" && !isReactClass(element.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
              element._owner) {
                var componentName = getComponentNameFromFiber(returnFiber) || "Component";
                if (!didWarnAboutStringRefs[componentName]) {
                  {
                    error2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, mixedRef);
                  }
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
            if (element._owner) {
              var owner = element._owner;
              var inst;
              if (owner) {
                var ownerFiber = owner;
                if (ownerFiber.tag !== ClassComponent) {
                  throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                }
                inst = ownerFiber.stateNode;
              }
              if (!inst) {
                throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
              }
              var resolvedInst = inst;
              {
                checkPropStringCoercion(mixedRef, "ref");
              }
              var stringRef = "" + mixedRef;
              if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
                return current2.ref;
              }
              var ref = function(value) {
                var refs = resolvedInst.refs;
                if (value === null) {
                  delete refs[stringRef];
                } else {
                  refs[stringRef] = value;
                }
              };
              ref._stringRef = stringRef;
              return ref;
            } else {
              if (typeof mixedRef !== "string") {
                throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
              }
              if (!element._owner) {
                throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
              }
            }
          }
          return mixedRef;
        }
        function throwOnInvalidObjectType(returnFiber, newChild) {
          var childString = Object.prototype.toString.call(newChild);
          throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
        }
        function warnOnFunctionType(returnFiber) {
          {
            var componentName = getComponentNameFromFiber(returnFiber) || "Component";
            if (ownerHasFunctionTypeWarning[componentName]) {
              return;
            }
            ownerHasFunctionTypeWarning[componentName] = true;
            error2("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
          }
        }
        function resolveLazy(lazyType) {
          var payload = lazyType._payload;
          var init = lazyType._init;
          return init(payload);
        }
        function ChildReconciler(shouldTrackSideEffects) {
          function deleteChild(returnFiber, childToDelete) {
            if (!shouldTrackSideEffects) {
              return;
            }
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [childToDelete];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(childToDelete);
            }
          }
          function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) {
              return null;
            }
            var childToDelete = currentFirstChild;
            while (childToDelete !== null) {
              deleteChild(returnFiber, childToDelete);
              childToDelete = childToDelete.sibling;
            }
            return null;
          }
          function mapRemainingChildren(returnFiber, currentFirstChild) {
            var existingChildren = /* @__PURE__ */ new Map();
            var existingChild = currentFirstChild;
            while (existingChild !== null) {
              if (existingChild.key !== null) {
                existingChildren.set(existingChild.key, existingChild);
              } else {
                existingChildren.set(existingChild.index, existingChild);
              }
              existingChild = existingChild.sibling;
            }
            return existingChildren;
          }
          function useFiber(fiber, pendingProps) {
            var clone = createWorkInProgress(fiber, pendingProps);
            clone.index = 0;
            clone.sibling = null;
            return clone;
          }
          function placeChild(newFiber, lastPlacedIndex, newIndex) {
            newFiber.index = newIndex;
            if (!shouldTrackSideEffects) {
              newFiber.flags |= Forked;
              return lastPlacedIndex;
            }
            var current2 = newFiber.alternate;
            if (current2 !== null) {
              var oldIndex = current2.index;
              if (oldIndex < lastPlacedIndex) {
                newFiber.flags |= Placement;
                return lastPlacedIndex;
              } else {
                return oldIndex;
              }
            } else {
              newFiber.flags |= Placement;
              return lastPlacedIndex;
            }
          }
          function placeSingleChild(newFiber) {
            if (shouldTrackSideEffects && newFiber.alternate === null) {
              newFiber.flags |= Placement;
            }
            return newFiber;
          }
          function updateTextNode(returnFiber, current2, textContent, lanes) {
            if (current2 === null || current2.tag !== HostText) {
              var created = createFiberFromText(textContent, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current2, textContent);
              existing.return = returnFiber;
              return existing;
            }
          }
          function updateElement(returnFiber, current2, element, lanes) {
            var elementType = element.type;
            if (elementType === REACT_FRAGMENT_TYPE) {
              return updateFragment2(returnFiber, current2, element.props.children, lanes, element.key);
            }
            if (current2 !== null) {
              if (current2.elementType === elementType || // Keep this check inline so it only runs on the false path:
              isCompatibleFamilyForHotReloading(current2, element) || // Lazy types should reconcile their resolved type.
              // We need to do this after the Hot Reloading check above,
              // because hot reloading has different semantics than prod because
              // it doesn't resuspend. So we can't let the call below suspend.
              typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type) {
                var existing = useFiber(current2, element.props);
                existing.ref = coerceRef(returnFiber, current2, element);
                existing.return = returnFiber;
                {
                  existing._debugSource = element._source;
                  existing._debugOwner = element._owner;
                }
                return existing;
              }
            }
            var created = createFiberFromElement(element, returnFiber.mode, lanes);
            created.ref = coerceRef(returnFiber, current2, element);
            created.return = returnFiber;
            return created;
          }
          function updatePortal(returnFiber, current2, portal, lanes) {
            if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
              var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current2, portal.children || []);
              existing.return = returnFiber;
              return existing;
            }
          }
          function updateFragment2(returnFiber, current2, fragment, lanes, key) {
            if (current2 === null || current2.tag !== Fragment) {
              var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current2, fragment);
              existing.return = returnFiber;
              return existing;
            }
          }
          function createChild(returnFiber, newChild, lanes) {
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                  _created.ref = coerceRef(returnFiber, null, newChild);
                  _created.return = returnFiber;
                  return _created;
                }
                case REACT_PORTAL_TYPE: {
                  var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                  _created2.return = returnFiber;
                  return _created2;
                }
                case REACT_LAZY_TYPE: {
                  var payload = newChild._payload;
                  var init = newChild._init;
                  return createChild(returnFiber, init(payload), lanes);
                }
              }
              if (isArray(newChild) || getIteratorFn(newChild)) {
                var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                _created3.return = returnFiber;
                return _created3;
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function updateSlot(returnFiber, oldFiber, newChild, lanes) {
            var key = oldFiber !== null ? oldFiber.key : null;
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              if (key !== null) {
                return null;
              }
              return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  if (newChild.key === key) {
                    return updateElement(returnFiber, oldFiber, newChild, lanes);
                  } else {
                    return null;
                  }
                }
                case REACT_PORTAL_TYPE: {
                  if (newChild.key === key) {
                    return updatePortal(returnFiber, oldFiber, newChild, lanes);
                  } else {
                    return null;
                  }
                }
                case REACT_LAZY_TYPE: {
                  var payload = newChild._payload;
                  var init = newChild._init;
                  return updateSlot(returnFiber, oldFiber, init(payload), lanes);
                }
              }
              if (isArray(newChild) || getIteratorFn(newChild)) {
                if (key !== null) {
                  return null;
                }
                return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              var matchedFiber = existingChildren.get(newIdx) || null;
              return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                  return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                }
                case REACT_PORTAL_TYPE: {
                  var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                  return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                }
                case REACT_LAZY_TYPE:
                  var payload = newChild._payload;
                  var init = newChild._init;
                  return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);
              }
              if (isArray(newChild) || getIteratorFn(newChild)) {
                var _matchedFiber3 = existingChildren.get(newIdx) || null;
                return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function warnOnInvalidKey(child, knownKeys, returnFiber) {
            {
              if (typeof child !== "object" || child === null) {
                return knownKeys;
              }
              switch (child.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  warnForMissingKey(child, returnFiber);
                  var key = child.key;
                  if (typeof key !== "string") {
                    break;
                  }
                  if (knownKeys === null) {
                    knownKeys = /* @__PURE__ */ new Set();
                    knownKeys.add(key);
                    break;
                  }
                  if (!knownKeys.has(key)) {
                    knownKeys.add(key);
                    break;
                  }
                  error2("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
                  break;
                case REACT_LAZY_TYPE:
                  var payload = child._payload;
                  var init = child._init;
                  warnOnInvalidKey(init(payload), knownKeys, returnFiber);
                  break;
              }
            }
            return knownKeys;
          }
          function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
            {
              var knownKeys = null;
              for (var i = 0; i < newChildren.length; i++) {
                var child = newChildren[i];
                knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
              }
            }
            var resultingFirstChild = null;
            var previousNewFiber = null;
            var oldFiber = currentFirstChild;
            var lastPlacedIndex = 0;
            var newIdx = 0;
            var nextOldFiber = null;
            for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
              if (oldFiber.index > newIdx) {
                nextOldFiber = oldFiber;
                oldFiber = null;
              } else {
                nextOldFiber = oldFiber.sibling;
              }
              var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
              if (newFiber === null) {
                if (oldFiber === null) {
                  oldFiber = nextOldFiber;
                }
                break;
              }
              if (shouldTrackSideEffects) {
                if (oldFiber && newFiber.alternate === null) {
                  deleteChild(returnFiber, oldFiber);
                }
              }
              lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = newFiber;
              } else {
                previousNewFiber.sibling = newFiber;
              }
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (newIdx === newChildren.length) {
              deleteRemainingChildren(returnFiber, oldFiber);
              if (getIsHydrating()) {
                var numberOfForks = newIdx;
                pushTreeFork(returnFiber, numberOfForks);
              }
              return resultingFirstChild;
            }
            if (oldFiber === null) {
              for (; newIdx < newChildren.length; newIdx++) {
                var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                if (_newFiber === null) {
                  continue;
                }
                lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber;
                } else {
                  previousNewFiber.sibling = _newFiber;
                }
                previousNewFiber = _newFiber;
              }
              if (getIsHydrating()) {
                var _numberOfForks = newIdx;
                pushTreeFork(returnFiber, _numberOfForks);
              }
              return resultingFirstChild;
            }
            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
            for (; newIdx < newChildren.length; newIdx++) {
              var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
              if (_newFiber2 !== null) {
                if (shouldTrackSideEffects) {
                  if (_newFiber2.alternate !== null) {
                    existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                  }
                }
                lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber2;
                } else {
                  previousNewFiber.sibling = _newFiber2;
                }
                previousNewFiber = _newFiber2;
              }
            }
            if (shouldTrackSideEffects) {
              existingChildren.forEach(function(child2) {
                return deleteChild(returnFiber, child2);
              });
            }
            if (getIsHydrating()) {
              var _numberOfForks2 = newIdx;
              pushTreeFork(returnFiber, _numberOfForks2);
            }
            return resultingFirstChild;
          }
          function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
            var iteratorFn = getIteratorFn(newChildrenIterable);
            if (typeof iteratorFn !== "function") {
              throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
            }
            {
              if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
              newChildrenIterable[Symbol.toStringTag] === "Generator") {
                if (!didWarnAboutGenerators) {
                  error2("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                }
                didWarnAboutGenerators = true;
              }
              if (newChildrenIterable.entries === iteratorFn) {
                if (!didWarnAboutMaps) {
                  error2("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                }
                didWarnAboutMaps = true;
              }
              var _newChildren = iteratorFn.call(newChildrenIterable);
              if (_newChildren) {
                var knownKeys = null;
                var _step = _newChildren.next();
                for (; !_step.done; _step = _newChildren.next()) {
                  var child = _step.value;
                  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                }
              }
            }
            var newChildren = iteratorFn.call(newChildrenIterable);
            if (newChildren == null) {
              throw new Error("An iterable object provided no iterator.");
            }
            var resultingFirstChild = null;
            var previousNewFiber = null;
            var oldFiber = currentFirstChild;
            var lastPlacedIndex = 0;
            var newIdx = 0;
            var nextOldFiber = null;
            var step = newChildren.next();
            for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
              if (oldFiber.index > newIdx) {
                nextOldFiber = oldFiber;
                oldFiber = null;
              } else {
                nextOldFiber = oldFiber.sibling;
              }
              var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
              if (newFiber === null) {
                if (oldFiber === null) {
                  oldFiber = nextOldFiber;
                }
                break;
              }
              if (shouldTrackSideEffects) {
                if (oldFiber && newFiber.alternate === null) {
                  deleteChild(returnFiber, oldFiber);
                }
              }
              lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = newFiber;
              } else {
                previousNewFiber.sibling = newFiber;
              }
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (step.done) {
              deleteRemainingChildren(returnFiber, oldFiber);
              if (getIsHydrating()) {
                var numberOfForks = newIdx;
                pushTreeFork(returnFiber, numberOfForks);
              }
              return resultingFirstChild;
            }
            if (oldFiber === null) {
              for (; !step.done; newIdx++, step = newChildren.next()) {
                var _newFiber3 = createChild(returnFiber, step.value, lanes);
                if (_newFiber3 === null) {
                  continue;
                }
                lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber3;
                } else {
                  previousNewFiber.sibling = _newFiber3;
                }
                previousNewFiber = _newFiber3;
              }
              if (getIsHydrating()) {
                var _numberOfForks3 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks3);
              }
              return resultingFirstChild;
            }
            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
            for (; !step.done; newIdx++, step = newChildren.next()) {
              var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
              if (_newFiber4 !== null) {
                if (shouldTrackSideEffects) {
                  if (_newFiber4.alternate !== null) {
                    existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                  }
                }
                lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber4;
                } else {
                  previousNewFiber.sibling = _newFiber4;
                }
                previousNewFiber = _newFiber4;
              }
            }
            if (shouldTrackSideEffects) {
              existingChildren.forEach(function(child2) {
                return deleteChild(returnFiber, child2);
              });
            }
            if (getIsHydrating()) {
              var _numberOfForks4 = newIdx;
              pushTreeFork(returnFiber, _numberOfForks4);
            }
            return resultingFirstChild;
          }
          function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
            if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
              deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
              var existing = useFiber(currentFirstChild, textContent);
              existing.return = returnFiber;
              return existing;
            }
            deleteRemainingChildren(returnFiber, currentFirstChild);
            var created = createFiberFromText(textContent, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          }
          function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
            var key = element.key;
            var child = currentFirstChild;
            while (child !== null) {
              if (child.key === key) {
                var elementType = element.type;
                if (elementType === REACT_FRAGMENT_TYPE) {
                  if (child.tag === Fragment) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var existing = useFiber(child, element.props.children);
                    existing.return = returnFiber;
                    {
                      existing._debugSource = element._source;
                      existing._debugOwner = element._owner;
                    }
                    return existing;
                  }
                } else {
                  if (child.elementType === elementType || // Keep this check inline so it only runs on the false path:
                  isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.
                  // We need to do this after the Hot Reloading check above,
                  // because hot reloading has different semantics than prod because
                  // it doesn't resuspend. So we can't let the call below suspend.
                  typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var _existing = useFiber(child, element.props);
                    _existing.ref = coerceRef(returnFiber, child, element);
                    _existing.return = returnFiber;
                    {
                      _existing._debugSource = element._source;
                      _existing._debugOwner = element._owner;
                    }
                    return _existing;
                  }
                }
                deleteRemainingChildren(returnFiber, child);
                break;
              } else {
                deleteChild(returnFiber, child);
              }
              child = child.sibling;
            }
            if (element.type === REACT_FRAGMENT_TYPE) {
              var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
              created.return = returnFiber;
              return created;
            } else {
              var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
              _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
              _created4.return = returnFiber;
              return _created4;
            }
          }
          function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
            var key = portal.key;
            var child = currentFirstChild;
            while (child !== null) {
              if (child.key === key) {
                if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                  deleteRemainingChildren(returnFiber, child.sibling);
                  var existing = useFiber(child, portal.children || []);
                  existing.return = returnFiber;
                  return existing;
                } else {
                  deleteRemainingChildren(returnFiber, child);
                  break;
                }
              } else {
                deleteChild(returnFiber, child);
              }
              child = child.sibling;
            }
            var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          }
          function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
            var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
            if (isUnkeyedTopLevelFragment) {
              newChild = newChild.props.children;
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                case REACT_PORTAL_TYPE:
                  return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                case REACT_LAZY_TYPE:
                  var payload = newChild._payload;
                  var init = newChild._init;
                  return reconcileChildFibers2(returnFiber, currentFirstChild, init(payload), lanes);
              }
              if (isArray(newChild)) {
                return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
              }
              if (getIteratorFn(newChild)) {
                return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return deleteRemainingChildren(returnFiber, currentFirstChild);
          }
          return reconcileChildFibers2;
        }
        var reconcileChildFibers = ChildReconciler(true);
        var mountChildFibers = ChildReconciler(false);
        function cloneChildFibers(current2, workInProgress2) {
          if (current2 !== null && workInProgress2.child !== current2.child) {
            throw new Error("Resuming work not yet implemented.");
          }
          if (workInProgress2.child === null) {
            return;
          }
          var currentChild = workInProgress2.child;
          var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
          workInProgress2.child = newChild;
          newChild.return = workInProgress2;
          while (currentChild.sibling !== null) {
            currentChild = currentChild.sibling;
            newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
            newChild.return = workInProgress2;
          }
          newChild.sibling = null;
        }
        function resetChildFibers(workInProgress2, lanes) {
          var child = workInProgress2.child;
          while (child !== null) {
            resetWorkInProgress(child, lanes);
            child = child.sibling;
          }
        }
        var valueCursor = createCursor(null);
        var rendererSigil;
        {
          rendererSigil = {};
        }
        var currentlyRenderingFiber = null;
        var lastContextDependency = null;
        var lastFullyObservedContext = null;
        var isDisallowedContextReadInDEV = false;
        function resetContextDependencies() {
          currentlyRenderingFiber = null;
          lastContextDependency = null;
          lastFullyObservedContext = null;
          {
            isDisallowedContextReadInDEV = false;
          }
        }
        function enterDisallowedContextReadInDEV() {
          {
            isDisallowedContextReadInDEV = true;
          }
        }
        function exitDisallowedContextReadInDEV() {
          {
            isDisallowedContextReadInDEV = false;
          }
        }
        function pushProvider(providerFiber, context, nextValue) {
          {
            push(valueCursor, context._currentValue, providerFiber);
            context._currentValue = nextValue;
            {
              if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                error2("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context._currentRenderer = rendererSigil;
            }
          }
        }
        function popProvider(context, providerFiber) {
          var currentValue = valueCursor.current;
          pop(valueCursor, providerFiber);
          {
            {
              context._currentValue = currentValue;
            }
          }
        }
        function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
          var node = parent;
          while (node !== null) {
            var alternate = node.alternate;
            if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
              node.childLanes = mergeLanes(node.childLanes, renderLanes2);
              if (alternate !== null) {
                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
              }
            } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
              alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
            }
            if (node === propagationRoot) {
              break;
            }
            node = node.return;
          }
          {
            if (node !== propagationRoot) {
              error2("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
        }
        function propagateContextChange(workInProgress2, context, renderLanes2) {
          {
            propagateContextChange_eager(workInProgress2, context, renderLanes2);
          }
        }
        function propagateContextChange_eager(workInProgress2, context, renderLanes2) {
          var fiber = workInProgress2.child;
          if (fiber !== null) {
            fiber.return = workInProgress2;
          }
          while (fiber !== null) {
            var nextFiber = void 0;
            var list2 = fiber.dependencies;
            if (list2 !== null) {
              nextFiber = fiber.child;
              var dependency = list2.firstContext;
              while (dependency !== null) {
                if (dependency.context === context) {
                  if (fiber.tag === ClassComponent) {
                    var lane = pickArbitraryLane(renderLanes2);
                    var update = createUpdate(NoTimestamp, lane);
                    update.tag = ForceUpdate;
                    var updateQueue = fiber.updateQueue;
                    if (updateQueue === null)
                      ;
                    else {
                      var sharedQueue = updateQueue.shared;
                      var pending = sharedQueue.pending;
                      if (pending === null) {
                        update.next = update;
                      } else {
                        update.next = pending.next;
                        pending.next = update;
                      }
                      sharedQueue.pending = update;
                    }
                  }
                  fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                  var alternate = fiber.alternate;
                  if (alternate !== null) {
                    alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                  }
                  scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);
                  list2.lanes = mergeLanes(list2.lanes, renderLanes2);
                  break;
                }
                dependency = dependency.next;
              }
            } else if (fiber.tag === ContextProvider) {
              nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
            } else if (fiber.tag === DehydratedFragment) {
              var parentSuspense = fiber.return;
              if (parentSuspense === null) {
                throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
              }
              parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
              var _alternate = parentSuspense.alternate;
              if (_alternate !== null) {
                _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);
              }
              scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);
              nextFiber = fiber.sibling;
            } else {
              nextFiber = fiber.child;
            }
            if (nextFiber !== null) {
              nextFiber.return = fiber;
            } else {
              nextFiber = fiber;
              while (nextFiber !== null) {
                if (nextFiber === workInProgress2) {
                  nextFiber = null;
                  break;
                }
                var sibling = nextFiber.sibling;
                if (sibling !== null) {
                  sibling.return = nextFiber.return;
                  nextFiber = sibling;
                  break;
                }
                nextFiber = nextFiber.return;
              }
            }
            fiber = nextFiber;
          }
        }
        function prepareToReadContext(workInProgress2, renderLanes2) {
          currentlyRenderingFiber = workInProgress2;
          lastContextDependency = null;
          lastFullyObservedContext = null;
          var dependencies = workInProgress2.dependencies;
          if (dependencies !== null) {
            {
              var firstContext = dependencies.firstContext;
              if (firstContext !== null) {
                if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                  markWorkInProgressReceivedUpdate();
                }
                dependencies.firstContext = null;
              }
            }
          }
        }
        function readContext(context) {
          {
            if (isDisallowedContextReadInDEV) {
              error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          var value = context._currentValue;
          if (lastFullyObservedContext === context)
            ;
          else {
            var contextItem = {
              context,
              memoizedValue: value,
              next: null
            };
            if (lastContextDependency === null) {
              if (currentlyRenderingFiber === null) {
                throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
              lastContextDependency = contextItem;
              currentlyRenderingFiber.dependencies = {
                lanes: NoLanes,
                firstContext: contextItem
              };
            } else {
              lastContextDependency = lastContextDependency.next = contextItem;
            }
          }
          return value;
        }
        var concurrentQueues = null;
        function pushConcurrentUpdateQueue(queue) {
          if (concurrentQueues === null) {
            concurrentQueues = [queue];
          } else {
            concurrentQueues.push(queue);
          }
        }
        function finishQueueingConcurrentUpdates() {
          if (concurrentQueues !== null) {
            for (var i = 0; i < concurrentQueues.length; i++) {
              var queue = concurrentQueues[i];
              var lastInterleavedUpdate = queue.interleaved;
              if (lastInterleavedUpdate !== null) {
                queue.interleaved = null;
                var firstInterleavedUpdate = lastInterleavedUpdate.next;
                var lastPendingUpdate = queue.pending;
                if (lastPendingUpdate !== null) {
                  var firstPendingUpdate = lastPendingUpdate.next;
                  lastPendingUpdate.next = firstInterleavedUpdate;
                  lastInterleavedUpdate.next = firstPendingUpdate;
                }
                queue.pending = lastInterleavedUpdate;
              }
            }
            concurrentQueues = null;
          }
        }
        function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
          var interleaved = queue.interleaved;
          if (interleaved === null) {
            update.next = update;
            pushConcurrentUpdateQueue(queue);
          } else {
            update.next = interleaved.next;
            interleaved.next = update;
          }
          queue.interleaved = update;
          return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {
          var interleaved = queue.interleaved;
          if (interleaved === null) {
            update.next = update;
            pushConcurrentUpdateQueue(queue);
          } else {
            update.next = interleaved.next;
            interleaved.next = update;
          }
          queue.interleaved = update;
        }
        function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
          var interleaved = queue.interleaved;
          if (interleaved === null) {
            update.next = update;
            pushConcurrentUpdateQueue(queue);
          } else {
            update.next = interleaved.next;
            interleaved.next = update;
          }
          queue.interleaved = update;
          return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        function enqueueConcurrentRenderForLane(fiber, lane) {
          return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
        function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
          sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
          var alternate = sourceFiber.alternate;
          if (alternate !== null) {
            alternate.lanes = mergeLanes(alternate.lanes, lane);
          }
          {
            if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
              warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
            }
          }
          var node = sourceFiber;
          var parent = sourceFiber.return;
          while (parent !== null) {
            parent.childLanes = mergeLanes(parent.childLanes, lane);
            alternate = parent.alternate;
            if (alternate !== null) {
              alternate.childLanes = mergeLanes(alternate.childLanes, lane);
            } else {
              {
                if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                  warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                }
              }
            }
            node = parent;
            parent = parent.return;
          }
          if (node.tag === HostRoot) {
            var root2 = node.stateNode;
            return root2;
          } else {
            return null;
          }
        }
        var UpdateState = 0;
        var ReplaceState = 1;
        var ForceUpdate = 2;
        var CaptureUpdate = 3;
        var hasForceUpdate = false;
        var didWarnUpdateInsideUpdate;
        var currentlyProcessingQueue;
        {
          didWarnUpdateInsideUpdate = false;
          currentlyProcessingQueue = null;
        }
        function initializeUpdateQueue(fiber) {
          var queue = {
            baseState: fiber.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
              pending: null,
              interleaved: null,
              lanes: NoLanes
            },
            effects: null
          };
          fiber.updateQueue = queue;
        }
        function cloneUpdateQueue(current2, workInProgress2) {
          var queue = workInProgress2.updateQueue;
          var currentQueue = current2.updateQueue;
          if (queue === currentQueue) {
            var clone = {
              baseState: currentQueue.baseState,
              firstBaseUpdate: currentQueue.firstBaseUpdate,
              lastBaseUpdate: currentQueue.lastBaseUpdate,
              shared: currentQueue.shared,
              effects: currentQueue.effects
            };
            workInProgress2.updateQueue = clone;
          }
        }
        function createUpdate(eventTime, lane) {
          var update = {
            eventTime,
            lane,
            tag: UpdateState,
            payload: null,
            callback: null,
            next: null
          };
          return update;
        }
        function enqueueUpdate(fiber, update, lane) {
          var updateQueue = fiber.updateQueue;
          if (updateQueue === null) {
            return null;
          }
          var sharedQueue = updateQueue.shared;
          {
            if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
              error2("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
              didWarnUpdateInsideUpdate = true;
            }
          }
          if (isUnsafeClassRenderPhaseUpdate()) {
            var pending = sharedQueue.pending;
            if (pending === null) {
              update.next = update;
            } else {
              update.next = pending.next;
              pending.next = update;
            }
            sharedQueue.pending = update;
            return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
          } else {
            return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
          }
        }
        function entangleTransitions(root2, fiber, lane) {
          var updateQueue = fiber.updateQueue;
          if (updateQueue === null) {
            return;
          }
          var sharedQueue = updateQueue.shared;
          if (isTransitionLane(lane)) {
            var queueLanes = sharedQueue.lanes;
            queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
            var newQueueLanes = mergeLanes(queueLanes, lane);
            sharedQueue.lanes = newQueueLanes;
            markRootEntangled(root2, newQueueLanes);
          }
        }
        function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
          var queue = workInProgress2.updateQueue;
          var current2 = workInProgress2.alternate;
          if (current2 !== null) {
            var currentQueue = current2.updateQueue;
            if (queue === currentQueue) {
              var newFirst = null;
              var newLast = null;
              var firstBaseUpdate = queue.firstBaseUpdate;
              if (firstBaseUpdate !== null) {
                var update = firstBaseUpdate;
                do {
                  var clone = {
                    eventTime: update.eventTime,
                    lane: update.lane,
                    tag: update.tag,
                    payload: update.payload,
                    callback: update.callback,
                    next: null
                  };
                  if (newLast === null) {
                    newFirst = newLast = clone;
                  } else {
                    newLast.next = clone;
                    newLast = clone;
                  }
                  update = update.next;
                } while (update !== null);
                if (newLast === null) {
                  newFirst = newLast = capturedUpdate;
                } else {
                  newLast.next = capturedUpdate;
                  newLast = capturedUpdate;
                }
              } else {
                newFirst = newLast = capturedUpdate;
              }
              queue = {
                baseState: currentQueue.baseState,
                firstBaseUpdate: newFirst,
                lastBaseUpdate: newLast,
                shared: currentQueue.shared,
                effects: currentQueue.effects
              };
              workInProgress2.updateQueue = queue;
              return;
            }
          }
          var lastBaseUpdate = queue.lastBaseUpdate;
          if (lastBaseUpdate === null) {
            queue.firstBaseUpdate = capturedUpdate;
          } else {
            lastBaseUpdate.next = capturedUpdate;
          }
          queue.lastBaseUpdate = capturedUpdate;
        }
        function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {
          switch (update.tag) {
            case ReplaceState: {
              var payload = update.payload;
              if (typeof payload === "function") {
                {
                  enterDisallowedContextReadInDEV();
                }
                var nextState = payload.call(instance, prevState, nextProps);
                {
                  if (workInProgress2.mode & StrictLegacyMode) {
                    setIsStrictModeForDevtools(true);
                    try {
                      payload.call(instance, prevState, nextProps);
                    } finally {
                      setIsStrictModeForDevtools(false);
                    }
                  }
                  exitDisallowedContextReadInDEV();
                }
                return nextState;
              }
              return payload;
            }
            case CaptureUpdate: {
              workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
            }
            case UpdateState: {
              var _payload = update.payload;
              var partialState;
              if (typeof _payload === "function") {
                {
                  enterDisallowedContextReadInDEV();
                }
                partialState = _payload.call(instance, prevState, nextProps);
                {
                  if (workInProgress2.mode & StrictLegacyMode) {
                    setIsStrictModeForDevtools(true);
                    try {
                      _payload.call(instance, prevState, nextProps);
                    } finally {
                      setIsStrictModeForDevtools(false);
                    }
                  }
                  exitDisallowedContextReadInDEV();
                }
              } else {
                partialState = _payload;
              }
              if (partialState === null || partialState === void 0) {
                return prevState;
              }
              return assign3({}, prevState, partialState);
            }
            case ForceUpdate: {
              hasForceUpdate = true;
              return prevState;
            }
          }
          return prevState;
        }
        function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
          var queue = workInProgress2.updateQueue;
          hasForceUpdate = false;
          {
            currentlyProcessingQueue = queue.shared;
          }
          var firstBaseUpdate = queue.firstBaseUpdate;
          var lastBaseUpdate = queue.lastBaseUpdate;
          var pendingQueue = queue.shared.pending;
          if (pendingQueue !== null) {
            queue.shared.pending = null;
            var lastPendingUpdate = pendingQueue;
            var firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = null;
            if (lastBaseUpdate === null) {
              firstBaseUpdate = firstPendingUpdate;
            } else {
              lastBaseUpdate.next = firstPendingUpdate;
            }
            lastBaseUpdate = lastPendingUpdate;
            var current2 = workInProgress2.alternate;
            if (current2 !== null) {
              var currentQueue = current2.updateQueue;
              var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
              if (currentLastBaseUpdate !== lastBaseUpdate) {
                if (currentLastBaseUpdate === null) {
                  currentQueue.firstBaseUpdate = firstPendingUpdate;
                } else {
                  currentLastBaseUpdate.next = firstPendingUpdate;
                }
                currentQueue.lastBaseUpdate = lastPendingUpdate;
              }
            }
          }
          if (firstBaseUpdate !== null) {
            var newState = queue.baseState;
            var newLanes = NoLanes;
            var newBaseState = null;
            var newFirstBaseUpdate = null;
            var newLastBaseUpdate = null;
            var update = firstBaseUpdate;
            do {
              var updateLane = update.lane;
              var updateEventTime = update.eventTime;
              if (!isSubsetOfLanes(renderLanes2, updateLane)) {
                var clone = {
                  eventTime: updateEventTime,
                  lane: updateLane,
                  tag: update.tag,
                  payload: update.payload,
                  callback: update.callback,
                  next: null
                };
                if (newLastBaseUpdate === null) {
                  newFirstBaseUpdate = newLastBaseUpdate = clone;
                  newBaseState = newState;
                } else {
                  newLastBaseUpdate = newLastBaseUpdate.next = clone;
                }
                newLanes = mergeLanes(newLanes, updateLane);
              } else {
                if (newLastBaseUpdate !== null) {
                  var _clone = {
                    eventTime: updateEventTime,
                    // This update is going to be committed so we never want uncommit
                    // it. Using NoLane works because 0 is a subset of all bitmasks, so
                    // this will never be skipped by the check above.
                    lane: NoLane,
                    tag: update.tag,
                    payload: update.payload,
                    callback: update.callback,
                    next: null
                  };
                  newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                }
                newState = getStateFromUpdate(workInProgress2, queue, update, newState, props, instance);
                var callback = update.callback;
                if (callback !== null && // If the update was already committed, we should not queue its
                // callback again.
                update.lane !== NoLane) {
                  workInProgress2.flags |= Callback;
                  var effects = queue.effects;
                  if (effects === null) {
                    queue.effects = [update];
                  } else {
                    effects.push(update);
                  }
                }
              }
              update = update.next;
              if (update === null) {
                pendingQueue = queue.shared.pending;
                if (pendingQueue === null) {
                  break;
                } else {
                  var _lastPendingUpdate = pendingQueue;
                  var _firstPendingUpdate = _lastPendingUpdate.next;
                  _lastPendingUpdate.next = null;
                  update = _firstPendingUpdate;
                  queue.lastBaseUpdate = _lastPendingUpdate;
                  queue.shared.pending = null;
                }
              }
            } while (true);
            if (newLastBaseUpdate === null) {
              newBaseState = newState;
            }
            queue.baseState = newBaseState;
            queue.firstBaseUpdate = newFirstBaseUpdate;
            queue.lastBaseUpdate = newLastBaseUpdate;
            var lastInterleaved = queue.shared.interleaved;
            if (lastInterleaved !== null) {
              var interleaved = lastInterleaved;
              do {
                newLanes = mergeLanes(newLanes, interleaved.lane);
                interleaved = interleaved.next;
              } while (interleaved !== lastInterleaved);
            } else if (firstBaseUpdate === null) {
              queue.shared.lanes = NoLanes;
            }
            markSkippedUpdateLanes(newLanes);
            workInProgress2.lanes = newLanes;
            workInProgress2.memoizedState = newState;
          }
          {
            currentlyProcessingQueue = null;
          }
        }
        function callCallback(callback, context) {
          if (typeof callback !== "function") {
            throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback));
          }
          callback.call(context);
        }
        function resetHasForceUpdateBeforeProcessing() {
          hasForceUpdate = false;
        }
        function checkHasForceUpdateAfterProcessing() {
          return hasForceUpdate;
        }
        function commitUpdateQueue(finishedWork, finishedQueue, instance) {
          var effects = finishedQueue.effects;
          finishedQueue.effects = null;
          if (effects !== null) {
            for (var i = 0; i < effects.length; i++) {
              var effect = effects[i];
              var callback = effect.callback;
              if (callback !== null) {
                effect.callback = null;
                callCallback(callback, instance);
              }
            }
          }
        }
        var NO_CONTEXT = {};
        var contextStackCursor$1 = createCursor(NO_CONTEXT);
        var contextFiberStackCursor = createCursor(NO_CONTEXT);
        var rootInstanceStackCursor = createCursor(NO_CONTEXT);
        function requiredContext(c) {
          if (c === NO_CONTEXT) {
            throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
          }
          return c;
        }
        function getRootHostContainer() {
          var rootInstance = requiredContext(rootInstanceStackCursor.current);
          return rootInstance;
        }
        function pushHostContainer(fiber, nextRootInstance) {
          push(rootInstanceStackCursor, nextRootInstance, fiber);
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor$1, NO_CONTEXT, fiber);
          var nextRootContext = getRootHostContext(nextRootInstance);
          pop(contextStackCursor$1, fiber);
          push(contextStackCursor$1, nextRootContext, fiber);
        }
        function popHostContainer(fiber) {
          pop(contextStackCursor$1, fiber);
          pop(contextFiberStackCursor, fiber);
          pop(rootInstanceStackCursor, fiber);
        }
        function getHostContext() {
          var context = requiredContext(contextStackCursor$1.current);
          return context;
        }
        function pushHostContext(fiber) {
          var rootInstance = requiredContext(rootInstanceStackCursor.current);
          var context = requiredContext(contextStackCursor$1.current);
          var nextContext = getChildHostContext(context, fiber.type);
          if (context === nextContext) {
            return;
          }
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor$1, nextContext, fiber);
        }
        function popHostContext(fiber) {
          if (contextFiberStackCursor.current !== fiber) {
            return;
          }
          pop(contextStackCursor$1, fiber);
          pop(contextFiberStackCursor, fiber);
        }
        var DefaultSuspenseContext = 0;
        var SubtreeSuspenseContextMask = 1;
        var InvisibleParentSuspenseContext = 1;
        var ForceSuspenseFallback = 2;
        var suspenseStackCursor = createCursor(DefaultSuspenseContext);
        function hasSuspenseContext(parentContext, flag) {
          return (parentContext & flag) !== 0;
        }
        function setDefaultShallowSuspenseContext(parentContext) {
          return parentContext & SubtreeSuspenseContextMask;
        }
        function setShallowSuspenseContext(parentContext, shallowContext) {
          return parentContext & SubtreeSuspenseContextMask | shallowContext;
        }
        function addSubtreeSuspenseContext(parentContext, subtreeContext) {
          return parentContext | subtreeContext;
        }
        function pushSuspenseContext(fiber, newContext) {
          push(suspenseStackCursor, newContext, fiber);
        }
        function popSuspenseContext(fiber) {
          pop(suspenseStackCursor, fiber);
        }
        function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
          var nextState = workInProgress2.memoizedState;
          if (nextState !== null) {
            if (nextState.dehydrated !== null) {
              return true;
            }
            return false;
          }
          var props = workInProgress2.memoizedProps;
          {
            return true;
          }
        }
        function findFirstSuspended(row) {
          var node = row;
          while (node !== null) {
            if (node.tag === SuspenseComponent) {
              var state = node.memoizedState;
              if (state !== null) {
                var dehydrated = state.dehydrated;
                if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                  return node;
                }
              }
            } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
            // keep track of whether it suspended or not.
            node.memoizedProps.revealOrder !== void 0) {
              var didSuspend = (node.flags & DidCapture) !== NoFlags;
              if (didSuspend) {
                return node;
              }
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === row) {
              return null;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === row) {
                return null;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
          return null;
        }
        var NoFlags$1 = (
          /*   */
          0
        );
        var HasEffect = (
          /* */
          1
        );
        var Insertion = (
          /*  */
          2
        );
        var Layout = (
          /*    */
          4
        );
        var Passive$1 = (
          /*   */
          8
        );
        var workInProgressSources = [];
        function resetWorkInProgressVersions() {
          for (var i = 0; i < workInProgressSources.length; i++) {
            var mutableSource = workInProgressSources[i];
            {
              mutableSource._workInProgressVersionPrimary = null;
            }
          }
          workInProgressSources.length = 0;
        }
        function registerMutableSourceForHydration(root2, mutableSource) {
          var getVersion = mutableSource._getVersion;
          var version = getVersion(mutableSource._source);
          if (root2.mutableSourceEagerHydrationData == null) {
            root2.mutableSourceEagerHydrationData = [mutableSource, version];
          } else {
            root2.mutableSourceEagerHydrationData.push(mutableSource, version);
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig;
        var didWarnAboutMismatchedHooksForComponent;
        var didWarnUncachedGetSnapshot;
        {
          didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
        }
        var renderLanes = NoLanes;
        var currentlyRenderingFiber$1 = null;
        var currentHook = null;
        var workInProgressHook = null;
        var didScheduleRenderPhaseUpdate = false;
        var didScheduleRenderPhaseUpdateDuringThisPass = false;
        var localIdCounter = 0;
        var globalClientIdCounter = 0;
        var RE_RENDER_LIMIT = 25;
        var currentHookNameInDev = null;
        var hookTypesDev = null;
        var hookTypesUpdateIndexDev = -1;
        var ignorePreviousDependencies = false;
        function mountHookTypesDev() {
          {
            var hookName = currentHookNameInDev;
            if (hookTypesDev === null) {
              hookTypesDev = [hookName];
            } else {
              hookTypesDev.push(hookName);
            }
          }
        }
        function updateHookTypesDev() {
          {
            var hookName = currentHookNameInDev;
            if (hookTypesDev !== null) {
              hookTypesUpdateIndexDev++;
              if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                warnOnHookMismatchInDev(hookName);
              }
            }
          }
        }
        function checkDepsAreArrayDev(deps) {
          {
            if (deps !== void 0 && deps !== null && !isArray(deps)) {
              error2("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
            }
          }
        }
        function warnOnHookMismatchInDev(currentHookName) {
          {
            var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
            if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
              didWarnAboutMismatchedHooksForComponent.add(componentName);
              if (hookTypesDev !== null) {
                var table2 = "";
                var secondColumnStart = 30;
                for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {
                  var oldHookName = hookTypesDev[i];
                  var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                  var row = i + 1 + ". " + oldHookName;
                  while (row.length < secondColumnStart) {
                    row += " ";
                  }
                  row += newHookName + "\n";
                  table2 += row;
                }
                error2("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table2);
              }
            }
          }
        }
        function throwInvalidHookError() {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          {
            if (ignorePreviousDependencies) {
              return false;
            }
          }
          if (prevDeps === null) {
            {
              error2("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error2("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
            }
          }
          for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
            if (objectIs(nextDeps[i], prevDeps[i])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
          renderLanes = nextRenderLanes;
          currentlyRenderingFiber$1 = workInProgress2;
          {
            hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
            hookTypesUpdateIndexDev = -1;
            ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
          }
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          workInProgress2.lanes = NoLanes;
          {
            if (current2 !== null && current2.memoizedState !== null) {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
            } else if (hookTypesDev !== null) {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
            } else {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
            }
          }
          var children = Component(props, secondArg);
          if (didScheduleRenderPhaseUpdateDuringThisPass) {
            var numberOfReRenders = 0;
            do {
              didScheduleRenderPhaseUpdateDuringThisPass = false;
              localIdCounter = 0;
              if (numberOfReRenders >= RE_RENDER_LIMIT) {
                throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
              }
              numberOfReRenders += 1;
              {
                ignorePreviousDependencies = false;
              }
              currentHook = null;
              workInProgressHook = null;
              workInProgress2.updateQueue = null;
              {
                hookTypesUpdateIndexDev = -1;
              }
              ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
              children = Component(props, secondArg);
            } while (didScheduleRenderPhaseUpdateDuringThisPass);
          }
          ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
          {
            workInProgress2._debugHookTypes = hookTypesDev;
          }
          var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
          renderLanes = NoLanes;
          currentlyRenderingFiber$1 = null;
          currentHook = null;
          workInProgressHook = null;
          {
            currentHookNameInDev = null;
            hookTypesDev = null;
            hookTypesUpdateIndexDev = -1;
            if (current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird
            // and creates false positives. To make this work in legacy mode, we'd
            // need to mark fibers that commit in an incomplete state, somehow. For
            // now I'll disable the warning that most of the bugs that would trigger
            // it are either exclusive to concurrent mode or exist in both.
            (current2.mode & ConcurrentMode) !== NoMode) {
              error2("Internal React error: Expected static flag was missing. Please notify the React team.");
            }
          }
          didScheduleRenderPhaseUpdate = false;
          if (didRenderTooFewHooks) {
            throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
          }
          return children;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = localIdCounter !== 0;
          localIdCounter = 0;
          return didRenderIdHook;
        }
        function bailoutHooks(current2, workInProgress2, lanes) {
          workInProgress2.updateQueue = current2.updateQueue;
          if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
            workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);
          } else {
            workInProgress2.flags &= ~(Passive | Update);
          }
          current2.lanes = removeLanes(current2.lanes, lanes);
        }
        function resetHooksAfterThrow() {
          ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
          if (didScheduleRenderPhaseUpdate) {
            var hook = currentlyRenderingFiber$1.memoizedState;
            while (hook !== null) {
              var queue = hook.queue;
              if (queue !== null) {
                queue.pending = null;
              }
              hook = hook.next;
            }
            didScheduleRenderPhaseUpdate = false;
          }
          renderLanes = NoLanes;
          currentlyRenderingFiber$1 = null;
          currentHook = null;
          workInProgressHook = null;
          {
            hookTypesDev = null;
            hookTypesUpdateIndexDev = -1;
            currentHookNameInDev = null;
            isUpdatingOpaqueValueInRenderPhase = false;
          }
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          localIdCounter = 0;
        }
        function mountWorkInProgressHook() {
          var hook = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          if (workInProgressHook === null) {
            currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
          } else {
            workInProgressHook = workInProgressHook.next = hook;
          }
          return workInProgressHook;
        }
        function updateWorkInProgressHook() {
          var nextCurrentHook;
          if (currentHook === null) {
            var current2 = currentlyRenderingFiber$1.alternate;
            if (current2 !== null) {
              nextCurrentHook = current2.memoizedState;
            } else {
              nextCurrentHook = null;
            }
          } else {
            nextCurrentHook = currentHook.next;
          }
          var nextWorkInProgressHook;
          if (workInProgressHook === null) {
            nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
          } else {
            nextWorkInProgressHook = workInProgressHook.next;
          }
          if (nextWorkInProgressHook !== null) {
            workInProgressHook = nextWorkInProgressHook;
            nextWorkInProgressHook = workInProgressHook.next;
            currentHook = nextCurrentHook;
          } else {
            if (nextCurrentHook === null) {
              throw new Error("Rendered more hooks than during the previous render.");
            }
            currentHook = nextCurrentHook;
            var newHook = {
              memoizedState: currentHook.memoizedState,
              baseState: currentHook.baseState,
              baseQueue: currentHook.baseQueue,
              queue: currentHook.queue,
              next: null
            };
            if (workInProgressHook === null) {
              currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
            } else {
              workInProgressHook = workInProgressHook.next = newHook;
            }
          }
          return workInProgressHook;
        }
        function createFunctionComponentUpdateQueue() {
          return {
            lastEffect: null,
            stores: null
          };
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function mountReducer(reducer, initialArg, init) {
          var hook = mountWorkInProgressHook();
          var initialState;
          if (init !== void 0) {
            initialState = init(initialArg);
          } else {
            initialState = initialArg;
          }
          hook.memoizedState = hook.baseState = initialState;
          var queue = {
            pending: null,
            interleaved: null,
            lanes: NoLanes,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          hook.queue = queue;
          var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
          return [hook.memoizedState, dispatch];
        }
        function updateReducer(reducer, initialArg, init) {
          var hook = updateWorkInProgressHook();
          var queue = hook.queue;
          if (queue === null) {
            throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
          }
          queue.lastRenderedReducer = reducer;
          var current2 = currentHook;
          var baseQueue = current2.baseQueue;
          var pendingQueue = queue.pending;
          if (pendingQueue !== null) {
            if (baseQueue !== null) {
              var baseFirst = baseQueue.next;
              var pendingFirst = pendingQueue.next;
              baseQueue.next = pendingFirst;
              pendingQueue.next = baseFirst;
            }
            {
              if (current2.baseQueue !== baseQueue) {
                error2("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
              }
            }
            current2.baseQueue = baseQueue = pendingQueue;
            queue.pending = null;
          }
          if (baseQueue !== null) {
            var first = baseQueue.next;
            var newState = current2.baseState;
            var newBaseState = null;
            var newBaseQueueFirst = null;
            var newBaseQueueLast = null;
            var update = first;
            do {
              var updateLane = update.lane;
              if (!isSubsetOfLanes(renderLanes, updateLane)) {
                var clone = {
                  lane: updateLane,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                };
                if (newBaseQueueLast === null) {
                  newBaseQueueFirst = newBaseQueueLast = clone;
                  newBaseState = newState;
                } else {
                  newBaseQueueLast = newBaseQueueLast.next = clone;
                }
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                markSkippedUpdateLanes(updateLane);
              } else {
                if (newBaseQueueLast !== null) {
                  var _clone = {
                    // This update is going to be committed so we never want uncommit
                    // it. Using NoLane works because 0 is a subset of all bitmasks, so
                    // this will never be skipped by the check above.
                    lane: NoLane,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  };
                  newBaseQueueLast = newBaseQueueLast.next = _clone;
                }
                if (update.hasEagerState) {
                  newState = update.eagerState;
                } else {
                  var action = update.action;
                  newState = reducer(newState, action);
                }
              }
              update = update.next;
            } while (update !== null && update !== first);
            if (newBaseQueueLast === null) {
              newBaseState = newState;
            } else {
              newBaseQueueLast.next = newBaseQueueFirst;
            }
            if (!objectIs(newState, hook.memoizedState)) {
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = newState;
            hook.baseState = newBaseState;
            hook.baseQueue = newBaseQueueLast;
            queue.lastRenderedState = newState;
          }
          var lastInterleaved = queue.interleaved;
          if (lastInterleaved !== null) {
            var interleaved = lastInterleaved;
            do {
              var interleavedLane = interleaved.lane;
              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
              markSkippedUpdateLanes(interleavedLane);
              interleaved = interleaved.next;
            } while (interleaved !== lastInterleaved);
          } else if (baseQueue === null) {
            queue.lanes = NoLanes;
          }
          var dispatch = queue.dispatch;
          return [hook.memoizedState, dispatch];
        }
        function rerenderReducer(reducer, initialArg, init) {
          var hook = updateWorkInProgressHook();
          var queue = hook.queue;
          if (queue === null) {
            throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
          }
          queue.lastRenderedReducer = reducer;
          var dispatch = queue.dispatch;
          var lastRenderPhaseUpdate = queue.pending;
          var newState = hook.memoizedState;
          if (lastRenderPhaseUpdate !== null) {
            queue.pending = null;
            var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            var update = firstRenderPhaseUpdate;
            do {
              var action = update.action;
              newState = reducer(newState, action);
              update = update.next;
            } while (update !== firstRenderPhaseUpdate);
            if (!objectIs(newState, hook.memoizedState)) {
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = newState;
            if (hook.baseQueue === null) {
              hook.baseState = newState;
            }
            queue.lastRenderedState = newState;
          }
          return [newState, dispatch];
        }
        function mountMutableSource(source, getSnapshot, subscribe) {
          {
            return void 0;
          }
        }
        function updateMutableSource(source, getSnapshot, subscribe) {
          {
            return void 0;
          }
        }
        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber$1;
          var hook = mountWorkInProgressHook();
          var nextSnapshot;
          var isHydrating2 = getIsHydrating();
          if (isHydrating2) {
            if (getServerSnapshot === void 0) {
              throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
            }
            nextSnapshot = getServerSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                if (nextSnapshot !== getServerSnapshot()) {
                  error2("The result of getServerSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
          } else {
            nextSnapshot = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedSnapshot = getSnapshot();
                if (!objectIs(nextSnapshot, cachedSnapshot)) {
                  error2("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var root2 = getWorkInProgressRoot();
            if (root2 === null) {
              throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
            }
            if (!includesBlockingLane(root2, renderLanes)) {
              pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
            }
          }
          hook.memoizedState = nextSnapshot;
          var inst = {
            value: nextSnapshot,
            getSnapshot
          };
          hook.queue = inst;
          mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
          fiber.flags |= Passive;
          pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
          return nextSnapshot;
        }
        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber$1;
          var hook = updateWorkInProgressHook();
          var nextSnapshot = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedSnapshot = getSnapshot();
              if (!objectIs(nextSnapshot, cachedSnapshot)) {
                error2("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var prevSnapshot = hook.memoizedState;
          var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
          if (snapshotChanged) {
            hook.memoizedState = nextSnapshot;
            markWorkInProgressReceivedUpdate();
          }
          var inst = hook.queue;
          updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
          if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by
          // checking whether we scheduled a subscription effect above.
          workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
            fiber.flags |= Passive;
            pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
            var root2 = getWorkInProgressRoot();
            if (root2 === null) {
              throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
            }
            if (!includesBlockingLane(root2, renderLanes)) {
              pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
            }
          }
          return nextSnapshot;
        }
        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
          fiber.flags |= StoreConsistency;
          var check = {
            getSnapshot,
            value: renderedSnapshot
          };
          var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
          if (componentUpdateQueue === null) {
            componentUpdateQueue = createFunctionComponentUpdateQueue();
            currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
            componentUpdateQueue.stores = [check];
          } else {
            var stores = componentUpdateQueue.stores;
            if (stores === null) {
              componentUpdateQueue.stores = [check];
            } else {
              stores.push(check);
            }
          }
        }
        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
          inst.value = nextSnapshot;
          inst.getSnapshot = getSnapshot;
          if (checkIfSnapshotChanged(inst)) {
            forceStoreRerender(fiber);
          }
        }
        function subscribeToStore(fiber, inst, subscribe) {
          var handleStoreChange = function() {
            if (checkIfSnapshotChanged(inst)) {
              forceStoreRerender(fiber);
            }
          };
          return subscribe(handleStoreChange);
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error3) {
            return true;
          }
        }
        function forceStoreRerender(fiber) {
          var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
          }
        }
        function mountState(initialState) {
          var hook = mountWorkInProgressHook();
          if (typeof initialState === "function") {
            initialState = initialState();
          }
          hook.memoizedState = hook.baseState = initialState;
          var queue = {
            pending: null,
            interleaved: null,
            lanes: NoLanes,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialState
          };
          hook.queue = queue;
          var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
          return [hook.memoizedState, dispatch];
        }
        function updateState(initialState) {
          return updateReducer(basicStateReducer);
        }
        function rerenderState(initialState) {
          return rerenderReducer(basicStateReducer);
        }
        function pushEffect(tag, create, destroy, deps) {
          var effect = {
            tag,
            create,
            destroy,
            deps,
            // Circular
            next: null
          };
          var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
          if (componentUpdateQueue === null) {
            componentUpdateQueue = createFunctionComponentUpdateQueue();
            currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
            componentUpdateQueue.lastEffect = effect.next = effect;
          } else {
            var lastEffect = componentUpdateQueue.lastEffect;
            if (lastEffect === null) {
              componentUpdateQueue.lastEffect = effect.next = effect;
            } else {
              var firstEffect = lastEffect.next;
              lastEffect.next = effect;
              effect.next = firstEffect;
              componentUpdateQueue.lastEffect = effect;
            }
          }
          return effect;
        }
        function mountRef(initialValue) {
          var hook = mountWorkInProgressHook();
          {
            var _ref2 = {
              current: initialValue
            };
            hook.memoizedState = _ref2;
            return _ref2;
          }
        }
        function updateRef(initialValue) {
          var hook = updateWorkInProgressHook();
          return hook.memoizedState;
        }
        function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          currentlyRenderingFiber$1.flags |= fiberFlags;
          hook.memoizedState = pushEffect(HasEffect | hookFlags, create, void 0, nextDeps);
        }
        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var destroy = void 0;
          if (currentHook !== null) {
            var prevEffect = currentHook.memoizedState;
            destroy = prevEffect.destroy;
            if (nextDeps !== null) {
              var prevDeps = prevEffect.deps;
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
                return;
              }
            }
          }
          currentlyRenderingFiber$1.flags |= fiberFlags;
          hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
        }
        function mountEffect(create, deps) {
          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
            return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);
          } else {
            return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);
          }
        }
        function updateEffect(create, deps) {
          return updateEffectImpl(Passive, Passive$1, create, deps);
        }
        function mountInsertionEffect(create, deps) {
          return mountEffectImpl(Update, Insertion, create, deps);
        }
        function updateInsertionEffect(create, deps) {
          return updateEffectImpl(Update, Insertion, create, deps);
        }
        function mountLayoutEffect(create, deps) {
          var fiberFlags = Update;
          {
            fiberFlags |= LayoutStatic;
          }
          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
            fiberFlags |= MountLayoutDev;
          }
          return mountEffectImpl(fiberFlags, Layout, create, deps);
        }
        function updateLayoutEffect(create, deps) {
          return updateEffectImpl(Update, Layout, create, deps);
        }
        function imperativeHandleEffect(create, ref) {
          if (typeof ref === "function") {
            var refCallback = ref;
            var _inst = create();
            refCallback(_inst);
            return function() {
              refCallback(null);
            };
          } else if (ref !== null && ref !== void 0) {
            var refObject = ref;
            {
              if (!refObject.hasOwnProperty("current")) {
                error2("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
              }
            }
            var _inst2 = create();
            refObject.current = _inst2;
            return function() {
              refObject.current = null;
            };
          }
        }
        function mountImperativeHandle(ref, create, deps) {
          {
            if (typeof create !== "function") {
              error2("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
            }
          }
          var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
          var fiberFlags = Update;
          {
            fiberFlags |= LayoutStatic;
          }
          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
            fiberFlags |= MountLayoutDev;
          }
          return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
        }
        function updateImperativeHandle(ref, create, deps) {
          {
            if (typeof create !== "function") {
              error2("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
            }
          }
          var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
          return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
        }
        function mountDebugValue(value, formatterFn) {
        }
        var updateDebugValue = mountDebugValue;
        function mountCallback(callback, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          hook.memoizedState = [callback, nextDeps];
          return callback;
        }
        function updateCallback(callback, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var prevState = hook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
          hook.memoizedState = [callback, nextDeps];
          return callback;
        }
        function mountMemo(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var nextValue = nextCreate();
          hook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function updateMemo(nextCreate, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var prevState = hook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
          var nextValue = nextCreate();
          hook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function mountDeferredValue(value) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = value;
          return value;
        }
        function updateDeferredValue(value) {
          var hook = updateWorkInProgressHook();
          var resolvedCurrentHook = currentHook;
          var prevValue = resolvedCurrentHook.memoizedState;
          return updateDeferredValueImpl(hook, prevValue, value);
        }
        function rerenderDeferredValue(value) {
          var hook = updateWorkInProgressHook();
          if (currentHook === null) {
            hook.memoizedState = value;
            return value;
          } else {
            var prevValue = currentHook.memoizedState;
            return updateDeferredValueImpl(hook, prevValue, value);
          }
        }
        function updateDeferredValueImpl(hook, prevValue, value) {
          var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
          if (shouldDeferValue) {
            if (!objectIs(value, prevValue)) {
              var deferredLane = claimNextTransitionLane();
              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
              markSkippedUpdateLanes(deferredLane);
              hook.baseState = true;
            }
            return prevValue;
          } else {
            if (hook.baseState) {
              hook.baseState = false;
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = value;
            return value;
          }
        }
        function startTransition(setPending, callback, options2) {
          var previousPriority = getCurrentUpdatePriority();
          setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
          setPending(true);
          var prevTransition = ReactCurrentBatchConfig$2.transition;
          ReactCurrentBatchConfig$2.transition = {};
          var currentTransition = ReactCurrentBatchConfig$2.transition;
          {
            ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            setPending(false);
            callback();
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$2.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        function mountTransition() {
          var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];
          var start = startTransition.bind(null, setPending);
          var hook = mountWorkInProgressHook();
          hook.memoizedState = start;
          return [isPending, start];
        }
        function updateTransition() {
          var _updateState = updateState(), isPending = _updateState[0];
          var hook = updateWorkInProgressHook();
          var start = hook.memoizedState;
          return [isPending, start];
        }
        function rerenderTransition() {
          var _rerenderState = rerenderState(), isPending = _rerenderState[0];
          var hook = updateWorkInProgressHook();
          var start = hook.memoizedState;
          return [isPending, start];
        }
        var isUpdatingOpaqueValueInRenderPhase = false;
        function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
          {
            return isUpdatingOpaqueValueInRenderPhase;
          }
        }
        function mountId() {
          var hook = mountWorkInProgressHook();
          var root2 = getWorkInProgressRoot();
          var identifierPrefix = root2.identifierPrefix;
          var id;
          if (getIsHydrating()) {
            var treeId = getTreeId();
            id = ":" + identifierPrefix + "R" + treeId;
            var localId = localIdCounter++;
            if (localId > 0) {
              id += "H" + localId.toString(32);
            }
            id += ":";
          } else {
            var globalClientId = globalClientIdCounter++;
            id = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
          }
          hook.memoizedState = id;
          return id;
        }
        function updateId() {
          var hook = updateWorkInProgressHook();
          var id = hook.memoizedState;
          return id;
        }
        function dispatchReducerAction(fiber, queue, action) {
          {
            if (typeof arguments[3] === "function") {
              error2("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
            }
          }
          var lane = requestUpdateLane(fiber);
          var update = {
            lane,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            enqueueRenderPhaseUpdate(queue, update);
          } else {
            var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
            if (root2 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
              entangleTransitionUpdate(root2, queue, lane);
            }
          }
          markUpdateInDevTools(fiber, lane);
        }
        function dispatchSetState(fiber, queue, action) {
          {
            if (typeof arguments[3] === "function") {
              error2("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
            }
          }
          var lane = requestUpdateLane(fiber);
          var update = {
            lane,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            enqueueRenderPhaseUpdate(queue, update);
          } else {
            var alternate = fiber.alternate;
            if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
              var lastRenderedReducer = queue.lastRenderedReducer;
              if (lastRenderedReducer !== null) {
                var prevDispatcher;
                {
                  prevDispatcher = ReactCurrentDispatcher$1.current;
                  ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                }
                try {
                  var currentState = queue.lastRenderedState;
                  var eagerState = lastRenderedReducer(currentState, action);
                  update.hasEagerState = true;
                  update.eagerState = eagerState;
                  if (objectIs(eagerState, currentState)) {
                    enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);
                    return;
                  }
                } catch (error3) {
                } finally {
                  {
                    ReactCurrentDispatcher$1.current = prevDispatcher;
                  }
                }
              }
            }
            var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
            if (root2 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
              entangleTransitionUpdate(root2, queue, lane);
            }
          }
          markUpdateInDevTools(fiber, lane);
        }
        function isRenderPhaseUpdate(fiber) {
          var alternate = fiber.alternate;
          return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
        }
        function enqueueRenderPhaseUpdate(queue, update) {
          didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
          var pending = queue.pending;
          if (pending === null) {
            update.next = update;
          } else {
            update.next = pending.next;
            pending.next = update;
          }
          queue.pending = update;
        }
        function entangleTransitionUpdate(root2, queue, lane) {
          if (isTransitionLane(lane)) {
            var queueLanes = queue.lanes;
            queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
            var newQueueLanes = mergeLanes(queueLanes, lane);
            queue.lanes = newQueueLanes;
            markRootEntangled(root2, newQueueLanes);
          }
        }
        function markUpdateInDevTools(fiber, lane, action) {
          {
            markStateUpdateScheduled(fiber, lane);
          }
        }
        var ContextOnlyDispatcher = {
          readContext,
          useCallback: throwInvalidHookError,
          useContext: throwInvalidHookError,
          useEffect: throwInvalidHookError,
          useImperativeHandle: throwInvalidHookError,
          useInsertionEffect: throwInvalidHookError,
          useLayoutEffect: throwInvalidHookError,
          useMemo: throwInvalidHookError,
          useReducer: throwInvalidHookError,
          useRef: throwInvalidHookError,
          useState: throwInvalidHookError,
          useDebugValue: throwInvalidHookError,
          useDeferredValue: throwInvalidHookError,
          useTransition: throwInvalidHookError,
          useMutableSource: throwInvalidHookError,
          useSyncExternalStore: throwInvalidHookError,
          useId: throwInvalidHookError,
          unstable_isNewReconciler: enableNewReconciler
        };
        var HooksDispatcherOnMountInDEV = null;
        var HooksDispatcherOnMountWithHookTypesInDEV = null;
        var HooksDispatcherOnUpdateInDEV = null;
        var HooksDispatcherOnRerenderInDEV = null;
        var InvalidNestedHooksDispatcherOnMountInDEV = null;
        var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
        var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
        {
          var warnInvalidContextAccess = function() {
            error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          };
          var warnInvalidHookAccess = function() {
            error2("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
          };
          HooksDispatcherOnMountInDEV = {
            readContext: function(context) {
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              mountHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountInsertionEffect(create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              mountHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              mountHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              mountHookTypesDev();
              return mountDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              mountHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              mountHookTypesDev();
              return mountMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              mountHookTypesDev();
              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              mountHookTypesDev();
              return mountId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnMountWithHookTypesInDEV = {
            readContext: function(context) {
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return mountCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return mountEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return mountImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return mountInsertionEffect(create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return mountLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return mountDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return mountMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return mountId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnUpdateInDEV = {
            readContext: function(context) {
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return updateEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return updateImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return updateInsertionEffect(create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return updateLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return updateDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return updateTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnRerenderInDEV = {
            readContext: function(context) {
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return updateEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return updateImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return updateInsertionEffect(create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return updateLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return rerenderReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return rerenderState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return rerenderDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return rerenderTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnMountInDEV = {
            readContext: function(context) {
              warnInvalidContextAccess();
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountInsertionEffect(create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnUpdateInDEV = {
            readContext: function(context) {
              warnInvalidContextAccess();
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateInsertionEffect(create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnRerenderInDEV = {
            readContext: function(context) {
              warnInvalidContextAccess();
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateInsertionEffect(create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return rerenderReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return rerenderState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
        }
        var now$1 = Scheduler.unstable_now;
        var commitTime = 0;
        var layoutEffectStartTime = -1;
        var profilerStartTime = -1;
        var passiveEffectStartTime = -1;
        var currentUpdateIsNested = false;
        var nestedUpdateScheduled = false;
        function isCurrentUpdateNested() {
          return currentUpdateIsNested;
        }
        function markNestedUpdateScheduled() {
          {
            nestedUpdateScheduled = true;
          }
        }
        function resetNestedUpdateFlag() {
          {
            currentUpdateIsNested = false;
            nestedUpdateScheduled = false;
          }
        }
        function syncNestedUpdateFlag() {
          {
            currentUpdateIsNested = nestedUpdateScheduled;
            nestedUpdateScheduled = false;
          }
        }
        function getCommitTime() {
          return commitTime;
        }
        function recordCommitTime() {
          commitTime = now$1();
        }
        function startProfilerTimer(fiber) {
          profilerStartTime = now$1();
          if (fiber.actualStartTime < 0) {
            fiber.actualStartTime = now$1();
          }
        }
        function stopProfilerTimerIfRunning(fiber) {
          profilerStartTime = -1;
        }
        function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
          if (profilerStartTime >= 0) {
            var elapsedTime = now$1() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            if (overrideBaseTime) {
              fiber.selfBaseDuration = elapsedTime;
            }
            profilerStartTime = -1;
          }
        }
        function recordLayoutEffectDuration(fiber) {
          if (layoutEffectStartTime >= 0) {
            var elapsedTime = now$1() - layoutEffectStartTime;
            layoutEffectStartTime = -1;
            var parentFiber = fiber.return;
            while (parentFiber !== null) {
              switch (parentFiber.tag) {
                case HostRoot:
                  var root2 = parentFiber.stateNode;
                  root2.effectDuration += elapsedTime;
                  return;
                case Profiler:
                  var parentStateNode = parentFiber.stateNode;
                  parentStateNode.effectDuration += elapsedTime;
                  return;
              }
              parentFiber = parentFiber.return;
            }
          }
        }
        function recordPassiveEffectDuration(fiber) {
          if (passiveEffectStartTime >= 0) {
            var elapsedTime = now$1() - passiveEffectStartTime;
            passiveEffectStartTime = -1;
            var parentFiber = fiber.return;
            while (parentFiber !== null) {
              switch (parentFiber.tag) {
                case HostRoot:
                  var root2 = parentFiber.stateNode;
                  if (root2 !== null) {
                    root2.passiveEffectDuration += elapsedTime;
                  }
                  return;
                case Profiler:
                  var parentStateNode = parentFiber.stateNode;
                  if (parentStateNode !== null) {
                    parentStateNode.passiveEffectDuration += elapsedTime;
                  }
                  return;
              }
              parentFiber = parentFiber.return;
            }
          }
        }
        function startLayoutEffectTimer() {
          layoutEffectStartTime = now$1();
        }
        function startPassiveEffectTimer() {
          passiveEffectStartTime = now$1();
        }
        function transferActualDuration(fiber) {
          var child = fiber.child;
          while (child) {
            fiber.actualDuration += child.actualDuration;
            child = child.sibling;
          }
        }
        function resolveDefaultProps(Component, baseProps) {
          if (Component && Component.defaultProps) {
            var props = assign3({}, baseProps);
            var defaultProps = Component.defaultProps;
            for (var propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
            return props;
          }
          return baseProps;
        }
        var fakeInternalInstance = {};
        var didWarnAboutStateAssignmentForComponent;
        var didWarnAboutUninitializedState;
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
        var didWarnAboutLegacyLifecyclesAndDerivedState;
        var didWarnAboutUndefinedDerivedState;
        var warnOnUndefinedDerivedState;
        var warnOnInvalidCallback;
        var didWarnAboutDirectlyAssigningPropsToState;
        var didWarnAboutContextTypeAndContextTypes;
        var didWarnAboutInvalidateContextType;
        var didWarnAboutLegacyContext$1;
        {
          didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
          didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
          didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
          didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
          didWarnAboutLegacyContext$1 = /* @__PURE__ */ new Set();
          var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
          warnOnInvalidCallback = function(callback, callerName) {
            if (callback === null || typeof callback === "function") {
              return;
            }
            var key = callerName + "_" + callback;
            if (!didWarnOnInvalidCallback.has(key)) {
              didWarnOnInvalidCallback.add(key);
              error2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          };
          warnOnUndefinedDerivedState = function(type, partialState) {
            if (partialState === void 0) {
              var componentName = getComponentNameFromType(type) || "Component";
              if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error2("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
              }
            }
          };
          Object.defineProperty(fakeInternalInstance, "_processChildContext", {
            enumerable: false,
            value: function() {
              throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
            }
          });
          Object.freeze(fakeInternalInstance);
        }
        function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
          var prevState = workInProgress2.memoizedState;
          var partialState = getDerivedStateFromProps(nextProps, prevState);
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                partialState = getDerivedStateFromProps(nextProps, prevState);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            warnOnUndefinedDerivedState(ctor, partialState);
          }
          var memoizedState = partialState === null || partialState === void 0 ? prevState : assign3({}, prevState, partialState);
          workInProgress2.memoizedState = memoizedState;
          if (workInProgress2.lanes === NoLanes) {
            var updateQueue = workInProgress2.updateQueue;
            updateQueue.baseState = memoizedState;
          }
        }
        var classComponentUpdater = {
          isMounted,
          enqueueSetState: function(inst, payload, callback) {
            var fiber = get(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = createUpdate(eventTime, lane);
            update.payload = payload;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "setState");
              }
              update.callback = callback;
            }
            var root2 = enqueueUpdate(fiber, update, lane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
              entangleTransitions(root2, fiber, lane);
            }
            {
              markStateUpdateScheduled(fiber, lane);
            }
          },
          enqueueReplaceState: function(inst, payload, callback) {
            var fiber = get(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = createUpdate(eventTime, lane);
            update.tag = ReplaceState;
            update.payload = payload;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "replaceState");
              }
              update.callback = callback;
            }
            var root2 = enqueueUpdate(fiber, update, lane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
              entangleTransitions(root2, fiber, lane);
            }
            {
              markStateUpdateScheduled(fiber, lane);
            }
          },
          enqueueForceUpdate: function(inst, callback) {
            var fiber = get(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = createUpdate(eventTime, lane);
            update.tag = ForceUpdate;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "forceUpdate");
              }
              update.callback = callback;
            }
            var root2 = enqueueUpdate(fiber, update, lane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
              entangleTransitions(root2, fiber, lane);
            }
            {
              markForceUpdateScheduled(fiber, lane);
            }
          }
        };
        function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
          var instance = workInProgress2.stateNode;
          if (typeof instance.shouldComponentUpdate === "function") {
            var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              if (shouldUpdate === void 0) {
                error2("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
              }
            }
            return shouldUpdate;
          }
          if (ctor.prototype && ctor.prototype.isPureReactComponent) {
            return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
          }
          return true;
        }
        function checkClassInstance(workInProgress2, ctor, newProps) {
          var instance = workInProgress2.stateNode;
          {
            var name2 = getComponentNameFromType(ctor) || "Component";
            var renderPresent = instance.render;
            if (!renderPresent) {
              if (ctor.prototype && typeof ctor.prototype.render === "function") {
                error2("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name2);
              } else {
                error2("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name2);
              }
            }
            if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
              error2("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name2);
            }
            if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
              error2("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name2);
            }
            if (instance.propTypes) {
              error2("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name2);
            }
            if (instance.contextType) {
              error2("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name2);
            }
            {
              if (ctor.childContextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
              // this one.
              (workInProgress2.mode & StrictLegacyMode) === NoMode) {
                didWarnAboutLegacyContext$1.add(ctor);
                error2("%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead\n\n.Learn more about this warning here: https://reactjs.org/link/legacy-context", name2);
              }
              if (ctor.contextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
              // this one.
              (workInProgress2.mode & StrictLegacyMode) === NoMode) {
                didWarnAboutLegacyContext$1.add(ctor);
                error2("%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", name2);
              }
              if (instance.contextTypes) {
                error2("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name2);
              }
              if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                didWarnAboutContextTypeAndContextTypes.add(ctor);
                error2("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name2);
              }
            }
            if (typeof instance.componentShouldUpdate === "function") {
              error2("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name2);
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
              error2("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
            }
            if (typeof instance.componentDidUnmount === "function") {
              error2("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name2);
            }
            if (typeof instance.componentDidReceiveProps === "function") {
              error2("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name2);
            }
            if (typeof instance.componentWillRecieveProps === "function") {
              error2("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name2);
            }
            if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
              error2("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name2);
            }
            var hasMutatedProps = instance.props !== newProps;
            if (instance.props !== void 0 && hasMutatedProps) {
              error2("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name2, name2);
            }
            if (instance.defaultProps) {
              error2("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name2, name2);
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
              didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
              error2("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
            }
            if (typeof instance.getDerivedStateFromProps === "function") {
              error2("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
            }
            if (typeof instance.getDerivedStateFromError === "function") {
              error2("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
            }
            if (typeof ctor.getSnapshotBeforeUpdate === "function") {
              error2("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name2);
            }
            var _state = instance.state;
            if (_state && (typeof _state !== "object" || isArray(_state))) {
              error2("%s.state: must be set to an object or null", name2);
            }
            if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
              error2("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name2);
            }
          }
        }
        function adoptClassInstance(workInProgress2, instance) {
          instance.updater = classComponentUpdater;
          workInProgress2.stateNode = instance;
          set2(instance, workInProgress2);
          {
            instance._reactInternalInstance = fakeInternalInstance;
          }
        }
        function constructClassInstance(workInProgress2, ctor, props) {
          var isLegacyContextConsumer = false;
          var unmaskedContext = emptyContextObject;
          var context = emptyContextObject;
          var contextType = ctor.contextType;
          {
            if ("contextType" in ctor) {
              var isValid = (
                // Allow null for conditional declaration
                contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
              );
              if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = "";
                if (contextType === void 0) {
                  addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                } else if (typeof contextType !== "object") {
                  addendum = " However, it is set to a " + typeof contextType + ".";
                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                  addendum = " Did you accidentally pass the Context.Provider instead?";
                } else if (contextType._context !== void 0) {
                  addendum = " Did you accidentally pass the Context.Consumer instead?";
                } else {
                  addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                }
                error2("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
              }
            }
          }
          if (typeof contextType === "object" && contextType !== null) {
            context = readContext(contextType);
          } else {
            unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            var contextTypes = ctor.contextTypes;
            isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
            context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
          }
          var instance = new ctor(props, context);
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                instance = new ctor(props, context);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          }
          var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
          adoptClassInstance(workInProgress2, instance);
          {
            if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error2("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
              }
            }
            if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
              var foundWillMountName = null;
              var foundWillReceivePropsName = null;
              var foundWillUpdateName = null;
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                foundWillMountName = "componentWillMount";
              } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                foundWillMountName = "UNSAFE_componentWillMount";
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                foundWillReceivePropsName = "componentWillReceiveProps";
              } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                foundWillUpdateName = "componentWillUpdate";
              } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                foundWillUpdateName = "UNSAFE_componentWillUpdate";
              }
              if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentNameFromType(ctor) || "Component";
                var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                  didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                  error2("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                }
              }
            }
          }
          if (isLegacyContextConsumer) {
            cacheContext(workInProgress2, unmaskedContext, context);
          }
          return instance;
        }
        function callComponentWillMount(workInProgress2, instance) {
          var oldState = instance.state;
          if (typeof instance.componentWillMount === "function") {
            instance.componentWillMount();
          }
          if (typeof instance.UNSAFE_componentWillMount === "function") {
            instance.UNSAFE_componentWillMount();
          }
          if (oldState !== instance.state) {
            {
              error2("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component");
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
          var oldState = instance.state;
          if (typeof instance.componentWillReceiveProps === "function") {
            instance.componentWillReceiveProps(newProps, nextContext);
          }
          if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
            instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
          }
          if (instance.state !== oldState) {
            {
              var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
              if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                didWarnAboutStateAssignmentForComponent.add(componentName);
                error2("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
              }
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
          {
            checkClassInstance(workInProgress2, ctor, newProps);
          }
          var instance = workInProgress2.stateNode;
          instance.props = newProps;
          instance.state = workInProgress2.memoizedState;
          instance.refs = {};
          initializeUpdateQueue(workInProgress2);
          var contextType = ctor.contextType;
          if (typeof contextType === "object" && contextType !== null) {
            instance.context = readContext(contextType);
          } else {
            var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            instance.context = getMaskedContext(workInProgress2, unmaskedContext);
          }
          {
            if (instance.state === newProps) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error2("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
              }
            }
            if (workInProgress2.mode & StrictLegacyMode) {
              ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);
            }
            {
              ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
            }
          }
          instance.state = workInProgress2.memoizedState;
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            instance.state = workInProgress2.memoizedState;
          }
          if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            callComponentWillMount(workInProgress2, instance);
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            instance.state = workInProgress2.memoizedState;
          }
          if (typeof instance.componentDidMount === "function") {
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            workInProgress2.flags |= fiberFlags;
          }
        }
        function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
          var instance = workInProgress2.stateNode;
          var oldProps = workInProgress2.memoizedProps;
          instance.props = oldProps;
          var oldContext = instance.context;
          var contextType = ctor.contextType;
          var nextContext = emptyContextObject;
          if (typeof contextType === "object" && contextType !== null) {
            nextContext = readContext(contextType);
          } else {
            var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
            if (oldProps !== newProps || oldContext !== nextContext) {
              callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
            }
          }
          resetHasForceUpdateBeforeProcessing();
          var oldState = workInProgress2.memoizedState;
          var newState = instance.state = oldState;
          processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
          newState = workInProgress2.memoizedState;
          if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
            if (typeof instance.componentDidMount === "function") {
              var fiberFlags = Update;
              {
                fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= fiberFlags;
            }
            return false;
          }
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            newState = workInProgress2.memoizedState;
          }
          var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
          if (shouldUpdate) {
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
              if (typeof instance.componentWillMount === "function") {
                instance.componentWillMount();
              }
              if (typeof instance.UNSAFE_componentWillMount === "function") {
                instance.UNSAFE_componentWillMount();
              }
            }
            if (typeof instance.componentDidMount === "function") {
              var _fiberFlags = Update;
              {
                _fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                _fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= _fiberFlags;
            }
          } else {
            if (typeof instance.componentDidMount === "function") {
              var _fiberFlags2 = Update;
              {
                _fiberFlags2 |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                _fiberFlags2 |= MountLayoutDev;
              }
              workInProgress2.flags |= _fiberFlags2;
            }
            workInProgress2.memoizedProps = newProps;
            workInProgress2.memoizedState = newState;
          }
          instance.props = newProps;
          instance.state = newState;
          instance.context = nextContext;
          return shouldUpdate;
        }
        function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
          var instance = workInProgress2.stateNode;
          cloneUpdateQueue(current2, workInProgress2);
          var unresolvedOldProps = workInProgress2.memoizedProps;
          var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
          instance.props = oldProps;
          var unresolvedNewProps = workInProgress2.pendingProps;
          var oldContext = instance.context;
          var contextType = ctor.contextType;
          var nextContext = emptyContextObject;
          if (typeof contextType === "object" && contextType !== null) {
            nextContext = readContext(contextType);
          } else {
            var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
            if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
              callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
            }
          }
          resetHasForceUpdateBeforeProcessing();
          var oldState = workInProgress2.memoizedState;
          var newState = instance.state = oldState;
          processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
          newState = workInProgress2.memoizedState;
          if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {
            if (typeof instance.componentDidUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Update;
              }
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Snapshot;
              }
            }
            return false;
          }
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            newState = workInProgress2.memoizedState;
          }
          var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,
          // both before and after `shouldComponentUpdate` has been called. Not ideal,
          // but I'm loath to refactor this function. This only happens for memoized
          // components so it's not that common.
          enableLazyContextPropagation;
          if (shouldUpdate) {
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
              if (typeof instance.componentWillUpdate === "function") {
                instance.componentWillUpdate(newProps, newState, nextContext);
              }
              if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
              }
            }
            if (typeof instance.componentDidUpdate === "function") {
              workInProgress2.flags |= Update;
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function") {
              workInProgress2.flags |= Snapshot;
            }
          } else {
            if (typeof instance.componentDidUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Update;
              }
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Snapshot;
              }
            }
            workInProgress2.memoizedProps = newProps;
            workInProgress2.memoizedState = newState;
          }
          instance.props = newProps;
          instance.state = newState;
          instance.context = nextContext;
          return shouldUpdate;
        }
        function createCapturedValueAtFiber(value, source) {
          return {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source),
            digest: null
          };
        }
        function createCapturedValue(value, digest, stack) {
          return {
            value,
            source: null,
            stack: stack != null ? stack : null,
            digest: digest != null ? digest : null
          };
        }
        function showErrorDialog(boundary, errorInfo) {
          return true;
        }
        function logCapturedError(boundary, errorInfo) {
          try {
            var logError = showErrorDialog(boundary, errorInfo);
            if (logError === false) {
              return;
            }
            var error3 = errorInfo.value;
            if (true) {
              var source = errorInfo.source;
              var stack = errorInfo.stack;
              var componentStack = stack !== null ? stack : "";
              if (error3 != null && error3._suppressLogging) {
                if (boundary.tag === ClassComponent) {
                  return;
                }
                console["error"](error3);
              }
              var componentName = source ? getComponentNameFromFiber(source) : null;
              var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
              var errorBoundaryMessage;
              if (boundary.tag === HostRoot) {
                errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
              } else {
                var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
                errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
              }
              var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
              console["error"](combinedMessage);
            } else {
              console["error"](error3);
            }
          } catch (e) {
            setTimeout(function() {
              throw e;
            });
          }
        }
        var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
        function createRootErrorUpdate(fiber, errorInfo, lane) {
          var update = createUpdate(NoTimestamp, lane);
          update.tag = CaptureUpdate;
          update.payload = {
            element: null
          };
          var error3 = errorInfo.value;
          update.callback = function() {
            onUncaughtError(error3);
            logCapturedError(fiber, errorInfo);
          };
          return update;
        }
        function createClassErrorUpdate(fiber, errorInfo, lane) {
          var update = createUpdate(NoTimestamp, lane);
          update.tag = CaptureUpdate;
          var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
          if (typeof getDerivedStateFromError === "function") {
            var error$1 = errorInfo.value;
            update.payload = function() {
              return getDerivedStateFromError(error$1);
            };
            update.callback = function() {
              {
                markFailedErrorBoundaryForHotReloading(fiber);
              }
              logCapturedError(fiber, errorInfo);
            };
          }
          var inst = fiber.stateNode;
          if (inst !== null && typeof inst.componentDidCatch === "function") {
            update.callback = function callback() {
              {
                markFailedErrorBoundaryForHotReloading(fiber);
              }
              logCapturedError(fiber, errorInfo);
              if (typeof getDerivedStateFromError !== "function") {
                markLegacyErrorBoundaryAsFailed(this);
              }
              var error$12 = errorInfo.value;
              var stack = errorInfo.stack;
              this.componentDidCatch(error$12, {
                componentStack: stack !== null ? stack : ""
              });
              {
                if (typeof getDerivedStateFromError !== "function") {
                  if (!includesSomeLane(fiber.lanes, SyncLane)) {
                    error2("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
                  }
                }
              }
            };
          }
          return update;
        }
        function attachPingListener(root2, wakeable, lanes) {
          var pingCache = root2.pingCache;
          var threadIDs;
          if (pingCache === null) {
            pingCache = root2.pingCache = new PossiblyWeakMap$1();
            threadIDs = /* @__PURE__ */ new Set();
            pingCache.set(wakeable, threadIDs);
          } else {
            threadIDs = pingCache.get(wakeable);
            if (threadIDs === void 0) {
              threadIDs = /* @__PURE__ */ new Set();
              pingCache.set(wakeable, threadIDs);
            }
          }
          if (!threadIDs.has(lanes)) {
            threadIDs.add(lanes);
            var ping = pingSuspendedRoot.bind(null, root2, wakeable, lanes);
            {
              if (isDevToolsPresent) {
                restorePendingUpdaters(root2, lanes);
              }
            }
            wakeable.then(ping, ping);
          }
        }
        function attachRetryListener(suspenseBoundary, root2, wakeable, lanes) {
          var wakeables = suspenseBoundary.updateQueue;
          if (wakeables === null) {
            var updateQueue = /* @__PURE__ */ new Set();
            updateQueue.add(wakeable);
            suspenseBoundary.updateQueue = updateQueue;
          } else {
            wakeables.add(wakeable);
          }
        }
        function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
          var tag = sourceFiber.tag;
          if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
            var currentSource = sourceFiber.alternate;
            if (currentSource) {
              sourceFiber.updateQueue = currentSource.updateQueue;
              sourceFiber.memoizedState = currentSource.memoizedState;
              sourceFiber.lanes = currentSource.lanes;
            } else {
              sourceFiber.updateQueue = null;
              sourceFiber.memoizedState = null;
            }
          }
        }
        function getNearestSuspenseBoundaryToCapture(returnFiber) {
          var node = returnFiber;
          do {
            if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {
              return node;
            }
            node = node.return;
          } while (node !== null);
          return null;
        }
        function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes) {
          if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
            if (suspenseBoundary === returnFiber) {
              suspenseBoundary.flags |= ShouldCapture;
            } else {
              suspenseBoundary.flags |= DidCapture;
              sourceFiber.flags |= ForceUpdateForLegacySuspense;
              sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
              if (sourceFiber.tag === ClassComponent) {
                var currentSourceFiber = sourceFiber.alternate;
                if (currentSourceFiber === null) {
                  sourceFiber.tag = IncompleteClassComponent;
                } else {
                  var update = createUpdate(NoTimestamp, SyncLane);
                  update.tag = ForceUpdate;
                  enqueueUpdate(sourceFiber, update, SyncLane);
                }
              }
              sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
            }
            return suspenseBoundary;
          }
          suspenseBoundary.flags |= ShouldCapture;
          suspenseBoundary.lanes = rootRenderLanes;
          return suspenseBoundary;
        }
        function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
          sourceFiber.flags |= Incomplete;
          {
            if (isDevToolsPresent) {
              restorePendingUpdaters(root2, rootRenderLanes);
            }
          }
          if (value !== null && typeof value === "object" && typeof value.then === "function") {
            var wakeable = value;
            resetSuspendedComponent(sourceFiber);
            {
              if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                markDidThrowWhileHydratingDEV();
              }
            }
            var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
            if (suspenseBoundary !== null) {
              suspenseBoundary.flags &= ~ForceClientRender;
              markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);
              if (suspenseBoundary.mode & ConcurrentMode) {
                attachPingListener(root2, wakeable, rootRenderLanes);
              }
              attachRetryListener(suspenseBoundary, root2, wakeable);
              return;
            } else {
              if (!includesSyncLane(rootRenderLanes)) {
                attachPingListener(root2, wakeable, rootRenderLanes);
                renderDidSuspendDelayIfPossible();
                return;
              }
              var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
              value = uncaughtSuspenseError;
            }
          } else {
            if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
              markDidThrowWhileHydratingDEV();
              var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
              if (_suspenseBoundary !== null) {
                if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                  _suspenseBoundary.flags |= ForceClientRender;
                }
                markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);
                queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));
                return;
              }
            }
          }
          value = createCapturedValueAtFiber(value, sourceFiber);
          renderDidError(value);
          var workInProgress2 = returnFiber;
          do {
            switch (workInProgress2.tag) {
              case HostRoot: {
                var _errorInfo = value;
                workInProgress2.flags |= ShouldCapture;
                var lane = pickArbitraryLane(rootRenderLanes);
                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
                enqueueCapturedUpdate(workInProgress2, update);
                return;
              }
              case ClassComponent:
                var errorInfo = value;
                var ctor = workInProgress2.type;
                var instance = workInProgress2.stateNode;
                if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                  workInProgress2.flags |= ShouldCapture;
                  var _lane = pickArbitraryLane(rootRenderLanes);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                  var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                  enqueueCapturedUpdate(workInProgress2, _update);
                  return;
                }
                break;
            }
            workInProgress2 = workInProgress2.return;
          } while (workInProgress2 !== null);
        }
        function getSuspendedCache() {
          {
            return null;
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var didReceiveUpdate = false;
        var didWarnAboutBadClass;
        var didWarnAboutModulePatternComponent;
        var didWarnAboutContextTypeOnFunctionComponent;
        var didWarnAboutGetDerivedStateOnFunctionComponent;
        var didWarnAboutFunctionRefs;
        var didWarnAboutReassigningProps;
        var didWarnAboutRevealOrder;
        var didWarnAboutTailOptions;
        var didWarnAboutDefaultPropsOnFunctionComponent;
        {
          didWarnAboutBadClass = {};
          didWarnAboutModulePatternComponent = {};
          didWarnAboutContextTypeOnFunctionComponent = {};
          didWarnAboutGetDerivedStateOnFunctionComponent = {};
          didWarnAboutFunctionRefs = {};
          didWarnAboutReassigningProps = false;
          didWarnAboutRevealOrder = {};
          didWarnAboutTailOptions = {};
          didWarnAboutDefaultPropsOnFunctionComponent = {};
        }
        function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
          if (current2 === null) {
            workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          } else {
            workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
          }
        }
        function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
          workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
        }
        function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(Component)
                );
              }
            }
          }
          var render2 = Component.render;
          var ref = workInProgress2.ref;
          var nextChildren;
          var hasId;
          prepareToReadContext(workInProgress2, renderLanes2);
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
            hasId = checkDidRenderIdHook();
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
                hasId = checkDidRenderIdHook();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          if (current2 !== null && !didReceiveUpdate) {
            bailoutHooks(current2, workInProgress2, renderLanes2);
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          if (getIsHydrating() && hasId) {
            pushMaterializedTreeId(workInProgress2);
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (current2 === null) {
            var type = Component.type;
            if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
            Component.defaultProps === void 0) {
              var resolvedType = type;
              {
                resolvedType = resolveFunctionForHotReloading(type);
              }
              workInProgress2.tag = SimpleMemoComponent;
              workInProgress2.type = resolvedType;
              {
                validateFunctionComponentInDev(workInProgress2, type);
              }
              return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);
            }
            {
              var innerPropTypes = type.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(type)
                );
              }
              if (Component.defaultProps !== void 0) {
                var componentName = getComponentNameFromType(type) || "Unknown";
                if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                  error2("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", componentName);
                  didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
                }
              }
            }
            var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
            child.ref = workInProgress2.ref;
            child.return = workInProgress2;
            workInProgress2.child = child;
            return child;
          }
          {
            var _type = Component.type;
            var _innerPropTypes = _type.propTypes;
            if (_innerPropTypes) {
              checkPropTypes(
                _innerPropTypes,
                nextProps,
                // Resolved props
                "prop",
                getComponentNameFromType(_type)
              );
            }
          }
          var currentChild = current2.child;
          var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
          if (!hasScheduledUpdateOrContext) {
            var prevProps = currentChild.memoizedProps;
            var compare = Component.compare;
            compare = compare !== null ? compare : shallowEqual;
            if (compare(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
          }
          workInProgress2.flags |= PerformedWork;
          var newChild = createWorkInProgress(currentChild, nextProps);
          newChild.ref = workInProgress2.ref;
          newChild.return = workInProgress2;
          workInProgress2.child = newChild;
          return newChild;
        }
        function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var outerMemoType = workInProgress2.elementType;
              if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                var lazyComponent = outerMemoType;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  outerMemoType = init(payload);
                } catch (x) {
                  outerMemoType = null;
                }
                var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                if (outerPropTypes) {
                  checkPropTypes(
                    outerPropTypes,
                    nextProps,
                    // Resolved (SimpleMemoComponent has no defaultProps)
                    "prop",
                    getComponentNameFromType(outerMemoType)
                  );
                }
              }
            }
          }
          if (current2 !== null) {
            var prevProps = current2.memoizedProps;
            if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && // Prevent bailout if the implementation changed due to hot reload.
            workInProgress2.type === current2.type) {
              didReceiveUpdate = false;
              workInProgress2.pendingProps = nextProps = prevProps;
              if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
                workInProgress2.lanes = current2.lanes;
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                didReceiveUpdate = true;
              }
            }
          }
          return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
        }
        function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          var nextChildren = nextProps.children;
          var prevState = current2 !== null ? current2.memoizedState : null;
          if (nextProps.mode === "hidden" || enableLegacyHidden) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              var nextState = {
                baseLanes: NoLanes,
                cachePool: null,
                transitions: null
              };
              workInProgress2.memoizedState = nextState;
              pushRenderLanes(workInProgress2, renderLanes2);
            } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
              var spawnedCachePool = null;
              var nextBaseLanes;
              if (prevState !== null) {
                var prevBaseLanes = prevState.baseLanes;
                nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
              } else {
                nextBaseLanes = renderLanes2;
              }
              workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
              var _nextState = {
                baseLanes: nextBaseLanes,
                cachePool: spawnedCachePool,
                transitions: null
              };
              workInProgress2.memoizedState = _nextState;
              workInProgress2.updateQueue = null;
              pushRenderLanes(workInProgress2, nextBaseLanes);
              return null;
            } else {
              var _nextState2 = {
                baseLanes: NoLanes,
                cachePool: null,
                transitions: null
              };
              workInProgress2.memoizedState = _nextState2;
              var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
              pushRenderLanes(workInProgress2, subtreeRenderLanes2);
            }
          } else {
            var _subtreeRenderLanes;
            if (prevState !== null) {
              _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
              workInProgress2.memoizedState = null;
            } else {
              _subtreeRenderLanes = renderLanes2;
            }
            pushRenderLanes(workInProgress2, _subtreeRenderLanes);
          }
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateFragment(current2, workInProgress2, renderLanes2) {
          var nextChildren = workInProgress2.pendingProps;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateMode(current2, workInProgress2, renderLanes2) {
          var nextChildren = workInProgress2.pendingProps.children;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateProfiler(current2, workInProgress2, renderLanes2) {
          {
            workInProgress2.flags |= Update;
            {
              var stateNode = workInProgress2.stateNode;
              stateNode.effectDuration = 0;
              stateNode.passiveEffectDuration = 0;
            }
          }
          var nextProps = workInProgress2.pendingProps;
          var nextChildren = nextProps.children;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function markRef(current2, workInProgress2) {
          var ref = workInProgress2.ref;
          if (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) {
            workInProgress2.flags |= Ref;
            {
              workInProgress2.flags |= RefStatic;
            }
          }
        }
        function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(Component)
                );
              }
            }
          }
          var context;
          {
            var unmaskedContext = getUnmaskedContext(workInProgress2, Component, true);
            context = getMaskedContext(workInProgress2, unmaskedContext);
          }
          var nextChildren;
          var hasId;
          prepareToReadContext(workInProgress2, renderLanes2);
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
            hasId = checkDidRenderIdHook();
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
                hasId = checkDidRenderIdHook();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          if (current2 !== null && !didReceiveUpdate) {
            bailoutHooks(current2, workInProgress2, renderLanes2);
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          if (getIsHydrating() && hasId) {
            pushMaterializedTreeId(workInProgress2);
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            switch (shouldError(workInProgress2)) {
              case false: {
                var _instance = workInProgress2.stateNode;
                var ctor = workInProgress2.type;
                var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);
                var state = tempInstance.state;
                _instance.updater.enqueueSetState(_instance, state, null);
                break;
              }
              case true: {
                workInProgress2.flags |= DidCapture;
                workInProgress2.flags |= ShouldCapture;
                var error$1 = new Error("Simulated error coming from DevTools");
                var lane = pickArbitraryLane(renderLanes2);
                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                var update = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);
                enqueueCapturedUpdate(workInProgress2, update);
                break;
              }
            }
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(Component)
                );
              }
            }
          }
          var hasContext;
          if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress2);
          } else {
            hasContext = false;
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var instance = workInProgress2.stateNode;
          var shouldUpdate;
          if (instance === null) {
            resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2);
            constructClassInstance(workInProgress2, Component, nextProps);
            mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
            shouldUpdate = true;
          } else if (current2 === null) {
            shouldUpdate = resumeMountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
          } else {
            shouldUpdate = updateClassInstance(current2, workInProgress2, Component, nextProps, renderLanes2);
          }
          var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2);
          {
            var inst = workInProgress2.stateNode;
            if (shouldUpdate && inst.props !== nextProps) {
              if (!didWarnAboutReassigningProps) {
                error2("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component");
              }
              didWarnAboutReassigningProps = true;
            }
          }
          return nextUnitOfWork;
        }
        function finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2) {
          markRef(current2, workInProgress2);
          var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
          if (!shouldUpdate && !didCaptureError) {
            if (hasContext) {
              invalidateContextProvider(workInProgress2, Component, false);
            }
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          var instance = workInProgress2.stateNode;
          ReactCurrentOwner$1.current = workInProgress2;
          var nextChildren;
          if (didCaptureError && typeof Component.getDerivedStateFromError !== "function") {
            nextChildren = null;
            {
              stopProfilerTimerIfRunning();
            }
          } else {
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              setIsRendering(true);
              nextChildren = instance.render();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  instance.render();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
          }
          workInProgress2.flags |= PerformedWork;
          if (current2 !== null && didCaptureError) {
            forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);
          } else {
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          }
          workInProgress2.memoizedState = instance.state;
          if (hasContext) {
            invalidateContextProvider(workInProgress2, Component, true);
          }
          return workInProgress2.child;
        }
        function pushHostRootContext(workInProgress2) {
          var root2 = workInProgress2.stateNode;
          if (root2.pendingContext) {
            pushTopLevelContextObject(workInProgress2, root2.pendingContext, root2.pendingContext !== root2.context);
          } else if (root2.context) {
            pushTopLevelContextObject(workInProgress2, root2.context, false);
          }
          pushHostContainer(workInProgress2, root2.containerInfo);
        }
        function updateHostRoot(current2, workInProgress2, renderLanes2) {
          pushHostRootContext(workInProgress2);
          if (current2 === null) {
            throw new Error("Should have a current fiber. This is a bug in React.");
          }
          var nextProps = workInProgress2.pendingProps;
          var prevState = workInProgress2.memoizedState;
          var prevChildren = prevState.element;
          cloneUpdateQueue(current2, workInProgress2);
          processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
          var nextState = workInProgress2.memoizedState;
          var root2 = workInProgress2.stateNode;
          var nextChildren = nextState.element;
          if (prevState.isDehydrated) {
            var overrideState = {
              element: nextChildren,
              isDehydrated: false,
              cache: nextState.cache,
              pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
              transitions: nextState.transitions
            };
            var updateQueue = workInProgress2.updateQueue;
            updateQueue.baseState = overrideState;
            workInProgress2.memoizedState = overrideState;
            if (workInProgress2.flags & ForceClientRender) {
              var recoverableError = createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), workInProgress2);
              return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);
            } else if (nextChildren !== prevChildren) {
              var _recoverableError = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
              return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);
            } else {
              enterHydrationState(workInProgress2);
              var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
              workInProgress2.child = child;
              var node = child;
              while (node) {
                node.flags = node.flags & ~Placement | Hydrating;
                node = node.sibling;
              }
            }
          } else {
            resetHydrationState();
            if (nextChildren === prevChildren) {
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          }
          return workInProgress2.child;
        }
        function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {
          resetHydrationState();
          queueHydrationError(recoverableError);
          workInProgress2.flags |= ForceClientRender;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateHostComponent(current2, workInProgress2, renderLanes2) {
          pushHostContext(workInProgress2);
          if (current2 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
          }
          var type = workInProgress2.type;
          var nextProps = workInProgress2.pendingProps;
          var prevProps = current2 !== null ? current2.memoizedProps : null;
          var nextChildren = nextProps.children;
          var isDirectTextChild = shouldSetTextContent(type, nextProps);
          if (isDirectTextChild) {
            nextChildren = null;
          } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
            workInProgress2.flags |= ContentReset;
          }
          markRef(current2, workInProgress2);
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateHostText(current2, workInProgress2) {
          if (current2 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
          }
          return null;
        }
        function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
          var props = workInProgress2.pendingProps;
          var lazyComponent = elementType;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;
          var Component = init(payload);
          workInProgress2.type = Component;
          var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component);
          var resolvedProps = resolveDefaultProps(Component, props);
          var child;
          switch (resolvedTag) {
            case FunctionComponent: {
              {
                validateFunctionComponentInDev(workInProgress2, Component);
                workInProgress2.type = Component = resolveFunctionForHotReloading(Component);
              }
              child = updateFunctionComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
              return child;
            }
            case ClassComponent: {
              {
                workInProgress2.type = Component = resolveClassForHotReloading(Component);
              }
              child = updateClassComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
              return child;
            }
            case ForwardRef: {
              {
                workInProgress2.type = Component = resolveForwardRefForHotReloading(Component);
              }
              child = updateForwardRef(null, workInProgress2, Component, resolvedProps, renderLanes2);
              return child;
            }
            case MemoComponent: {
              {
                if (workInProgress2.type !== workInProgress2.elementType) {
                  var outerPropTypes = Component.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(
                      outerPropTypes,
                      resolvedProps,
                      // Resolved for outer only
                      "prop",
                      getComponentNameFromType(Component)
                    );
                  }
                }
              }
              child = updateMemoComponent(
                null,
                workInProgress2,
                Component,
                resolveDefaultProps(Component.type, resolvedProps),
                // The inner type can have defaults too
                renderLanes2
              );
              return child;
            }
          }
          var hint = "";
          {
            if (Component !== null && typeof Component === "object" && Component.$$typeof === REACT_LAZY_TYPE) {
              hint = " Did you wrap a component in React.lazy() more than once?";
            }
          }
          throw new Error("Element type is invalid. Received a promise that resolves to: " + Component + ". " + ("Lazy element type must resolve to a class or function." + hint));
        }
        function mountIncompleteClassComponent(_current, workInProgress2, Component, nextProps, renderLanes2) {
          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
          workInProgress2.tag = ClassComponent;
          var hasContext;
          if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress2);
          } else {
            hasContext = false;
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          constructClassInstance(workInProgress2, Component, nextProps);
          mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
          return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
        }
        function mountIndeterminateComponent(_current, workInProgress2, Component, renderLanes2) {
          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
          var props = workInProgress2.pendingProps;
          var context;
          {
            var unmaskedContext = getUnmaskedContext(workInProgress2, Component, false);
            context = getMaskedContext(workInProgress2, unmaskedContext);
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var value;
          var hasId;
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            if (Component.prototype && typeof Component.prototype.render === "function") {
              var componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutBadClass[componentName]) {
                error2("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
              }
            }
            if (workInProgress2.mode & StrictLegacyMode) {
              ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
            }
            setIsRendering(true);
            ReactCurrentOwner$1.current = workInProgress2;
            value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
            hasId = checkDidRenderIdHook();
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          workInProgress2.flags |= PerformedWork;
          {
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              var _componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName]) {
                error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
              }
            }
          }
          if (
            // Run these checks in production only if the flag is off.
            // Eventually we'll delete this branch altogether.
            typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0
          ) {
            {
              var _componentName2 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
              }
            }
            workInProgress2.tag = ClassComponent;
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            var hasContext = false;
            if (isContextProvider(Component)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;
            initializeUpdateQueue(workInProgress2);
            adoptClassInstance(workInProgress2, value);
            mountClassInstance(workInProgress2, Component, props, renderLanes2);
            return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
          } else {
            workInProgress2.tag = FunctionComponent;
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            reconcileChildren(null, workInProgress2, value, renderLanes2);
            {
              validateFunctionComponentInDev(workInProgress2, Component);
            }
            return workInProgress2.child;
          }
        }
        function validateFunctionComponentInDev(workInProgress2, Component) {
          {
            if (Component) {
              if (Component.childContextTypes) {
                error2("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
              }
            }
            if (workInProgress2.ref !== null) {
              var info = "";
              var ownerName = getCurrentFiberOwnerNameInDevOrNull();
              if (ownerName) {
                info += "\n\nCheck the render method of `" + ownerName + "`.";
              }
              var warningKey = ownerName || "";
              var debugSource = workInProgress2._debugSource;
              if (debugSource) {
                warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
              }
              if (!didWarnAboutFunctionRefs[warningKey]) {
                didWarnAboutFunctionRefs[warningKey] = true;
                error2("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
              }
            }
            if (Component.defaultProps !== void 0) {
              var componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                error2("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", componentName);
                didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
              }
            }
            if (typeof Component.getDerivedStateFromProps === "function") {
              var _componentName3 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error2("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
              }
            }
            if (typeof Component.contextType === "object" && Component.contextType !== null) {
              var _componentName4 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error2("%s: Function components do not support contextType.", _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
              }
            }
          }
        }
        var SUSPENDED_MARKER = {
          dehydrated: null,
          treeContext: null,
          retryLane: NoLane
        };
        function mountSuspenseOffscreenState(renderLanes2) {
          return {
            baseLanes: renderLanes2,
            cachePool: getSuspendedCache(),
            transitions: null
          };
        }
        function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
          var cachePool = null;
          return {
            baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
            cachePool,
            transitions: prevOffscreenState.transitions
          };
        }
        function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
          if (current2 !== null) {
            var suspenseState = current2.memoizedState;
            if (suspenseState === null) {
              return false;
            }
          }
          return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
        }
        function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
          return removeLanes(current2.childLanes, renderLanes2);
        }
        function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          {
            if (shouldSuspend(workInProgress2)) {
              workInProgress2.flags |= DidCapture;
            }
          }
          var suspenseContext = suspenseStackCursor.current;
          var showFallback = false;
          var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
          if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
            showFallback = true;
            workInProgress2.flags &= ~DidCapture;
          } else {
            if (current2 === null || current2.memoizedState !== null) {
              {
                suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
              }
            }
          }
          suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
          pushSuspenseContext(workInProgress2, suspenseContext);
          if (current2 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
            var suspenseState = workInProgress2.memoizedState;
            if (suspenseState !== null) {
              var dehydrated = suspenseState.dehydrated;
              if (dehydrated !== null) {
                return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
              }
            }
            var nextPrimaryChildren = nextProps.children;
            var nextFallbackChildren = nextProps.fallback;
            if (showFallback) {
              var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
              var primaryChildFragment = workInProgress2.child;
              primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackFragment;
            } else {
              return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
            }
          } else {
            var prevState = current2.memoizedState;
            if (prevState !== null) {
              var _dehydrated = prevState.dehydrated;
              if (_dehydrated !== null) {
                return updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);
              }
            }
            if (showFallback) {
              var _nextFallbackChildren = nextProps.fallback;
              var _nextPrimaryChildren = nextProps.children;
              var fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);
              var _primaryChildFragment2 = workInProgress2.child;
              var prevOffscreenState = current2.child.memoizedState;
              _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
              _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackChildFragment;
            } else {
              var _nextPrimaryChildren2 = nextProps.children;
              var _primaryChildFragment3 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren2, renderLanes2);
              workInProgress2.memoizedState = null;
              return _primaryChildFragment3;
            }
          }
        }
        function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var primaryChildProps = {
            mode: "visible",
            children: primaryChildren
          };
          var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
          primaryChildFragment.return = workInProgress2;
          workInProgress2.child = primaryChildFragment;
          return primaryChildFragment;
        }
        function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var progressedPrimaryFragment = workInProgress2.child;
          var primaryChildProps = {
            mode: "hidden",
            children: primaryChildren
          };
          var primaryChildFragment;
          var fallbackChildFragment;
          if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
            primaryChildFragment = progressedPrimaryFragment;
            primaryChildFragment.childLanes = NoLanes;
            primaryChildFragment.pendingProps = primaryChildProps;
            if (workInProgress2.mode & ProfileMode) {
              primaryChildFragment.actualDuration = 0;
              primaryChildFragment.actualStartTime = -1;
              primaryChildFragment.selfBaseDuration = 0;
              primaryChildFragment.treeBaseDuration = 0;
            }
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
          } else {
            primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
          }
          primaryChildFragment.return = workInProgress2;
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          return fallbackChildFragment;
        }
        function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
          return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
        }
        function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {
          return createWorkInProgress(current2, offscreenProps);
        }
        function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
          var currentPrimaryChildFragment = current2.child;
          var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
          var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
            mode: "visible",
            children: primaryChildren
          });
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            primaryChildFragment.lanes = renderLanes2;
          }
          primaryChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = null;
          if (currentFallbackChildFragment !== null) {
            var deletions = workInProgress2.deletions;
            if (deletions === null) {
              workInProgress2.deletions = [currentFallbackChildFragment];
              workInProgress2.flags |= ChildDeletion;
            } else {
              deletions.push(currentFallbackChildFragment);
            }
          }
          workInProgress2.child = primaryChildFragment;
          return primaryChildFragment;
        }
        function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var currentPrimaryChildFragment = current2.child;
          var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
          var primaryChildProps = {
            mode: "hidden",
            children: primaryChildren
          };
          var primaryChildFragment;
          if (
            // In legacy mode, we commit the primary tree as if it successfully
            // completed, even though it's in an inconsistent state.
            (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
            // already cloned. In legacy mode, the only case where this isn't true is
            // when DevTools forces us to display a fallback; we skip the first render
            // pass entirely and go straight to rendering the fallback. (In Concurrent
            // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
            // only codepath.)
            workInProgress2.child !== currentPrimaryChildFragment
          ) {
            var progressedPrimaryFragment = workInProgress2.child;
            primaryChildFragment = progressedPrimaryFragment;
            primaryChildFragment.childLanes = NoLanes;
            primaryChildFragment.pendingProps = primaryChildProps;
            if (workInProgress2.mode & ProfileMode) {
              primaryChildFragment.actualDuration = 0;
              primaryChildFragment.actualStartTime = -1;
              primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
              primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
            }
            workInProgress2.deletions = null;
          } else {
            primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
            primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
          }
          var fallbackChildFragment;
          if (currentFallbackChildFragment !== null) {
            fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
          } else {
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            fallbackChildFragment.flags |= Placement;
          }
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          return fallbackChildFragment;
        }
        function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {
          if (recoverableError !== null) {
            queueHydrationError(recoverableError);
          }
          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          var nextProps = workInProgress2.pendingProps;
          var primaryChildren = nextProps.children;
          var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
          primaryChildFragment.flags |= Placement;
          workInProgress2.memoizedState = null;
          return primaryChildFragment;
        }
        function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var fiberMode = workInProgress2.mode;
          var primaryChildProps = {
            mode: "visible",
            children: primaryChildren
          };
          var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
          var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
          fallbackChildFragment.flags |= Placement;
          primaryChildFragment.return = workInProgress2;
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
            reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          }
          return fallbackChildFragment;
        }
        function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            {
              error2("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.");
            }
            workInProgress2.lanes = laneToLanes(SyncLane);
          } else if (isSuspenseInstanceFallback(suspenseInstance)) {
            workInProgress2.lanes = laneToLanes(DefaultHydrationLane);
          } else {
            workInProgress2.lanes = laneToLanes(OffscreenLane);
          }
          return null;
        }
        function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {
          if (!didSuspend) {
            warnIfHydrating();
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              return retrySuspenseComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2,
                // TODO: When we delete legacy mode, we should make this error argument
                // required  every concurrent mode path that causes hydration to
                // de-opt to client rendering should have an error message.
                null
              );
            }
            if (isSuspenseInstanceFallback(suspenseInstance)) {
              var digest, message, stack;
              {
                var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
                digest = _getSuspenseInstanceF.digest;
                message = _getSuspenseInstanceF.message;
                stack = _getSuspenseInstanceF.stack;
              }
              var error3;
              if (message) {
                error3 = new Error(message);
              } else {
                error3 = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
              }
              var capturedValue = createCapturedValue(error3, digest, stack);
              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, capturedValue);
            }
            var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);
            if (didReceiveUpdate || hasContextChanged2) {
              var root2 = getWorkInProgressRoot();
              if (root2 !== null) {
                var attemptHydrationAtLane = getBumpedLaneForHydration(root2, renderLanes2);
                if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                  suspenseState.retryLane = attemptHydrationAtLane;
                  var eventTime = NoTimestamp;
                  enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane);
                  scheduleUpdateOnFiber(root2, current2, attemptHydrationAtLane, eventTime);
                }
              }
              renderDidSuspendDelayIfPossible();
              var _capturedValue = createCapturedValue(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue);
            } else if (isSuspenseInstancePending(suspenseInstance)) {
              workInProgress2.flags |= DidCapture;
              workInProgress2.child = current2.child;
              var retry = retryDehydratedSuspenseBoundary.bind(null, current2);
              registerSuspenseInstanceRetry(suspenseInstance, retry);
              return null;
            } else {
              reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
              var primaryChildren = nextProps.children;
              var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
              primaryChildFragment.flags |= Hydrating;
              return primaryChildFragment;
            }
          } else {
            if (workInProgress2.flags & ForceClientRender) {
              workInProgress2.flags &= ~ForceClientRender;
              var _capturedValue2 = createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue2);
            } else if (workInProgress2.memoizedState !== null) {
              workInProgress2.child = current2.child;
              workInProgress2.flags |= DidCapture;
              return null;
            } else {
              var nextPrimaryChildren = nextProps.children;
              var nextFallbackChildren = nextProps.fallback;
              var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
              var _primaryChildFragment4 = workInProgress2.child;
              _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackChildFragment;
            }
          }
        }
        function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
          fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
          var alternate = fiber.alternate;
          if (alternate !== null) {
            alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
          }
          scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
        }
        function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
          var node = firstChild;
          while (node !== null) {
            if (node.tag === SuspenseComponent) {
              var state = node.memoizedState;
              if (state !== null) {
                scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
              }
            } else if (node.tag === SuspenseListComponent) {
              scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === workInProgress2) {
              return;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress2) {
                return;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        function findLastContentRow(firstChild) {
          var row = firstChild;
          var lastContentRow = null;
          while (row !== null) {
            var currentRow = row.alternate;
            if (currentRow !== null && findFirstSuspended(currentRow) === null) {
              lastContentRow = row;
            }
            row = row.sibling;
          }
          return lastContentRow;
        }
        function validateRevealOrder(revealOrder) {
          {
            if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
              didWarnAboutRevealOrder[revealOrder] = true;
              if (typeof revealOrder === "string") {
                switch (revealOrder.toLowerCase()) {
                  case "together":
                  case "forwards":
                  case "backwards": {
                    error2('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                    break;
                  }
                  case "forward":
                  case "backward": {
                    error2('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                    break;
                  }
                  default:
                    error2('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                    break;
                }
              } else {
                error2('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
              }
            }
          }
        }
        function validateTailOptions(tailMode, revealOrder) {
          {
            if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
              if (tailMode !== "collapsed" && tailMode !== "hidden") {
                didWarnAboutTailOptions[tailMode] = true;
                error2('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
              } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
                didWarnAboutTailOptions[tailMode] = true;
                error2('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
              }
            }
          }
        }
        function validateSuspenseListNestedChild(childSlot, index2) {
          {
            var isAnArray = isArray(childSlot);
            var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === "function";
            if (isAnArray || isIterable) {
              var type = isAnArray ? "array" : "iterable";
              error2("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index2, type);
              return false;
            }
          }
          return true;
        }
        function validateSuspenseListChildren(children, revealOrder) {
          {
            if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
              if (isArray(children)) {
                for (var i = 0; i < children.length; i++) {
                  if (!validateSuspenseListNestedChild(children[i], i)) {
                    return;
                  }
                }
              } else {
                var iteratorFn = getIteratorFn(children);
                if (typeof iteratorFn === "function") {
                  var childrenIterator = iteratorFn.call(children);
                  if (childrenIterator) {
                    var step = childrenIterator.next();
                    var _i = 0;
                    for (; !step.done; step = childrenIterator.next()) {
                      if (!validateSuspenseListNestedChild(step.value, _i)) {
                        return;
                      }
                      _i++;
                    }
                  }
                } else {
                  error2('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
                }
              }
            }
          }
        }
        function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
          var renderState = workInProgress2.memoizedState;
          if (renderState === null) {
            workInProgress2.memoizedState = {
              isBackwards,
              rendering: null,
              renderingStartTime: 0,
              last: lastContentRow,
              tail,
              tailMode
            };
          } else {
            renderState.isBackwards = isBackwards;
            renderState.rendering = null;
            renderState.renderingStartTime = 0;
            renderState.last = lastContentRow;
            renderState.tail = tail;
            renderState.tailMode = tailMode;
          }
        }
        function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          var revealOrder = nextProps.revealOrder;
          var tailMode = nextProps.tail;
          var newChildren = nextProps.children;
          validateRevealOrder(revealOrder);
          validateTailOptions(tailMode, revealOrder);
          validateSuspenseListChildren(newChildren, revealOrder);
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          var suspenseContext = suspenseStackCursor.current;
          var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
          if (shouldForceFallback) {
            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
            workInProgress2.flags |= DidCapture;
          } else {
            var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
            if (didSuspendBefore) {
              propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
            }
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
          }
          pushSuspenseContext(workInProgress2, suspenseContext);
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            workInProgress2.memoizedState = null;
          } else {
            switch (revealOrder) {
              case "forwards": {
                var lastContentRow = findLastContentRow(workInProgress2.child);
                var tail;
                if (lastContentRow === null) {
                  tail = workInProgress2.child;
                  workInProgress2.child = null;
                } else {
                  tail = lastContentRow.sibling;
                  lastContentRow.sibling = null;
                }
                initSuspenseListRenderState(
                  workInProgress2,
                  false,
                  // isBackwards
                  tail,
                  lastContentRow,
                  tailMode
                );
                break;
              }
              case "backwards": {
                var _tail = null;
                var row = workInProgress2.child;
                workInProgress2.child = null;
                while (row !== null) {
                  var currentRow = row.alternate;
                  if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                    workInProgress2.child = row;
                    break;
                  }
                  var nextRow = row.sibling;
                  row.sibling = _tail;
                  _tail = row;
                  row = nextRow;
                }
                initSuspenseListRenderState(
                  workInProgress2,
                  true,
                  // isBackwards
                  _tail,
                  null,
                  // last
                  tailMode
                );
                break;
              }
              case "together": {
                initSuspenseListRenderState(
                  workInProgress2,
                  false,
                  // isBackwards
                  null,
                  // tail
                  null,
                  // last
                  void 0
                );
                break;
              }
              default: {
                workInProgress2.memoizedState = null;
              }
            }
          }
          return workInProgress2.child;
        }
        function updatePortalComponent(current2, workInProgress2, renderLanes2) {
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          var nextChildren = workInProgress2.pendingProps;
          if (current2 === null) {
            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          } else {
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          }
          return workInProgress2.child;
        }
        var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
        function updateContextProvider(current2, workInProgress2, renderLanes2) {
          var providerType = workInProgress2.type;
          var context = providerType._context;
          var newProps = workInProgress2.pendingProps;
          var oldProps = workInProgress2.memoizedProps;
          var newValue = newProps.value;
          {
            if (!("value" in newProps)) {
              if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                error2("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
              }
            }
            var providerPropTypes = workInProgress2.type.propTypes;
            if (providerPropTypes) {
              checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
            }
          }
          pushProvider(workInProgress2, context, newValue);
          {
            if (oldProps !== null) {
              var oldValue = oldProps.value;
              if (objectIs(oldValue, newValue)) {
                if (oldProps.children === newProps.children && !hasContextChanged()) {
                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                }
              } else {
                propagateContextChange(workInProgress2, context, renderLanes2);
              }
            }
          }
          var newChildren = newProps.children;
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          return workInProgress2.child;
        }
        var hasWarnedAboutUsingContextAsConsumer = false;
        function updateContextConsumer(current2, workInProgress2, renderLanes2) {
          var context = workInProgress2.type;
          {
            if (context._context === void 0) {
              if (context !== context.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                  hasWarnedAboutUsingContextAsConsumer = true;
                  error2("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
              }
            } else {
              context = context._context;
            }
          }
          var newProps = workInProgress2.pendingProps;
          var render2 = newProps.children;
          {
            if (typeof render2 !== "function") {
              error2("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
            }
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var newValue = readContext(context);
          {
            markComponentRenderStarted(workInProgress2);
          }
          var newChildren;
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            newChildren = render2(newValue);
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          return workInProgress2.child;
        }
        function markWorkInProgressReceivedUpdate() {
          didReceiveUpdate = true;
        }
        function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            if (current2 !== null) {
              current2.alternate = null;
              workInProgress2.alternate = null;
              workInProgress2.flags |= Placement;
            }
          }
        }
        function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
          if (current2 !== null) {
            workInProgress2.dependencies = current2.dependencies;
          }
          {
            stopProfilerTimerIfRunning();
          }
          markSkippedUpdateLanes(workInProgress2.lanes);
          if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
            {
              return null;
            }
          }
          cloneChildFibers(current2, workInProgress2);
          return workInProgress2.child;
        }
        function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
          {
            var returnFiber = oldWorkInProgress.return;
            if (returnFiber === null) {
              throw new Error("Cannot swap the root fiber.");
            }
            current2.alternate = null;
            oldWorkInProgress.alternate = null;
            newWorkInProgress.index = oldWorkInProgress.index;
            newWorkInProgress.sibling = oldWorkInProgress.sibling;
            newWorkInProgress.return = oldWorkInProgress.return;
            newWorkInProgress.ref = oldWorkInProgress.ref;
            if (oldWorkInProgress === returnFiber.child) {
              returnFiber.child = newWorkInProgress;
            } else {
              var prevSibling = returnFiber.child;
              if (prevSibling === null) {
                throw new Error("Expected parent to have a child.");
              }
              while (prevSibling.sibling !== oldWorkInProgress) {
                prevSibling = prevSibling.sibling;
                if (prevSibling === null) {
                  throw new Error("Expected to find the previous sibling.");
                }
              }
              prevSibling.sibling = newWorkInProgress;
            }
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [current2];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(current2);
            }
            newWorkInProgress.flags |= Placement;
            return newWorkInProgress;
          }
        }
        function checkScheduledUpdateOrContext(current2, renderLanes2) {
          var updateLanes = current2.lanes;
          if (includesSomeLane(updateLanes, renderLanes2)) {
            return true;
          }
          return false;
        }
        function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
          switch (workInProgress2.tag) {
            case HostRoot:
              pushHostRootContext(workInProgress2);
              var root2 = workInProgress2.stateNode;
              resetHydrationState();
              break;
            case HostComponent:
              pushHostContext(workInProgress2);
              break;
            case ClassComponent: {
              var Component = workInProgress2.type;
              if (isContextProvider(Component)) {
                pushContextProvider(workInProgress2);
              }
              break;
            }
            case HostPortal:
              pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
              break;
            case ContextProvider: {
              var newValue = workInProgress2.memoizedProps.value;
              var context = workInProgress2.type._context;
              pushProvider(workInProgress2, context, newValue);
              break;
            }
            case Profiler:
              {
                var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                if (hasChildWork) {
                  workInProgress2.flags |= Update;
                }
                {
                  var stateNode = workInProgress2.stateNode;
                  stateNode.effectDuration = 0;
                  stateNode.passiveEffectDuration = 0;
                }
              }
              break;
            case SuspenseComponent: {
              var state = workInProgress2.memoizedState;
              if (state !== null) {
                if (state.dehydrated !== null) {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                  workInProgress2.flags |= DidCapture;
                  return null;
                }
                var primaryChildFragment = workInProgress2.child;
                var primaryChildLanes = primaryChildFragment.childLanes;
                if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                  return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
                } else {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                  var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                  if (child !== null) {
                    return child.sibling;
                  } else {
                    return null;
                  }
                }
              } else {
                pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
              }
              break;
            }
            case SuspenseListComponent: {
              var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
              var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
              if (didSuspendBefore) {
                if (_hasChildWork) {
                  return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
                }
                workInProgress2.flags |= DidCapture;
              }
              var renderState = workInProgress2.memoizedState;
              if (renderState !== null) {
                renderState.rendering = null;
                renderState.tail = null;
                renderState.lastEffect = null;
              }
              pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
              if (_hasChildWork) {
                break;
              } else {
                return null;
              }
            }
            case OffscreenComponent:
            case LegacyHiddenComponent: {
              workInProgress2.lanes = NoLanes;
              return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
            }
          }
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        function beginWork(current2, workInProgress2, renderLanes2) {
          {
            if (workInProgress2._debugNeedsRemount && current2 !== null) {
              return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
            }
          }
          if (current2 !== null) {
            var oldProps = current2.memoizedProps;
            var newProps = workInProgress2.pendingProps;
            if (oldProps !== newProps || hasContextChanged() || // Force a re-render if the implementation changed due to hot reload:
            workInProgress2.type !== current2.type) {
              didReceiveUpdate = true;
            } else {
              var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
              if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there
              // may not be work scheduled on `current`, so we check for this flag.
              (workInProgress2.flags & DidCapture) === NoFlags) {
                didReceiveUpdate = false;
                return attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
              }
              if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                didReceiveUpdate = true;
              } else {
                didReceiveUpdate = false;
              }
            }
          } else {
            didReceiveUpdate = false;
            if (getIsHydrating() && isForkedChild(workInProgress2)) {
              var slotIndex = workInProgress2.index;
              var numberOfForks = getForksAtLevel();
              pushTreeId(workInProgress2, numberOfForks, slotIndex);
            }
          }
          workInProgress2.lanes = NoLanes;
          switch (workInProgress2.tag) {
            case IndeterminateComponent: {
              return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
            }
            case LazyComponent: {
              var elementType = workInProgress2.elementType;
              return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2);
            }
            case FunctionComponent: {
              var Component = workInProgress2.type;
              var unresolvedProps = workInProgress2.pendingProps;
              var resolvedProps = workInProgress2.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);
              return updateFunctionComponent(current2, workInProgress2, Component, resolvedProps, renderLanes2);
            }
            case ClassComponent: {
              var _Component = workInProgress2.type;
              var _unresolvedProps = workInProgress2.pendingProps;
              var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
              return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);
            }
            case HostRoot:
              return updateHostRoot(current2, workInProgress2, renderLanes2);
            case HostComponent:
              return updateHostComponent(current2, workInProgress2, renderLanes2);
            case HostText:
              return updateHostText(current2, workInProgress2);
            case SuspenseComponent:
              return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
            case HostPortal:
              return updatePortalComponent(current2, workInProgress2, renderLanes2);
            case ForwardRef: {
              var type = workInProgress2.type;
              var _unresolvedProps2 = workInProgress2.pendingProps;
              var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
              return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);
            }
            case Fragment:
              return updateFragment(current2, workInProgress2, renderLanes2);
            case Mode:
              return updateMode(current2, workInProgress2, renderLanes2);
            case Profiler:
              return updateProfiler(current2, workInProgress2, renderLanes2);
            case ContextProvider:
              return updateContextProvider(current2, workInProgress2, renderLanes2);
            case ContextConsumer:
              return updateContextConsumer(current2, workInProgress2, renderLanes2);
            case MemoComponent: {
              var _type2 = workInProgress2.type;
              var _unresolvedProps3 = workInProgress2.pendingProps;
              var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
              {
                if (workInProgress2.type !== workInProgress2.elementType) {
                  var outerPropTypes = _type2.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(
                      outerPropTypes,
                      _resolvedProps3,
                      // Resolved for outer only
                      "prop",
                      getComponentNameFromType(_type2)
                    );
                  }
                }
              }
              _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
              return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);
            }
            case SimpleMemoComponent: {
              return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
            }
            case IncompleteClassComponent: {
              var _Component2 = workInProgress2.type;
              var _unresolvedProps4 = workInProgress2.pendingProps;
              var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
              return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
            }
            case SuspenseListComponent: {
              return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
            }
            case ScopeComponent: {
              break;
            }
            case OffscreenComponent: {
              return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
            }
          }
          throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
        }
        function markUpdate(workInProgress2) {
          workInProgress2.flags |= Update;
        }
        function markRef$1(workInProgress2) {
          workInProgress2.flags |= Ref;
          {
            workInProgress2.flags |= RefStatic;
          }
        }
        var appendAllChildren;
        var updateHostContainer;
        var updateHostComponent$1;
        var updateHostText$1;
        {
          appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
            var node = workInProgress2.child;
            while (node !== null) {
              if (node.tag === HostComponent || node.tag === HostText) {
                appendInitialChild(parent, node.stateNode);
              } else if (node.tag === HostPortal)
                ;
              else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === workInProgress2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === workInProgress2) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          };
          updateHostContainer = function(current2, workInProgress2) {
          };
          updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
            var oldProps = current2.memoizedProps;
            if (oldProps === newProps) {
              return;
            }
            var instance = workInProgress2.stateNode;
            var currentHostContext = getHostContext();
            var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
            workInProgress2.updateQueue = updatePayload;
            if (updatePayload) {
              markUpdate(workInProgress2);
            }
          };
          updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
            if (oldText !== newText) {
              markUpdate(workInProgress2);
            }
          };
        }
        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
          if (getIsHydrating()) {
            return;
          }
          switch (renderState.tailMode) {
            case "hidden": {
              var tailNode = renderState.tail;
              var lastTailNode = null;
              while (tailNode !== null) {
                if (tailNode.alternate !== null) {
                  lastTailNode = tailNode;
                }
                tailNode = tailNode.sibling;
              }
              if (lastTailNode === null) {
                renderState.tail = null;
              } else {
                lastTailNode.sibling = null;
              }
              break;
            }
            case "collapsed": {
              var _tailNode = renderState.tail;
              var _lastTailNode = null;
              while (_tailNode !== null) {
                if (_tailNode.alternate !== null) {
                  _lastTailNode = _tailNode;
                }
                _tailNode = _tailNode.sibling;
              }
              if (_lastTailNode === null) {
                if (!hasRenderedATailFallback && renderState.tail !== null) {
                  renderState.tail.sibling = null;
                } else {
                  renderState.tail = null;
                }
              } else {
                _lastTailNode.sibling = null;
              }
              break;
            }
          }
        }
        function bubbleProperties(completedWork) {
          var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
          var newChildLanes = NoLanes;
          var subtreeFlags = NoFlags;
          if (!didBailout) {
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              var actualDuration = completedWork.actualDuration;
              var treeBaseDuration = completedWork.selfBaseDuration;
              var child = completedWork.child;
              while (child !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                subtreeFlags |= child.subtreeFlags;
                subtreeFlags |= child.flags;
                actualDuration += child.actualDuration;
                treeBaseDuration += child.treeBaseDuration;
                child = child.sibling;
              }
              completedWork.actualDuration = actualDuration;
              completedWork.treeBaseDuration = treeBaseDuration;
            } else {
              var _child = completedWork.child;
              while (_child !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                subtreeFlags |= _child.subtreeFlags;
                subtreeFlags |= _child.flags;
                _child.return = completedWork;
                _child = _child.sibling;
              }
            }
            completedWork.subtreeFlags |= subtreeFlags;
          } else {
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              var _treeBaseDuration = completedWork.selfBaseDuration;
              var _child2 = completedWork.child;
              while (_child2 !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));
                subtreeFlags |= _child2.subtreeFlags & StaticMask;
                subtreeFlags |= _child2.flags & StaticMask;
                _treeBaseDuration += _child2.treeBaseDuration;
                _child2 = _child2.sibling;
              }
              completedWork.treeBaseDuration = _treeBaseDuration;
            } else {
              var _child3 = completedWork.child;
              while (_child3 !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));
                subtreeFlags |= _child3.subtreeFlags & StaticMask;
                subtreeFlags |= _child3.flags & StaticMask;
                _child3.return = completedWork;
                _child3 = _child3.sibling;
              }
            }
            completedWork.subtreeFlags |= subtreeFlags;
          }
          completedWork.childLanes = newChildLanes;
          return didBailout;
        }
        function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {
          if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {
            warnIfUnhydratedTailNodes(workInProgress2);
            resetHydrationState();
            workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;
            return false;
          }
          var wasHydrated = popHydrationState(workInProgress2);
          if (nextState !== null && nextState.dehydrated !== null) {
            if (current2 === null) {
              if (!wasHydrated) {
                throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
              }
              prepareToHydrateHostSuspenseInstance(workInProgress2);
              bubbleProperties(workInProgress2);
              {
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  var isTimedOutSuspense = nextState !== null;
                  if (isTimedOutSuspense) {
                    var primaryChildFragment = workInProgress2.child;
                    if (primaryChildFragment !== null) {
                      workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                    }
                  }
                }
              }
              return false;
            } else {
              resetHydrationState();
              if ((workInProgress2.flags & DidCapture) === NoFlags) {
                workInProgress2.memoizedState = null;
              }
              workInProgress2.flags |= Update;
              bubbleProperties(workInProgress2);
              {
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  var _isTimedOutSuspense = nextState !== null;
                  if (_isTimedOutSuspense) {
                    var _primaryChildFragment = workInProgress2.child;
                    if (_primaryChildFragment !== null) {
                      workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                    }
                  }
                }
              }
              return false;
            }
          } else {
            upgradeHydrationErrorsToRecoverable();
            return true;
          }
        }
        function completeWork(current2, workInProgress2, renderLanes2) {
          var newProps = workInProgress2.pendingProps;
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case IndeterminateComponent:
            case LazyComponent:
            case SimpleMemoComponent:
            case FunctionComponent:
            case ForwardRef:
            case Fragment:
            case Mode:
            case Profiler:
            case ContextConsumer:
            case MemoComponent:
              bubbleProperties(workInProgress2);
              return null;
            case ClassComponent: {
              var Component = workInProgress2.type;
              if (isContextProvider(Component)) {
                popContext(workInProgress2);
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case HostRoot: {
              var fiberRoot = workInProgress2.stateNode;
              popHostContainer(workInProgress2);
              popTopLevelContextObject(workInProgress2);
              resetWorkInProgressVersions();
              if (fiberRoot.pendingContext) {
                fiberRoot.context = fiberRoot.pendingContext;
                fiberRoot.pendingContext = null;
              }
              if (current2 === null || current2.child === null) {
                var wasHydrated = popHydrationState(workInProgress2);
                if (wasHydrated) {
                  markUpdate(workInProgress2);
                } else {
                  if (current2 !== null) {
                    var prevState = current2.memoizedState;
                    if (
                      // Check if this is a client root
                      !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
                      (workInProgress2.flags & ForceClientRender) !== NoFlags
                    ) {
                      workInProgress2.flags |= Snapshot;
                      upgradeHydrationErrorsToRecoverable();
                    }
                  }
                }
              }
              updateHostContainer(current2, workInProgress2);
              bubbleProperties(workInProgress2);
              return null;
            }
            case HostComponent: {
              popHostContext(workInProgress2);
              var rootContainerInstance = getRootHostContainer();
              var type = workInProgress2.type;
              if (current2 !== null && workInProgress2.stateNode != null) {
                updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance);
                if (current2.ref !== workInProgress2.ref) {
                  markRef$1(workInProgress2);
                }
              } else {
                if (!newProps) {
                  if (workInProgress2.stateNode === null) {
                    throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                  }
                  bubbleProperties(workInProgress2);
                  return null;
                }
                var currentHostContext = getHostContext();
                var _wasHydrated = popHydrationState(workInProgress2);
                if (_wasHydrated) {
                  if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                    markUpdate(workInProgress2);
                  }
                } else {
                  var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                  appendAllChildren(instance, workInProgress2, false, false);
                  workInProgress2.stateNode = instance;
                  if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
                    markUpdate(workInProgress2);
                  }
                }
                if (workInProgress2.ref !== null) {
                  markRef$1(workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case HostText: {
              var newText = newProps;
              if (current2 && workInProgress2.stateNode != null) {
                var oldText = current2.memoizedProps;
                updateHostText$1(current2, workInProgress2, oldText, newText);
              } else {
                if (typeof newText !== "string") {
                  if (workInProgress2.stateNode === null) {
                    throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                  }
                }
                var _rootContainerInstance = getRootHostContainer();
                var _currentHostContext = getHostContext();
                var _wasHydrated2 = popHydrationState(workInProgress2);
                if (_wasHydrated2) {
                  if (prepareToHydrateHostTextInstance(workInProgress2)) {
                    markUpdate(workInProgress2);
                  }
                } else {
                  workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case SuspenseComponent: {
              popSuspenseContext(workInProgress2);
              var nextState = workInProgress2.memoizedState;
              if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
                var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState);
                if (!fallthroughToNormalSuspensePath) {
                  if (workInProgress2.flags & ShouldCapture) {
                    return workInProgress2;
                  } else {
                    return null;
                  }
                }
              }
              if ((workInProgress2.flags & DidCapture) !== NoFlags) {
                workInProgress2.lanes = renderLanes2;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              var nextDidTimeout = nextState !== null;
              var prevDidTimeout = current2 !== null && current2.memoizedState !== null;
              if (nextDidTimeout !== prevDidTimeout) {
                if (nextDidTimeout) {
                  var _offscreenFiber2 = workInProgress2.child;
                  _offscreenFiber2.flags |= Visibility;
                  if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
                    var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);
                    if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                      renderDidSuspend();
                    } else {
                      renderDidSuspendDelayIfPossible();
                    }
                  }
                }
              }
              var wakeables = workInProgress2.updateQueue;
              if (wakeables !== null) {
                workInProgress2.flags |= Update;
              }
              bubbleProperties(workInProgress2);
              {
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  if (nextDidTimeout) {
                    var primaryChildFragment = workInProgress2.child;
                    if (primaryChildFragment !== null) {
                      workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                    }
                  }
                }
              }
              return null;
            }
            case HostPortal:
              popHostContainer(workInProgress2);
              updateHostContainer(current2, workInProgress2);
              if (current2 === null) {
                preparePortalMount(workInProgress2.stateNode.containerInfo);
              }
              bubbleProperties(workInProgress2);
              return null;
            case ContextProvider:
              var context = workInProgress2.type._context;
              popProvider(context, workInProgress2);
              bubbleProperties(workInProgress2);
              return null;
            case IncompleteClassComponent: {
              var _Component = workInProgress2.type;
              if (isContextProvider(_Component)) {
                popContext(workInProgress2);
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case SuspenseListComponent: {
              popSuspenseContext(workInProgress2);
              var renderState = workInProgress2.memoizedState;
              if (renderState === null) {
                bubbleProperties(workInProgress2);
                return null;
              }
              var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
              var renderedTail = renderState.rendering;
              if (renderedTail === null) {
                if (!didSuspendAlready) {
                  var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                  if (!cannotBeSuspended) {
                    var row = workInProgress2.child;
                    while (row !== null) {
                      var suspended = findFirstSuspended(row);
                      if (suspended !== null) {
                        didSuspendAlready = true;
                        workInProgress2.flags |= DidCapture;
                        cutOffTailIfNeeded(renderState, false);
                        var newThenables = suspended.updateQueue;
                        if (newThenables !== null) {
                          workInProgress2.updateQueue = newThenables;
                          workInProgress2.flags |= Update;
                        }
                        workInProgress2.subtreeFlags = NoFlags;
                        resetChildFibers(workInProgress2, renderLanes2);
                        pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                        return workInProgress2.child;
                      }
                      row = row.sibling;
                    }
                  }
                  if (renderState.tail !== null && now() > getRenderTargetTime()) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    cutOffTailIfNeeded(renderState, false);
                    workInProgress2.lanes = SomeRetryLane;
                  }
                } else {
                  cutOffTailIfNeeded(renderState, false);
                }
              } else {
                if (!didSuspendAlready) {
                  var _suspended = findFirstSuspended(renderedTail);
                  if (_suspended !== null) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    var _newThenables = _suspended.updateQueue;
                    if (_newThenables !== null) {
                      workInProgress2.updateQueue = _newThenables;
                      workInProgress2.flags |= Update;
                    }
                    cutOffTailIfNeeded(renderState, true);
                    if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                      bubbleProperties(workInProgress2);
                      return null;
                    }
                  } else if (
                    // The time it took to render last row is greater than the remaining
                    // time we have to render. So rendering one more row would likely
                    // exceed it.
                    now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane
                  ) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    cutOffTailIfNeeded(renderState, false);
                    workInProgress2.lanes = SomeRetryLane;
                  }
                }
                if (renderState.isBackwards) {
                  renderedTail.sibling = workInProgress2.child;
                  workInProgress2.child = renderedTail;
                } else {
                  var previousSibling = renderState.last;
                  if (previousSibling !== null) {
                    previousSibling.sibling = renderedTail;
                  } else {
                    workInProgress2.child = renderedTail;
                  }
                  renderState.last = renderedTail;
                }
              }
              if (renderState.tail !== null) {
                var next = renderState.tail;
                renderState.rendering = next;
                renderState.tail = next.sibling;
                renderState.renderingStartTime = now();
                next.sibling = null;
                var suspenseContext = suspenseStackCursor.current;
                if (didSuspendAlready) {
                  suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                } else {
                  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                }
                pushSuspenseContext(workInProgress2, suspenseContext);
                return next;
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case ScopeComponent: {
              break;
            }
            case OffscreenComponent:
            case LegacyHiddenComponent: {
              popRenderLanes(workInProgress2);
              var _nextState = workInProgress2.memoizedState;
              var nextIsHidden = _nextState !== null;
              if (current2 !== null) {
                var _prevState = current2.memoizedState;
                var prevIsHidden = _prevState !== null;
                if (prevIsHidden !== nextIsHidden && // LegacyHidden doesn't do any hiding  it only pre-renders.
                !enableLegacyHidden) {
                  workInProgress2.flags |= Visibility;
                }
              }
              if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {
                bubbleProperties(workInProgress2);
              } else {
                if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                  bubbleProperties(workInProgress2);
                  {
                    if (workInProgress2.subtreeFlags & (Placement | Update)) {
                      workInProgress2.flags |= Visibility;
                    }
                  }
                }
              }
              return null;
            }
            case CacheComponent: {
              return null;
            }
            case TracingMarkerComponent: {
              return null;
            }
          }
          throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
        }
        function unwindWork(current2, workInProgress2, renderLanes2) {
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case ClassComponent: {
              var Component = workInProgress2.type;
              if (isContextProvider(Component)) {
                popContext(workInProgress2);
              }
              var flags = workInProgress2.flags;
              if (flags & ShouldCapture) {
                workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              return null;
            }
            case HostRoot: {
              var root2 = workInProgress2.stateNode;
              popHostContainer(workInProgress2);
              popTopLevelContextObject(workInProgress2);
              resetWorkInProgressVersions();
              var _flags = workInProgress2.flags;
              if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
                workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
                return workInProgress2;
              }
              return null;
            }
            case HostComponent: {
              popHostContext(workInProgress2);
              return null;
            }
            case SuspenseComponent: {
              popSuspenseContext(workInProgress2);
              var suspenseState = workInProgress2.memoizedState;
              if (suspenseState !== null && suspenseState.dehydrated !== null) {
                if (workInProgress2.alternate === null) {
                  throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
                }
                resetHydrationState();
              }
              var _flags2 = workInProgress2.flags;
              if (_flags2 & ShouldCapture) {
                workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              return null;
            }
            case SuspenseListComponent: {
              popSuspenseContext(workInProgress2);
              return null;
            }
            case HostPortal:
              popHostContainer(workInProgress2);
              return null;
            case ContextProvider:
              var context = workInProgress2.type._context;
              popProvider(context, workInProgress2);
              return null;
            case OffscreenComponent:
            case LegacyHiddenComponent:
              popRenderLanes(workInProgress2);
              return null;
            case CacheComponent:
              return null;
            default:
              return null;
          }
        }
        function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {
          popTreeContext(interruptedWork);
          switch (interruptedWork.tag) {
            case ClassComponent: {
              var childContextTypes = interruptedWork.type.childContextTypes;
              if (childContextTypes !== null && childContextTypes !== void 0) {
                popContext(interruptedWork);
              }
              break;
            }
            case HostRoot: {
              var root2 = interruptedWork.stateNode;
              popHostContainer(interruptedWork);
              popTopLevelContextObject(interruptedWork);
              resetWorkInProgressVersions();
              break;
            }
            case HostComponent: {
              popHostContext(interruptedWork);
              break;
            }
            case HostPortal:
              popHostContainer(interruptedWork);
              break;
            case SuspenseComponent:
              popSuspenseContext(interruptedWork);
              break;
            case SuspenseListComponent:
              popSuspenseContext(interruptedWork);
              break;
            case ContextProvider:
              var context = interruptedWork.type._context;
              popProvider(context, interruptedWork);
              break;
            case OffscreenComponent:
            case LegacyHiddenComponent:
              popRenderLanes(interruptedWork);
              break;
          }
        }
        var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
        {
          didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
        }
        var offscreenSubtreeIsHidden = false;
        var offscreenSubtreeWasHidden = false;
        var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
        var nextEffect = null;
        var inProgressLanes = null;
        var inProgressRoot = null;
        function reportUncaughtErrorInDEV(error3) {
          {
            invokeGuardedCallback(null, function() {
              throw error3;
            });
            clearCaughtError();
          }
        }
        var callComponentWillUnmountWithTimer = function(current2, instance) {
          instance.props = current2.memoizedProps;
          instance.state = current2.memoizedState;
          if (current2.mode & ProfileMode) {
            try {
              startLayoutEffectTimer();
              instance.componentWillUnmount();
            } finally {
              recordLayoutEffectDuration(current2);
            }
          } else {
            instance.componentWillUnmount();
          }
        };
        function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {
          try {
            commitHookEffectListMount(Layout, current2);
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
          try {
            callComponentWillUnmountWithTimer(current2, instance);
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance) {
          try {
            instance.componentDidMount();
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        function safelyAttachRef(current2, nearestMountedAncestor) {
          try {
            commitAttachRef(current2);
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        function safelyDetachRef(current2, nearestMountedAncestor) {
          var ref = current2.ref;
          if (ref !== null) {
            if (typeof ref === "function") {
              var retVal;
              try {
                if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    retVal = ref(null);
                  } finally {
                    recordLayoutEffectDuration(current2);
                  }
                } else {
                  retVal = ref(null);
                }
              } catch (error3) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error3);
              }
              {
                if (typeof retVal === "function") {
                  error2("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(current2));
                }
              }
            } else {
              ref.current = null;
            }
          }
        }
        function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {
          try {
            destroy();
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        var focusedInstanceHandle = null;
        var shouldFireAfterActiveInstanceBlur = false;
        function commitBeforeMutationEffects(root2, firstChild) {
          focusedInstanceHandle = prepareForCommit(root2.containerInfo);
          nextEffect = firstChild;
          commitBeforeMutationEffects_begin();
          var shouldFire = shouldFireAfterActiveInstanceBlur;
          shouldFireAfterActiveInstanceBlur = false;
          focusedInstanceHandle = null;
          return shouldFire;
        }
        function commitBeforeMutationEffects_begin() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var child = fiber.child;
            if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
              child.return = fiber;
              nextEffect = child;
            } else {
              commitBeforeMutationEffects_complete();
            }
          }
        }
        function commitBeforeMutationEffects_complete() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            setCurrentFiber(fiber);
            try {
              commitBeforeMutationEffectsOnFiber(fiber);
            } catch (error3) {
              captureCommitPhaseError(fiber, fiber.return, error3);
            }
            resetCurrentFiber();
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitBeforeMutationEffectsOnFiber(finishedWork) {
          var current2 = finishedWork.alternate;
          var flags = finishedWork.flags;
          if ((flags & Snapshot) !== NoFlags) {
            setCurrentFiber(finishedWork);
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                break;
              }
              case ClassComponent: {
                if (current2 !== null) {
                  var prevProps = current2.memoizedProps;
                  var prevState = current2.memoizedState;
                  var instance = finishedWork.stateNode;
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      if (instance.props !== finishedWork.memoizedProps) {
                        error2("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                      if (instance.state !== finishedWork.memoizedState) {
                        error2("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                    }
                  }
                  var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                  {
                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                    if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
                      didWarnSet.add(finishedWork.type);
                      error2("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
                    }
                  }
                  instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                }
                break;
              }
              case HostRoot: {
                {
                  var root2 = finishedWork.stateNode;
                  clearContainer(root2.containerInfo);
                }
                break;
              }
              case HostComponent:
              case HostText:
              case HostPortal:
              case IncompleteClassComponent:
                break;
              default: {
                throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            resetCurrentFiber();
          }
        }
        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
          var updateQueue = finishedWork.updateQueue;
          var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
              if ((effect.tag & flags) === flags) {
                var destroy = effect.destroy;
                effect.destroy = void 0;
                if (destroy !== void 0) {
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectUnmountStarted(finishedWork);
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectUnmountStarted(finishedWork);
                    }
                  }
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(true);
                    }
                  }
                  safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(false);
                    }
                  }
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectUnmountStopped();
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectUnmountStopped();
                    }
                  }
                }
              }
              effect = effect.next;
            } while (effect !== firstEffect);
          }
        }
        function commitHookEffectListMount(flags, finishedWork) {
          var updateQueue = finishedWork.updateQueue;
          var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
              if ((effect.tag & flags) === flags) {
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectMountStarted(finishedWork);
                  } else if ((flags & Layout) !== NoFlags$1) {
                    markComponentLayoutEffectMountStarted(finishedWork);
                  }
                }
                var create = effect.create;
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(true);
                  }
                }
                effect.destroy = create();
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(false);
                  }
                }
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectMountStopped();
                  } else if ((flags & Layout) !== NoFlags$1) {
                    markComponentLayoutEffectMountStopped();
                  }
                }
                {
                  var destroy = effect.destroy;
                  if (destroy !== void 0 && typeof destroy !== "function") {
                    var hookName = void 0;
                    if ((effect.tag & Layout) !== NoFlags) {
                      hookName = "useLayoutEffect";
                    } else if ((effect.tag & Insertion) !== NoFlags) {
                      hookName = "useInsertionEffect";
                    } else {
                      hookName = "useEffect";
                    }
                    var addendum = void 0;
                    if (destroy === null) {
                      addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                    } else if (typeof destroy.then === "function") {
                      addendum = "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                    } else {
                      addendum = " You returned: " + destroy;
                    }
                    error2("%s must not return anything besides a function, which is used for clean-up.%s", hookName, addendum);
                  }
                }
              }
              effect = effect.next;
            } while (effect !== firstEffect);
          }
        }
        function commitPassiveEffectDurations(finishedRoot, finishedWork) {
          {
            if ((finishedWork.flags & Update) !== NoFlags) {
              switch (finishedWork.tag) {
                case Profiler: {
                  var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                  var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;
                  var commitTime2 = getCommitTime();
                  var phase = finishedWork.alternate === null ? "mount" : "update";
                  {
                    if (isCurrentUpdateNested()) {
                      phase = "nested-update";
                    }
                  }
                  if (typeof onPostCommit === "function") {
                    onPostCommit(id, phase, passiveEffectDuration, commitTime2);
                  }
                  var parentFiber = finishedWork.return;
                  outer:
                    while (parentFiber !== null) {
                      switch (parentFiber.tag) {
                        case HostRoot:
                          var root2 = parentFiber.stateNode;
                          root2.passiveEffectDuration += passiveEffectDuration;
                          break outer;
                        case Profiler:
                          var parentStateNode = parentFiber.stateNode;
                          parentStateNode.passiveEffectDuration += passiveEffectDuration;
                          break outer;
                      }
                      parentFiber = parentFiber.return;
                    }
                  break;
                }
              }
            }
          }
        }
        function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {
          if ((finishedWork.flags & LayoutMask) !== NoFlags) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (!offscreenSubtreeWasHidden) {
                  if (finishedWork.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListMount(Layout | HasEffect, finishedWork);
                    } finally {
                      recordLayoutEffectDuration(finishedWork);
                    }
                  } else {
                    commitHookEffectListMount(Layout | HasEffect, finishedWork);
                  }
                }
                break;
              }
              case ClassComponent: {
                var instance = finishedWork.stateNode;
                if (finishedWork.flags & Update) {
                  if (!offscreenSubtreeWasHidden) {
                    if (current2 === null) {
                      {
                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                          if (instance.props !== finishedWork.memoizedProps) {
                            error2("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                          if (instance.state !== finishedWork.memoizedState) {
                            error2("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                        }
                      }
                      if (finishedWork.mode & ProfileMode) {
                        try {
                          startLayoutEffectTimer();
                          instance.componentDidMount();
                        } finally {
                          recordLayoutEffectDuration(finishedWork);
                        }
                      } else {
                        instance.componentDidMount();
                      }
                    } else {
                      var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                      var prevState = current2.memoizedState;
                      {
                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                          if (instance.props !== finishedWork.memoizedProps) {
                            error2("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                          if (instance.state !== finishedWork.memoizedState) {
                            error2("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                        }
                      }
                      if (finishedWork.mode & ProfileMode) {
                        try {
                          startLayoutEffectTimer();
                          instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                        } finally {
                          recordLayoutEffectDuration(finishedWork);
                        }
                      } else {
                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                      }
                    }
                  }
                }
                var updateQueue = finishedWork.updateQueue;
                if (updateQueue !== null) {
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      if (instance.props !== finishedWork.memoizedProps) {
                        error2("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                      if (instance.state !== finishedWork.memoizedState) {
                        error2("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                    }
                  }
                  commitUpdateQueue(finishedWork, updateQueue, instance);
                }
                break;
              }
              case HostRoot: {
                var _updateQueue = finishedWork.updateQueue;
                if (_updateQueue !== null) {
                  var _instance = null;
                  if (finishedWork.child !== null) {
                    switch (finishedWork.child.tag) {
                      case HostComponent:
                        _instance = getPublicInstance(finishedWork.child.stateNode);
                        break;
                      case ClassComponent:
                        _instance = finishedWork.child.stateNode;
                        break;
                    }
                  }
                  commitUpdateQueue(finishedWork, _updateQueue, _instance);
                }
                break;
              }
              case HostComponent: {
                var _instance2 = finishedWork.stateNode;
                if (current2 === null && finishedWork.flags & Update) {
                  var type = finishedWork.type;
                  var props = finishedWork.memoizedProps;
                  commitMount(_instance2, type, props);
                }
                break;
              }
              case HostText: {
                break;
              }
              case HostPortal: {
                break;
              }
              case Profiler: {
                {
                  var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                  var effectDuration = finishedWork.stateNode.effectDuration;
                  var commitTime2 = getCommitTime();
                  var phase = current2 === null ? "mount" : "update";
                  {
                    if (isCurrentUpdateNested()) {
                      phase = "nested-update";
                    }
                  }
                  if (typeof onRender === "function") {
                    onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
                  }
                  {
                    if (typeof onCommit === "function") {
                      onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);
                    }
                    enqueuePendingPassiveProfilerEffect(finishedWork);
                    var parentFiber = finishedWork.return;
                    outer:
                      while (parentFiber !== null) {
                        switch (parentFiber.tag) {
                          case HostRoot:
                            var root2 = parentFiber.stateNode;
                            root2.effectDuration += effectDuration;
                            break outer;
                          case Profiler:
                            var parentStateNode = parentFiber.stateNode;
                            parentStateNode.effectDuration += effectDuration;
                            break outer;
                        }
                        parentFiber = parentFiber.return;
                      }
                  }
                }
                break;
              }
              case SuspenseComponent: {
                commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                break;
              }
              case SuspenseListComponent:
              case IncompleteClassComponent:
              case ScopeComponent:
              case OffscreenComponent:
              case LegacyHiddenComponent:
              case TracingMarkerComponent: {
                break;
              }
              default:
                throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          if (!offscreenSubtreeWasHidden) {
            {
              if (finishedWork.flags & Ref) {
                commitAttachRef(finishedWork);
              }
            }
          }
        }
        function reappearLayoutEffectsOnFiber(node) {
          switch (node.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (node.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  safelyCallCommitHookLayoutEffectListMount(node, node.return);
                } finally {
                  recordLayoutEffectDuration(node);
                }
              } else {
                safelyCallCommitHookLayoutEffectListMount(node, node.return);
              }
              break;
            }
            case ClassComponent: {
              var instance = node.stateNode;
              if (typeof instance.componentDidMount === "function") {
                safelyCallComponentDidMount(node, node.return, instance);
              }
              safelyAttachRef(node, node.return);
              break;
            }
            case HostComponent: {
              safelyAttachRef(node, node.return);
              break;
            }
          }
        }
        function hideOrUnhideAllChildren(finishedWork, isHidden) {
          var hostSubtreeRoot = null;
          {
            var node = finishedWork;
            while (true) {
              if (node.tag === HostComponent) {
                if (hostSubtreeRoot === null) {
                  hostSubtreeRoot = node;
                  try {
                    var instance = node.stateNode;
                    if (isHidden) {
                      hideInstance(instance);
                    } else {
                      unhideInstance(node.stateNode, node.memoizedProps);
                    }
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
              } else if (node.tag === HostText) {
                if (hostSubtreeRoot === null) {
                  try {
                    var _instance3 = node.stateNode;
                    if (isHidden) {
                      hideTextInstance(_instance3);
                    } else {
                      unhideTextInstance(_instance3, node.memoizedProps);
                    }
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
              } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork)
                ;
              else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === finishedWork) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === finishedWork) {
                  return;
                }
                if (hostSubtreeRoot === node) {
                  hostSubtreeRoot = null;
                }
                node = node.return;
              }
              if (hostSubtreeRoot === node) {
                hostSubtreeRoot = null;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
        }
        function commitAttachRef(finishedWork) {
          var ref = finishedWork.ref;
          if (ref !== null) {
            var instance = finishedWork.stateNode;
            var instanceToUse;
            switch (finishedWork.tag) {
              case HostComponent:
                instanceToUse = getPublicInstance(instance);
                break;
              default:
                instanceToUse = instance;
            }
            if (typeof ref === "function") {
              var retVal;
              if (finishedWork.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  retVal = ref(instanceToUse);
                } finally {
                  recordLayoutEffectDuration(finishedWork);
                }
              } else {
                retVal = ref(instanceToUse);
              }
              {
                if (typeof retVal === "function") {
                  error2("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
                }
              }
            } else {
              {
                if (!ref.hasOwnProperty("current")) {
                  error2("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork));
                }
              }
              ref.current = instanceToUse;
            }
          }
        }
        function detachFiberMutation(fiber) {
          var alternate = fiber.alternate;
          if (alternate !== null) {
            alternate.return = null;
          }
          fiber.return = null;
        }
        function detachFiberAfterEffects(fiber) {
          var alternate = fiber.alternate;
          if (alternate !== null) {
            fiber.alternate = null;
            detachFiberAfterEffects(alternate);
          }
          {
            fiber.child = null;
            fiber.deletions = null;
            fiber.sibling = null;
            if (fiber.tag === HostComponent) {
              var hostInstance = fiber.stateNode;
              if (hostInstance !== null) {
                detachDeletedInstance(hostInstance);
              }
            }
            fiber.stateNode = null;
            {
              fiber._debugOwner = null;
            }
            {
              fiber.return = null;
              fiber.dependencies = null;
              fiber.memoizedProps = null;
              fiber.memoizedState = null;
              fiber.pendingProps = null;
              fiber.stateNode = null;
              fiber.updateQueue = null;
            }
          }
        }
        function getHostParentFiber(fiber) {
          var parent = fiber.return;
          while (parent !== null) {
            if (isHostParent(parent)) {
              return parent;
            }
            parent = parent.return;
          }
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        }
        function isHostParent(fiber) {
          return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
        }
        function getHostSibling(fiber) {
          var node = fiber;
          siblings:
            while (true) {
              while (node.sibling === null) {
                if (node.return === null || isHostParent(node.return)) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
              while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
                if (node.flags & Placement) {
                  continue siblings;
                }
                if (node.child === null || node.tag === HostPortal) {
                  continue siblings;
                } else {
                  node.child.return = node;
                  node = node.child;
                }
              }
              if (!(node.flags & Placement)) {
                return node.stateNode;
              }
            }
        }
        function commitPlacement(finishedWork) {
          var parentFiber = getHostParentFiber(finishedWork);
          switch (parentFiber.tag) {
            case HostComponent: {
              var parent = parentFiber.stateNode;
              if (parentFiber.flags & ContentReset) {
                resetTextContent(parent);
                parentFiber.flags &= ~ContentReset;
              }
              var before = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before, parent);
              break;
            }
            case HostRoot:
            case HostPortal: {
              var _parent = parentFiber.stateNode.containerInfo;
              var _before = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
              break;
            }
            default:
              throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
          var tag = node.tag;
          var isHost = tag === HostComponent || tag === HostText;
          if (isHost) {
            var stateNode = node.stateNode;
            if (before) {
              insertInContainerBefore(parent, stateNode, before);
            } else {
              appendChildToContainer(parent, stateNode);
            }
          } else if (tag === HostPortal)
            ;
          else {
            var child = node.child;
            if (child !== null) {
              insertOrAppendPlacementNodeIntoContainer(child, before, parent);
              var sibling = child.sibling;
              while (sibling !== null) {
                insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                sibling = sibling.sibling;
              }
            }
          }
        }
        function insertOrAppendPlacementNode(node, before, parent) {
          var tag = node.tag;
          var isHost = tag === HostComponent || tag === HostText;
          if (isHost) {
            var stateNode = node.stateNode;
            if (before) {
              insertBefore(parent, stateNode, before);
            } else {
              appendChild(parent, stateNode);
            }
          } else if (tag === HostPortal)
            ;
          else {
            var child = node.child;
            if (child !== null) {
              insertOrAppendPlacementNode(child, before, parent);
              var sibling = child.sibling;
              while (sibling !== null) {
                insertOrAppendPlacementNode(sibling, before, parent);
                sibling = sibling.sibling;
              }
            }
          }
        }
        var hostParent = null;
        var hostParentIsContainer = false;
        function commitDeletionEffects(root2, returnFiber, deletedFiber) {
          {
            var parent = returnFiber;
            findParent:
              while (parent !== null) {
                switch (parent.tag) {
                  case HostComponent: {
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break findParent;
                  }
                  case HostRoot: {
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break findParent;
                  }
                  case HostPortal: {
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break findParent;
                  }
                }
                parent = parent.return;
              }
            if (hostParent === null) {
              throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
            }
            commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
            hostParent = null;
            hostParentIsContainer = false;
          }
          detachFiberMutation(deletedFiber);
        }
        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
          var child = parent.child;
          while (child !== null) {
            commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
            child = child.sibling;
          }
        }
        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
          onCommitUnmount(deletedFiber);
          switch (deletedFiber.tag) {
            case HostComponent: {
              if (!offscreenSubtreeWasHidden) {
                safelyDetachRef(deletedFiber, nearestMountedAncestor);
              }
            }
            case HostText: {
              {
                var prevHostParent = hostParent;
                var prevHostParentIsContainer = hostParentIsContainer;
                hostParent = null;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                hostParent = prevHostParent;
                hostParentIsContainer = prevHostParentIsContainer;
                if (hostParent !== null) {
                  if (hostParentIsContainer) {
                    removeChildFromContainer(hostParent, deletedFiber.stateNode);
                  } else {
                    removeChild(hostParent, deletedFiber.stateNode);
                  }
                }
              }
              return;
            }
            case DehydratedFragment: {
              {
                if (hostParent !== null) {
                  if (hostParentIsContainer) {
                    clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);
                  } else {
                    clearSuspenseBoundary(hostParent, deletedFiber.stateNode);
                  }
                }
              }
              return;
            }
            case HostPortal: {
              {
                var _prevHostParent = hostParent;
                var _prevHostParentIsContainer = hostParentIsContainer;
                hostParent = deletedFiber.stateNode.containerInfo;
                hostParentIsContainer = true;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                hostParent = _prevHostParent;
                hostParentIsContainer = _prevHostParentIsContainer;
              }
              return;
            }
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent: {
              if (!offscreenSubtreeWasHidden) {
                var updateQueue = deletedFiber.updateQueue;
                if (updateQueue !== null) {
                  var lastEffect = updateQueue.lastEffect;
                  if (lastEffect !== null) {
                    var firstEffect = lastEffect.next;
                    var effect = firstEffect;
                    do {
                      var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;
                      if (destroy !== void 0) {
                        if ((tag & Insertion) !== NoFlags$1) {
                          safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                        } else if ((tag & Layout) !== NoFlags$1) {
                          {
                            markComponentLayoutEffectUnmountStarted(deletedFiber);
                          }
                          if (deletedFiber.mode & ProfileMode) {
                            startLayoutEffectTimer();
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                            recordLayoutEffectDuration(deletedFiber);
                          } else {
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                          }
                          {
                            markComponentLayoutEffectUnmountStopped();
                          }
                        }
                      }
                      effect = effect.next;
                    } while (effect !== firstEffect);
                  }
                }
              }
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
            case ClassComponent: {
              if (!offscreenSubtreeWasHidden) {
                safelyDetachRef(deletedFiber, nearestMountedAncestor);
                var instance = deletedFiber.stateNode;
                if (typeof instance.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);
                }
              }
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
            case ScopeComponent: {
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
            case OffscreenComponent: {
              if (
                // TODO: Remove this dead flag
                deletedFiber.mode & ConcurrentMode
              ) {
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              } else {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              }
              break;
            }
            default: {
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
          }
        }
        function commitSuspenseCallback(finishedWork) {
          var newState = finishedWork.memoizedState;
        }
        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
          var newState = finishedWork.memoizedState;
          if (newState === null) {
            var current2 = finishedWork.alternate;
            if (current2 !== null) {
              var prevState = current2.memoizedState;
              if (prevState !== null) {
                var suspenseInstance = prevState.dehydrated;
                if (suspenseInstance !== null) {
                  commitHydratedSuspenseInstance(suspenseInstance);
                }
              }
            }
          }
        }
        function attachSuspenseRetryListeners(finishedWork) {
          var wakeables = finishedWork.updateQueue;
          if (wakeables !== null) {
            finishedWork.updateQueue = null;
            var retryCache = finishedWork.stateNode;
            if (retryCache === null) {
              retryCache = finishedWork.stateNode = new PossiblyWeakSet();
            }
            wakeables.forEach(function(wakeable) {
              var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
              if (!retryCache.has(wakeable)) {
                retryCache.add(wakeable);
                {
                  if (isDevToolsPresent) {
                    if (inProgressLanes !== null && inProgressRoot !== null) {
                      restorePendingUpdaters(inProgressRoot, inProgressLanes);
                    } else {
                      throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                    }
                  }
                }
                wakeable.then(retry, retry);
              }
            });
          }
        }
        function commitMutationEffects(root2, finishedWork, committedLanes) {
          inProgressLanes = committedLanes;
          inProgressRoot = root2;
          setCurrentFiber(finishedWork);
          commitMutationEffectsOnFiber(finishedWork, root2);
          setCurrentFiber(finishedWork);
          inProgressLanes = null;
          inProgressRoot = null;
        }
        function recursivelyTraverseMutationEffects(root2, parentFiber, lanes) {
          var deletions = parentFiber.deletions;
          if (deletions !== null) {
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              try {
                commitDeletionEffects(root2, parentFiber, childToDelete);
              } catch (error3) {
                captureCommitPhaseError(childToDelete, parentFiber, error3);
              }
            }
          }
          var prevDebugFiber = getCurrentFiber();
          if (parentFiber.subtreeFlags & MutationMask) {
            var child = parentFiber.child;
            while (child !== null) {
              setCurrentFiber(child);
              commitMutationEffectsOnFiber(child, root2);
              child = child.sibling;
            }
          }
          setCurrentFiber(prevDebugFiber);
        }
        function commitMutationEffectsOnFiber(finishedWork, root2, lanes) {
          var current2 = finishedWork.alternate;
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                try {
                  commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                  commitHookEffectListMount(Insertion | HasEffect, finishedWork);
                } catch (error3) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                }
                if (finishedWork.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                  recordLayoutEffectDuration(finishedWork);
                } else {
                  try {
                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
              }
              return;
            }
            case ClassComponent: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Ref) {
                if (current2 !== null) {
                  safelyDetachRef(current2, current2.return);
                }
              }
              return;
            }
            case HostComponent: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Ref) {
                if (current2 !== null) {
                  safelyDetachRef(current2, current2.return);
                }
              }
              {
                if (finishedWork.flags & ContentReset) {
                  var instance = finishedWork.stateNode;
                  try {
                    resetTextContent(instance);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
                if (flags & Update) {
                  var _instance4 = finishedWork.stateNode;
                  if (_instance4 != null) {
                    var newProps = finishedWork.memoizedProps;
                    var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                    var type = finishedWork.type;
                    var updatePayload = finishedWork.updateQueue;
                    finishedWork.updateQueue = null;
                    if (updatePayload !== null) {
                      try {
                        commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);
                      } catch (error3) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                      }
                    }
                  }
                }
              }
              return;
            }
            case HostText: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                {
                  if (finishedWork.stateNode === null) {
                    throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                  }
                  var textInstance = finishedWork.stateNode;
                  var newText = finishedWork.memoizedProps;
                  var oldText = current2 !== null ? current2.memoizedProps : newText;
                  try {
                    commitTextUpdate(textInstance, oldText, newText);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
              }
              return;
            }
            case HostRoot: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                {
                  if (current2 !== null) {
                    var prevRootState = current2.memoizedState;
                    if (prevRootState.isDehydrated) {
                      try {
                        commitHydratedContainer(root2.containerInfo);
                      } catch (error3) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                      }
                    }
                  }
                }
              }
              return;
            }
            case HostPortal: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              return;
            }
            case SuspenseComponent: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              var offscreenFiber = finishedWork.child;
              if (offscreenFiber.flags & Visibility) {
                var offscreenInstance = offscreenFiber.stateNode;
                var newState = offscreenFiber.memoizedState;
                var isHidden = newState !== null;
                offscreenInstance.isHidden = isHidden;
                if (isHidden) {
                  var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                  if (!wasHidden) {
                    markCommitTimeOfFallback();
                  }
                }
              }
              if (flags & Update) {
                try {
                  commitSuspenseCallback(finishedWork);
                } catch (error3) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                }
                attachSuspenseRetryListeners(finishedWork);
              }
              return;
            }
            case OffscreenComponent: {
              var _wasHidden = current2 !== null && current2.memoizedState !== null;
              if (
                // TODO: Remove this dead flag
                finishedWork.mode & ConcurrentMode
              ) {
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;
                recursivelyTraverseMutationEffects(root2, finishedWork);
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              } else {
                recursivelyTraverseMutationEffects(root2, finishedWork);
              }
              commitReconciliationEffects(finishedWork);
              if (flags & Visibility) {
                var _offscreenInstance = finishedWork.stateNode;
                var _newState = finishedWork.memoizedState;
                var _isHidden = _newState !== null;
                var offscreenBoundary = finishedWork;
                _offscreenInstance.isHidden = _isHidden;
                {
                  if (_isHidden) {
                    if (!_wasHidden) {
                      if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                        nextEffect = offscreenBoundary;
                        var offscreenChild = offscreenBoundary.child;
                        while (offscreenChild !== null) {
                          nextEffect = offscreenChild;
                          disappearLayoutEffects_begin(offscreenChild);
                          offscreenChild = offscreenChild.sibling;
                        }
                      }
                    }
                  }
                }
                {
                  hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
                }
              }
              return;
            }
            case SuspenseListComponent: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                attachSuspenseRetryListeners(finishedWork);
              }
              return;
            }
            case ScopeComponent: {
              return;
            }
            default: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              return;
            }
          }
        }
        function commitReconciliationEffects(finishedWork) {
          var flags = finishedWork.flags;
          if (flags & Placement) {
            try {
              commitPlacement(finishedWork);
            } catch (error3) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error3);
            }
            finishedWork.flags &= ~Placement;
          }
          if (flags & Hydrating) {
            finishedWork.flags &= ~Hydrating;
          }
        }
        function commitLayoutEffects(finishedWork, root2, committedLanes) {
          inProgressLanes = committedLanes;
          inProgressRoot = root2;
          nextEffect = finishedWork;
          commitLayoutEffects_begin(finishedWork, root2, committedLanes);
          inProgressLanes = null;
          inProgressRoot = null;
        }
        function commitLayoutEffects_begin(subtreeRoot, root2, committedLanes) {
          var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            if (fiber.tag === OffscreenComponent && isModernRoot) {
              var isHidden = fiber.memoizedState !== null;
              var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;
              if (newOffscreenSubtreeIsHidden) {
                commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
                continue;
              } else {
                var current2 = fiber.alternate;
                var wasHidden = current2 !== null && current2.memoizedState !== null;
                var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
                var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
                offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
                if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                  nextEffect = fiber;
                  reappearLayoutEffects_begin(fiber);
                }
                var child = firstChild;
                while (child !== null) {
                  nextEffect = child;
                  commitLayoutEffects_begin(
                    child,
                    // New root; bubble back up to here and stop.
                    root2,
                    committedLanes
                  );
                  child = child.sibling;
                }
                nextEffect = fiber;
                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
                continue;
              }
            }
            if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
            }
          }
        }
        function commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if ((fiber.flags & LayoutMask) !== NoFlags) {
              var current2 = fiber.alternate;
              setCurrentFiber(fiber);
              try {
                commitLayoutEffectOnFiber(root2, current2, fiber, committedLanes);
              } catch (error3) {
                captureCommitPhaseError(fiber, fiber.return, error3);
              }
              resetCurrentFiber();
            }
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function disappearLayoutEffects_begin(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent: {
                if (fiber.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    commitHookEffectListUnmount(Layout, fiber, fiber.return);
                  } finally {
                    recordLayoutEffectDuration(fiber);
                  }
                } else {
                  commitHookEffectListUnmount(Layout, fiber, fiber.return);
                }
                break;
              }
              case ClassComponent: {
                safelyDetachRef(fiber, fiber.return);
                var instance = fiber.stateNode;
                if (typeof instance.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                }
                break;
              }
              case HostComponent: {
                safelyDetachRef(fiber, fiber.return);
                break;
              }
              case OffscreenComponent: {
                var isHidden = fiber.memoizedState !== null;
                if (isHidden) {
                  disappearLayoutEffects_complete(subtreeRoot);
                  continue;
                }
                break;
              }
            }
            if (firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              disappearLayoutEffects_complete(subtreeRoot);
            }
          }
        }
        function disappearLayoutEffects_complete(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function reappearLayoutEffects_begin(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            if (fiber.tag === OffscreenComponent) {
              var isHidden = fiber.memoizedState !== null;
              if (isHidden) {
                reappearLayoutEffects_complete(subtreeRoot);
                continue;
              }
            }
            if (firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              reappearLayoutEffects_complete(subtreeRoot);
            }
          }
        }
        function reappearLayoutEffects_complete(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            setCurrentFiber(fiber);
            try {
              reappearLayoutEffectsOnFiber(fiber);
            } catch (error3) {
              captureCommitPhaseError(fiber, fiber.return, error3);
            }
            resetCurrentFiber();
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitPassiveMountEffects(root2, finishedWork, committedLanes, committedTransitions) {
          nextEffect = finishedWork;
          commitPassiveMountEffects_begin(finishedWork, root2, committedLanes, committedTransitions);
        }
        function commitPassiveMountEffects_begin(subtreeRoot, root2, committedLanes, committedTransitions) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions);
            }
          }
        }
        function commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if ((fiber.flags & Passive) !== NoFlags) {
              setCurrentFiber(fiber);
              try {
                commitPassiveMountOnFiber(root2, fiber, committedLanes, committedTransitions);
              } catch (error3) {
                captureCommitPhaseError(fiber, fiber.return, error3);
              }
              resetCurrentFiber();
            }
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (finishedWork.mode & ProfileMode) {
                startPassiveEffectTimer();
                try {
                  commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                } finally {
                  recordPassiveEffectDuration(finishedWork);
                }
              } else {
                commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
              }
              break;
            }
          }
        }
        function commitPassiveUnmountEffects(firstChild) {
          nextEffect = firstChild;
          commitPassiveUnmountEffects_begin();
        }
        function commitPassiveUnmountEffects_begin() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var child = fiber.child;
            if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
              var deletions = fiber.deletions;
              if (deletions !== null) {
                for (var i = 0; i < deletions.length; i++) {
                  var fiberToDelete = deletions[i];
                  nextEffect = fiberToDelete;
                  commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
                }
                {
                  var previousFiber = fiber.alternate;
                  if (previousFiber !== null) {
                    var detachedChild = previousFiber.child;
                    if (detachedChild !== null) {
                      previousFiber.child = null;
                      do {
                        var detachedSibling = detachedChild.sibling;
                        detachedChild.sibling = null;
                        detachedChild = detachedSibling;
                      } while (detachedChild !== null);
                    }
                  }
                }
                nextEffect = fiber;
              }
            }
            if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
              child.return = fiber;
              nextEffect = child;
            } else {
              commitPassiveUnmountEffects_complete();
            }
          }
        }
        function commitPassiveUnmountEffects_complete() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if ((fiber.flags & Passive) !== NoFlags) {
              setCurrentFiber(fiber);
              commitPassiveUnmountOnFiber(fiber);
              resetCurrentFiber();
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitPassiveUnmountOnFiber(finishedWork) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (finishedWork.mode & ProfileMode) {
                startPassiveEffectTimer();
                commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                recordPassiveEffectDuration(finishedWork);
              } else {
                commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
              }
              break;
            }
          }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            setCurrentFiber(fiber);
            commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
            resetCurrentFiber();
            var child = fiber.child;
            if (child !== null) {
              child.return = fiber;
              nextEffect = child;
            } else {
              commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
            }
          }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var sibling = fiber.sibling;
            var returnFiber = fiber.return;
            {
              detachFiberAfterEffects(fiber);
              if (fiber === deletedSubtreeRoot) {
                nextEffect = null;
                return;
              }
            }
            if (sibling !== null) {
              sibling.return = returnFiber;
              nextEffect = sibling;
              return;
            }
            nextEffect = returnFiber;
          }
        }
        function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {
          switch (current2.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (current2.mode & ProfileMode) {
                startPassiveEffectTimer();
                commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                recordPassiveEffectDuration(current2);
              } else {
                commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
              }
              break;
            }
          }
        }
        function invokeLayoutEffectMountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListMount(Layout | HasEffect, fiber);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                break;
              }
              case ClassComponent: {
                var instance = fiber.stateNode;
                try {
                  instance.componentDidMount();
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                break;
              }
            }
          }
        }
        function invokePassiveEffectMountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListMount(Passive$1 | HasEffect, fiber);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                break;
              }
            }
          }
        }
        function invokeLayoutEffectUnmountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                break;
              }
              case ClassComponent: {
                var instance = fiber.stateNode;
                if (typeof instance.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                }
                break;
              }
            }
          }
        }
        function invokePassiveEffectUnmountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
              }
            }
          }
        }
        var COMPONENT_TYPE = 0;
        var HAS_PSEUDO_CLASS_TYPE = 1;
        var ROLE_TYPE = 2;
        var TEST_NAME_TYPE = 3;
        var TEXT_TYPE = 4;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          COMPONENT_TYPE = symbolFor("selector.component");
          HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
          ROLE_TYPE = symbolFor("selector.role");
          TEST_NAME_TYPE = symbolFor("selector.test_id");
          TEXT_TYPE = symbolFor("selector.text");
        }
        var commitHooks = [];
        function onCommitRoot$1() {
          {
            commitHooks.forEach(function(commitHook) {
              return commitHook();
            });
          }
        }
        var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
        function isLegacyActEnvironment(fiber) {
          {
            var isReactActEnvironmentGlobal = (
              // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
              typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
            );
            var jestIsDefined = typeof jest !== "undefined";
            return jestIsDefined && isReactActEnvironmentGlobal !== false;
          }
        }
        function isConcurrentActEnvironment() {
          {
            var isReactActEnvironmentGlobal = (
              // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
              typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
            );
            if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
              error2("The current testing environment is not configured to support act(...)");
            }
            return isReactActEnvironmentGlobal;
          }
        }
        var ceil = Math.ceil;
        var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;
        var NoContext = (
          /*             */
          0
        );
        var BatchedContext = (
          /*               */
          1
        );
        var RenderContext = (
          /*                */
          2
        );
        var CommitContext = (
          /*                */
          4
        );
        var RootInProgress = 0;
        var RootFatalErrored = 1;
        var RootErrored = 2;
        var RootSuspended = 3;
        var RootSuspendedWithDelay = 4;
        var RootCompleted = 5;
        var RootDidNotComplete = 6;
        var executionContext = NoContext;
        var workInProgressRoot = null;
        var workInProgress = null;
        var workInProgressRootRenderLanes = NoLanes;
        var subtreeRenderLanes = NoLanes;
        var subtreeRenderLanesCursor = createCursor(NoLanes);
        var workInProgressRootExitStatus = RootInProgress;
        var workInProgressRootFatalError = null;
        var workInProgressRootIncludedLanes = NoLanes;
        var workInProgressRootSkippedLanes = NoLanes;
        var workInProgressRootInterleavedUpdatedLanes = NoLanes;
        var workInProgressRootPingedLanes = NoLanes;
        var workInProgressRootConcurrentErrors = null;
        var workInProgressRootRecoverableErrors = null;
        var globalMostRecentFallbackTime = 0;
        var FALLBACK_THROTTLE_MS = 500;
        var workInProgressRootRenderTargetTime = Infinity;
        var RENDER_TIMEOUT_MS = 500;
        var workInProgressTransitions = null;
        function resetRenderTimer() {
          workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
        }
        function getRenderTargetTime() {
          return workInProgressRootRenderTargetTime;
        }
        var hasUncaughtError = false;
        var firstUncaughtError = null;
        var legacyErrorBoundariesThatAlreadyFailed = null;
        var rootDoesHavePassiveEffects = false;
        var rootWithPendingPassiveEffects = null;
        var pendingPassiveEffectsLanes = NoLanes;
        var pendingPassiveProfilerEffects = [];
        var pendingPassiveTransitions = null;
        var NESTED_UPDATE_LIMIT = 50;
        var nestedUpdateCount = 0;
        var rootWithNestedUpdates = null;
        var isFlushingPassiveEffects = false;
        var didScheduleUpdateDuringPassiveEffects = false;
        var NESTED_PASSIVE_UPDATE_LIMIT = 50;
        var nestedPassiveUpdateCount = 0;
        var rootWithPassiveNestedUpdates = null;
        var currentEventTime = NoTimestamp;
        var currentEventTransitionLane = NoLanes;
        var isRunningInsertionEffect = false;
        function getWorkInProgressRoot() {
          return workInProgressRoot;
        }
        function requestEventTime() {
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            return now();
          }
          if (currentEventTime !== NoTimestamp) {
            return currentEventTime;
          }
          currentEventTime = now();
          return currentEventTime;
        }
        function requestUpdateLane(fiber) {
          var mode = fiber.mode;
          if ((mode & ConcurrentMode) === NoMode) {
            return SyncLane;
          } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
            return pickArbitraryLane(workInProgressRootRenderLanes);
          }
          var isTransition = requestCurrentTransition() !== NoTransition;
          if (isTransition) {
            if (ReactCurrentBatchConfig$3.transition !== null) {
              var transition = ReactCurrentBatchConfig$3.transition;
              if (!transition._updatedFibers) {
                transition._updatedFibers = /* @__PURE__ */ new Set();
              }
              transition._updatedFibers.add(fiber);
            }
            if (currentEventTransitionLane === NoLane) {
              currentEventTransitionLane = claimNextTransitionLane();
            }
            return currentEventTransitionLane;
          }
          var updateLane = getCurrentUpdatePriority();
          if (updateLane !== NoLane) {
            return updateLane;
          }
          var eventLane = getCurrentEventPriority();
          return eventLane;
        }
        function requestRetryLane(fiber) {
          var mode = fiber.mode;
          if ((mode & ConcurrentMode) === NoMode) {
            return SyncLane;
          }
          return claimNextRetryLane();
        }
        function scheduleUpdateOnFiber(root2, fiber, lane, eventTime) {
          checkForNestedUpdates();
          {
            if (isRunningInsertionEffect) {
              error2("useInsertionEffect must not schedule updates.");
            }
          }
          {
            if (isFlushingPassiveEffects) {
              didScheduleUpdateDuringPassiveEffects = true;
            }
          }
          markRootUpdated(root2, lane, eventTime);
          if ((executionContext & RenderContext) !== NoLanes && root2 === workInProgressRoot) {
            warnAboutRenderPhaseUpdatesInDEV(fiber);
          } else {
            {
              if (isDevToolsPresent) {
                addFiberToLanesMap(root2, fiber, lane);
              }
            }
            warnIfUpdatesNotWrappedWithActDEV(fiber);
            if (root2 === workInProgressRoot) {
              if ((executionContext & RenderContext) === NoContext) {
                workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
              }
              if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                markRootSuspended$1(root2, workInProgressRootRenderLanes);
              }
            }
            ensureRootIsScheduled(root2, eventTime);
            if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
            !ReactCurrentActQueue$1.isBatchingLegacy) {
              resetRenderTimer();
              flushSyncCallbacksOnlyInLegacyMode();
            }
          }
        }
        function scheduleInitialHydrationOnRoot(root2, lane, eventTime) {
          var current2 = root2.current;
          current2.lanes = lane;
          markRootUpdated(root2, lane, eventTime);
          ensureRootIsScheduled(root2, eventTime);
        }
        function isUnsafeClassRenderPhaseUpdate(fiber) {
          return (
            // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
            // decided not to enable it.
            (executionContext & RenderContext) !== NoContext
          );
        }
        function ensureRootIsScheduled(root2, currentTime) {
          var existingCallbackNode = root2.callbackNode;
          markStarvedLanesAsExpired(root2, currentTime);
          var nextLanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
          if (nextLanes === NoLanes) {
            if (existingCallbackNode !== null) {
              cancelCallback$1(existingCallbackNode);
            }
            root2.callbackNode = null;
            root2.callbackPriority = NoLane;
            return;
          }
          var newCallbackPriority = getHighestPriorityLane(nextLanes);
          var existingCallbackPriority = root2.callbackPriority;
          if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a
          // Scheduler task, rather than an `act` task, cancel it and re-scheduled
          // on the `act` queue.
          !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
            {
              if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
                error2("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            return;
          }
          if (existingCallbackNode != null) {
            cancelCallback$1(existingCallbackNode);
          }
          var newCallbackNode;
          if (newCallbackPriority === SyncLane) {
            if (root2.tag === LegacyRoot) {
              if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
                ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
              }
              scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root2));
            } else {
              scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root2));
            }
            {
              if (ReactCurrentActQueue$1.current !== null) {
                ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
              } else {
                scheduleMicrotask(function() {
                  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                    flushSyncCallbacks();
                  }
                });
              }
            }
            newCallbackNode = null;
          } else {
            var schedulerPriorityLevel;
            switch (lanesToEventPriority(nextLanes)) {
              case DiscreteEventPriority:
                schedulerPriorityLevel = ImmediatePriority;
                break;
              case ContinuousEventPriority:
                schedulerPriorityLevel = UserBlockingPriority;
                break;
              case DefaultEventPriority:
                schedulerPriorityLevel = NormalPriority;
                break;
              case IdleEventPriority:
                schedulerPriorityLevel = IdlePriority;
                break;
              default:
                schedulerPriorityLevel = NormalPriority;
                break;
            }
            newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root2));
          }
          root2.callbackPriority = newCallbackPriority;
          root2.callbackNode = newCallbackNode;
        }
        function performConcurrentWorkOnRoot(root2, didTimeout) {
          {
            resetNestedUpdateFlag();
          }
          currentEventTime = NoTimestamp;
          currentEventTransitionLane = NoLanes;
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Should not already be working.");
          }
          var originalCallbackNode = root2.callbackNode;
          var didFlushPassiveEffects = flushPassiveEffects();
          if (didFlushPassiveEffects) {
            if (root2.callbackNode !== originalCallbackNode) {
              return null;
            }
          }
          var lanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
          if (lanes === NoLanes) {
            return null;
          }
          var shouldTimeSlice = !includesBlockingLane(root2, lanes) && !includesExpiredLane(root2, lanes) && !didTimeout;
          var exitStatus = shouldTimeSlice ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes);
          if (exitStatus !== RootInProgress) {
            if (exitStatus === RootErrored) {
              var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
              if (errorRetryLanes !== NoLanes) {
                lanes = errorRetryLanes;
                exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);
              }
            }
            if (exitStatus === RootFatalErrored) {
              var fatalError = workInProgressRootFatalError;
              prepareFreshStack(root2, NoLanes);
              markRootSuspended$1(root2, lanes);
              ensureRootIsScheduled(root2, now());
              throw fatalError;
            }
            if (exitStatus === RootDidNotComplete) {
              markRootSuspended$1(root2, lanes);
            } else {
              var renderWasConcurrent = !includesBlockingLane(root2, lanes);
              var finishedWork = root2.current.alternate;
              if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
                exitStatus = renderRootSync(root2, lanes);
                if (exitStatus === RootErrored) {
                  var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
                  if (_errorRetryLanes !== NoLanes) {
                    lanes = _errorRetryLanes;
                    exitStatus = recoverFromConcurrentError(root2, _errorRetryLanes);
                  }
                }
                if (exitStatus === RootFatalErrored) {
                  var _fatalError = workInProgressRootFatalError;
                  prepareFreshStack(root2, NoLanes);
                  markRootSuspended$1(root2, lanes);
                  ensureRootIsScheduled(root2, now());
                  throw _fatalError;
                }
              }
              root2.finishedWork = finishedWork;
              root2.finishedLanes = lanes;
              finishConcurrentRender(root2, exitStatus, lanes);
            }
          }
          ensureRootIsScheduled(root2, now());
          if (root2.callbackNode === originalCallbackNode) {
            return performConcurrentWorkOnRoot.bind(null, root2);
          }
          return null;
        }
        function recoverFromConcurrentError(root2, errorRetryLanes) {
          var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
          if (isRootDehydrated(root2)) {
            var rootWorkInProgress = prepareFreshStack(root2, errorRetryLanes);
            rootWorkInProgress.flags |= ForceClientRender;
            {
              errorHydratingContainer(root2.containerInfo);
            }
          }
          var exitStatus = renderRootSync(root2, errorRetryLanes);
          if (exitStatus !== RootErrored) {
            var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
            workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
            if (errorsFromSecondAttempt !== null) {
              queueRecoverableErrors(errorsFromSecondAttempt);
            }
          }
          return exitStatus;
        }
        function queueRecoverableErrors(errors2) {
          if (workInProgressRootRecoverableErrors === null) {
            workInProgressRootRecoverableErrors = errors2;
          } else {
            workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors2);
          }
        }
        function finishConcurrentRender(root2, exitStatus, lanes) {
          switch (exitStatus) {
            case RootInProgress:
            case RootFatalErrored: {
              throw new Error("Root did not complete. This is a bug in React.");
            }
            case RootErrored: {
              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            case RootSuspended: {
              markRootSuspended$1(root2, lanes);
              if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
              !shouldForceFlushFallbacksInDEV()) {
                var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();
                if (msUntilTimeout > 10) {
                  var nextLanes = getNextLanes(root2, NoLanes);
                  if (nextLanes !== NoLanes) {
                    break;
                  }
                  var suspendedLanes = root2.suspendedLanes;
                  if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                    var eventTime = requestEventTime();
                    markRootPinged(root2, suspendedLanes);
                    break;
                  }
                  root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                  break;
                }
              }
              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            case RootSuspendedWithDelay: {
              markRootSuspended$1(root2, lanes);
              if (includesOnlyTransitions(lanes)) {
                break;
              }
              if (!shouldForceFlushFallbacksInDEV()) {
                var mostRecentEventTime = getMostRecentEventTime(root2, lanes);
                var eventTimeMs = mostRecentEventTime;
                var timeElapsedMs = now() - eventTimeMs;
                var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
                if (_msUntilTimeout > 10) {
                  root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                  break;
                }
              }
              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            case RootCompleted: {
              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            default: {
              throw new Error("Unknown root exit status.");
            }
          }
        }
        function isRenderConsistentWithExternalStores(finishedWork) {
          var node = finishedWork;
          while (true) {
            if (node.flags & StoreConsistency) {
              var updateQueue = node.updateQueue;
              if (updateQueue !== null) {
                var checks = updateQueue.stores;
                if (checks !== null) {
                  for (var i = 0; i < checks.length; i++) {
                    var check = checks[i];
                    var getSnapshot = check.getSnapshot;
                    var renderedValue = check.value;
                    try {
                      if (!objectIs(getSnapshot(), renderedValue)) {
                        return false;
                      }
                    } catch (error3) {
                      return false;
                    }
                  }
                }
              }
            }
            var child = node.child;
            if (node.subtreeFlags & StoreConsistency && child !== null) {
              child.return = node;
              node = child;
              continue;
            }
            if (node === finishedWork) {
              return true;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === finishedWork) {
                return true;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
          return true;
        }
        function markRootSuspended$1(root2, suspendedLanes) {
          suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
          suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
          markRootSuspended(root2, suspendedLanes);
        }
        function performSyncWorkOnRoot(root2) {
          {
            syncNestedUpdateFlag();
          }
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Should not already be working.");
          }
          flushPassiveEffects();
          var lanes = getNextLanes(root2, NoLanes);
          if (!includesSomeLane(lanes, SyncLane)) {
            ensureRootIsScheduled(root2, now());
            return null;
          }
          var exitStatus = renderRootSync(root2, lanes);
          if (root2.tag !== LegacyRoot && exitStatus === RootErrored) {
            var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
            if (errorRetryLanes !== NoLanes) {
              lanes = errorRetryLanes;
              exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);
            }
          }
          if (exitStatus === RootFatalErrored) {
            var fatalError = workInProgressRootFatalError;
            prepareFreshStack(root2, NoLanes);
            markRootSuspended$1(root2, lanes);
            ensureRootIsScheduled(root2, now());
            throw fatalError;
          }
          if (exitStatus === RootDidNotComplete) {
            throw new Error("Root did not complete. This is a bug in React.");
          }
          var finishedWork = root2.current.alternate;
          root2.finishedWork = finishedWork;
          root2.finishedLanes = lanes;
          commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
          ensureRootIsScheduled(root2, now());
          return null;
        }
        function flushRoot(root2, lanes) {
          if (lanes !== NoLanes) {
            markRootEntangled(root2, mergeLanes(lanes, SyncLane));
            ensureRootIsScheduled(root2, now());
            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
              resetRenderTimer();
              flushSyncCallbacks();
            }
          }
        }
        function batchedUpdates$1(fn, a) {
          var prevExecutionContext = executionContext;
          executionContext |= BatchedContext;
          try {
            return fn(a);
          } finally {
            executionContext = prevExecutionContext;
            if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
            !ReactCurrentActQueue$1.isBatchingLegacy) {
              resetRenderTimer();
              flushSyncCallbacksOnlyInLegacyMode();
            }
          }
        }
        function discreteUpdates(fn, a, b, c, d) {
          var previousPriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(DiscreteEventPriority);
            return fn(a, b, c, d);
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
            if (executionContext === NoContext) {
              resetRenderTimer();
            }
          }
        }
        function flushSync(fn) {
          if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
            flushPassiveEffects();
          }
          var prevExecutionContext = executionContext;
          executionContext |= BatchedContext;
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          var previousPriority = getCurrentUpdatePriority();
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(DiscreteEventPriority);
            if (fn) {
              return fn();
            } else {
              return void 0;
            }
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
            executionContext = prevExecutionContext;
            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
              flushSyncCallbacks();
            }
          }
        }
        function isAlreadyRendering() {
          return (executionContext & (RenderContext | CommitContext)) !== NoContext;
        }
        function pushRenderLanes(fiber, lanes) {
          push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
          subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
          workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
        }
        function popRenderLanes(fiber) {
          subtreeRenderLanes = subtreeRenderLanesCursor.current;
          pop(subtreeRenderLanesCursor, fiber);
        }
        function prepareFreshStack(root2, lanes) {
          root2.finishedWork = null;
          root2.finishedLanes = NoLanes;
          var timeoutHandle = root2.timeoutHandle;
          if (timeoutHandle !== noTimeout) {
            root2.timeoutHandle = noTimeout;
            cancelTimeout(timeoutHandle);
          }
          if (workInProgress !== null) {
            var interruptedWork = workInProgress.return;
            while (interruptedWork !== null) {
              var current2 = interruptedWork.alternate;
              unwindInterruptedWork(current2, interruptedWork);
              interruptedWork = interruptedWork.return;
            }
          }
          workInProgressRoot = root2;
          var rootWorkInProgress = createWorkInProgress(root2.current, null);
          workInProgress = rootWorkInProgress;
          workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
          workInProgressRootExitStatus = RootInProgress;
          workInProgressRootFatalError = null;
          workInProgressRootSkippedLanes = NoLanes;
          workInProgressRootInterleavedUpdatedLanes = NoLanes;
          workInProgressRootPingedLanes = NoLanes;
          workInProgressRootConcurrentErrors = null;
          workInProgressRootRecoverableErrors = null;
          finishQueueingConcurrentUpdates();
          {
            ReactStrictModeWarnings.discardPendingWarnings();
          }
          return rootWorkInProgress;
        }
        function handleError(root2, thrownValue) {
          do {
            var erroredWork = workInProgress;
            try {
              resetContextDependencies();
              resetHooksAfterThrow();
              resetCurrentFiber();
              ReactCurrentOwner$2.current = null;
              if (erroredWork === null || erroredWork.return === null) {
                workInProgressRootExitStatus = RootFatalErrored;
                workInProgressRootFatalError = thrownValue;
                workInProgress = null;
                return;
              }
              if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
              }
              if (enableSchedulingProfiler) {
                markComponentRenderStopped();
                if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
                  var wakeable = thrownValue;
                  markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
                } else {
                  markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
                }
              }
              throwException(root2, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
              completeUnitOfWork(erroredWork);
            } catch (yetAnotherThrownValue) {
              thrownValue = yetAnotherThrownValue;
              if (workInProgress === erroredWork && erroredWork !== null) {
                erroredWork = erroredWork.return;
                workInProgress = erroredWork;
              } else {
                erroredWork = workInProgress;
              }
              continue;
            }
            return;
          } while (true);
        }
        function pushDispatcher() {
          var prevDispatcher = ReactCurrentDispatcher$2.current;
          ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
          if (prevDispatcher === null) {
            return ContextOnlyDispatcher;
          } else {
            return prevDispatcher;
          }
        }
        function popDispatcher(prevDispatcher) {
          ReactCurrentDispatcher$2.current = prevDispatcher;
        }
        function markCommitTimeOfFallback() {
          globalMostRecentFallbackTime = now();
        }
        function markSkippedUpdateLanes(lane) {
          workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
        }
        function renderDidSuspend() {
          if (workInProgressRootExitStatus === RootInProgress) {
            workInProgressRootExitStatus = RootSuspended;
          }
        }
        function renderDidSuspendDelayIfPossible() {
          if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
            workInProgressRootExitStatus = RootSuspendedWithDelay;
          }
          if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
            markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
          }
        }
        function renderDidError(error3) {
          if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
            workInProgressRootExitStatus = RootErrored;
          }
          if (workInProgressRootConcurrentErrors === null) {
            workInProgressRootConcurrentErrors = [error3];
          } else {
            workInProgressRootConcurrentErrors.push(error3);
          }
        }
        function renderHasNotSuspendedYet() {
          return workInProgressRootExitStatus === RootInProgress;
        }
        function renderRootSync(root2, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root2.memoizedUpdaters;
                if (memoizedUpdaters.size > 0) {
                  restorePendingUpdaters(root2, workInProgressRootRenderLanes);
                  memoizedUpdaters.clear();
                }
                movePendingFibersToMemoized(root2, lanes);
              }
            }
            workInProgressTransitions = getTransitionsForLanes();
            prepareFreshStack(root2, lanes);
          }
          {
            markRenderStarted(lanes);
          }
          do {
            try {
              workLoopSync();
              break;
            } catch (thrownValue) {
              handleError(root2, thrownValue);
            }
          } while (true);
          resetContextDependencies();
          executionContext = prevExecutionContext;
          popDispatcher(prevDispatcher);
          if (workInProgress !== null) {
            throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
          }
          {
            markRenderStopped();
          }
          workInProgressRoot = null;
          workInProgressRootRenderLanes = NoLanes;
          return workInProgressRootExitStatus;
        }
        function workLoopSync() {
          while (workInProgress !== null) {
            performUnitOfWork(workInProgress);
          }
        }
        function renderRootConcurrent(root2, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root2.memoizedUpdaters;
                if (memoizedUpdaters.size > 0) {
                  restorePendingUpdaters(root2, workInProgressRootRenderLanes);
                  memoizedUpdaters.clear();
                }
                movePendingFibersToMemoized(root2, lanes);
              }
            }
            workInProgressTransitions = getTransitionsForLanes();
            resetRenderTimer();
            prepareFreshStack(root2, lanes);
          }
          {
            markRenderStarted(lanes);
          }
          do {
            try {
              workLoopConcurrent();
              break;
            } catch (thrownValue) {
              handleError(root2, thrownValue);
            }
          } while (true);
          resetContextDependencies();
          popDispatcher(prevDispatcher);
          executionContext = prevExecutionContext;
          if (workInProgress !== null) {
            {
              markRenderYielded();
            }
            return RootInProgress;
          } else {
            {
              markRenderStopped();
            }
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes;
            return workInProgressRootExitStatus;
          }
        }
        function workLoopConcurrent() {
          while (workInProgress !== null && !shouldYield()) {
            performUnitOfWork(workInProgress);
          }
        }
        function performUnitOfWork(unitOfWork) {
          var current2 = unitOfWork.alternate;
          setCurrentFiber(unitOfWork);
          var next;
          if ((unitOfWork.mode & ProfileMode) !== NoMode) {
            startProfilerTimer(unitOfWork);
            next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
            stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
          } else {
            next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
          }
          resetCurrentFiber();
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          if (next === null) {
            completeUnitOfWork(unitOfWork);
          } else {
            workInProgress = next;
          }
          ReactCurrentOwner$2.current = null;
        }
        function completeUnitOfWork(unitOfWork) {
          var completedWork = unitOfWork;
          do {
            var current2 = completedWork.alternate;
            var returnFiber = completedWork.return;
            if ((completedWork.flags & Incomplete) === NoFlags) {
              setCurrentFiber(completedWork);
              var next = void 0;
              if ((completedWork.mode & ProfileMode) === NoMode) {
                next = completeWork(current2, completedWork, subtreeRenderLanes);
              } else {
                startProfilerTimer(completedWork);
                next = completeWork(current2, completedWork, subtreeRenderLanes);
                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
              }
              resetCurrentFiber();
              if (next !== null) {
                workInProgress = next;
                return;
              }
            } else {
              var _next = unwindWork(current2, completedWork);
              if (_next !== null) {
                _next.flags &= HostEffectMask;
                workInProgress = _next;
                return;
              }
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                var actualDuration = completedWork.actualDuration;
                var child = completedWork.child;
                while (child !== null) {
                  actualDuration += child.actualDuration;
                  child = child.sibling;
                }
                completedWork.actualDuration = actualDuration;
              }
              if (returnFiber !== null) {
                returnFiber.flags |= Incomplete;
                returnFiber.subtreeFlags = NoFlags;
                returnFiber.deletions = null;
              } else {
                workInProgressRootExitStatus = RootDidNotComplete;
                workInProgress = null;
                return;
              }
            }
            var siblingFiber = completedWork.sibling;
            if (siblingFiber !== null) {
              workInProgress = siblingFiber;
              return;
            }
            completedWork = returnFiber;
            workInProgress = completedWork;
          } while (completedWork !== null);
          if (workInProgressRootExitStatus === RootInProgress) {
            workInProgressRootExitStatus = RootCompleted;
          }
        }
        function commitRoot(root2, recoverableErrors, transitions) {
          var previousUpdateLanePriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(DiscreteEventPriority);
            commitRootImpl(root2, recoverableErrors, transitions, previousUpdateLanePriority);
          } finally {
            ReactCurrentBatchConfig$3.transition = prevTransition;
            setCurrentUpdatePriority(previousUpdateLanePriority);
          }
          return null;
        }
        function commitRootImpl(root2, recoverableErrors, transitions, renderPriorityLevel) {
          do {
            flushPassiveEffects();
          } while (rootWithPendingPassiveEffects !== null);
          flushRenderPhaseStrictModeWarningsInDEV();
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Should not already be working.");
          }
          var finishedWork = root2.finishedWork;
          var lanes = root2.finishedLanes;
          {
            markCommitStarted(lanes);
          }
          if (finishedWork === null) {
            {
              markCommitStopped();
            }
            return null;
          } else {
            {
              if (lanes === NoLanes) {
                error2("root.finishedLanes should not be empty during a commit. This is a bug in React.");
              }
            }
          }
          root2.finishedWork = null;
          root2.finishedLanes = NoLanes;
          if (finishedWork === root2.current) {
            throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
          }
          root2.callbackNode = null;
          root2.callbackPriority = NoLane;
          var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
          markRootFinished(root2, remainingLanes);
          if (root2 === workInProgressRoot) {
            workInProgressRoot = null;
            workInProgress = null;
            workInProgressRootRenderLanes = NoLanes;
          }
          if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
            if (!rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = true;
              pendingPassiveTransitions = transitions;
              scheduleCallback$1(NormalPriority, function() {
                flushPassiveEffects();
                return null;
              });
            }
          }
          var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
          var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
          if (subtreeHasEffects || rootHasEffect) {
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            ReactCurrentBatchConfig$3.transition = null;
            var previousPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(DiscreteEventPriority);
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            ReactCurrentOwner$2.current = null;
            var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(root2, finishedWork);
            {
              recordCommitTime();
            }
            commitMutationEffects(root2, finishedWork, lanes);
            resetAfterCommit(root2.containerInfo);
            root2.current = finishedWork;
            {
              markLayoutEffectsStarted(lanes);
            }
            commitLayoutEffects(finishedWork, root2, lanes);
            {
              markLayoutEffectsStopped();
            }
            requestPaint();
            executionContext = prevExecutionContext;
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
          } else {
            root2.current = finishedWork;
            {
              recordCommitTime();
            }
          }
          var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
          if (rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = false;
            rootWithPendingPassiveEffects = root2;
            pendingPassiveEffectsLanes = lanes;
          } else {
            {
              nestedPassiveUpdateCount = 0;
              rootWithPassiveNestedUpdates = null;
            }
          }
          remainingLanes = root2.pendingLanes;
          if (remainingLanes === NoLanes) {
            legacyErrorBoundariesThatAlreadyFailed = null;
          }
          {
            if (!rootDidHavePassiveEffects) {
              commitDoubleInvokeEffectsInDEV(root2.current, false);
            }
          }
          onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
          {
            if (isDevToolsPresent) {
              root2.memoizedUpdaters.clear();
            }
          }
          {
            onCommitRoot$1();
          }
          ensureRootIsScheduled(root2, now());
          if (recoverableErrors !== null) {
            var onRecoverableError = root2.onRecoverableError;
            for (var i = 0; i < recoverableErrors.length; i++) {
              var recoverableError = recoverableErrors[i];
              var componentStack = recoverableError.stack;
              var digest = recoverableError.digest;
              onRecoverableError(recoverableError.value, {
                componentStack,
                digest
              });
            }
          }
          if (hasUncaughtError) {
            hasUncaughtError = false;
            var error$1 = firstUncaughtError;
            firstUncaughtError = null;
            throw error$1;
          }
          if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root2.tag !== LegacyRoot) {
            flushPassiveEffects();
          }
          remainingLanes = root2.pendingLanes;
          if (includesSomeLane(remainingLanes, SyncLane)) {
            {
              markNestedUpdateScheduled();
            }
            if (root2 === rootWithNestedUpdates) {
              nestedUpdateCount++;
            } else {
              nestedUpdateCount = 0;
              rootWithNestedUpdates = root2;
            }
          } else {
            nestedUpdateCount = 0;
          }
          flushSyncCallbacks();
          {
            markCommitStopped();
          }
          return null;
        }
        function flushPassiveEffects() {
          if (rootWithPendingPassiveEffects !== null) {
            var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
            var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            var previousPriority = getCurrentUpdatePriority();
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(priority);
              return flushPassiveEffectsImpl();
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
            }
          }
          return false;
        }
        function enqueuePendingPassiveProfilerEffect(fiber) {
          {
            pendingPassiveProfilerEffects.push(fiber);
            if (!rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = true;
              scheduleCallback$1(NormalPriority, function() {
                flushPassiveEffects();
                return null;
              });
            }
          }
        }
        function flushPassiveEffectsImpl() {
          if (rootWithPendingPassiveEffects === null) {
            return false;
          }
          var transitions = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          var root2 = rootWithPendingPassiveEffects;
          var lanes = pendingPassiveEffectsLanes;
          rootWithPendingPassiveEffects = null;
          pendingPassiveEffectsLanes = NoLanes;
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Cannot flush passive effects while already rendering.");
          }
          {
            isFlushingPassiveEffects = true;
            didScheduleUpdateDuringPassiveEffects = false;
          }
          {
            markPassiveEffectsStarted(lanes);
          }
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          commitPassiveUnmountEffects(root2.current);
          commitPassiveMountEffects(root2, root2.current, lanes, transitions);
          {
            var profilerEffects = pendingPassiveProfilerEffects;
            pendingPassiveProfilerEffects = [];
            for (var i = 0; i < profilerEffects.length; i++) {
              var _fiber = profilerEffects[i];
              commitPassiveEffectDurations(root2, _fiber);
            }
          }
          {
            markPassiveEffectsStopped();
          }
          {
            commitDoubleInvokeEffectsInDEV(root2.current, true);
          }
          executionContext = prevExecutionContext;
          flushSyncCallbacks();
          {
            if (didScheduleUpdateDuringPassiveEffects) {
              if (root2 === rootWithPassiveNestedUpdates) {
                nestedPassiveUpdateCount++;
              } else {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = root2;
              }
            } else {
              nestedPassiveUpdateCount = 0;
            }
            isFlushingPassiveEffects = false;
            didScheduleUpdateDuringPassiveEffects = false;
          }
          onPostCommitRoot(root2);
          {
            var stateNode = root2.current.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
          }
          return true;
        }
        function isAlreadyFailedLegacyErrorBoundary(instance) {
          return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
        }
        function markLegacyErrorBoundaryAsFailed(instance) {
          if (legacyErrorBoundariesThatAlreadyFailed === null) {
            legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]);
          } else {
            legacyErrorBoundariesThatAlreadyFailed.add(instance);
          }
        }
        function prepareToThrowUncaughtError(error3) {
          if (!hasUncaughtError) {
            hasUncaughtError = true;
            firstUncaughtError = error3;
          }
        }
        var onUncaughtError = prepareToThrowUncaughtError;
        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error3) {
          var errorInfo = createCapturedValueAtFiber(error3, sourceFiber);
          var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
          var root2 = enqueueUpdate(rootFiber, update, SyncLane);
          var eventTime = requestEventTime();
          if (root2 !== null) {
            markRootUpdated(root2, SyncLane, eventTime);
            ensureRootIsScheduled(root2, eventTime);
          }
        }
        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
          {
            reportUncaughtErrorInDEV(error$1);
            setIsRunningInsertionEffect(false);
          }
          if (sourceFiber.tag === HostRoot) {
            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
            return;
          }
          var fiber = null;
          {
            fiber = nearestMountedAncestor;
          }
          while (fiber !== null) {
            if (fiber.tag === HostRoot) {
              captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
              return;
            } else if (fiber.tag === ClassComponent) {
              var ctor = fiber.type;
              var instance = fiber.stateNode;
              if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);
                var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                var root2 = enqueueUpdate(fiber, update, SyncLane);
                var eventTime = requestEventTime();
                if (root2 !== null) {
                  markRootUpdated(root2, SyncLane, eventTime);
                  ensureRootIsScheduled(root2, eventTime);
                }
                return;
              }
            }
            fiber = fiber.return;
          }
          {
            error2("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error$1);
          }
        }
        function pingSuspendedRoot(root2, wakeable, pingedLanes) {
          var pingCache = root2.pingCache;
          if (pingCache !== null) {
            pingCache.delete(wakeable);
          }
          var eventTime = requestEventTime();
          markRootPinged(root2, pingedLanes);
          warnIfSuspenseResolutionNotWrappedWithActDEV(root2);
          if (workInProgressRoot === root2 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
            if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
              prepareFreshStack(root2, NoLanes);
            } else {
              workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
            }
          }
          ensureRootIsScheduled(root2, eventTime);
        }
        function retryTimedOutBoundary(boundaryFiber, retryLane) {
          if (retryLane === NoLane) {
            retryLane = requestRetryLane(boundaryFiber);
          }
          var eventTime = requestEventTime();
          var root2 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
          if (root2 !== null) {
            markRootUpdated(root2, retryLane, eventTime);
            ensureRootIsScheduled(root2, eventTime);
          }
        }
        function retryDehydratedSuspenseBoundary(boundaryFiber) {
          var suspenseState = boundaryFiber.memoizedState;
          var retryLane = NoLane;
          if (suspenseState !== null) {
            retryLane = suspenseState.retryLane;
          }
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function resolveRetryWakeable(boundaryFiber, wakeable) {
          var retryLane = NoLane;
          var retryCache;
          switch (boundaryFiber.tag) {
            case SuspenseComponent:
              retryCache = boundaryFiber.stateNode;
              var suspenseState = boundaryFiber.memoizedState;
              if (suspenseState !== null) {
                retryLane = suspenseState.retryLane;
              }
              break;
            case SuspenseListComponent:
              retryCache = boundaryFiber.stateNode;
              break;
            default:
              throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
          }
          if (retryCache !== null) {
            retryCache.delete(wakeable);
          }
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function jnd(timeElapsed) {
          return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
        }
        function checkForNestedUpdates() {
          if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
            nestedUpdateCount = 0;
            rootWithNestedUpdates = null;
            throw new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
          }
          {
            if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
              nestedPassiveUpdateCount = 0;
              rootWithPassiveNestedUpdates = null;
              error2("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
            }
          }
        }
        function flushRenderPhaseStrictModeWarningsInDEV() {
          {
            ReactStrictModeWarnings.flushLegacyContextWarning();
            {
              ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
            }
          }
        }
        function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
          {
            setCurrentFiber(fiber);
            invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
            if (hasPassiveEffects) {
              invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
            }
            invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
            if (hasPassiveEffects) {
              invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
            }
            resetCurrentFiber();
          }
        }
        function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
          {
            var current2 = firstChild;
            var subtreeRoot = null;
            while (current2 !== null) {
              var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;
              if (current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags) {
                current2 = current2.child;
              } else {
                if ((current2.flags & fiberFlags) !== NoFlags) {
                  invokeEffectFn(current2);
                }
                if (current2.sibling !== null) {
                  current2 = current2.sibling;
                } else {
                  current2 = subtreeRoot = current2.return;
                }
              }
            }
          }
        }
        var didWarnStateUpdateForNotYetMountedComponent = null;
        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
          {
            if ((executionContext & RenderContext) !== NoContext) {
              return;
            }
            if (!(fiber.mode & ConcurrentMode)) {
              return;
            }
            var tag = fiber.tag;
            if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {
              return;
            }
            var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
            if (didWarnStateUpdateForNotYetMountedComponent !== null) {
              if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                return;
              }
              didWarnStateUpdateForNotYetMountedComponent.add(componentName);
            } else {
              didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
            }
            var previousFiber = current;
            try {
              setCurrentFiber(fiber);
              error2("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
            } finally {
              if (previousFiber) {
                setCurrentFiber(fiber);
              } else {
                resetCurrentFiber();
              }
            }
          }
        }
        var beginWork$1;
        {
          var dummyFiber = null;
          beginWork$1 = function(current2, unitOfWork, lanes) {
            var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
            try {
              return beginWork(current2, unitOfWork, lanes);
            } catch (originalError) {
              if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
                throw originalError;
              }
              resetContextDependencies();
              resetHooksAfterThrow();
              unwindInterruptedWork(current2, unitOfWork);
              assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
              if (unitOfWork.mode & ProfileMode) {
                startProfilerTimer(unitOfWork);
              }
              invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);
              if (hasCaughtError()) {
                var replayError = clearCaughtError();
                if (typeof replayError === "object" && replayError !== null && replayError._suppressLogging && typeof originalError === "object" && originalError !== null && !originalError._suppressLogging) {
                  originalError._suppressLogging = true;
                }
              }
              throw originalError;
            }
          };
        }
        var didWarnAboutUpdateInRender = false;
        var didWarnAboutUpdateInRenderForAnotherComponent;
        {
          didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
        }
        function warnAboutRenderPhaseUpdatesInDEV(fiber) {
          {
            if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                  var dedupeKey = renderingComponentName;
                  if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                    didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                    var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
                    error2("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                  }
                  break;
                }
                case ClassComponent: {
                  if (!didWarnAboutUpdateInRender) {
                    error2("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                    didWarnAboutUpdateInRender = true;
                  }
                  break;
                }
              }
            }
          }
        }
        function restorePendingUpdaters(root2, lanes) {
          {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root2.memoizedUpdaters;
              memoizedUpdaters.forEach(function(schedulingFiber) {
                addFiberToLanesMap(root2, schedulingFiber, lanes);
              });
            }
          }
        }
        var fakeActCallbackNode = {};
        function scheduleCallback$1(priorityLevel, callback) {
          {
            var actQueue = ReactCurrentActQueue$1.current;
            if (actQueue !== null) {
              actQueue.push(callback);
              return fakeActCallbackNode;
            } else {
              return scheduleCallback(priorityLevel, callback);
            }
          }
        }
        function cancelCallback$1(callbackNode) {
          if (callbackNode === fakeActCallbackNode) {
            return;
          }
          return cancelCallback(callbackNode);
        }
        function shouldForceFlushFallbacksInDEV() {
          return ReactCurrentActQueue$1.current !== null;
        }
        function warnIfUpdatesNotWrappedWithActDEV(fiber) {
          {
            if (fiber.mode & ConcurrentMode) {
              if (!isConcurrentActEnvironment()) {
                return;
              }
            } else {
              if (!isLegacyActEnvironment()) {
                return;
              }
              if (executionContext !== NoContext) {
                return;
              }
              if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {
                return;
              }
            }
            if (ReactCurrentActQueue$1.current === null) {
              var previousFiber = current;
              try {
                setCurrentFiber(fiber);
                error2("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
              } finally {
                if (previousFiber) {
                  setCurrentFiber(fiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
        }
        function warnIfSuspenseResolutionNotWrappedWithActDEV(root2) {
          {
            if (root2.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
              error2("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act");
            }
          }
        }
        function setIsRunningInsertionEffect(isRunning) {
          {
            isRunningInsertionEffect = isRunning;
          }
        }
        var resolveFamily = null;
        var failedBoundaries = null;
        var setRefreshHandler = function(handler) {
          {
            resolveFamily = handler;
          }
        };
        function resolveFunctionForHotReloading(type) {
          {
            if (resolveFamily === null) {
              return type;
            }
            var family = resolveFamily(type);
            if (family === void 0) {
              return type;
            }
            return family.current;
          }
        }
        function resolveClassForHotReloading(type) {
          return resolveFunctionForHotReloading(type);
        }
        function resolveForwardRefForHotReloading(type) {
          {
            if (resolveFamily === null) {
              return type;
            }
            var family = resolveFamily(type);
            if (family === void 0) {
              if (type !== null && type !== void 0 && typeof type.render === "function") {
                var currentRender = resolveFunctionForHotReloading(type.render);
                if (type.render !== currentRender) {
                  var syntheticType = {
                    $$typeof: REACT_FORWARD_REF_TYPE,
                    render: currentRender
                  };
                  if (type.displayName !== void 0) {
                    syntheticType.displayName = type.displayName;
                  }
                  return syntheticType;
                }
              }
              return type;
            }
            return family.current;
          }
        }
        function isCompatibleFamilyForHotReloading(fiber, element) {
          {
            if (resolveFamily === null) {
              return false;
            }
            var prevType = fiber.elementType;
            var nextType = element.type;
            var needsCompareFamilies = false;
            var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
            switch (fiber.tag) {
              case ClassComponent: {
                if (typeof nextType === "function") {
                  needsCompareFamilies = true;
                }
                break;
              }
              case FunctionComponent: {
                if (typeof nextType === "function") {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                  needsCompareFamilies = true;
                }
                break;
              }
              case ForwardRef: {
                if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                  needsCompareFamilies = true;
                }
                break;
              }
              case MemoComponent:
              case SimpleMemoComponent: {
                if ($$typeofNextType === REACT_MEMO_TYPE) {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                  needsCompareFamilies = true;
                }
                break;
              }
              default:
                return false;
            }
            if (needsCompareFamilies) {
              var prevFamily = resolveFamily(prevType);
              if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
                return true;
              }
            }
            return false;
          }
        }
        function markFailedErrorBoundaryForHotReloading(fiber) {
          {
            if (resolveFamily === null) {
              return;
            }
            if (typeof WeakSet !== "function") {
              return;
            }
            if (failedBoundaries === null) {
              failedBoundaries = /* @__PURE__ */ new WeakSet();
            }
            failedBoundaries.add(fiber);
          }
        }
        var scheduleRefresh = function(root2, update) {
          {
            if (resolveFamily === null) {
              return;
            }
            var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
            flushPassiveEffects();
            flushSync(function() {
              scheduleFibersWithFamiliesRecursively(root2.current, updatedFamilies, staleFamilies);
            });
          }
        };
        var scheduleRoot = function(root2, element) {
          {
            if (root2.context !== emptyContextObject) {
              return;
            }
            flushPassiveEffects();
            flushSync(function() {
              updateContainer(element, root2, null, null);
            });
          }
        };
        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
          {
            var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
            var candidateType = null;
            switch (tag) {
              case FunctionComponent:
              case SimpleMemoComponent:
              case ClassComponent:
                candidateType = type;
                break;
              case ForwardRef:
                candidateType = type.render;
                break;
            }
            if (resolveFamily === null) {
              throw new Error("Expected resolveFamily to be set during hot reload.");
            }
            var needsRender = false;
            var needsRemount = false;
            if (candidateType !== null) {
              var family = resolveFamily(candidateType);
              if (family !== void 0) {
                if (staleFamilies.has(family)) {
                  needsRemount = true;
                } else if (updatedFamilies.has(family)) {
                  if (tag === ClassComponent) {
                    needsRemount = true;
                  } else {
                    needsRender = true;
                  }
                }
              }
            }
            if (failedBoundaries !== null) {
              if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                needsRemount = true;
              }
            }
            if (needsRemount) {
              fiber._debugNeedsRemount = true;
            }
            if (needsRemount || needsRender) {
              var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (_root !== null) {
                scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);
              }
            }
            if (child !== null && !needsRemount) {
              scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
            }
            if (sibling !== null) {
              scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
            }
          }
        }
        var findHostInstancesForRefresh = function(root2, families) {
          {
            var hostInstances = /* @__PURE__ */ new Set();
            var types = new Set(families.map(function(family) {
              return family.current;
            }));
            findHostInstancesForMatchingFibersRecursively(root2.current, types, hostInstances);
            return hostInstances;
          }
        };
        function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
          {
            var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
            var candidateType = null;
            switch (tag) {
              case FunctionComponent:
              case SimpleMemoComponent:
              case ClassComponent:
                candidateType = type;
                break;
              case ForwardRef:
                candidateType = type.render;
                break;
            }
            var didMatch = false;
            if (candidateType !== null) {
              if (types.has(candidateType)) {
                didMatch = true;
              }
            }
            if (didMatch) {
              findHostInstancesForFiberShallowly(fiber, hostInstances);
            } else {
              if (child !== null) {
                findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
              }
            }
            if (sibling !== null) {
              findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
            }
          }
        }
        function findHostInstancesForFiberShallowly(fiber, hostInstances) {
          {
            var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
            if (foundHostInstances) {
              return;
            }
            var node = fiber;
            while (true) {
              switch (node.tag) {
                case HostComponent:
                  hostInstances.add(node.stateNode);
                  return;
                case HostPortal:
                  hostInstances.add(node.stateNode.containerInfo);
                  return;
                case HostRoot:
                  hostInstances.add(node.stateNode.containerInfo);
                  return;
              }
              if (node.return === null) {
                throw new Error("Expected to reach root first.");
              }
              node = node.return;
            }
          }
        }
        function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
          {
            var node = fiber;
            var foundHostInstances = false;
            while (true) {
              if (node.tag === HostComponent) {
                foundHostInstances = true;
                hostInstances.add(node.stateNode);
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === fiber) {
                return foundHostInstances;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === fiber) {
                  return foundHostInstances;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          return false;
        }
        var hasBadMapPolyfill;
        {
          hasBadMapPolyfill = false;
          try {
            var nonExtensibleObject = Object.preventExtensions({});
            /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
            /* @__PURE__ */ new Set([nonExtensibleObject]);
          } catch (e) {
            hasBadMapPolyfill = true;
          }
        }
        function FiberNode(tag, pendingProps, key, mode) {
          this.tag = tag;
          this.key = key;
          this.elementType = null;
          this.type = null;
          this.stateNode = null;
          this.return = null;
          this.child = null;
          this.sibling = null;
          this.index = 0;
          this.ref = null;
          this.pendingProps = pendingProps;
          this.memoizedProps = null;
          this.updateQueue = null;
          this.memoizedState = null;
          this.dependencies = null;
          this.mode = mode;
          this.flags = NoFlags;
          this.subtreeFlags = NoFlags;
          this.deletions = null;
          this.lanes = NoLanes;
          this.childLanes = NoLanes;
          this.alternate = null;
          {
            this.actualDuration = Number.NaN;
            this.actualStartTime = Number.NaN;
            this.selfBaseDuration = Number.NaN;
            this.treeBaseDuration = Number.NaN;
            this.actualDuration = 0;
            this.actualStartTime = -1;
            this.selfBaseDuration = 0;
            this.treeBaseDuration = 0;
          }
          {
            this._debugSource = null;
            this._debugOwner = null;
            this._debugNeedsRemount = false;
            this._debugHookTypes = null;
            if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
              Object.preventExtensions(this);
            }
          }
        }
        var createFiber = function(tag, pendingProps, key, mode) {
          return new FiberNode(tag, pendingProps, key, mode);
        };
        function shouldConstruct$1(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function isSimpleFunctionComponent(type) {
          return typeof type === "function" && !shouldConstruct$1(type) && type.defaultProps === void 0;
        }
        function resolveLazyComponentTag(Component) {
          if (typeof Component === "function") {
            return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
          } else if (Component !== void 0 && Component !== null) {
            var $$typeof = Component.$$typeof;
            if ($$typeof === REACT_FORWARD_REF_TYPE) {
              return ForwardRef;
            }
            if ($$typeof === REACT_MEMO_TYPE) {
              return MemoComponent;
            }
          }
          return IndeterminateComponent;
        }
        function createWorkInProgress(current2, pendingProps) {
          var workInProgress2 = current2.alternate;
          if (workInProgress2 === null) {
            workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
            workInProgress2.elementType = current2.elementType;
            workInProgress2.type = current2.type;
            workInProgress2.stateNode = current2.stateNode;
            {
              workInProgress2._debugSource = current2._debugSource;
              workInProgress2._debugOwner = current2._debugOwner;
              workInProgress2._debugHookTypes = current2._debugHookTypes;
            }
            workInProgress2.alternate = current2;
            current2.alternate = workInProgress2;
          } else {
            workInProgress2.pendingProps = pendingProps;
            workInProgress2.type = current2.type;
            workInProgress2.flags = NoFlags;
            workInProgress2.subtreeFlags = NoFlags;
            workInProgress2.deletions = null;
            {
              workInProgress2.actualDuration = 0;
              workInProgress2.actualStartTime = -1;
            }
          }
          workInProgress2.flags = current2.flags & StaticMask;
          workInProgress2.childLanes = current2.childLanes;
          workInProgress2.lanes = current2.lanes;
          workInProgress2.child = current2.child;
          workInProgress2.memoizedProps = current2.memoizedProps;
          workInProgress2.memoizedState = current2.memoizedState;
          workInProgress2.updateQueue = current2.updateQueue;
          var currentDependencies = current2.dependencies;
          workInProgress2.dependencies = currentDependencies === null ? null : {
            lanes: currentDependencies.lanes,
            firstContext: currentDependencies.firstContext
          };
          workInProgress2.sibling = current2.sibling;
          workInProgress2.index = current2.index;
          workInProgress2.ref = current2.ref;
          {
            workInProgress2.selfBaseDuration = current2.selfBaseDuration;
            workInProgress2.treeBaseDuration = current2.treeBaseDuration;
          }
          {
            workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
            switch (workInProgress2.tag) {
              case IndeterminateComponent:
              case FunctionComponent:
              case SimpleMemoComponent:
                workInProgress2.type = resolveFunctionForHotReloading(current2.type);
                break;
              case ClassComponent:
                workInProgress2.type = resolveClassForHotReloading(current2.type);
                break;
              case ForwardRef:
                workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
                break;
            }
          }
          return workInProgress2;
        }
        function resetWorkInProgress(workInProgress2, renderLanes2) {
          workInProgress2.flags &= StaticMask | Placement;
          var current2 = workInProgress2.alternate;
          if (current2 === null) {
            workInProgress2.childLanes = NoLanes;
            workInProgress2.lanes = renderLanes2;
            workInProgress2.child = null;
            workInProgress2.subtreeFlags = NoFlags;
            workInProgress2.memoizedProps = null;
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            workInProgress2.dependencies = null;
            workInProgress2.stateNode = null;
            {
              workInProgress2.selfBaseDuration = 0;
              workInProgress2.treeBaseDuration = 0;
            }
          } else {
            workInProgress2.childLanes = current2.childLanes;
            workInProgress2.lanes = current2.lanes;
            workInProgress2.child = current2.child;
            workInProgress2.subtreeFlags = NoFlags;
            workInProgress2.deletions = null;
            workInProgress2.memoizedProps = current2.memoizedProps;
            workInProgress2.memoizedState = current2.memoizedState;
            workInProgress2.updateQueue = current2.updateQueue;
            workInProgress2.type = current2.type;
            var currentDependencies = current2.dependencies;
            workInProgress2.dependencies = currentDependencies === null ? null : {
              lanes: currentDependencies.lanes,
              firstContext: currentDependencies.firstContext
            };
            {
              workInProgress2.selfBaseDuration = current2.selfBaseDuration;
              workInProgress2.treeBaseDuration = current2.treeBaseDuration;
            }
          }
          return workInProgress2;
        }
        function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
          var mode;
          if (tag === ConcurrentRoot) {
            mode = ConcurrentMode;
            if (isStrictMode === true) {
              mode |= StrictLegacyMode;
              {
                mode |= StrictEffectsMode;
              }
            }
          } else {
            mode = NoMode;
          }
          if (isDevToolsPresent) {
            mode |= ProfileMode;
          }
          return createFiber(HostRoot, null, null, mode);
        }
        function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
          var fiberTag = IndeterminateComponent;
          var resolvedType = type;
          if (typeof type === "function") {
            if (shouldConstruct$1(type)) {
              fiberTag = ClassComponent;
              {
                resolvedType = resolveClassForHotReloading(resolvedType);
              }
            } else {
              {
                resolvedType = resolveFunctionForHotReloading(resolvedType);
              }
            }
          } else if (typeof type === "string") {
            fiberTag = HostComponent;
          } else {
            getTag:
              switch (type) {
                case REACT_FRAGMENT_TYPE:
                  return createFiberFromFragment(pendingProps.children, mode, lanes, key);
                case REACT_STRICT_MODE_TYPE:
                  fiberTag = Mode;
                  mode |= StrictLegacyMode;
                  if ((mode & ConcurrentMode) !== NoMode) {
                    mode |= StrictEffectsMode;
                  }
                  break;
                case REACT_PROFILER_TYPE:
                  return createFiberFromProfiler(pendingProps, mode, lanes, key);
                case REACT_SUSPENSE_TYPE:
                  return createFiberFromSuspense(pendingProps, mode, lanes, key);
                case REACT_SUSPENSE_LIST_TYPE:
                  return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
                case REACT_OFFSCREEN_TYPE:
                  return createFiberFromOffscreen(pendingProps, mode, lanes, key);
                case REACT_LEGACY_HIDDEN_TYPE:
                case REACT_SCOPE_TYPE:
                case REACT_CACHE_TYPE:
                case REACT_TRACING_MARKER_TYPE:
                case REACT_DEBUG_TRACING_MODE_TYPE:
                default: {
                  if (typeof type === "object" && type !== null) {
                    switch (type.$$typeof) {
                      case REACT_PROVIDER_TYPE:
                        fiberTag = ContextProvider;
                        break getTag;
                      case REACT_CONTEXT_TYPE:
                        fiberTag = ContextConsumer;
                        break getTag;
                      case REACT_FORWARD_REF_TYPE:
                        fiberTag = ForwardRef;
                        {
                          resolvedType = resolveForwardRefForHotReloading(resolvedType);
                        }
                        break getTag;
                      case REACT_MEMO_TYPE:
                        fiberTag = MemoComponent;
                        break getTag;
                      case REACT_LAZY_TYPE:
                        fiberTag = LazyComponent;
                        resolvedType = null;
                        break getTag;
                    }
                  }
                  var info = "";
                  {
                    if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                      info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                    }
                    var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                    if (ownerName) {
                      info += "\n\nCheck the render method of `" + ownerName + "`.";
                    }
                  }
                  throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
                }
              }
          }
          var fiber = createFiber(fiberTag, pendingProps, key, mode);
          fiber.elementType = type;
          fiber.type = resolvedType;
          fiber.lanes = lanes;
          {
            fiber._debugOwner = owner;
          }
          return fiber;
        }
        function createFiberFromElement(element, mode, lanes) {
          var owner = null;
          {
            owner = element._owner;
          }
          var type = element.type;
          var key = element.key;
          var pendingProps = element.props;
          var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);
          {
            fiber._debugSource = element._source;
            fiber._debugOwner = element._owner;
          }
          return fiber;
        }
        function createFiberFromFragment(elements, mode, lanes, key) {
          var fiber = createFiber(Fragment, elements, key, mode);
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromProfiler(pendingProps, mode, lanes, key) {
          {
            if (typeof pendingProps.id !== "string") {
              error2('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
            }
          }
          var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
          fiber.elementType = REACT_PROFILER_TYPE;
          fiber.lanes = lanes;
          {
            fiber.stateNode = {
              effectDuration: 0,
              passiveEffectDuration: 0
            };
          }
          return fiber;
        }
        function createFiberFromSuspense(pendingProps, mode, lanes, key) {
          var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
          fiber.elementType = REACT_SUSPENSE_TYPE;
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
          var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
          fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
          var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
          fiber.elementType = REACT_OFFSCREEN_TYPE;
          fiber.lanes = lanes;
          var primaryChildInstance = {
            isHidden: false
          };
          fiber.stateNode = primaryChildInstance;
          return fiber;
        }
        function createFiberFromText(content, mode, lanes) {
          var fiber = createFiber(HostText, content, null, mode);
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromHostInstanceForDeletion() {
          var fiber = createFiber(HostComponent, null, null, NoMode);
          fiber.elementType = "DELETED";
          return fiber;
        }
        function createFiberFromDehydratedFragment(dehydratedNode) {
          var fiber = createFiber(DehydratedFragment, null, null, NoMode);
          fiber.stateNode = dehydratedNode;
          return fiber;
        }
        function createFiberFromPortal(portal, mode, lanes) {
          var pendingProps = portal.children !== null ? portal.children : [];
          var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
          fiber.lanes = lanes;
          fiber.stateNode = {
            containerInfo: portal.containerInfo,
            pendingChildren: null,
            // Used by persistent updates
            implementation: portal.implementation
          };
          return fiber;
        }
        function assignFiberPropertiesInDEV(target, source) {
          if (target === null) {
            target = createFiber(IndeterminateComponent, null, null, NoMode);
          }
          target.tag = source.tag;
          target.key = source.key;
          target.elementType = source.elementType;
          target.type = source.type;
          target.stateNode = source.stateNode;
          target.return = source.return;
          target.child = source.child;
          target.sibling = source.sibling;
          target.index = source.index;
          target.ref = source.ref;
          target.pendingProps = source.pendingProps;
          target.memoizedProps = source.memoizedProps;
          target.updateQueue = source.updateQueue;
          target.memoizedState = source.memoizedState;
          target.dependencies = source.dependencies;
          target.mode = source.mode;
          target.flags = source.flags;
          target.subtreeFlags = source.subtreeFlags;
          target.deletions = source.deletions;
          target.lanes = source.lanes;
          target.childLanes = source.childLanes;
          target.alternate = source.alternate;
          {
            target.actualDuration = source.actualDuration;
            target.actualStartTime = source.actualStartTime;
            target.selfBaseDuration = source.selfBaseDuration;
            target.treeBaseDuration = source.treeBaseDuration;
          }
          target._debugSource = source._debugSource;
          target._debugOwner = source._debugOwner;
          target._debugNeedsRemount = source._debugNeedsRemount;
          target._debugHookTypes = source._debugHookTypes;
          return target;
        }
        function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError) {
          this.tag = tag;
          this.containerInfo = containerInfo;
          this.pendingChildren = null;
          this.current = null;
          this.pingCache = null;
          this.finishedWork = null;
          this.timeoutHandle = noTimeout;
          this.context = null;
          this.pendingContext = null;
          this.callbackNode = null;
          this.callbackPriority = NoLane;
          this.eventTimes = createLaneMap(NoLanes);
          this.expirationTimes = createLaneMap(NoTimestamp);
          this.pendingLanes = NoLanes;
          this.suspendedLanes = NoLanes;
          this.pingedLanes = NoLanes;
          this.expiredLanes = NoLanes;
          this.mutableReadLanes = NoLanes;
          this.finishedLanes = NoLanes;
          this.entangledLanes = NoLanes;
          this.entanglements = createLaneMap(NoLanes);
          this.identifierPrefix = identifierPrefix;
          this.onRecoverableError = onRecoverableError;
          {
            this.mutableSourceEagerHydrationData = null;
          }
          {
            this.effectDuration = 0;
            this.passiveEffectDuration = 0;
          }
          {
            this.memoizedUpdaters = /* @__PURE__ */ new Set();
            var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
            for (var _i = 0; _i < TotalLanes; _i++) {
              pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
            }
          }
          {
            switch (tag) {
              case ConcurrentRoot:
                this._debugRootType = hydrate2 ? "hydrateRoot()" : "createRoot()";
                break;
              case LegacyRoot:
                this._debugRootType = hydrate2 ? "hydrate()" : "render()";
                break;
            }
          }
        }
        function createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
          var root2 = new FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError);
          var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
          root2.current = uninitializedFiber;
          uninitializedFiber.stateNode = root2;
          {
            var _initialState = {
              element: initialChildren,
              isDehydrated: hydrate2,
              cache: null,
              // not enabled yet
              transitions: null,
              pendingSuspenseBoundaries: null
            };
            uninitializedFiber.memoizedState = _initialState;
          }
          initializeUpdateQueue(uninitializedFiber);
          return root2;
        }
        var ReactVersion = "18.3.1";
        function createPortal(children, containerInfo, implementation) {
          var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          {
            checkKeyStringCoercion(key);
          }
          return {
            // This tag allow us to uniquely identify this as a React Portal
            $$typeof: REACT_PORTAL_TYPE,
            key: key == null ? null : "" + key,
            children,
            containerInfo,
            implementation
          };
        }
        var didWarnAboutNestedUpdates;
        var didWarnAboutFindNodeInStrictMode;
        {
          didWarnAboutNestedUpdates = false;
          didWarnAboutFindNodeInStrictMode = {};
        }
        function getContextForSubtree(parentComponent) {
          if (!parentComponent) {
            return emptyContextObject;
          }
          var fiber = get(parentComponent);
          var parentContext = findCurrentUnmaskedContext(fiber);
          if (fiber.tag === ClassComponent) {
            var Component = fiber.type;
            if (isContextProvider(Component)) {
              return processChildContext(fiber, Component, parentContext);
            }
          }
          return parentContext;
        }
        function findHostInstanceWithWarning(component, methodName) {
          {
            var fiber = get(component);
            if (fiber === void 0) {
              if (typeof component.render === "function") {
                throw new Error("Unable to find node on an unmounted component.");
              } else {
                var keys = Object.keys(component).join(",");
                throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys);
              }
            }
            var hostFiber = findCurrentHostFiber(fiber);
            if (hostFiber === null) {
              return null;
            }
            if (hostFiber.mode & StrictLegacyMode) {
              var componentName = getComponentNameFromFiber(fiber) || "Component";
              if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                didWarnAboutFindNodeInStrictMode[componentName] = true;
                var previousFiber = current;
                try {
                  setCurrentFiber(hostFiber);
                  if (fiber.mode & StrictLegacyMode) {
                    error2("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                  } else {
                    error2("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                  }
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(previousFiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
            return hostFiber.stateNode;
          }
        }
        function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
          var hydrate2 = false;
          var initialChildren = null;
          return createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
        }
        function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
          var hydrate2 = true;
          var root2 = createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          root2.context = getContextForSubtree(null);
          var current2 = root2.current;
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(current2);
          var update = createUpdate(eventTime, lane);
          update.callback = callback !== void 0 && callback !== null ? callback : null;
          enqueueUpdate(current2, update, lane);
          scheduleInitialHydrationOnRoot(root2, lane, eventTime);
          return root2;
        }
        function updateContainer(element, container, parentComponent, callback) {
          {
            onScheduleRoot(container, element);
          }
          var current$1 = container.current;
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(current$1);
          {
            markRenderScheduled(lane);
          }
          var context = getContextForSubtree(parentComponent);
          if (container.context === null) {
            container.context = context;
          } else {
            container.pendingContext = context;
          }
          {
            if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
              didWarnAboutNestedUpdates = true;
              error2("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current) || "Unknown");
            }
          }
          var update = createUpdate(eventTime, lane);
          update.payload = {
            element
          };
          callback = callback === void 0 ? null : callback;
          if (callback !== null) {
            {
              if (typeof callback !== "function") {
                error2("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
              }
            }
            update.callback = callback;
          }
          var root2 = enqueueUpdate(current$1, update, lane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, current$1, lane, eventTime);
            entangleTransitions(root2, current$1, lane);
          }
          return lane;
        }
        function getPublicRootInstance(container) {
          var containerFiber = container.current;
          if (!containerFiber.child) {
            return null;
          }
          switch (containerFiber.child.tag) {
            case HostComponent:
              return getPublicInstance(containerFiber.child.stateNode);
            default:
              return containerFiber.child.stateNode;
          }
        }
        function attemptSynchronousHydration$1(fiber) {
          switch (fiber.tag) {
            case HostRoot: {
              var root2 = fiber.stateNode;
              if (isRootDehydrated(root2)) {
                var lanes = getHighestPriorityPendingLanes(root2);
                flushRoot(root2, lanes);
              }
              break;
            }
            case SuspenseComponent: {
              flushSync(function() {
                var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root3 !== null) {
                  var eventTime = requestEventTime();
                  scheduleUpdateOnFiber(root3, fiber, SyncLane, eventTime);
                }
              });
              var retryLane = SyncLane;
              markRetryLaneIfNotHydrated(fiber, retryLane);
              break;
            }
          }
        }
        function markRetryLaneImpl(fiber, retryLane) {
          var suspenseState = fiber.memoizedState;
          if (suspenseState !== null && suspenseState.dehydrated !== null) {
            suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
          }
        }
        function markRetryLaneIfNotHydrated(fiber, retryLane) {
          markRetryLaneImpl(fiber, retryLane);
          var alternate = fiber.alternate;
          if (alternate) {
            markRetryLaneImpl(alternate, retryLane);
          }
        }
        function attemptContinuousHydration$1(fiber) {
          if (fiber.tag !== SuspenseComponent) {
            return;
          }
          var lane = SelectiveHydrationLane;
          var root2 = enqueueConcurrentRenderForLane(fiber, lane);
          if (root2 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
          }
          markRetryLaneIfNotHydrated(fiber, lane);
        }
        function attemptHydrationAtCurrentPriority$1(fiber) {
          if (fiber.tag !== SuspenseComponent) {
            return;
          }
          var lane = requestUpdateLane(fiber);
          var root2 = enqueueConcurrentRenderForLane(fiber, lane);
          if (root2 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
          }
          markRetryLaneIfNotHydrated(fiber, lane);
        }
        function findHostInstanceWithNoPortals(fiber) {
          var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
          if (hostFiber === null) {
            return null;
          }
          return hostFiber.stateNode;
        }
        var shouldErrorImpl = function(fiber) {
          return null;
        };
        function shouldError(fiber) {
          return shouldErrorImpl(fiber);
        }
        var shouldSuspendImpl = function(fiber) {
          return false;
        };
        function shouldSuspend(fiber) {
          return shouldSuspendImpl(fiber);
        }
        var overrideHookState = null;
        var overrideHookStateDeletePath = null;
        var overrideHookStateRenamePath = null;
        var overrideProps = null;
        var overridePropsDeletePath = null;
        var overridePropsRenamePath = null;
        var scheduleUpdate = null;
        var setErrorHandler = null;
        var setSuspenseHandler = null;
        {
          var copyWithDeleteImpl = function(obj, path, index2) {
            var key = path[index2];
            var updated = isArray(obj) ? obj.slice() : assign3({}, obj);
            if (index2 + 1 === path.length) {
              if (isArray(updated)) {
                updated.splice(key, 1);
              } else {
                delete updated[key];
              }
              return updated;
            }
            updated[key] = copyWithDeleteImpl(obj[key], path, index2 + 1);
            return updated;
          };
          var copyWithDelete = function(obj, path) {
            return copyWithDeleteImpl(obj, path, 0);
          };
          var copyWithRenameImpl = function(obj, oldPath, newPath, index2) {
            var oldKey = oldPath[index2];
            var updated = isArray(obj) ? obj.slice() : assign3({}, obj);
            if (index2 + 1 === oldPath.length) {
              var newKey = newPath[index2];
              updated[newKey] = updated[oldKey];
              if (isArray(updated)) {
                updated.splice(oldKey, 1);
              } else {
                delete updated[oldKey];
              }
            } else {
              updated[oldKey] = copyWithRenameImpl(
                // $FlowFixMe number or string is fine here
                obj[oldKey],
                oldPath,
                newPath,
                index2 + 1
              );
            }
            return updated;
          };
          var copyWithRename = function(obj, oldPath, newPath) {
            if (oldPath.length !== newPath.length) {
              warn("copyWithRename() expects paths of the same length");
              return;
            } else {
              for (var i = 0; i < newPath.length - 1; i++) {
                if (oldPath[i] !== newPath[i]) {
                  warn("copyWithRename() expects paths to be the same except for the deepest key");
                  return;
                }
              }
            }
            return copyWithRenameImpl(obj, oldPath, newPath, 0);
          };
          var copyWithSetImpl = function(obj, path, index2, value) {
            if (index2 >= path.length) {
              return value;
            }
            var key = path[index2];
            var updated = isArray(obj) ? obj.slice() : assign3({}, obj);
            updated[key] = copyWithSetImpl(obj[key], path, index2 + 1, value);
            return updated;
          };
          var copyWithSet = function(obj, path, value) {
            return copyWithSetImpl(obj, path, 0, value);
          };
          var findHook = function(fiber, id) {
            var currentHook2 = fiber.memoizedState;
            while (currentHook2 !== null && id > 0) {
              currentHook2 = currentHook2.next;
              id--;
            }
            return currentHook2;
          };
          overrideHookState = function(fiber, id, path, value) {
            var hook = findHook(fiber, id);
            if (hook !== null) {
              var newState = copyWithSet(hook.memoizedState, path, value);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = assign3({}, fiber.memoizedProps);
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            }
          };
          overrideHookStateDeletePath = function(fiber, id, path) {
            var hook = findHook(fiber, id);
            if (hook !== null) {
              var newState = copyWithDelete(hook.memoizedState, path);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = assign3({}, fiber.memoizedProps);
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            }
          };
          overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
            var hook = findHook(fiber, id);
            if (hook !== null) {
              var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = assign3({}, fiber.memoizedProps);
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            }
          };
          overrideProps = function(fiber, path, value) {
            fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          };
          overridePropsDeletePath = function(fiber, path) {
            fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          };
          overridePropsRenamePath = function(fiber, oldPath, newPath) {
            fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          };
          scheduleUpdate = function(fiber) {
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          };
          setErrorHandler = function(newShouldErrorImpl) {
            shouldErrorImpl = newShouldErrorImpl;
          };
          setSuspenseHandler = function(newShouldSuspendImpl) {
            shouldSuspendImpl = newShouldSuspendImpl;
          };
        }
        function findHostInstanceByFiber(fiber) {
          var hostFiber = findCurrentHostFiber(fiber);
          if (hostFiber === null) {
            return null;
          }
          return hostFiber.stateNode;
        }
        function emptyFindFiberByHostInstance(instance) {
          return null;
        }
        function getCurrentFiberForDevTools() {
          return current;
        }
        function injectIntoDevTools(devToolsConfig) {
          var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
          var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
          return injectInternals({
            bundleType: devToolsConfig.bundleType,
            version: devToolsConfig.version,
            rendererPackageName: devToolsConfig.rendererPackageName,
            rendererConfig: devToolsConfig.rendererConfig,
            overrideHookState,
            overrideHookStateDeletePath,
            overrideHookStateRenamePath,
            overrideProps,
            overridePropsDeletePath,
            overridePropsRenamePath,
            setErrorHandler,
            setSuspenseHandler,
            scheduleUpdate,
            currentDispatcherRef: ReactCurrentDispatcher2,
            findHostInstanceByFiber,
            findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
            // React Refresh
            findHostInstancesForRefresh,
            scheduleRefresh,
            scheduleRoot,
            setRefreshHandler,
            // Enables DevTools to append owner stacks to error messages in DEV mode.
            getCurrentFiber: getCurrentFiberForDevTools,
            // Enables DevTools to detect reconciler version rather than renderer version
            // which may not match for third party renderers.
            reconcilerVersion: ReactVersion
          });
        }
        var defaultOnRecoverableError = typeof reportError === "function" ? (
          // In modern browsers, reportError will dispatch an error event,
          // emulating an uncaught JavaScript error.
          reportError
        ) : function(error3) {
          console["error"](error3);
        };
        function ReactDOMRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
          var root2 = this._internalRoot;
          if (root2 === null) {
            throw new Error("Cannot update an unmounted root.");
          }
          {
            if (typeof arguments[1] === "function") {
              error2("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
            } else if (isValidContainer(arguments[1])) {
              error2("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.");
            } else if (typeof arguments[1] !== "undefined") {
              error2("You passed a second argument to root.render(...) but it only accepts one argument.");
            }
            var container = root2.containerInfo;
            if (container.nodeType !== COMMENT_NODE) {
              var hostInstance = findHostInstanceWithNoPortals(root2.current);
              if (hostInstance) {
                if (hostInstance.parentNode !== container) {
                  error2("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
                }
              }
            }
          }
          updateContainer(children, root2, null, null);
        };
        ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
          {
            if (typeof arguments[0] === "function") {
              error2("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
            }
          }
          var root2 = this._internalRoot;
          if (root2 !== null) {
            this._internalRoot = null;
            var container = root2.containerInfo;
            {
              if (isAlreadyRendering()) {
                error2("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
              }
            }
            flushSync(function() {
              updateContainer(null, root2, null, null);
            });
            unmarkContainerAsRoot(container);
          }
        };
        function createRoot7(container, options2) {
          if (!isValidContainer(container)) {
            throw new Error("createRoot(...): Target container is not a DOM element.");
          }
          warnIfReactDOMContainerInDEV(container);
          var isStrictMode = false;
          var concurrentUpdatesByDefaultOverride = false;
          var identifierPrefix = "";
          var onRecoverableError = defaultOnRecoverableError;
          var transitionCallbacks = null;
          if (options2 !== null && options2 !== void 0) {
            {
              if (options2.hydrate) {
                warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.");
              } else {
                if (typeof options2 === "object" && options2 !== null && options2.$$typeof === REACT_ELEMENT_TYPE) {
                  error2("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);");
                }
              }
            }
            if (options2.unstable_strictMode === true) {
              isStrictMode = true;
            }
            if (options2.identifierPrefix !== void 0) {
              identifierPrefix = options2.identifierPrefix;
            }
            if (options2.onRecoverableError !== void 0) {
              onRecoverableError = options2.onRecoverableError;
            }
            if (options2.transitionCallbacks !== void 0) {
              transitionCallbacks = options2.transitionCallbacks;
            }
          }
          var root2 = createContainer(container, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          markContainerAsRoot(root2.current, container);
          var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
          listenToAllSupportedEvents(rootContainerElement);
          return new ReactDOMRoot(root2);
        }
        function ReactDOMHydrationRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function scheduleHydration(target) {
          if (target) {
            queueExplicitHydrationTarget(target);
          }
        }
        ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
        function hydrateRoot(container, initialChildren, options2) {
          if (!isValidContainer(container)) {
            throw new Error("hydrateRoot(...): Target container is not a DOM element.");
          }
          warnIfReactDOMContainerInDEV(container);
          {
            if (initialChildren === void 0) {
              error2("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
            }
          }
          var hydrationCallbacks = options2 != null ? options2 : null;
          var mutableSources = options2 != null && options2.hydratedSources || null;
          var isStrictMode = false;
          var concurrentUpdatesByDefaultOverride = false;
          var identifierPrefix = "";
          var onRecoverableError = defaultOnRecoverableError;
          if (options2 !== null && options2 !== void 0) {
            if (options2.unstable_strictMode === true) {
              isStrictMode = true;
            }
            if (options2.identifierPrefix !== void 0) {
              identifierPrefix = options2.identifierPrefix;
            }
            if (options2.onRecoverableError !== void 0) {
              onRecoverableError = options2.onRecoverableError;
            }
          }
          var root2 = createHydrationContainer(initialChildren, null, container, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          markContainerAsRoot(root2.current, container);
          listenToAllSupportedEvents(container);
          if (mutableSources) {
            for (var i = 0; i < mutableSources.length; i++) {
              var mutableSource = mutableSources[i];
              registerMutableSourceForHydration(root2, mutableSource);
            }
          }
          return new ReactDOMHydrationRoot(root2);
        }
        function isValidContainer(node) {
          return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));
        }
        function isValidContainerLegacy(node) {
          return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
        }
        function warnIfReactDOMContainerInDEV(container) {
          {
            if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
              error2("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.");
            }
            if (isContainerMarkedAsRoot(container)) {
              if (container._reactRootContainer) {
                error2("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.");
              } else {
                error2("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.");
              }
            }
          }
        }
        var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
        var topLevelUpdateWarnings;
        {
          topLevelUpdateWarnings = function(container) {
            if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
              var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer.current);
              if (hostInstance) {
                if (hostInstance.parentNode !== container) {
                  error2("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
                }
              }
            }
            var isRootRenderedBySomeReact = !!container._reactRootContainer;
            var rootEl = getReactRootElementInContainer(container);
            var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
            if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
              error2("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
            }
            if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
              error2("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
            }
          };
        }
        function getReactRootElementInContainer(container) {
          if (!container) {
            return null;
          }
          if (container.nodeType === DOCUMENT_NODE) {
            return container.documentElement;
          } else {
            return container.firstChild;
          }
        }
        function noopOnRecoverableError() {
        }
        function legacyCreateRootFromDOMContainer(container, initialChildren, parentComponent, callback, isHydrationContainer) {
          if (isHydrationContainer) {
            if (typeof callback === "function") {
              var originalCallback = callback;
              callback = function() {
                var instance = getPublicRootInstance(root2);
                originalCallback.call(instance);
              };
            }
            var root2 = createHydrationContainer(
              initialChildren,
              callback,
              container,
              LegacyRoot,
              null,
              // hydrationCallbacks
              false,
              // isStrictMode
              false,
              // concurrentUpdatesByDefaultOverride,
              "",
              // identifierPrefix
              noopOnRecoverableError
            );
            container._reactRootContainer = root2;
            markContainerAsRoot(root2.current, container);
            var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
            listenToAllSupportedEvents(rootContainerElement);
            flushSync();
            return root2;
          } else {
            var rootSibling;
            while (rootSibling = container.lastChild) {
              container.removeChild(rootSibling);
            }
            if (typeof callback === "function") {
              var _originalCallback = callback;
              callback = function() {
                var instance = getPublicRootInstance(_root);
                _originalCallback.call(instance);
              };
            }
            var _root = createContainer(
              container,
              LegacyRoot,
              null,
              // hydrationCallbacks
              false,
              // isStrictMode
              false,
              // concurrentUpdatesByDefaultOverride,
              "",
              // identifierPrefix
              noopOnRecoverableError
            );
            container._reactRootContainer = _root;
            markContainerAsRoot(_root.current, container);
            var _rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
            listenToAllSupportedEvents(_rootContainerElement);
            flushSync(function() {
              updateContainer(initialChildren, _root, parentComponent, callback);
            });
            return _root;
          }
        }
        function warnOnInvalidCallback$1(callback, callerName) {
          {
            if (callback !== null && typeof callback !== "function") {
              error2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          }
        }
        function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
          {
            topLevelUpdateWarnings(container);
            warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
          }
          var maybeRoot = container._reactRootContainer;
          var root2;
          if (!maybeRoot) {
            root2 = legacyCreateRootFromDOMContainer(container, children, parentComponent, callback, forceHydrate);
          } else {
            root2 = maybeRoot;
            if (typeof callback === "function") {
              var originalCallback = callback;
              callback = function() {
                var instance = getPublicRootInstance(root2);
                originalCallback.call(instance);
              };
            }
            updateContainer(children, root2, parentComponent, callback);
          }
          return getPublicRootInstance(root2);
        }
        var didWarnAboutFindDOMNode = false;
        function findDOMNode(componentOrElement) {
          {
            if (!didWarnAboutFindDOMNode) {
              didWarnAboutFindDOMNode = true;
              error2("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node");
            }
            var owner = ReactCurrentOwner$3.current;
            if (owner !== null && owner.stateNode !== null) {
              var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
              if (!warnedAboutRefsInRender) {
                error2("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromType(owner.type) || "A component");
              }
              owner.stateNode._warnedAboutRefsInRender = true;
            }
          }
          if (componentOrElement == null) {
            return null;
          }
          if (componentOrElement.nodeType === ELEMENT_NODE) {
            return componentOrElement;
          }
          {
            return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
          }
        }
        function hydrate(element, container, callback) {
          {
            error2("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
          if (!isValidContainerLegacy(container)) {
            throw new Error("Target container is not a DOM element.");
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
            if (isModernRoot) {
              error2("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
            }
          }
          return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
        }
        function render(element, container, callback) {
          {
            error2("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
          if (!isValidContainerLegacy(container)) {
            throw new Error("Target container is not a DOM element.");
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
            if (isModernRoot) {
              error2("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
            }
          }
          return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
        }
        function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
          {
            error2("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
          if (!isValidContainerLegacy(containerNode)) {
            throw new Error("Target container is not a DOM element.");
          }
          if (parentComponent == null || !has2(parentComponent)) {
            throw new Error("parentComponent must be a valid React Component");
          }
          return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
        }
        var didWarnAboutUnmountComponentAtNode = false;
        function unmountComponentAtNode(container) {
          {
            if (!didWarnAboutUnmountComponentAtNode) {
              didWarnAboutUnmountComponentAtNode = true;
              error2("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
          }
          if (!isValidContainerLegacy(container)) {
            throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
            if (isModernRoot) {
              error2("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
            }
          }
          if (container._reactRootContainer) {
            {
              var rootEl = getReactRootElementInContainer(container);
              var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
              if (renderedByDifferentReact) {
                error2("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
              }
            }
            flushSync(function() {
              legacyRenderSubtreeIntoContainer(null, null, container, false, function() {
                container._reactRootContainer = null;
                unmarkContainerAsRoot(container);
              });
            });
            return true;
          } else {
            {
              var _rootEl = getReactRootElementInContainer(container);
              var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
              var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainerLegacy(container.parentNode) && !!container.parentNode._reactRootContainer;
              if (hasNonRootReactChild) {
                error2("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
              }
            }
            return false;
          }
        }
        setAttemptSynchronousHydration(attemptSynchronousHydration$1);
        setAttemptContinuousHydration(attemptContinuousHydration$1);
        setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
        setGetCurrentUpdatePriority(getCurrentUpdatePriority);
        setAttemptHydrationAtPriority(runWithPriority);
        {
          if (typeof Map !== "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
          Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
          Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
            error2("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
          }
        }
        setRestoreImplementation(restoreControlledState$3);
        setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync);
        function createPortal$1(children, container) {
          var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          if (!isValidContainer(container)) {
            throw new Error("Target container is not a DOM element.");
          }
          return createPortal(children, container, null, key);
        }
        function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
          return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
        }
        var Internals = {
          usingClientEntryPoint: false,
          // Keep in sync with ReactTestUtils.js.
          // This is an array for better minification.
          Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]
        };
        function createRoot$1(container, options2) {
          {
            if (!Internals.usingClientEntryPoint && true) {
              error2('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
            }
          }
          return createRoot7(container, options2);
        }
        function hydrateRoot$1(container, initialChildren, options2) {
          {
            if (!Internals.usingClientEntryPoint && true) {
              error2('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
            }
          }
          return hydrateRoot(container, initialChildren, options2);
        }
        function flushSync$1(fn) {
          {
            if (isAlreadyRendering()) {
              error2("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
            }
          }
          return flushSync(fn);
        }
        var foundDevTools = injectIntoDevTools({
          findFiberByHostInstance: getClosestInstanceFromNode,
          bundleType: 1,
          version: ReactVersion,
          rendererPackageName: "react-dom"
        });
        {
          if (!foundDevTools && canUseDOM && window.top === window.self) {
            if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
              var protocol = window.location.protocol;
              if (/^(https?|file):$/.test(protocol)) {
                console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
              }
            }
          }
        }
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
        exports.createPortal = createPortal$1;
        exports.createRoot = createRoot$1;
        exports.findDOMNode = findDOMNode;
        exports.flushSync = flushSync$1;
        exports.hydrate = hydrate;
        exports.hydrateRoot = hydrateRoot$1;
        exports.render = render;
        exports.unmountComponentAtNode = unmountComponentAtNode;
        exports.unstable_batchedUpdates = batchedUpdates$1;
        exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "node_modules/react-dom/index.js"(exports, module2) {
    "use strict";
    if (false) {
      checkDCE();
      module2.exports = null;
    } else {
      module2.exports = require_react_dom_development();
    }
  }
});

// node_modules/react-dom/client.js
var require_client = __commonJS({
  "node_modules/react-dom/client.js"(exports) {
    "use strict";
    var m = require_react_dom();
    if (false) {
      exports.createRoot = m.createRoot;
      exports.hydrateRoot = m.hydrateRoot;
    } else {
      i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      exports.createRoot = function(c, o) {
        i.usingClientEntryPoint = true;
        try {
          return m.createRoot(c, o);
        } finally {
          i.usingClientEntryPoint = false;
        }
      };
      exports.hydrateRoot = function(c, h, o) {
        i.usingClientEntryPoint = true;
        try {
          return m.hydrateRoot(c, h, o);
        } finally {
          i.usingClientEntryPoint = false;
        }
      };
    }
    var i;
  }
});

// lib/transformers.js
var transformers_exports = {};
__export(transformers_exports, {
  ASTFeatureExtractor: () => __webpack_exports__ASTFeatureExtractor,
  ASTForAudioClassification: () => __webpack_exports__ASTForAudioClassification,
  ASTModel: () => __webpack_exports__ASTModel,
  ASTPreTrainedModel: () => __webpack_exports__ASTPreTrainedModel,
  AlbertForMaskedLM: () => __webpack_exports__AlbertForMaskedLM,
  AlbertForQuestionAnswering: () => __webpack_exports__AlbertForQuestionAnswering,
  AlbertForSequenceClassification: () => __webpack_exports__AlbertForSequenceClassification,
  AlbertModel: () => __webpack_exports__AlbertModel,
  AlbertPreTrainedModel: () => __webpack_exports__AlbertPreTrainedModel,
  AlbertTokenizer: () => __webpack_exports__AlbertTokenizer,
  AudioClassificationPipeline: () => __webpack_exports__AudioClassificationPipeline,
  AutoConfig: () => __webpack_exports__AutoConfig,
  AutoModel: () => __webpack_exports__AutoModel,
  AutoModelForAudioClassification: () => __webpack_exports__AutoModelForAudioClassification,
  AutoModelForAudioFrameClassification: () => __webpack_exports__AutoModelForAudioFrameClassification,
  AutoModelForCTC: () => __webpack_exports__AutoModelForCTC,
  AutoModelForCausalLM: () => __webpack_exports__AutoModelForCausalLM,
  AutoModelForDepthEstimation: () => __webpack_exports__AutoModelForDepthEstimation,
  AutoModelForDocumentQuestionAnswering: () => __webpack_exports__AutoModelForDocumentQuestionAnswering,
  AutoModelForImageClassification: () => __webpack_exports__AutoModelForImageClassification,
  AutoModelForImageFeatureExtraction: () => __webpack_exports__AutoModelForImageFeatureExtraction,
  AutoModelForImageMatting: () => __webpack_exports__AutoModelForImageMatting,
  AutoModelForImageSegmentation: () => __webpack_exports__AutoModelForImageSegmentation,
  AutoModelForImageToImage: () => __webpack_exports__AutoModelForImageToImage,
  AutoModelForMaskGeneration: () => __webpack_exports__AutoModelForMaskGeneration,
  AutoModelForMaskedLM: () => __webpack_exports__AutoModelForMaskedLM,
  AutoModelForObjectDetection: () => __webpack_exports__AutoModelForObjectDetection,
  AutoModelForQuestionAnswering: () => __webpack_exports__AutoModelForQuestionAnswering,
  AutoModelForSemanticSegmentation: () => __webpack_exports__AutoModelForSemanticSegmentation,
  AutoModelForSeq2SeqLM: () => __webpack_exports__AutoModelForSeq2SeqLM,
  AutoModelForSequenceClassification: () => __webpack_exports__AutoModelForSequenceClassification,
  AutoModelForSpeechSeq2Seq: () => __webpack_exports__AutoModelForSpeechSeq2Seq,
  AutoModelForTextToSpectrogram: () => __webpack_exports__AutoModelForTextToSpectrogram,
  AutoModelForTextToWaveform: () => __webpack_exports__AutoModelForTextToWaveform,
  AutoModelForTokenClassification: () => __webpack_exports__AutoModelForTokenClassification,
  AutoModelForVision2Seq: () => __webpack_exports__AutoModelForVision2Seq,
  AutoModelForXVector: () => __webpack_exports__AutoModelForXVector,
  AutoModelForZeroShotObjectDetection: () => __webpack_exports__AutoModelForZeroShotObjectDetection,
  AutoProcessor: () => __webpack_exports__AutoProcessor,
  AutoTokenizer: () => __webpack_exports__AutoTokenizer,
  AutomaticSpeechRecognitionPipeline: () => __webpack_exports__AutomaticSpeechRecognitionPipeline,
  BartForConditionalGeneration: () => __webpack_exports__BartForConditionalGeneration,
  BartForSequenceClassification: () => __webpack_exports__BartForSequenceClassification,
  BartModel: () => __webpack_exports__BartModel,
  BartPretrainedModel: () => __webpack_exports__BartPretrainedModel,
  BartTokenizer: () => __webpack_exports__BartTokenizer,
  BaseModelOutput: () => __webpack_exports__BaseModelOutput,
  BeitFeatureExtractor: () => __webpack_exports__BeitFeatureExtractor,
  BeitForImageClassification: () => __webpack_exports__BeitForImageClassification,
  BeitModel: () => __webpack_exports__BeitModel,
  BeitPreTrainedModel: () => __webpack_exports__BeitPreTrainedModel,
  BertForMaskedLM: () => __webpack_exports__BertForMaskedLM,
  BertForQuestionAnswering: () => __webpack_exports__BertForQuestionAnswering,
  BertForSequenceClassification: () => __webpack_exports__BertForSequenceClassification,
  BertForTokenClassification: () => __webpack_exports__BertForTokenClassification,
  BertModel: () => __webpack_exports__BertModel,
  BertPreTrainedModel: () => __webpack_exports__BertPreTrainedModel,
  BertTokenizer: () => __webpack_exports__BertTokenizer,
  BitImageProcessor: () => __webpack_exports__BitImageProcessor,
  BlenderbotForConditionalGeneration: () => __webpack_exports__BlenderbotForConditionalGeneration,
  BlenderbotModel: () => __webpack_exports__BlenderbotModel,
  BlenderbotPreTrainedModel: () => __webpack_exports__BlenderbotPreTrainedModel,
  BlenderbotSmallForConditionalGeneration: () => __webpack_exports__BlenderbotSmallForConditionalGeneration,
  BlenderbotSmallModel: () => __webpack_exports__BlenderbotSmallModel,
  BlenderbotSmallPreTrainedModel: () => __webpack_exports__BlenderbotSmallPreTrainedModel,
  BlenderbotSmallTokenizer: () => __webpack_exports__BlenderbotSmallTokenizer,
  BlenderbotTokenizer: () => __webpack_exports__BlenderbotTokenizer,
  BloomForCausalLM: () => __webpack_exports__BloomForCausalLM,
  BloomModel: () => __webpack_exports__BloomModel,
  BloomPreTrainedModel: () => __webpack_exports__BloomPreTrainedModel,
  BloomTokenizer: () => __webpack_exports__BloomTokenizer,
  CLIPFeatureExtractor: () => __webpack_exports__CLIPFeatureExtractor,
  CLIPModel: () => __webpack_exports__CLIPModel,
  CLIPPreTrainedModel: () => __webpack_exports__CLIPPreTrainedModel,
  CLIPSegForImageSegmentation: () => __webpack_exports__CLIPSegForImageSegmentation,
  CLIPSegModel: () => __webpack_exports__CLIPSegModel,
  CLIPSegPreTrainedModel: () => __webpack_exports__CLIPSegPreTrainedModel,
  CLIPTextModelWithProjection: () => __webpack_exports__CLIPTextModelWithProjection,
  CLIPTokenizer: () => __webpack_exports__CLIPTokenizer,
  CLIPVisionModelWithProjection: () => __webpack_exports__CLIPVisionModelWithProjection,
  CamembertForMaskedLM: () => __webpack_exports__CamembertForMaskedLM,
  CamembertForQuestionAnswering: () => __webpack_exports__CamembertForQuestionAnswering,
  CamembertForSequenceClassification: () => __webpack_exports__CamembertForSequenceClassification,
  CamembertForTokenClassification: () => __webpack_exports__CamembertForTokenClassification,
  CamembertModel: () => __webpack_exports__CamembertModel,
  CamembertPreTrainedModel: () => __webpack_exports__CamembertPreTrainedModel,
  CamembertTokenizer: () => __webpack_exports__CamembertTokenizer,
  CausalLMOutput: () => __webpack_exports__CausalLMOutput,
  CausalLMOutputWithPast: () => __webpack_exports__CausalLMOutputWithPast,
  ChineseCLIPFeatureExtractor: () => __webpack_exports__ChineseCLIPFeatureExtractor,
  ChineseCLIPModel: () => __webpack_exports__ChineseCLIPModel,
  ChineseCLIPPreTrainedModel: () => __webpack_exports__ChineseCLIPPreTrainedModel,
  ClapAudioModelWithProjection: () => __webpack_exports__ClapAudioModelWithProjection,
  ClapFeatureExtractor: () => __webpack_exports__ClapFeatureExtractor,
  ClapModel: () => __webpack_exports__ClapModel,
  ClapPreTrainedModel: () => __webpack_exports__ClapPreTrainedModel,
  ClapTextModelWithProjection: () => __webpack_exports__ClapTextModelWithProjection,
  CodeGenForCausalLM: () => __webpack_exports__CodeGenForCausalLM,
  CodeGenModel: () => __webpack_exports__CodeGenModel,
  CodeGenPreTrainedModel: () => __webpack_exports__CodeGenPreTrainedModel,
  CodeGenTokenizer: () => __webpack_exports__CodeGenTokenizer,
  CodeLlamaTokenizer: () => __webpack_exports__CodeLlamaTokenizer,
  CohereTokenizer: () => __webpack_exports__CohereTokenizer,
  ConvBertForMaskedLM: () => __webpack_exports__ConvBertForMaskedLM,
  ConvBertForQuestionAnswering: () => __webpack_exports__ConvBertForQuestionAnswering,
  ConvBertForSequenceClassification: () => __webpack_exports__ConvBertForSequenceClassification,
  ConvBertForTokenClassification: () => __webpack_exports__ConvBertForTokenClassification,
  ConvBertModel: () => __webpack_exports__ConvBertModel,
  ConvBertPreTrainedModel: () => __webpack_exports__ConvBertPreTrainedModel,
  ConvBertTokenizer: () => __webpack_exports__ConvBertTokenizer,
  ConvNextFeatureExtractor: () => __webpack_exports__ConvNextFeatureExtractor,
  ConvNextForImageClassification: () => __webpack_exports__ConvNextForImageClassification,
  ConvNextImageProcessor: () => __webpack_exports__ConvNextImageProcessor,
  ConvNextModel: () => __webpack_exports__ConvNextModel,
  ConvNextPreTrainedModel: () => __webpack_exports__ConvNextPreTrainedModel,
  ConvNextV2ForImageClassification: () => __webpack_exports__ConvNextV2ForImageClassification,
  ConvNextV2Model: () => __webpack_exports__ConvNextV2Model,
  ConvNextV2PreTrainedModel: () => __webpack_exports__ConvNextV2PreTrainedModel,
  DPTFeatureExtractor: () => __webpack_exports__DPTFeatureExtractor,
  DPTForDepthEstimation: () => __webpack_exports__DPTForDepthEstimation,
  DPTImageProcessor: () => __webpack_exports__DPTImageProcessor,
  DPTModel: () => __webpack_exports__DPTModel,
  DPTPreTrainedModel: () => __webpack_exports__DPTPreTrainedModel,
  DebertaForMaskedLM: () => __webpack_exports__DebertaForMaskedLM,
  DebertaForQuestionAnswering: () => __webpack_exports__DebertaForQuestionAnswering,
  DebertaForSequenceClassification: () => __webpack_exports__DebertaForSequenceClassification,
  DebertaForTokenClassification: () => __webpack_exports__DebertaForTokenClassification,
  DebertaModel: () => __webpack_exports__DebertaModel,
  DebertaPreTrainedModel: () => __webpack_exports__DebertaPreTrainedModel,
  DebertaTokenizer: () => __webpack_exports__DebertaTokenizer,
  DebertaV2ForMaskedLM: () => __webpack_exports__DebertaV2ForMaskedLM,
  DebertaV2ForQuestionAnswering: () => __webpack_exports__DebertaV2ForQuestionAnswering,
  DebertaV2ForSequenceClassification: () => __webpack_exports__DebertaV2ForSequenceClassification,
  DebertaV2ForTokenClassification: () => __webpack_exports__DebertaV2ForTokenClassification,
  DebertaV2Model: () => __webpack_exports__DebertaV2Model,
  DebertaV2PreTrainedModel: () => __webpack_exports__DebertaV2PreTrainedModel,
  DebertaV2Tokenizer: () => __webpack_exports__DebertaV2Tokenizer,
  DeiTFeatureExtractor: () => __webpack_exports__DeiTFeatureExtractor,
  DeiTForImageClassification: () => __webpack_exports__DeiTForImageClassification,
  DeiTModel: () => __webpack_exports__DeiTModel,
  DeiTPreTrainedModel: () => __webpack_exports__DeiTPreTrainedModel,
  DepthAnythingForDepthEstimation: () => __webpack_exports__DepthAnythingForDepthEstimation,
  DepthAnythingPreTrainedModel: () => __webpack_exports__DepthAnythingPreTrainedModel,
  DepthEstimationPipeline: () => __webpack_exports__DepthEstimationPipeline,
  DetrFeatureExtractor: () => __webpack_exports__DetrFeatureExtractor,
  DetrForObjectDetection: () => __webpack_exports__DetrForObjectDetection,
  DetrForSegmentation: () => __webpack_exports__DetrForSegmentation,
  DetrModel: () => __webpack_exports__DetrModel,
  DetrObjectDetectionOutput: () => __webpack_exports__DetrObjectDetectionOutput,
  DetrPreTrainedModel: () => __webpack_exports__DetrPreTrainedModel,
  DetrSegmentationOutput: () => __webpack_exports__DetrSegmentationOutput,
  Dinov2ForImageClassification: () => __webpack_exports__Dinov2ForImageClassification,
  Dinov2Model: () => __webpack_exports__Dinov2Model,
  Dinov2PreTrainedModel: () => __webpack_exports__Dinov2PreTrainedModel,
  DistilBertForMaskedLM: () => __webpack_exports__DistilBertForMaskedLM,
  DistilBertForQuestionAnswering: () => __webpack_exports__DistilBertForQuestionAnswering,
  DistilBertForSequenceClassification: () => __webpack_exports__DistilBertForSequenceClassification,
  DistilBertForTokenClassification: () => __webpack_exports__DistilBertForTokenClassification,
  DistilBertModel: () => __webpack_exports__DistilBertModel,
  DistilBertPreTrainedModel: () => __webpack_exports__DistilBertPreTrainedModel,
  DistilBertTokenizer: () => __webpack_exports__DistilBertTokenizer,
  DocumentQuestionAnsweringPipeline: () => __webpack_exports__DocumentQuestionAnsweringPipeline,
  DonutFeatureExtractor: () => __webpack_exports__DonutFeatureExtractor,
  DonutSwinModel: () => __webpack_exports__DonutSwinModel,
  DonutSwinPreTrainedModel: () => __webpack_exports__DonutSwinPreTrainedModel,
  EfficientNetForImageClassification: () => __webpack_exports__EfficientNetForImageClassification,
  EfficientNetImageProcessor: () => __webpack_exports__EfficientNetImageProcessor,
  EfficientNetModel: () => __webpack_exports__EfficientNetModel,
  EfficientNetPreTrainedModel: () => __webpack_exports__EfficientNetPreTrainedModel,
  ElectraForMaskedLM: () => __webpack_exports__ElectraForMaskedLM,
  ElectraForQuestionAnswering: () => __webpack_exports__ElectraForQuestionAnswering,
  ElectraForSequenceClassification: () => __webpack_exports__ElectraForSequenceClassification,
  ElectraForTokenClassification: () => __webpack_exports__ElectraForTokenClassification,
  ElectraModel: () => __webpack_exports__ElectraModel,
  ElectraPreTrainedModel: () => __webpack_exports__ElectraPreTrainedModel,
  ElectraTokenizer: () => __webpack_exports__ElectraTokenizer,
  EsmForMaskedLM: () => __webpack_exports__EsmForMaskedLM,
  EsmForSequenceClassification: () => __webpack_exports__EsmForSequenceClassification,
  EsmForTokenClassification: () => __webpack_exports__EsmForTokenClassification,
  EsmModel: () => __webpack_exports__EsmModel,
  EsmPreTrainedModel: () => __webpack_exports__EsmPreTrainedModel,
  EsmTokenizer: () => __webpack_exports__EsmTokenizer,
  FFT: () => __webpack_exports__FFT,
  FalconForCausalLM: () => __webpack_exports__FalconForCausalLM,
  FalconModel: () => __webpack_exports__FalconModel,
  FalconPreTrainedModel: () => __webpack_exports__FalconPreTrainedModel,
  FalconTokenizer: () => __webpack_exports__FalconTokenizer,
  FastViTForImageClassification: () => __webpack_exports__FastViTForImageClassification,
  FastViTModel: () => __webpack_exports__FastViTModel,
  FastViTPreTrainedModel: () => __webpack_exports__FastViTPreTrainedModel,
  FeatureExtractionPipeline: () => __webpack_exports__FeatureExtractionPipeline,
  FeatureExtractor: () => __webpack_exports__FeatureExtractor,
  FillMaskPipeline: () => __webpack_exports__FillMaskPipeline,
  GLPNFeatureExtractor: () => __webpack_exports__GLPNFeatureExtractor,
  GLPNForDepthEstimation: () => __webpack_exports__GLPNForDepthEstimation,
  GLPNModel: () => __webpack_exports__GLPNModel,
  GLPNPreTrainedModel: () => __webpack_exports__GLPNPreTrainedModel,
  GPT2LMHeadModel: () => __webpack_exports__GPT2LMHeadModel,
  GPT2Model: () => __webpack_exports__GPT2Model,
  GPT2PreTrainedModel: () => __webpack_exports__GPT2PreTrainedModel,
  GPT2Tokenizer: () => __webpack_exports__GPT2Tokenizer,
  GPTBigCodeForCausalLM: () => __webpack_exports__GPTBigCodeForCausalLM,
  GPTBigCodeModel: () => __webpack_exports__GPTBigCodeModel,
  GPTBigCodePreTrainedModel: () => __webpack_exports__GPTBigCodePreTrainedModel,
  GPTJForCausalLM: () => __webpack_exports__GPTJForCausalLM,
  GPTJModel: () => __webpack_exports__GPTJModel,
  GPTJPreTrainedModel: () => __webpack_exports__GPTJPreTrainedModel,
  GPTNeoForCausalLM: () => __webpack_exports__GPTNeoForCausalLM,
  GPTNeoModel: () => __webpack_exports__GPTNeoModel,
  GPTNeoPreTrainedModel: () => __webpack_exports__GPTNeoPreTrainedModel,
  GPTNeoXForCausalLM: () => __webpack_exports__GPTNeoXForCausalLM,
  GPTNeoXModel: () => __webpack_exports__GPTNeoXModel,
  GPTNeoXPreTrainedModel: () => __webpack_exports__GPTNeoXPreTrainedModel,
  GPTNeoXTokenizer: () => __webpack_exports__GPTNeoXTokenizer,
  GemmaTokenizer: () => __webpack_exports__GemmaTokenizer,
  Grok1Tokenizer: () => __webpack_exports__Grok1Tokenizer,
  HerbertTokenizer: () => __webpack_exports__HerbertTokenizer,
  HubertForCTC: () => __webpack_exports__HubertForCTC,
  HubertForSequenceClassification: () => __webpack_exports__HubertForSequenceClassification,
  HubertModel: () => __webpack_exports__HubertModel,
  HubertPreTrainedModel: () => __webpack_exports__HubertPreTrainedModel,
  ImageClassificationPipeline: () => __webpack_exports__ImageClassificationPipeline,
  ImageFeatureExtractionPipeline: () => __webpack_exports__ImageFeatureExtractionPipeline,
  ImageFeatureExtractor: () => __webpack_exports__ImageFeatureExtractor,
  ImageMattingOutput: () => __webpack_exports__ImageMattingOutput,
  ImageSegmentationPipeline: () => __webpack_exports__ImageSegmentationPipeline,
  ImageToImagePipeline: () => __webpack_exports__ImageToImagePipeline,
  ImageToTextPipeline: () => __webpack_exports__ImageToTextPipeline,
  LlamaForCausalLM: () => __webpack_exports__LlamaForCausalLM,
  LlamaModel: () => __webpack_exports__LlamaModel,
  LlamaPreTrainedModel: () => __webpack_exports__LlamaPreTrainedModel,
  LlamaTokenizer: () => __webpack_exports__LlamaTokenizer,
  LongT5ForConditionalGeneration: () => __webpack_exports__LongT5ForConditionalGeneration,
  LongT5Model: () => __webpack_exports__LongT5Model,
  LongT5PreTrainedModel: () => __webpack_exports__LongT5PreTrainedModel,
  M2M100ForConditionalGeneration: () => __webpack_exports__M2M100ForConditionalGeneration,
  M2M100Model: () => __webpack_exports__M2M100Model,
  M2M100PreTrainedModel: () => __webpack_exports__M2M100PreTrainedModel,
  M2M100Tokenizer: () => __webpack_exports__M2M100Tokenizer,
  MBart50Tokenizer: () => __webpack_exports__MBart50Tokenizer,
  MBartForCausalLM: () => __webpack_exports__MBartForCausalLM,
  MBartForConditionalGeneration: () => __webpack_exports__MBartForConditionalGeneration,
  MBartForSequenceClassification: () => __webpack_exports__MBartForSequenceClassification,
  MBartModel: () => __webpack_exports__MBartModel,
  MBartPreTrainedModel: () => __webpack_exports__MBartPreTrainedModel,
  MBartTokenizer: () => __webpack_exports__MBartTokenizer,
  MPNetForMaskedLM: () => __webpack_exports__MPNetForMaskedLM,
  MPNetForQuestionAnswering: () => __webpack_exports__MPNetForQuestionAnswering,
  MPNetForSequenceClassification: () => __webpack_exports__MPNetForSequenceClassification,
  MPNetForTokenClassification: () => __webpack_exports__MPNetForTokenClassification,
  MPNetModel: () => __webpack_exports__MPNetModel,
  MPNetPreTrainedModel: () => __webpack_exports__MPNetPreTrainedModel,
  MPNetTokenizer: () => __webpack_exports__MPNetTokenizer,
  MT5ForConditionalGeneration: () => __webpack_exports__MT5ForConditionalGeneration,
  MT5Model: () => __webpack_exports__MT5Model,
  MT5PreTrainedModel: () => __webpack_exports__MT5PreTrainedModel,
  MarianMTModel: () => __webpack_exports__MarianMTModel,
  MarianModel: () => __webpack_exports__MarianModel,
  MarianPreTrainedModel: () => __webpack_exports__MarianPreTrainedModel,
  MarianTokenizer: () => __webpack_exports__MarianTokenizer,
  MaskedLMOutput: () => __webpack_exports__MaskedLMOutput,
  MistralForCausalLM: () => __webpack_exports__MistralForCausalLM,
  MistralModel: () => __webpack_exports__MistralModel,
  MistralPreTrainedModel: () => __webpack_exports__MistralPreTrainedModel,
  MobileBertForMaskedLM: () => __webpack_exports__MobileBertForMaskedLM,
  MobileBertForQuestionAnswering: () => __webpack_exports__MobileBertForQuestionAnswering,
  MobileBertForSequenceClassification: () => __webpack_exports__MobileBertForSequenceClassification,
  MobileBertModel: () => __webpack_exports__MobileBertModel,
  MobileBertPreTrainedModel: () => __webpack_exports__MobileBertPreTrainedModel,
  MobileBertTokenizer: () => __webpack_exports__MobileBertTokenizer,
  MobileViTFeatureExtractor: () => __webpack_exports__MobileViTFeatureExtractor,
  MobileViTForImageClassification: () => __webpack_exports__MobileViTForImageClassification,
  MobileViTImageProcessor: () => __webpack_exports__MobileViTImageProcessor,
  MobileViTModel: () => __webpack_exports__MobileViTModel,
  MobileViTPreTrainedModel: () => __webpack_exports__MobileViTPreTrainedModel,
  MobileViTV2ForImageClassification: () => __webpack_exports__MobileViTV2ForImageClassification,
  MobileViTV2Model: () => __webpack_exports__MobileViTV2Model,
  MobileViTV2PreTrainedModel: () => __webpack_exports__MobileViTV2PreTrainedModel,
  ModelOutput: () => __webpack_exports__ModelOutput,
  MptForCausalLM: () => __webpack_exports__MptForCausalLM,
  MptModel: () => __webpack_exports__MptModel,
  MptPreTrainedModel: () => __webpack_exports__MptPreTrainedModel,
  NllbTokenizer: () => __webpack_exports__NllbTokenizer,
  NomicBertModel: () => __webpack_exports__NomicBertModel,
  NomicBertPreTrainedModel: () => __webpack_exports__NomicBertPreTrainedModel,
  NougatImageProcessor: () => __webpack_exports__NougatImageProcessor,
  NougatTokenizer: () => __webpack_exports__NougatTokenizer,
  OPTForCausalLM: () => __webpack_exports__OPTForCausalLM,
  OPTModel: () => __webpack_exports__OPTModel,
  OPTPreTrainedModel: () => __webpack_exports__OPTPreTrainedModel,
  ObjectDetectionPipeline: () => __webpack_exports__ObjectDetectionPipeline,
  OwlViTFeatureExtractor: () => __webpack_exports__OwlViTFeatureExtractor,
  OwlViTForObjectDetection: () => __webpack_exports__OwlViTForObjectDetection,
  OwlViTModel: () => __webpack_exports__OwlViTModel,
  OwlViTPreTrainedModel: () => __webpack_exports__OwlViTPreTrainedModel,
  OwlViTProcessor: () => __webpack_exports__OwlViTProcessor,
  Owlv2ForObjectDetection: () => __webpack_exports__Owlv2ForObjectDetection,
  Owlv2ImageProcessor: () => __webpack_exports__Owlv2ImageProcessor,
  Owlv2Model: () => __webpack_exports__Owlv2Model,
  Owlv2PreTrainedModel: () => __webpack_exports__Owlv2PreTrainedModel,
  PhiForCausalLM: () => __webpack_exports__PhiForCausalLM,
  PhiModel: () => __webpack_exports__PhiModel,
  PhiPreTrainedModel: () => __webpack_exports__PhiPreTrainedModel,
  Pipeline: () => __webpack_exports__Pipeline,
  PreTrainedModel: () => __webpack_exports__PreTrainedModel,
  PreTrainedTokenizer: () => __webpack_exports__PreTrainedTokenizer,
  PretrainedConfig: () => __webpack_exports__PretrainedConfig,
  PretrainedMixin: () => __webpack_exports__PretrainedMixin,
  Processor: () => __webpack_exports__Processor,
  QuestionAnsweringModelOutput: () => __webpack_exports__QuestionAnsweringModelOutput,
  QuestionAnsweringPipeline: () => __webpack_exports__QuestionAnsweringPipeline,
  Qwen2ForCausalLM: () => __webpack_exports__Qwen2ForCausalLM,
  Qwen2Model: () => __webpack_exports__Qwen2Model,
  Qwen2PreTrainedModel: () => __webpack_exports__Qwen2PreTrainedModel,
  Qwen2Tokenizer: () => __webpack_exports__Qwen2Tokenizer,
  RawImage: () => __webpack_exports__RawImage,
  ResNetForImageClassification: () => __webpack_exports__ResNetForImageClassification,
  ResNetModel: () => __webpack_exports__ResNetModel,
  ResNetPreTrainedModel: () => __webpack_exports__ResNetPreTrainedModel,
  RoFormerForMaskedLM: () => __webpack_exports__RoFormerForMaskedLM,
  RoFormerForQuestionAnswering: () => __webpack_exports__RoFormerForQuestionAnswering,
  RoFormerForSequenceClassification: () => __webpack_exports__RoFormerForSequenceClassification,
  RoFormerForTokenClassification: () => __webpack_exports__RoFormerForTokenClassification,
  RoFormerModel: () => __webpack_exports__RoFormerModel,
  RoFormerPreTrainedModel: () => __webpack_exports__RoFormerPreTrainedModel,
  RoFormerTokenizer: () => __webpack_exports__RoFormerTokenizer,
  RobertaForMaskedLM: () => __webpack_exports__RobertaForMaskedLM,
  RobertaForQuestionAnswering: () => __webpack_exports__RobertaForQuestionAnswering,
  RobertaForSequenceClassification: () => __webpack_exports__RobertaForSequenceClassification,
  RobertaForTokenClassification: () => __webpack_exports__RobertaForTokenClassification,
  RobertaModel: () => __webpack_exports__RobertaModel,
  RobertaPreTrainedModel: () => __webpack_exports__RobertaPreTrainedModel,
  RobertaTokenizer: () => __webpack_exports__RobertaTokenizer,
  SamImageProcessor: () => __webpack_exports__SamImageProcessor,
  SamImageSegmentationOutput: () => __webpack_exports__SamImageSegmentationOutput,
  SamModel: () => __webpack_exports__SamModel,
  SamPreTrainedModel: () => __webpack_exports__SamPreTrainedModel,
  SamProcessor: () => __webpack_exports__SamProcessor,
  SeamlessM4TFeatureExtractor: () => __webpack_exports__SeamlessM4TFeatureExtractor,
  SegformerFeatureExtractor: () => __webpack_exports__SegformerFeatureExtractor,
  SegformerForImageClassification: () => __webpack_exports__SegformerForImageClassification,
  SegformerForSemanticSegmentation: () => __webpack_exports__SegformerForSemanticSegmentation,
  SegformerModel: () => __webpack_exports__SegformerModel,
  SegformerPreTrainedModel: () => __webpack_exports__SegformerPreTrainedModel,
  Seq2SeqLMOutput: () => __webpack_exports__Seq2SeqLMOutput,
  SequenceClassifierOutput: () => __webpack_exports__SequenceClassifierOutput,
  SiglipImageProcessor: () => __webpack_exports__SiglipImageProcessor,
  SiglipModel: () => __webpack_exports__SiglipModel,
  SiglipPreTrainedModel: () => __webpack_exports__SiglipPreTrainedModel,
  SiglipTextModel: () => __webpack_exports__SiglipTextModel,
  SiglipTokenizer: () => __webpack_exports__SiglipTokenizer,
  SiglipVisionModel: () => __webpack_exports__SiglipVisionModel,
  SpeechT5FeatureExtractor: () => __webpack_exports__SpeechT5FeatureExtractor,
  SpeechT5ForSpeechToText: () => __webpack_exports__SpeechT5ForSpeechToText,
  SpeechT5ForTextToSpeech: () => __webpack_exports__SpeechT5ForTextToSpeech,
  SpeechT5HifiGan: () => __webpack_exports__SpeechT5HifiGan,
  SpeechT5Model: () => __webpack_exports__SpeechT5Model,
  SpeechT5PreTrainedModel: () => __webpack_exports__SpeechT5PreTrainedModel,
  SpeechT5Processor: () => __webpack_exports__SpeechT5Processor,
  SpeechT5Tokenizer: () => __webpack_exports__SpeechT5Tokenizer,
  SqueezeBertForMaskedLM: () => __webpack_exports__SqueezeBertForMaskedLM,
  SqueezeBertForQuestionAnswering: () => __webpack_exports__SqueezeBertForQuestionAnswering,
  SqueezeBertForSequenceClassification: () => __webpack_exports__SqueezeBertForSequenceClassification,
  SqueezeBertModel: () => __webpack_exports__SqueezeBertModel,
  SqueezeBertPreTrainedModel: () => __webpack_exports__SqueezeBertPreTrainedModel,
  SqueezeBertTokenizer: () => __webpack_exports__SqueezeBertTokenizer,
  StableLmForCausalLM: () => __webpack_exports__StableLmForCausalLM,
  StableLmModel: () => __webpack_exports__StableLmModel,
  StableLmPreTrainedModel: () => __webpack_exports__StableLmPreTrainedModel,
  Starcoder2ForCausalLM: () => __webpack_exports__Starcoder2ForCausalLM,
  Starcoder2Model: () => __webpack_exports__Starcoder2Model,
  Starcoder2PreTrainedModel: () => __webpack_exports__Starcoder2PreTrainedModel,
  SummarizationPipeline: () => __webpack_exports__SummarizationPipeline,
  Swin2SRForImageSuperResolution: () => __webpack_exports__Swin2SRForImageSuperResolution,
  Swin2SRImageProcessor: () => __webpack_exports__Swin2SRImageProcessor,
  Swin2SRModel: () => __webpack_exports__Swin2SRModel,
  Swin2SRPreTrainedModel: () => __webpack_exports__Swin2SRPreTrainedModel,
  SwinForImageClassification: () => __webpack_exports__SwinForImageClassification,
  SwinModel: () => __webpack_exports__SwinModel,
  SwinPreTrainedModel: () => __webpack_exports__SwinPreTrainedModel,
  T5ForConditionalGeneration: () => __webpack_exports__T5ForConditionalGeneration,
  T5Model: () => __webpack_exports__T5Model,
  T5PreTrainedModel: () => __webpack_exports__T5PreTrainedModel,
  T5Tokenizer: () => __webpack_exports__T5Tokenizer,
  TableTransformerForObjectDetection: () => __webpack_exports__TableTransformerForObjectDetection,
  TableTransformerModel: () => __webpack_exports__TableTransformerModel,
  TableTransformerObjectDetectionOutput: () => __webpack_exports__TableTransformerObjectDetectionOutput,
  TableTransformerPreTrainedModel: () => __webpack_exports__TableTransformerPreTrainedModel,
  Tensor: () => __webpack_exports__Tensor,
  Text2TextGenerationPipeline: () => __webpack_exports__Text2TextGenerationPipeline,
  TextClassificationPipeline: () => __webpack_exports__TextClassificationPipeline,
  TextGenerationPipeline: () => __webpack_exports__TextGenerationPipeline,
  TextToAudioPipeline: () => __webpack_exports__TextToAudioPipeline,
  TokenClassificationPipeline: () => __webpack_exports__TokenClassificationPipeline,
  TokenClassifierOutput: () => __webpack_exports__TokenClassifierOutput,
  TokenizerModel: () => __webpack_exports__TokenizerModel,
  TrOCRForCausalLM: () => __webpack_exports__TrOCRForCausalLM,
  TrOCRPreTrainedModel: () => __webpack_exports__TrOCRPreTrainedModel,
  TranslationPipeline: () => __webpack_exports__TranslationPipeline,
  UniSpeechForCTC: () => __webpack_exports__UniSpeechForCTC,
  UniSpeechForSequenceClassification: () => __webpack_exports__UniSpeechForSequenceClassification,
  UniSpeechModel: () => __webpack_exports__UniSpeechModel,
  UniSpeechPreTrainedModel: () => __webpack_exports__UniSpeechPreTrainedModel,
  UniSpeechSatForAudioFrameClassification: () => __webpack_exports__UniSpeechSatForAudioFrameClassification,
  UniSpeechSatForCTC: () => __webpack_exports__UniSpeechSatForCTC,
  UniSpeechSatForSequenceClassification: () => __webpack_exports__UniSpeechSatForSequenceClassification,
  UniSpeechSatModel: () => __webpack_exports__UniSpeechSatModel,
  UniSpeechSatPreTrainedModel: () => __webpack_exports__UniSpeechSatPreTrainedModel,
  ViTFeatureExtractor: () => __webpack_exports__ViTFeatureExtractor,
  ViTForImageClassification: () => __webpack_exports__ViTForImageClassification,
  ViTImageProcessor: () => __webpack_exports__ViTImageProcessor,
  ViTModel: () => __webpack_exports__ViTModel,
  ViTPreTrainedModel: () => __webpack_exports__ViTPreTrainedModel,
  VisionEncoderDecoderModel: () => __webpack_exports__VisionEncoderDecoderModel,
  VitMatteForImageMatting: () => __webpack_exports__VitMatteForImageMatting,
  VitMatteImageProcessor: () => __webpack_exports__VitMatteImageProcessor,
  VitMattePreTrainedModel: () => __webpack_exports__VitMattePreTrainedModel,
  VitsModel: () => __webpack_exports__VitsModel,
  VitsModelOutput: () => __webpack_exports__VitsModelOutput,
  VitsPreTrainedModel: () => __webpack_exports__VitsPreTrainedModel,
  VitsTokenizer: () => __webpack_exports__VitsTokenizer,
  Wav2Vec2BertForCTC: () => __webpack_exports__Wav2Vec2BertForCTC,
  Wav2Vec2BertForSequenceClassification: () => __webpack_exports__Wav2Vec2BertForSequenceClassification,
  Wav2Vec2BertModel: () => __webpack_exports__Wav2Vec2BertModel,
  Wav2Vec2BertPreTrainedModel: () => __webpack_exports__Wav2Vec2BertPreTrainedModel,
  Wav2Vec2CTCTokenizer: () => __webpack_exports__Wav2Vec2CTCTokenizer,
  Wav2Vec2FeatureExtractor: () => __webpack_exports__Wav2Vec2FeatureExtractor,
  Wav2Vec2ForAudioFrameClassification: () => __webpack_exports__Wav2Vec2ForAudioFrameClassification,
  Wav2Vec2ForCTC: () => __webpack_exports__Wav2Vec2ForCTC,
  Wav2Vec2ForSequenceClassification: () => __webpack_exports__Wav2Vec2ForSequenceClassification,
  Wav2Vec2Model: () => __webpack_exports__Wav2Vec2Model,
  Wav2Vec2PreTrainedModel: () => __webpack_exports__Wav2Vec2PreTrainedModel,
  Wav2Vec2ProcessorWithLM: () => __webpack_exports__Wav2Vec2ProcessorWithLM,
  WavLMForAudioFrameClassification: () => __webpack_exports__WavLMForAudioFrameClassification,
  WavLMForCTC: () => __webpack_exports__WavLMForCTC,
  WavLMForSequenceClassification: () => __webpack_exports__WavLMForSequenceClassification,
  WavLMForXVector: () => __webpack_exports__WavLMForXVector,
  WavLMModel: () => __webpack_exports__WavLMModel,
  WavLMPreTrainedModel: () => __webpack_exports__WavLMPreTrainedModel,
  WhisperFeatureExtractor: () => __webpack_exports__WhisperFeatureExtractor,
  WhisperForConditionalGeneration: () => __webpack_exports__WhisperForConditionalGeneration,
  WhisperModel: () => __webpack_exports__WhisperModel,
  WhisperPreTrainedModel: () => __webpack_exports__WhisperPreTrainedModel,
  WhisperProcessor: () => __webpack_exports__WhisperProcessor,
  WhisperTokenizer: () => __webpack_exports__WhisperTokenizer,
  XLMForQuestionAnswering: () => __webpack_exports__XLMForQuestionAnswering,
  XLMForSequenceClassification: () => __webpack_exports__XLMForSequenceClassification,
  XLMForTokenClassification: () => __webpack_exports__XLMForTokenClassification,
  XLMModel: () => __webpack_exports__XLMModel,
  XLMPreTrainedModel: () => __webpack_exports__XLMPreTrainedModel,
  XLMRobertaForMaskedLM: () => __webpack_exports__XLMRobertaForMaskedLM,
  XLMRobertaForQuestionAnswering: () => __webpack_exports__XLMRobertaForQuestionAnswering,
  XLMRobertaForSequenceClassification: () => __webpack_exports__XLMRobertaForSequenceClassification,
  XLMRobertaForTokenClassification: () => __webpack_exports__XLMRobertaForTokenClassification,
  XLMRobertaModel: () => __webpack_exports__XLMRobertaModel,
  XLMRobertaPreTrainedModel: () => __webpack_exports__XLMRobertaPreTrainedModel,
  XLMRobertaTokenizer: () => __webpack_exports__XLMRobertaTokenizer,
  XLMTokenizer: () => __webpack_exports__XLMTokenizer,
  XLMWithLMHeadModel: () => __webpack_exports__XLMWithLMHeadModel,
  XVectorOutput: () => __webpack_exports__XVectorOutput,
  YolosFeatureExtractor: () => __webpack_exports__YolosFeatureExtractor,
  YolosForObjectDetection: () => __webpack_exports__YolosForObjectDetection,
  YolosModel: () => __webpack_exports__YolosModel,
  YolosObjectDetectionOutput: () => __webpack_exports__YolosObjectDetectionOutput,
  YolosPreTrainedModel: () => __webpack_exports__YolosPreTrainedModel,
  ZeroShotAudioClassificationPipeline: () => __webpack_exports__ZeroShotAudioClassificationPipeline,
  ZeroShotClassificationPipeline: () => __webpack_exports__ZeroShotClassificationPipeline,
  ZeroShotImageClassificationPipeline: () => __webpack_exports__ZeroShotImageClassificationPipeline,
  ZeroShotObjectDetectionPipeline: () => __webpack_exports__ZeroShotObjectDetectionPipeline,
  bankers_round: () => __webpack_exports__bankers_round,
  cat: () => __webpack_exports__cat,
  cos_sim: () => __webpack_exports__cos_sim,
  dot: () => __webpack_exports__dot,
  dynamicTimeWarping: () => __webpack_exports__dynamicTimeWarping,
  env: () => __webpack_exports__env,
  getTopItems: () => __webpack_exports__getTopItems,
  hanning: () => __webpack_exports__hanning,
  interpolate: () => __webpack_exports__interpolate,
  interpolate_data: () => __webpack_exports__interpolate_data,
  layer_norm: () => __webpack_exports__layer_norm,
  log_softmax: () => __webpack_exports__log_softmax,
  magnitude: () => __webpack_exports__magnitude,
  max: () => __webpack_exports__max,
  mean: () => __webpack_exports__mean,
  mean_pooling: () => __webpack_exports__mean_pooling,
  medianFilter: () => __webpack_exports__medianFilter,
  mel_filter_bank: () => __webpack_exports__mel_filter_bank,
  min: () => __webpack_exports__min,
  ones: () => __webpack_exports__ones,
  ones_like: () => __webpack_exports__ones_like,
  permute: () => __webpack_exports__permute,
  permute_data: () => __webpack_exports__permute_data,
  pipeline: () => __webpack_exports__pipeline,
  quantize_embeddings: () => __webpack_exports__quantize_embeddings,
  read_audio: () => __webpack_exports__read_audio,
  round: () => __webpack_exports__round,
  softmax: () => __webpack_exports__softmax,
  spectrogram: () => __webpack_exports__spectrogram,
  stack: () => __webpack_exports__stack,
  std_mean: () => __webpack_exports__std_mean,
  window_function: () => __webpack_exports__window_function
});
function __webpack_require__2(moduleId) {
  var cachedModule = __webpack_module_cache__2[moduleId];
  if (cachedModule !== void 0) {
    return cachedModule.exports;
  }
  var module2 = __webpack_module_cache__2[moduleId] = {
    /******/
    // no module.id needed
    /******/
    // no module.loaded needed
    /******/
    exports: {}
    /******/
  };
  __webpack_modules__2[moduleId](module2, module2.exports, __webpack_require__2);
  return module2.exports;
}
var __webpack_modules__2, __webpack_module_cache__2, __webpack_exports__, __webpack_exports__ASTFeatureExtractor, __webpack_exports__ASTForAudioClassification, __webpack_exports__ASTModel, __webpack_exports__ASTPreTrainedModel, __webpack_exports__AlbertForMaskedLM, __webpack_exports__AlbertForQuestionAnswering, __webpack_exports__AlbertForSequenceClassification, __webpack_exports__AlbertModel, __webpack_exports__AlbertPreTrainedModel, __webpack_exports__AlbertTokenizer, __webpack_exports__AudioClassificationPipeline, __webpack_exports__AutoConfig, __webpack_exports__AutoModel, __webpack_exports__AutoModelForAudioClassification, __webpack_exports__AutoModelForAudioFrameClassification, __webpack_exports__AutoModelForCTC, __webpack_exports__AutoModelForCausalLM, __webpack_exports__AutoModelForDepthEstimation, __webpack_exports__AutoModelForDocumentQuestionAnswering, __webpack_exports__AutoModelForImageClassification, __webpack_exports__AutoModelForImageFeatureExtraction, __webpack_exports__AutoModelForImageMatting, __webpack_exports__AutoModelForImageSegmentation, __webpack_exports__AutoModelForImageToImage, __webpack_exports__AutoModelForMaskGeneration, __webpack_exports__AutoModelForMaskedLM, __webpack_exports__AutoModelForObjectDetection, __webpack_exports__AutoModelForQuestionAnswering, __webpack_exports__AutoModelForSemanticSegmentation, __webpack_exports__AutoModelForSeq2SeqLM, __webpack_exports__AutoModelForSequenceClassification, __webpack_exports__AutoModelForSpeechSeq2Seq, __webpack_exports__AutoModelForTextToSpectrogram, __webpack_exports__AutoModelForTextToWaveform, __webpack_exports__AutoModelForTokenClassification, __webpack_exports__AutoModelForVision2Seq, __webpack_exports__AutoModelForXVector, __webpack_exports__AutoModelForZeroShotObjectDetection, __webpack_exports__AutoProcessor, __webpack_exports__AutoTokenizer, __webpack_exports__AutomaticSpeechRecognitionPipeline, __webpack_exports__BartForConditionalGeneration, __webpack_exports__BartForSequenceClassification, __webpack_exports__BartModel, __webpack_exports__BartPretrainedModel, __webpack_exports__BartTokenizer, __webpack_exports__BaseModelOutput, __webpack_exports__BeitFeatureExtractor, __webpack_exports__BeitForImageClassification, __webpack_exports__BeitModel, __webpack_exports__BeitPreTrainedModel, __webpack_exports__BertForMaskedLM, __webpack_exports__BertForQuestionAnswering, __webpack_exports__BertForSequenceClassification, __webpack_exports__BertForTokenClassification, __webpack_exports__BertModel, __webpack_exports__BertPreTrainedModel, __webpack_exports__BertTokenizer, __webpack_exports__BitImageProcessor, __webpack_exports__BlenderbotForConditionalGeneration, __webpack_exports__BlenderbotModel, __webpack_exports__BlenderbotPreTrainedModel, __webpack_exports__BlenderbotSmallForConditionalGeneration, __webpack_exports__BlenderbotSmallModel, __webpack_exports__BlenderbotSmallPreTrainedModel, __webpack_exports__BlenderbotSmallTokenizer, __webpack_exports__BlenderbotTokenizer, __webpack_exports__BloomForCausalLM, __webpack_exports__BloomModel, __webpack_exports__BloomPreTrainedModel, __webpack_exports__BloomTokenizer, __webpack_exports__CLIPFeatureExtractor, __webpack_exports__CLIPModel, __webpack_exports__CLIPPreTrainedModel, __webpack_exports__CLIPSegForImageSegmentation, __webpack_exports__CLIPSegModel, __webpack_exports__CLIPSegPreTrainedModel, __webpack_exports__CLIPTextModelWithProjection, __webpack_exports__CLIPTokenizer, __webpack_exports__CLIPVisionModelWithProjection, __webpack_exports__CamembertForMaskedLM, __webpack_exports__CamembertForQuestionAnswering, __webpack_exports__CamembertForSequenceClassification, __webpack_exports__CamembertForTokenClassification, __webpack_exports__CamembertModel, __webpack_exports__CamembertPreTrainedModel, __webpack_exports__CamembertTokenizer, __webpack_exports__CausalLMOutput, __webpack_exports__CausalLMOutputWithPast, __webpack_exports__ChineseCLIPFeatureExtractor, __webpack_exports__ChineseCLIPModel, __webpack_exports__ChineseCLIPPreTrainedModel, __webpack_exports__ClapAudioModelWithProjection, __webpack_exports__ClapFeatureExtractor, __webpack_exports__ClapModel, __webpack_exports__ClapPreTrainedModel, __webpack_exports__ClapTextModelWithProjection, __webpack_exports__CodeGenForCausalLM, __webpack_exports__CodeGenModel, __webpack_exports__CodeGenPreTrainedModel, __webpack_exports__CodeGenTokenizer, __webpack_exports__CodeLlamaTokenizer, __webpack_exports__CohereTokenizer, __webpack_exports__ConvBertForMaskedLM, __webpack_exports__ConvBertForQuestionAnswering, __webpack_exports__ConvBertForSequenceClassification, __webpack_exports__ConvBertForTokenClassification, __webpack_exports__ConvBertModel, __webpack_exports__ConvBertPreTrainedModel, __webpack_exports__ConvBertTokenizer, __webpack_exports__ConvNextFeatureExtractor, __webpack_exports__ConvNextForImageClassification, __webpack_exports__ConvNextImageProcessor, __webpack_exports__ConvNextModel, __webpack_exports__ConvNextPreTrainedModel, __webpack_exports__ConvNextV2ForImageClassification, __webpack_exports__ConvNextV2Model, __webpack_exports__ConvNextV2PreTrainedModel, __webpack_exports__DPTFeatureExtractor, __webpack_exports__DPTForDepthEstimation, __webpack_exports__DPTImageProcessor, __webpack_exports__DPTModel, __webpack_exports__DPTPreTrainedModel, __webpack_exports__DebertaForMaskedLM, __webpack_exports__DebertaForQuestionAnswering, __webpack_exports__DebertaForSequenceClassification, __webpack_exports__DebertaForTokenClassification, __webpack_exports__DebertaModel, __webpack_exports__DebertaPreTrainedModel, __webpack_exports__DebertaTokenizer, __webpack_exports__DebertaV2ForMaskedLM, __webpack_exports__DebertaV2ForQuestionAnswering, __webpack_exports__DebertaV2ForSequenceClassification, __webpack_exports__DebertaV2ForTokenClassification, __webpack_exports__DebertaV2Model, __webpack_exports__DebertaV2PreTrainedModel, __webpack_exports__DebertaV2Tokenizer, __webpack_exports__DeiTFeatureExtractor, __webpack_exports__DeiTForImageClassification, __webpack_exports__DeiTModel, __webpack_exports__DeiTPreTrainedModel, __webpack_exports__DepthAnythingForDepthEstimation, __webpack_exports__DepthAnythingPreTrainedModel, __webpack_exports__DepthEstimationPipeline, __webpack_exports__DetrFeatureExtractor, __webpack_exports__DetrForObjectDetection, __webpack_exports__DetrForSegmentation, __webpack_exports__DetrModel, __webpack_exports__DetrObjectDetectionOutput, __webpack_exports__DetrPreTrainedModel, __webpack_exports__DetrSegmentationOutput, __webpack_exports__Dinov2ForImageClassification, __webpack_exports__Dinov2Model, __webpack_exports__Dinov2PreTrainedModel, __webpack_exports__DistilBertForMaskedLM, __webpack_exports__DistilBertForQuestionAnswering, __webpack_exports__DistilBertForSequenceClassification, __webpack_exports__DistilBertForTokenClassification, __webpack_exports__DistilBertModel, __webpack_exports__DistilBertPreTrainedModel, __webpack_exports__DistilBertTokenizer, __webpack_exports__DocumentQuestionAnsweringPipeline, __webpack_exports__DonutFeatureExtractor, __webpack_exports__DonutSwinModel, __webpack_exports__DonutSwinPreTrainedModel, __webpack_exports__EfficientNetForImageClassification, __webpack_exports__EfficientNetImageProcessor, __webpack_exports__EfficientNetModel, __webpack_exports__EfficientNetPreTrainedModel, __webpack_exports__ElectraForMaskedLM, __webpack_exports__ElectraForQuestionAnswering, __webpack_exports__ElectraForSequenceClassification, __webpack_exports__ElectraForTokenClassification, __webpack_exports__ElectraModel, __webpack_exports__ElectraPreTrainedModel, __webpack_exports__ElectraTokenizer, __webpack_exports__EsmForMaskedLM, __webpack_exports__EsmForSequenceClassification, __webpack_exports__EsmForTokenClassification, __webpack_exports__EsmModel, __webpack_exports__EsmPreTrainedModel, __webpack_exports__EsmTokenizer, __webpack_exports__FFT, __webpack_exports__FalconForCausalLM, __webpack_exports__FalconModel, __webpack_exports__FalconPreTrainedModel, __webpack_exports__FalconTokenizer, __webpack_exports__FastViTForImageClassification, __webpack_exports__FastViTModel, __webpack_exports__FastViTPreTrainedModel, __webpack_exports__FeatureExtractionPipeline, __webpack_exports__FeatureExtractor, __webpack_exports__FillMaskPipeline, __webpack_exports__GLPNFeatureExtractor, __webpack_exports__GLPNForDepthEstimation, __webpack_exports__GLPNModel, __webpack_exports__GLPNPreTrainedModel, __webpack_exports__GPT2LMHeadModel, __webpack_exports__GPT2Model, __webpack_exports__GPT2PreTrainedModel, __webpack_exports__GPT2Tokenizer, __webpack_exports__GPTBigCodeForCausalLM, __webpack_exports__GPTBigCodeModel, __webpack_exports__GPTBigCodePreTrainedModel, __webpack_exports__GPTJForCausalLM, __webpack_exports__GPTJModel, __webpack_exports__GPTJPreTrainedModel, __webpack_exports__GPTNeoForCausalLM, __webpack_exports__GPTNeoModel, __webpack_exports__GPTNeoPreTrainedModel, __webpack_exports__GPTNeoXForCausalLM, __webpack_exports__GPTNeoXModel, __webpack_exports__GPTNeoXPreTrainedModel, __webpack_exports__GPTNeoXTokenizer, __webpack_exports__GemmaTokenizer, __webpack_exports__Grok1Tokenizer, __webpack_exports__HerbertTokenizer, __webpack_exports__HubertForCTC, __webpack_exports__HubertForSequenceClassification, __webpack_exports__HubertModel, __webpack_exports__HubertPreTrainedModel, __webpack_exports__ImageClassificationPipeline, __webpack_exports__ImageFeatureExtractionPipeline, __webpack_exports__ImageFeatureExtractor, __webpack_exports__ImageMattingOutput, __webpack_exports__ImageSegmentationPipeline, __webpack_exports__ImageToImagePipeline, __webpack_exports__ImageToTextPipeline, __webpack_exports__LlamaForCausalLM, __webpack_exports__LlamaModel, __webpack_exports__LlamaPreTrainedModel, __webpack_exports__LlamaTokenizer, __webpack_exports__LongT5ForConditionalGeneration, __webpack_exports__LongT5Model, __webpack_exports__LongT5PreTrainedModel, __webpack_exports__M2M100ForConditionalGeneration, __webpack_exports__M2M100Model, __webpack_exports__M2M100PreTrainedModel, __webpack_exports__M2M100Tokenizer, __webpack_exports__MBart50Tokenizer, __webpack_exports__MBartForCausalLM, __webpack_exports__MBartForConditionalGeneration, __webpack_exports__MBartForSequenceClassification, __webpack_exports__MBartModel, __webpack_exports__MBartPreTrainedModel, __webpack_exports__MBartTokenizer, __webpack_exports__MPNetForMaskedLM, __webpack_exports__MPNetForQuestionAnswering, __webpack_exports__MPNetForSequenceClassification, __webpack_exports__MPNetForTokenClassification, __webpack_exports__MPNetModel, __webpack_exports__MPNetPreTrainedModel, __webpack_exports__MPNetTokenizer, __webpack_exports__MT5ForConditionalGeneration, __webpack_exports__MT5Model, __webpack_exports__MT5PreTrainedModel, __webpack_exports__MarianMTModel, __webpack_exports__MarianModel, __webpack_exports__MarianPreTrainedModel, __webpack_exports__MarianTokenizer, __webpack_exports__MaskedLMOutput, __webpack_exports__MistralForCausalLM, __webpack_exports__MistralModel, __webpack_exports__MistralPreTrainedModel, __webpack_exports__MobileBertForMaskedLM, __webpack_exports__MobileBertForQuestionAnswering, __webpack_exports__MobileBertForSequenceClassification, __webpack_exports__MobileBertModel, __webpack_exports__MobileBertPreTrainedModel, __webpack_exports__MobileBertTokenizer, __webpack_exports__MobileViTFeatureExtractor, __webpack_exports__MobileViTForImageClassification, __webpack_exports__MobileViTImageProcessor, __webpack_exports__MobileViTModel, __webpack_exports__MobileViTPreTrainedModel, __webpack_exports__MobileViTV2ForImageClassification, __webpack_exports__MobileViTV2Model, __webpack_exports__MobileViTV2PreTrainedModel, __webpack_exports__ModelOutput, __webpack_exports__MptForCausalLM, __webpack_exports__MptModel, __webpack_exports__MptPreTrainedModel, __webpack_exports__NllbTokenizer, __webpack_exports__NomicBertModel, __webpack_exports__NomicBertPreTrainedModel, __webpack_exports__NougatImageProcessor, __webpack_exports__NougatTokenizer, __webpack_exports__OPTForCausalLM, __webpack_exports__OPTModel, __webpack_exports__OPTPreTrainedModel, __webpack_exports__ObjectDetectionPipeline, __webpack_exports__OwlViTFeatureExtractor, __webpack_exports__OwlViTForObjectDetection, __webpack_exports__OwlViTModel, __webpack_exports__OwlViTPreTrainedModel, __webpack_exports__OwlViTProcessor, __webpack_exports__Owlv2ForObjectDetection, __webpack_exports__Owlv2ImageProcessor, __webpack_exports__Owlv2Model, __webpack_exports__Owlv2PreTrainedModel, __webpack_exports__PhiForCausalLM, __webpack_exports__PhiModel, __webpack_exports__PhiPreTrainedModel, __webpack_exports__Pipeline, __webpack_exports__PreTrainedModel, __webpack_exports__PreTrainedTokenizer, __webpack_exports__PretrainedConfig, __webpack_exports__PretrainedMixin, __webpack_exports__Processor, __webpack_exports__QuestionAnsweringModelOutput, __webpack_exports__QuestionAnsweringPipeline, __webpack_exports__Qwen2ForCausalLM, __webpack_exports__Qwen2Model, __webpack_exports__Qwen2PreTrainedModel, __webpack_exports__Qwen2Tokenizer, __webpack_exports__RawImage, __webpack_exports__ResNetForImageClassification, __webpack_exports__ResNetModel, __webpack_exports__ResNetPreTrainedModel, __webpack_exports__RoFormerForMaskedLM, __webpack_exports__RoFormerForQuestionAnswering, __webpack_exports__RoFormerForSequenceClassification, __webpack_exports__RoFormerForTokenClassification, __webpack_exports__RoFormerModel, __webpack_exports__RoFormerPreTrainedModel, __webpack_exports__RoFormerTokenizer, __webpack_exports__RobertaForMaskedLM, __webpack_exports__RobertaForQuestionAnswering, __webpack_exports__RobertaForSequenceClassification, __webpack_exports__RobertaForTokenClassification, __webpack_exports__RobertaModel, __webpack_exports__RobertaPreTrainedModel, __webpack_exports__RobertaTokenizer, __webpack_exports__SamImageProcessor, __webpack_exports__SamImageSegmentationOutput, __webpack_exports__SamModel, __webpack_exports__SamPreTrainedModel, __webpack_exports__SamProcessor, __webpack_exports__SeamlessM4TFeatureExtractor, __webpack_exports__SegformerFeatureExtractor, __webpack_exports__SegformerForImageClassification, __webpack_exports__SegformerForSemanticSegmentation, __webpack_exports__SegformerModel, __webpack_exports__SegformerPreTrainedModel, __webpack_exports__Seq2SeqLMOutput, __webpack_exports__SequenceClassifierOutput, __webpack_exports__SiglipImageProcessor, __webpack_exports__SiglipModel, __webpack_exports__SiglipPreTrainedModel, __webpack_exports__SiglipTextModel, __webpack_exports__SiglipTokenizer, __webpack_exports__SiglipVisionModel, __webpack_exports__SpeechT5FeatureExtractor, __webpack_exports__SpeechT5ForSpeechToText, __webpack_exports__SpeechT5ForTextToSpeech, __webpack_exports__SpeechT5HifiGan, __webpack_exports__SpeechT5Model, __webpack_exports__SpeechT5PreTrainedModel, __webpack_exports__SpeechT5Processor, __webpack_exports__SpeechT5Tokenizer, __webpack_exports__SqueezeBertForMaskedLM, __webpack_exports__SqueezeBertForQuestionAnswering, __webpack_exports__SqueezeBertForSequenceClassification, __webpack_exports__SqueezeBertModel, __webpack_exports__SqueezeBertPreTrainedModel, __webpack_exports__SqueezeBertTokenizer, __webpack_exports__StableLmForCausalLM, __webpack_exports__StableLmModel, __webpack_exports__StableLmPreTrainedModel, __webpack_exports__Starcoder2ForCausalLM, __webpack_exports__Starcoder2Model, __webpack_exports__Starcoder2PreTrainedModel, __webpack_exports__SummarizationPipeline, __webpack_exports__Swin2SRForImageSuperResolution, __webpack_exports__Swin2SRImageProcessor, __webpack_exports__Swin2SRModel, __webpack_exports__Swin2SRPreTrainedModel, __webpack_exports__SwinForImageClassification, __webpack_exports__SwinModel, __webpack_exports__SwinPreTrainedModel, __webpack_exports__T5ForConditionalGeneration, __webpack_exports__T5Model, __webpack_exports__T5PreTrainedModel, __webpack_exports__T5Tokenizer, __webpack_exports__TableTransformerForObjectDetection, __webpack_exports__TableTransformerModel, __webpack_exports__TableTransformerObjectDetectionOutput, __webpack_exports__TableTransformerPreTrainedModel, __webpack_exports__Tensor, __webpack_exports__Text2TextGenerationPipeline, __webpack_exports__TextClassificationPipeline, __webpack_exports__TextGenerationPipeline, __webpack_exports__TextToAudioPipeline, __webpack_exports__TokenClassificationPipeline, __webpack_exports__TokenClassifierOutput, __webpack_exports__TokenizerModel, __webpack_exports__TrOCRForCausalLM, __webpack_exports__TrOCRPreTrainedModel, __webpack_exports__TranslationPipeline, __webpack_exports__UniSpeechForCTC, __webpack_exports__UniSpeechForSequenceClassification, __webpack_exports__UniSpeechModel, __webpack_exports__UniSpeechPreTrainedModel, __webpack_exports__UniSpeechSatForAudioFrameClassification, __webpack_exports__UniSpeechSatForCTC, __webpack_exports__UniSpeechSatForSequenceClassification, __webpack_exports__UniSpeechSatModel, __webpack_exports__UniSpeechSatPreTrainedModel, __webpack_exports__ViTFeatureExtractor, __webpack_exports__ViTForImageClassification, __webpack_exports__ViTImageProcessor, __webpack_exports__ViTModel, __webpack_exports__ViTPreTrainedModel, __webpack_exports__VisionEncoderDecoderModel, __webpack_exports__VitMatteForImageMatting, __webpack_exports__VitMatteImageProcessor, __webpack_exports__VitMattePreTrainedModel, __webpack_exports__VitsModel, __webpack_exports__VitsModelOutput, __webpack_exports__VitsPreTrainedModel, __webpack_exports__VitsTokenizer, __webpack_exports__Wav2Vec2BertForCTC, __webpack_exports__Wav2Vec2BertForSequenceClassification, __webpack_exports__Wav2Vec2BertModel, __webpack_exports__Wav2Vec2BertPreTrainedModel, __webpack_exports__Wav2Vec2CTCTokenizer, __webpack_exports__Wav2Vec2FeatureExtractor, __webpack_exports__Wav2Vec2ForAudioFrameClassification, __webpack_exports__Wav2Vec2ForCTC, __webpack_exports__Wav2Vec2ForSequenceClassification, __webpack_exports__Wav2Vec2Model, __webpack_exports__Wav2Vec2PreTrainedModel, __webpack_exports__Wav2Vec2ProcessorWithLM, __webpack_exports__WavLMForAudioFrameClassification, __webpack_exports__WavLMForCTC, __webpack_exports__WavLMForSequenceClassification, __webpack_exports__WavLMForXVector, __webpack_exports__WavLMModel, __webpack_exports__WavLMPreTrainedModel, __webpack_exports__WhisperFeatureExtractor, __webpack_exports__WhisperForConditionalGeneration, __webpack_exports__WhisperModel, __webpack_exports__WhisperPreTrainedModel, __webpack_exports__WhisperProcessor, __webpack_exports__WhisperTokenizer, __webpack_exports__XLMForQuestionAnswering, __webpack_exports__XLMForSequenceClassification, __webpack_exports__XLMForTokenClassification, __webpack_exports__XLMModel, __webpack_exports__XLMPreTrainedModel, __webpack_exports__XLMRobertaForMaskedLM, __webpack_exports__XLMRobertaForQuestionAnswering, __webpack_exports__XLMRobertaForSequenceClassification, __webpack_exports__XLMRobertaForTokenClassification, __webpack_exports__XLMRobertaModel, __webpack_exports__XLMRobertaPreTrainedModel, __webpack_exports__XLMRobertaTokenizer, __webpack_exports__XLMTokenizer, __webpack_exports__XLMWithLMHeadModel, __webpack_exports__XVectorOutput, __webpack_exports__YolosFeatureExtractor, __webpack_exports__YolosForObjectDetection, __webpack_exports__YolosModel, __webpack_exports__YolosObjectDetectionOutput, __webpack_exports__YolosPreTrainedModel, __webpack_exports__ZeroShotAudioClassificationPipeline, __webpack_exports__ZeroShotClassificationPipeline, __webpack_exports__ZeroShotImageClassificationPipeline, __webpack_exports__ZeroShotObjectDetectionPipeline, __webpack_exports__bankers_round, __webpack_exports__cat, __webpack_exports__cos_sim, __webpack_exports__dot, __webpack_exports__dynamicTimeWarping, __webpack_exports__env, __webpack_exports__getTopItems, __webpack_exports__hanning, __webpack_exports__interpolate, __webpack_exports__interpolate_data, __webpack_exports__layer_norm, __webpack_exports__log_softmax, __webpack_exports__magnitude, __webpack_exports__max, __webpack_exports__mean, __webpack_exports__mean_pooling, __webpack_exports__medianFilter, __webpack_exports__mel_filter_bank, __webpack_exports__min, __webpack_exports__ones, __webpack_exports__ones_like, __webpack_exports__permute, __webpack_exports__permute_data, __webpack_exports__pipeline, __webpack_exports__quantize_embeddings, __webpack_exports__read_audio, __webpack_exports__round, __webpack_exports__softmax, __webpack_exports__spectrogram, __webpack_exports__stack, __webpack_exports__std_mean, __webpack_exports__window_function;
var init_transformers = __esm({
  "lib/transformers.js"() {
    __webpack_modules__2 = {
      /***/
      "./node_modules/onnxruntime-common/dist/lib/backend-impl.js": (
        /*!******************************************************************!*\
          !*** ./node_modules/onnxruntime-common/dist/lib/backend-impl.js ***!
          \******************************************************************/
        /***/
        (__unused_webpack_module, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "registerBackend": () => (
              /* binding */
              registerBackend
            ),
            /* harmony export */
            "resolveBackend": () => (
              /* binding */
              resolveBackend
            )
            /* harmony export */
          });
          const backends = {};
          const backendsSortedByPriority = [];
          const registerBackend = (name2, backend, priority) => {
            if (backend && typeof backend.init === "function" && typeof backend.createSessionHandler === "function") {
              const currentBackend = backends[name2];
              if (currentBackend === void 0) {
                backends[name2] = { backend, priority };
              } else if (currentBackend.priority > priority) {
                return;
              } else if (currentBackend.priority === priority) {
                if (currentBackend.backend !== backend) {
                  throw new Error(`cannot register backend "${name2}" using priority ${priority}`);
                }
              }
              if (priority >= 0) {
                const i = backendsSortedByPriority.indexOf(name2);
                if (i !== -1) {
                  backendsSortedByPriority.splice(i, 1);
                }
                for (let i2 = 0; i2 < backendsSortedByPriority.length; i2++) {
                  if (backends[backendsSortedByPriority[i2]].priority <= priority) {
                    backendsSortedByPriority.splice(i2, 0, name2);
                    return;
                  }
                }
                backendsSortedByPriority.push(name2);
              }
              return;
            }
            throw new TypeError("not a valid backend");
          };
          const resolveBackend = async (backendHints) => {
            const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
            const errors2 = [];
            for (const backendName of backendNames) {
              const backendInfo = backends[backendName];
              if (backendInfo) {
                if (backendInfo.initialized) {
                  return backendInfo.backend;
                } else if (backendInfo.aborted) {
                  continue;
                }
                const isInitializing = !!backendInfo.initPromise;
                try {
                  if (!isInitializing) {
                    backendInfo.initPromise = backendInfo.backend.init();
                  }
                  await backendInfo.initPromise;
                  backendInfo.initialized = true;
                  return backendInfo.backend;
                } catch (e) {
                  if (!isInitializing) {
                    errors2.push({ name: backendName, err: e });
                  }
                  backendInfo.aborted = true;
                } finally {
                  delete backendInfo.initPromise;
                }
              }
            }
            throw new Error(`no available backend found. ERR: ${errors2.map((e) => `[${e.name}] ${e.err}`).join(", ")}`);
          };
        }
      ),
      /***/
      "./node_modules/onnxruntime-common/dist/lib/backend.js": (
        /*!*************************************************************!*\
          !*** ./node_modules/onnxruntime-common/dist/lib/backend.js ***!
          \*************************************************************/
        /***/
        (__unused_webpack_module, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "registerBackend": () => (
              /* reexport safe */
              _backend_impl__WEBPACK_IMPORTED_MODULE_0__.registerBackend
            )
            /* harmony export */
          });
          var _backend_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__3(
            /*! ./backend-impl */
            "./node_modules/onnxruntime-common/dist/lib/backend-impl.js"
          );
        }
      ),
      /***/
      "./node_modules/onnxruntime-common/dist/lib/env-impl.js": (
        /*!**************************************************************!*\
          !*** ./node_modules/onnxruntime-common/dist/lib/env-impl.js ***!
          \**************************************************************/
        /***/
        (__unused_webpack_module, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "EnvImpl": () => (
              /* binding */
              EnvImpl
            )
            /* harmony export */
          });
          class EnvImpl {
            constructor() {
              this.wasm = {};
              this.webgl = {};
              this.logLevelInternal = "warning";
            }
            // TODO standadize the getter and setter convention in env for other fields.
            set logLevel(value) {
              if (value === void 0) {
                return;
              }
              if (typeof value !== "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(value) === -1) {
                throw new Error(`Unsupported logging level: ${value}`);
              }
              this.logLevelInternal = value;
            }
            get logLevel() {
              return this.logLevelInternal;
            }
          }
        }
      ),
      /***/
      "./node_modules/onnxruntime-common/dist/lib/env.js": (
        /*!*********************************************************!*\
          !*** ./node_modules/onnxruntime-common/dist/lib/env.js ***!
          \*********************************************************/
        /***/
        (__unused_webpack_module, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "env": () => (
              /* binding */
              env
            )
            /* harmony export */
          });
          var _env_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__3(
            /*! ./env-impl */
            "./node_modules/onnxruntime-common/dist/lib/env-impl.js"
          );
          const env = new _env_impl__WEBPACK_IMPORTED_MODULE_0__.EnvImpl();
        }
      ),
      /***/
      "./node_modules/onnxruntime-common/dist/lib/index.js": (
        /*!***********************************************************!*\
          !*** ./node_modules/onnxruntime-common/dist/lib/index.js ***!
          \***********************************************************/
        /***/
        (__unused_webpack_module, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "InferenceSession": () => (
              /* reexport safe */
              _inference_session__WEBPACK_IMPORTED_MODULE_2__.InferenceSession
            ),
            /* harmony export */
            "Tensor": () => (
              /* reexport safe */
              _tensor__WEBPACK_IMPORTED_MODULE_3__.Tensor
            ),
            /* harmony export */
            "env": () => (
              /* reexport safe */
              _env__WEBPACK_IMPORTED_MODULE_1__.env
            ),
            /* harmony export */
            "registerBackend": () => (
              /* reexport safe */
              _backend__WEBPACK_IMPORTED_MODULE_0__.registerBackend
            )
            /* harmony export */
          });
          var _backend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__3(
            /*! ./backend */
            "./node_modules/onnxruntime-common/dist/lib/backend.js"
          );
          var _env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__3(
            /*! ./env */
            "./node_modules/onnxruntime-common/dist/lib/env.js"
          );
          var _inference_session__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__3(
            /*! ./inference-session */
            "./node_modules/onnxruntime-common/dist/lib/inference-session.js"
          );
          var _tensor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__3(
            /*! ./tensor */
            "./node_modules/onnxruntime-common/dist/lib/tensor.js"
          );
          var _onnx_value__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__3(
            /*! ./onnx-value */
            "./node_modules/onnxruntime-common/dist/lib/onnx-value.js"
          );
        }
      ),
      /***/
      "./node_modules/onnxruntime-common/dist/lib/inference-session-impl.js": (
        /*!****************************************************************************!*\
          !*** ./node_modules/onnxruntime-common/dist/lib/inference-session-impl.js ***!
          \****************************************************************************/
        /***/
        (__unused_webpack_module, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "InferenceSession": () => (
              /* binding */
              InferenceSession
            )
            /* harmony export */
          });
          var _backend_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__3(
            /*! ./backend-impl */
            "./node_modules/onnxruntime-common/dist/lib/backend-impl.js"
          );
          var _tensor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__3(
            /*! ./tensor */
            "./node_modules/onnxruntime-common/dist/lib/tensor.js"
          );
          class InferenceSession {
            constructor(handler) {
              this.handler = handler;
            }
            async run(feeds, arg1, arg2) {
              const fetches = {};
              let options = {};
              if (typeof feeds !== "object" || feeds === null || feeds instanceof _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor || Array.isArray(feeds)) {
                throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
              }
              let isFetchesEmpty = true;
              if (typeof arg1 === "object") {
                if (arg1 === null) {
                  throw new TypeError("Unexpected argument[1]: cannot be null.");
                }
                if (arg1 instanceof _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor) {
                  throw new TypeError("'fetches' cannot be a Tensor");
                }
                if (Array.isArray(arg1)) {
                  if (arg1.length === 0) {
                    throw new TypeError("'fetches' cannot be an empty array.");
                  }
                  isFetchesEmpty = false;
                  for (const name2 of arg1) {
                    if (typeof name2 !== "string") {
                      throw new TypeError("'fetches' must be a string array or an object.");
                    }
                    if (this.outputNames.indexOf(name2) === -1) {
                      throw new RangeError(`'fetches' contains invalid output name: ${name2}.`);
                    }
                    fetches[name2] = null;
                  }
                  if (typeof arg2 === "object" && arg2 !== null) {
                    options = arg2;
                  } else if (typeof arg2 !== "undefined") {
                    throw new TypeError("'options' must be an object.");
                  }
                } else {
                  let isFetches = false;
                  const arg1Keys = Object.getOwnPropertyNames(arg1);
                  for (const name2 of this.outputNames) {
                    if (arg1Keys.indexOf(name2) !== -1) {
                      const v = arg1[name2];
                      if (v === null || v instanceof _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor) {
                        isFetches = true;
                        isFetchesEmpty = false;
                        fetches[name2] = v;
                      }
                    }
                  }
                  if (isFetches) {
                    if (typeof arg2 === "object" && arg2 !== null) {
                      options = arg2;
                    } else if (typeof arg2 !== "undefined") {
                      throw new TypeError("'options' must be an object.");
                    }
                  } else {
                    options = arg1;
                  }
                }
              } else if (typeof arg1 !== "undefined") {
                throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
              }
              for (const name2 of this.inputNames) {
                if (typeof feeds[name2] === "undefined") {
                  throw new Error(`input '${name2}' is missing in 'feeds'.`);
                }
              }
              if (isFetchesEmpty) {
                for (const name2 of this.outputNames) {
                  fetches[name2] = null;
                }
              }
              const results = await this.handler.run(feeds, fetches, options);
              const returnValue = {};
              for (const key in results) {
                if (Object.hasOwnProperty.call(results, key)) {
                  returnValue[key] = new _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor(results[key].type, results[key].data, results[key].dims);
                }
              }
              return returnValue;
            }
            static async create(arg0, arg1, arg2, arg3) {
              let filePathOrUint8Array;
              let options = {};
              if (typeof arg0 === "string") {
                filePathOrUint8Array = arg0;
                if (typeof arg1 === "object" && arg1 !== null) {
                  options = arg1;
                } else if (typeof arg1 !== "undefined") {
                  throw new TypeError("'options' must be an object.");
                }
              } else if (arg0 instanceof Uint8Array) {
                filePathOrUint8Array = arg0;
                if (typeof arg1 === "object" && arg1 !== null) {
                  options = arg1;
                } else if (typeof arg1 !== "undefined") {
                  throw new TypeError("'options' must be an object.");
                }
              } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && arg0 instanceof SharedArrayBuffer) {
                const buffer = arg0;
                let byteOffset = 0;
                let byteLength = arg0.byteLength;
                if (typeof arg1 === "object" && arg1 !== null) {
                  options = arg1;
                } else if (typeof arg1 === "number") {
                  byteOffset = arg1;
                  if (!Number.isSafeInteger(byteOffset)) {
                    throw new RangeError("'byteOffset' must be an integer.");
                  }
                  if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
                    throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
                  }
                  byteLength = arg0.byteLength - byteOffset;
                  if (typeof arg2 === "number") {
                    byteLength = arg2;
                    if (!Number.isSafeInteger(byteLength)) {
                      throw new RangeError("'byteLength' must be an integer.");
                    }
                    if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
                      throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
                    }
                    if (typeof arg3 === "object" && arg3 !== null) {
                      options = arg3;
                    } else if (typeof arg3 !== "undefined") {
                      throw new TypeError("'options' must be an object.");
                    }
                  } else if (typeof arg2 !== "undefined") {
                    throw new TypeError("'byteLength' must be a number.");
                  }
                } else if (typeof arg1 !== "undefined") {
                  throw new TypeError("'options' must be an object.");
                }
                filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
              } else {
                throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
              }
              const eps = options.executionProviders || [];
              const backendHints = eps.map((i) => typeof i === "string" ? i : i.name);
              const backend = await (0, _backend_impl__WEBPACK_IMPORTED_MODULE_0__.resolveBackend)(backendHints);
              const handler = await backend.createSessionHandler(filePathOrUint8Array, options);
              return new InferenceSession(handler);
            }
            startProfiling() {
              this.handler.startProfiling();
            }
            endProfiling() {
              this.handler.endProfiling();
            }
            get inputNames() {
              return this.handler.inputNames;
            }
            get outputNames() {
              return this.handler.outputNames;
            }
          }
        }
      ),
      /***/
      "./node_modules/onnxruntime-common/dist/lib/inference-session.js": (
        /*!***********************************************************************!*\
          !*** ./node_modules/onnxruntime-common/dist/lib/inference-session.js ***!
          \***********************************************************************/
        /***/
        (__unused_webpack_module, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "InferenceSession": () => (
              /* binding */
              InferenceSession
            )
            /* harmony export */
          });
          var _inference_session_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__3(
            /*! ./inference-session-impl */
            "./node_modules/onnxruntime-common/dist/lib/inference-session-impl.js"
          );
          const InferenceSession = _inference_session_impl__WEBPACK_IMPORTED_MODULE_0__.InferenceSession;
        }
      ),
      /***/
      "./node_modules/onnxruntime-common/dist/lib/onnx-value.js": (
        /*!****************************************************************!*\
          !*** ./node_modules/onnxruntime-common/dist/lib/onnx-value.js ***!
          \****************************************************************/
        /***/
        (__unused_webpack_module, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
        }
      ),
      /***/
      "./node_modules/onnxruntime-common/dist/lib/tensor-impl.js": (
        /*!*****************************************************************!*\
          !*** ./node_modules/onnxruntime-common/dist/lib/tensor-impl.js ***!
          \*****************************************************************/
        /***/
        (__unused_webpack_module, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "Tensor": () => (
              /* binding */
              Tensor
            )
            /* harmony export */
          });
          const isBigInt64ArrayAvailable = typeof BigInt64Array !== "undefined" && typeof BigInt64Array.from === "function";
          const isBigUint64ArrayAvailable = typeof BigUint64Array !== "undefined" && typeof BigUint64Array.from === "function";
          const NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = /* @__PURE__ */ new Map([
            ["float32", Float32Array],
            ["uint8", Uint8Array],
            ["int8", Int8Array],
            ["uint16", Uint16Array],
            ["int16", Int16Array],
            ["int32", Int32Array],
            ["bool", Uint8Array],
            ["float64", Float64Array],
            ["uint32", Uint32Array]
          ]);
          const NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = /* @__PURE__ */ new Map([
            [Float32Array, "float32"],
            [Uint8Array, "uint8"],
            [Int8Array, "int8"],
            [Uint16Array, "uint16"],
            [Int16Array, "int16"],
            [Int32Array, "int32"],
            [Float64Array, "float64"],
            [Uint32Array, "uint32"]
          ]);
          if (isBigInt64ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64", BigInt64Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, "int64");
          }
          if (isBigUint64ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64", BigUint64Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, "uint64");
          }
          const calculateSize = (dims) => {
            let size = 1;
            for (let i = 0; i < dims.length; i++) {
              const dim = dims[i];
              if (typeof dim !== "number" || !Number.isSafeInteger(dim)) {
                throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
              }
              if (dim < 0) {
                throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
              }
              size *= dim;
            }
            return size;
          };
          class Tensor {
            constructor(arg0, arg1, arg2) {
              let type;
              let data;
              let dims;
              if (typeof arg0 === "string") {
                type = arg0;
                dims = arg2;
                if (arg0 === "string") {
                  if (!Array.isArray(arg1)) {
                    throw new TypeError("A string tensor's data must be a string array.");
                  }
                  data = arg1;
                } else {
                  const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
                  if (typedArrayConstructor === void 0) {
                    throw new TypeError(`Unsupported tensor type: ${arg0}.`);
                  }
                  if (Array.isArray(arg1)) {
                    data = typedArrayConstructor.from(arg1);
                  } else if (arg1 instanceof typedArrayConstructor) {
                    data = arg1;
                  } else {
                    throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
                  }
                }
              } else {
                dims = arg1;
                if (Array.isArray(arg0)) {
                  if (arg0.length === 0) {
                    throw new TypeError("Tensor type cannot be inferred from an empty array.");
                  }
                  const firstElementType = typeof arg0[0];
                  if (firstElementType === "string") {
                    type = "string";
                    data = arg0;
                  } else if (firstElementType === "boolean") {
                    type = "bool";
                    data = Uint8Array.from(arg0);
                  } else {
                    throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
                  }
                } else {
                  const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
                  if (mappedType === void 0) {
                    throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
                  }
                  type = mappedType;
                  data = arg0;
                }
              }
              if (dims === void 0) {
                dims = [data.length];
              } else if (!Array.isArray(dims)) {
                throw new TypeError("A tensor's dims must be a number array");
              }
              const size = calculateSize(dims);
              if (size !== data.length) {
                throw new Error(`Tensor's size(${size}) does not match data length(${data.length}).`);
              }
              this.dims = dims;
              this.type = type;
              this.data = data;
              this.size = size;
            }
            // #endregion
            /**
             * Create a new tensor object from image object
             *
             * @param buffer - Extracted image buffer data - assuming RGBA format
             * @param imageFormat - input image configuration - required configurations height, width, format
             * @param tensorFormat - output tensor configuration - Default is RGB format
             */
            static bufferToTensor(buffer, options) {
              if (buffer === void 0) {
                throw new Error("Image buffer must be defined");
              }
              if (options.height === void 0 || options.width === void 0) {
                throw new Error("Image height and width must be defined");
              }
              const { height, width } = options;
              const norm = options.norm;
              let normMean;
              let normBias;
              if (norm === void 0 || norm.mean === void 0) {
                normMean = 255;
              } else {
                normMean = norm.mean;
              }
              if (norm === void 0 || norm.bias === void 0) {
                normBias = 0;
              } else {
                normBias = norm.bias;
              }
              const inputformat = options.bitmapFormat !== void 0 ? options.bitmapFormat : "RGBA";
              const outputformat = options.tensorFormat !== void 0 ? options.tensorFormat !== void 0 ? options.tensorFormat : "RGB" : "RGB";
              const offset = height * width;
              const float32Data = outputformat === "RGBA" ? new Float32Array(offset * 4) : new Float32Array(offset * 3);
              let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
              let rTensorPointer = 0, gTensorPointer = offset, bTensorPointer = offset * 2, aTensorPointer = -1;
              if (inputformat === "RGB") {
                step = 3;
                rImagePointer = 0;
                gImagePointer = 1;
                bImagePointer = 2;
                aImagePointer = -1;
              }
              if (outputformat === "RGBA") {
                aTensorPointer = offset * 3;
              } else if (outputformat === "RBG") {
                rTensorPointer = 0;
                bTensorPointer = offset;
                gTensorPointer = offset * 2;
              } else if (outputformat === "BGR") {
                bTensorPointer = 0;
                gTensorPointer = offset;
                rTensorPointer = offset * 2;
              }
              for (let i = 0; i < offset; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {
                float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias) / normMean;
                float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias) / normMean;
                float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias) / normMean;
                if (aTensorPointer !== -1 && aImagePointer !== -1) {
                  float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias) / normMean;
                }
              }
              const outputTensor = outputformat === "RGBA" ? new Tensor("float32", float32Data, [1, 4, height, width]) : new Tensor("float32", float32Data, [1, 3, height, width]);
              return outputTensor;
            }
            static async fromImage(image2, options) {
              const isHTMLImageEle = typeof HTMLImageElement !== "undefined" && image2 instanceof HTMLImageElement;
              const isImageDataEle = typeof ImageData !== "undefined" && image2 instanceof ImageData;
              const isImageBitmap = typeof ImageBitmap !== "undefined" && image2 instanceof ImageBitmap;
              const isURL = typeof String !== "undefined" && (image2 instanceof String || typeof image2 === "string");
              let data;
              let tensorConfig = {};
              if (isHTMLImageEle) {
                const canvas = document.createElement("canvas");
                const pixels2DContext = canvas.getContext("2d");
                if (pixels2DContext != null) {
                  let height = image2.naturalHeight;
                  let width = image2.naturalWidth;
                  if (options !== void 0 && options.resizedHeight !== void 0 && options.resizedWidth !== void 0) {
                    height = options.resizedHeight;
                    width = options.resizedWidth;
                  }
                  if (options !== void 0) {
                    tensorConfig = options;
                    if (options.tensorFormat !== void 0) {
                      throw new Error("Image input config format must be RGBA for HTMLImageElement");
                    } else {
                      tensorConfig.tensorFormat = "RGBA";
                    }
                    if (options.height !== void 0 && options.height !== height) {
                      throw new Error("Image input config height doesn't match HTMLImageElement height");
                    } else {
                      tensorConfig.height = height;
                    }
                    if (options.width !== void 0 && options.width !== width) {
                      throw new Error("Image input config width doesn't match HTMLImageElement width");
                    } else {
                      tensorConfig.width = width;
                    }
                  } else {
                    tensorConfig.tensorFormat = "RGBA";
                    tensorConfig.height = height;
                    tensorConfig.width = width;
                  }
                  canvas.width = width;
                  canvas.height = height;
                  pixels2DContext.drawImage(image2, 0, 0, width, height);
                  data = pixels2DContext.getImageData(0, 0, width, height).data;
                } else {
                  throw new Error("Can not access image data");
                }
              } else if (isImageDataEle) {
                const format2 = "RGBA";
                let height;
                let width;
                if (options !== void 0 && options.resizedWidth !== void 0 && options.resizedHeight !== void 0) {
                  height = options.resizedHeight;
                  width = options.resizedWidth;
                } else {
                  height = image2.height;
                  width = image2.width;
                }
                if (options !== void 0) {
                  tensorConfig = options;
                  if (options.bitmapFormat !== void 0 && options.bitmapFormat !== format2) {
                    throw new Error("Image input config format must be RGBA for ImageData");
                  } else {
                    tensorConfig.bitmapFormat = "RGBA";
                  }
                } else {
                  tensorConfig.bitmapFormat = "RGBA";
                }
                tensorConfig.height = height;
                tensorConfig.width = width;
                if (options !== void 0) {
                  const tempCanvas = document.createElement("canvas");
                  tempCanvas.width = width;
                  tempCanvas.height = height;
                  const pixels2DContext = tempCanvas.getContext("2d");
                  if (pixels2DContext != null) {
                    pixels2DContext.putImageData(image2, 0, 0);
                    data = pixels2DContext.getImageData(0, 0, width, height).data;
                  } else {
                    throw new Error("Can not access image data");
                  }
                } else {
                  data = image2.data;
                }
              } else if (isImageBitmap) {
                if (options === void 0) {
                  throw new Error("Please provide image config with format for Imagebitmap");
                }
                if (options.bitmapFormat !== void 0) {
                  throw new Error("Image input config format must be defined for ImageBitmap");
                }
                const pixels2DContext = document.createElement("canvas").getContext("2d");
                if (pixels2DContext != null) {
                  const height = image2.height;
                  const width = image2.width;
                  pixels2DContext.drawImage(image2, 0, 0, width, height);
                  data = pixels2DContext.getImageData(0, 0, width, height).data;
                  if (options !== void 0) {
                    if (options.height !== void 0 && options.height !== height) {
                      throw new Error("Image input config height doesn't match ImageBitmap height");
                    } else {
                      tensorConfig.height = height;
                    }
                    if (options.width !== void 0 && options.width !== width) {
                      throw new Error("Image input config width doesn't match ImageBitmap width");
                    } else {
                      tensorConfig.width = width;
                    }
                  } else {
                    tensorConfig.height = height;
                    tensorConfig.width = width;
                  }
                  return Tensor.bufferToTensor(data, tensorConfig);
                } else {
                  throw new Error("Can not access image data");
                }
              } else if (isURL) {
                return new Promise((resolve, reject) => {
                  const canvas = document.createElement("canvas");
                  const context = canvas.getContext("2d");
                  if (!image2 || !context) {
                    return reject();
                  }
                  const newImage = new Image();
                  newImage.crossOrigin = "Anonymous";
                  newImage.src = image2;
                  newImage.onload = () => {
                    canvas.width = newImage.width;
                    canvas.height = newImage.height;
                    context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
                    const img = context.getImageData(0, 0, canvas.width, canvas.height);
                    if (options !== void 0) {
                      if (options.height !== void 0 && options.height !== canvas.height) {
                        throw new Error("Image input config height doesn't match ImageBitmap height");
                      } else {
                        tensorConfig.height = canvas.height;
                      }
                      if (options.width !== void 0 && options.width !== canvas.width) {
                        throw new Error("Image input config width doesn't match ImageBitmap width");
                      } else {
                        tensorConfig.width = canvas.width;
                      }
                    } else {
                      tensorConfig.height = canvas.height;
                      tensorConfig.width = canvas.width;
                    }
                    resolve(Tensor.bufferToTensor(img.data, tensorConfig));
                  };
                });
              } else {
                throw new Error("Input data provided is not supported - aborted tensor creation");
              }
              if (data !== void 0) {
                return Tensor.bufferToTensor(data, tensorConfig);
              } else {
                throw new Error("Input data provided is not supported - aborted tensor creation");
              }
            }
            toImageData(options) {
              var _a2, _b;
              const pixels2DContext = document.createElement("canvas").getContext("2d");
              let image2;
              if (pixels2DContext != null) {
                const width = this.dims[3];
                const height = this.dims[2];
                const channels = this.dims[1];
                const inputformat = options !== void 0 ? options.format !== void 0 ? options.format : "RGB" : "RGB";
                const normMean = options !== void 0 ? ((_a2 = options.norm) === null || _a2 === void 0 ? void 0 : _a2.mean) !== void 0 ? options.norm.mean : 255 : 255;
                const normBias = options !== void 0 ? ((_b = options.norm) === null || _b === void 0 ? void 0 : _b.bias) !== void 0 ? options.norm.bias : 0 : 0;
                const offset = height * width;
                if (options !== void 0) {
                  if (options.height !== void 0 && options.height !== height) {
                    throw new Error("Image output config height doesn't match tensor height");
                  }
                  if (options.width !== void 0 && options.width !== width) {
                    throw new Error("Image output config width doesn't match tensor width");
                  }
                  if (options.format !== void 0 && (channels === 4 && options.format !== "RGBA") || channels === 3 && (options.format !== "RGB" && options.format !== "BGR")) {
                    throw new Error("Tensor format doesn't match input tensor dims");
                  }
                }
                const step = 4;
                let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
                let rTensorPointer = 0, gTensorPointer = offset, bTensorPointer = offset * 2, aTensorPointer = -1;
                if (inputformat === "RGBA") {
                  rTensorPointer = 0;
                  gTensorPointer = offset;
                  bTensorPointer = offset * 2;
                  aTensorPointer = offset * 3;
                } else if (inputformat === "RGB") {
                  rTensorPointer = 0;
                  gTensorPointer = offset;
                  bTensorPointer = offset * 2;
                } else if (inputformat === "RBG") {
                  rTensorPointer = 0;
                  bTensorPointer = offset;
                  gTensorPointer = offset * 2;
                }
                image2 = pixels2DContext.createImageData(width, height);
                for (let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {
                  image2.data[rImagePointer] = (this.data[rTensorPointer++] - normBias) * normMean;
                  image2.data[gImagePointer] = (this.data[gTensorPointer++] - normBias) * normMean;
                  image2.data[bImagePointer] = (this.data[bTensorPointer++] - normBias) * normMean;
                  image2.data[aImagePointer] = aTensorPointer === -1 ? 255 : (this.data[aTensorPointer++] - normBias) * normMean;
                }
              } else {
                throw new Error("Can not access image data");
              }
              return image2;
            }
            // #endregion
            // #region tensor utilities
            reshape(dims) {
              return new Tensor(this.type, this.data, dims);
            }
          }
        }
      ),
      /***/
      "./node_modules/onnxruntime-common/dist/lib/tensor.js": (
        /*!************************************************************!*\
          !*** ./node_modules/onnxruntime-common/dist/lib/tensor.js ***!
          \************************************************************/
        /***/
        (__unused_webpack_module, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "Tensor": () => (
              /* binding */
              Tensor
            )
            /* harmony export */
          });
          var _tensor_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__3(
            /*! ./tensor-impl */
            "./node_modules/onnxruntime-common/dist/lib/tensor-impl.js"
          );
          const Tensor = _tensor_impl__WEBPACK_IMPORTED_MODULE_0__.Tensor;
        }
      ),
      /***/
      "./node_modules/onnxruntime-web/dist/ort-web.min.js": (
        /*!**********************************************************!*\
          !*** ./node_modules/onnxruntime-web/dist/ort-web.min.js ***!
          \**********************************************************/
        /***/
        (module, __unused_webpack_exports, __webpack_require__) => {
          !function(t, e) {
            if (true)
              module.exports = e(__webpack_require__(
                /*! onnxruntime-common */
                "./node_modules/onnxruntime-common/dist/lib/index.js"
              ));
            else {
              var r, n;
            }
          }(self, (__WEBPACK_EXTERNAL_MODULE__1670__) => (() => {
            var __webpack_modules__ = { 3474: (t, e, n) => {
              var _scriptDir, r = (_scriptDir = (_scriptDir = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0) || "/index.js", function(t2) {
                function e2() {
                  return $.buffer != C && H($.buffer), F;
                }
                function r2() {
                  return $.buffer != C && H($.buffer), N;
                }
                function i() {
                  return $.buffer != C && H($.buffer), L;
                }
                function o() {
                  return $.buffer != C && H($.buffer), R;
                }
                function a() {
                  return $.buffer != C && H($.buffer), j;
                }
                var s, u, c;
                t2 = t2 || {}, s || (s = void 0 !== t2 ? t2 : {}), s.ready = new Promise(function(t3, e3) {
                  u = t3, c = e3;
                });
                var l, p, f, d, h, g, b = Object.assign({}, s), m = "./this.program", y = (t3, e3) => {
                  throw e3;
                }, _ = "object" == typeof window, v = "function" == typeof importScripts, w = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, x = s.ENVIRONMENT_IS_PTHREAD || false, T = "";
                function S(t3) {
                  return s.locateFile ? s.locateFile(t3, T) : T + t3;
                }
                if (w) {
                  let e3;
                  T = v ? n(908).dirname(T) + "/" : "//", g = () => {
                    h || (d = n(1384), h = n(908));
                  }, l = function(t3, e4) {
                    return g(), t3 = h.normalize(t3), d.readFileSync(t3, e4 ? void 0 : "utf8");
                  }, f = (t3) => ((t3 = l(t3, true)).buffer || (t3 = new Uint8Array(t3)), t3), p = (t3, e4, n2) => {
                    g(), t3 = h.normalize(t3), d.readFile(t3, function(t4, r3) {
                      t4 ? n2(t4) : e4(r3.buffer);
                    });
                  }, 1 < process.argv.length && (m = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), process.on("uncaughtException", function(t3) {
                    if (!(t3 instanceof ut))
                      throw t3;
                  }), process.on("unhandledRejection", function(t3) {
                    throw t3;
                  }), y = (t3, e4) => {
                    if (J())
                      throw process.exitCode = t3, e4;
                    e4 instanceof ut || P("exiting due to exception: " + e4), process.exit(t3);
                  }, s.inspect = function() {
                    return "[Emscripten Module object]";
                  };
                  try {
                    e3 = n(9925);
                  } catch (t3) {
                    throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'), t3;
                  }
                  n.g.Worker = e3.Worker;
                } else
                  (_ || v) && (v ? T = self.location.href : "undefined" != typeof document && document.currentScript && (T = document.currentScript.src), _scriptDir && (T = _scriptDir), T = 0 !== T.indexOf("blob:") ? T.substr(0, T.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", w || (l = (t3) => {
                    var e3 = new XMLHttpRequest();
                    return e3.open("GET", t3, false), e3.send(null), e3.responseText;
                  }, v && (f = (t3) => {
                    var e3 = new XMLHttpRequest();
                    return e3.open("GET", t3, false), e3.responseType = "arraybuffer", e3.send(null), new Uint8Array(e3.response);
                  }), p = (t3, e3, n2) => {
                    var r3 = new XMLHttpRequest();
                    r3.open("GET", t3, true), r3.responseType = "arraybuffer", r3.onload = () => {
                      200 == r3.status || 0 == r3.status && r3.response ? e3(r3.response) : n2();
                    }, r3.onerror = n2, r3.send(null);
                  }));
                w && "undefined" == typeof performance && (n.g.performance = n(6953).performance);
                var O = console.log.bind(console), A = console.warn.bind(console);
                w && (g(), O = (t3) => d.writeSync(1, t3 + "\n"), A = (t3) => d.writeSync(2, t3 + "\n"));
                var E, I = s.print || O, P = s.printErr || A;
                Object.assign(s, b), b = null, s.thisProgram && (m = s.thisProgram), s.quit && (y = s.quit), s.wasmBinary && (E = s.wasmBinary);
                var D = s.noExitRuntime || false;
                "object" != typeof WebAssembly && it("no native wasm support detected");
                var $, k, C, F, N, L, R, j, M = false, U = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
                function V(t3, e3, n2) {
                  var r3 = (e3 >>>= 0) + n2;
                  for (n2 = e3; t3[n2] && !(n2 >= r3); )
                    ++n2;
                  if (16 < n2 - e3 && t3.buffer && U)
                    return U.decode(t3.buffer instanceof SharedArrayBuffer ? t3.slice(e3, n2) : t3.subarray(e3, n2));
                  for (r3 = ""; e3 < n2; ) {
                    var i2 = t3[e3++];
                    if (128 & i2) {
                      var o2 = 63 & t3[e3++];
                      if (192 == (224 & i2))
                        r3 += String.fromCharCode((31 & i2) << 6 | o2);
                      else {
                        var a2 = 63 & t3[e3++];
                        65536 > (i2 = 224 == (240 & i2) ? (15 & i2) << 12 | o2 << 6 | a2 : (7 & i2) << 18 | o2 << 12 | a2 << 6 | 63 & t3[e3++]) ? r3 += String.fromCharCode(i2) : (i2 -= 65536, r3 += String.fromCharCode(55296 | i2 >> 10, 56320 | 1023 & i2));
                      }
                    } else
                      r3 += String.fromCharCode(i2);
                  }
                  return r3;
                }
                function B(t3, e3) {
                  return (t3 >>>= 0) ? V(r2(), t3, e3) : "";
                }
                function z(t3, e3, n2, r3) {
                  if (!(0 < r3))
                    return 0;
                  var i2 = n2 >>>= 0;
                  r3 = n2 + r3 - 1;
                  for (var o2 = 0; o2 < t3.length; ++o2) {
                    var a2 = t3.charCodeAt(o2);
                    if (55296 <= a2 && 57343 >= a2 && (a2 = 65536 + ((1023 & a2) << 10) | 1023 & t3.charCodeAt(++o2)), 127 >= a2) {
                      if (n2 >= r3)
                        break;
                      e3[n2++ >>> 0] = a2;
                    } else {
                      if (2047 >= a2) {
                        if (n2 + 1 >= r3)
                          break;
                        e3[n2++ >>> 0] = 192 | a2 >> 6;
                      } else {
                        if (65535 >= a2) {
                          if (n2 + 2 >= r3)
                            break;
                          e3[n2++ >>> 0] = 224 | a2 >> 12;
                        } else {
                          if (n2 + 3 >= r3)
                            break;
                          e3[n2++ >>> 0] = 240 | a2 >> 18, e3[n2++ >>> 0] = 128 | a2 >> 12 & 63;
                        }
                        e3[n2++ >>> 0] = 128 | a2 >> 6 & 63;
                      }
                      e3[n2++ >>> 0] = 128 | 63 & a2;
                    }
                  }
                  return e3[n2 >>> 0] = 0, n2 - i2;
                }
                function G(t3) {
                  for (var e3 = 0, n2 = 0; n2 < t3.length; ++n2) {
                    var r3 = t3.charCodeAt(n2);
                    127 >= r3 ? e3++ : 2047 >= r3 ? e3 += 2 : 55296 <= r3 && 57343 >= r3 ? (e3 += 4, ++n2) : e3 += 3;
                  }
                  return e3;
                }
                function H(t3) {
                  C = t3, s.HEAP8 = F = new Int8Array(t3), s.HEAP16 = new Int16Array(t3), s.HEAP32 = L = new Int32Array(t3), s.HEAPU8 = N = new Uint8Array(t3), s.HEAPU16 = new Uint16Array(t3), s.HEAPU32 = R = new Uint32Array(t3), s.HEAPF32 = new Float32Array(t3), s.HEAPF64 = j = new Float64Array(t3);
                }
                x && (C = s.buffer);
                var W = s.INITIAL_MEMORY || 16777216;
                if (x)
                  $ = s.wasmMemory, C = s.buffer;
                else if (s.wasmMemory)
                  $ = s.wasmMemory;
                else if (!(($ = new WebAssembly.Memory({ initial: W / 65536, maximum: 65536, shared: true })).buffer instanceof SharedArrayBuffer))
                  throw P("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"), w && console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"), Error("bad memory");
                $ && (C = $.buffer), W = C.byteLength, H(C);
                var q, X = [], Y = [], K = [], Z = [];
                function J() {
                  return D || false;
                }
                function Q() {
                  var t3 = s.preRun.shift();
                  X.unshift(t3);
                }
                var tt, et = 0, nt = null, rt = null;
                function it(t3) {
                  throw x ? postMessage({ cmd: "onAbort", arg: t3 }) : s.onAbort && s.onAbort(t3), P(t3 = "Aborted(" + t3 + ")"), M = true, t3 = new WebAssembly.RuntimeError(t3 + ". Build with -sASSERTIONS for more info."), c(t3), t3;
                }
                function ot() {
                  return tt.startsWith("data:application/octet-stream;base64,");
                }
                function at() {
                  var t3 = tt;
                  try {
                    if (t3 == tt && E)
                      return new Uint8Array(E);
                    if (f)
                      return f(t3);
                    throw "both async and sync fetching of the wasm failed";
                  } catch (t4) {
                    it(t4);
                  }
                }
                tt = "ort-wasm-threaded.wasm", ot() || (tt = S(tt));
                var st = {};
                function ut(t3) {
                  this.name = "ExitStatus", this.message = "Program terminated with exit(" + t3 + ")", this.status = t3;
                }
                function ct(t3) {
                  (t3 = dt.Vb[t3]) || it(), dt.mc(t3);
                }
                function lt(t3) {
                  var e3 = dt.Cc();
                  if (!e3)
                    return 6;
                  dt.ac.push(e3), dt.Vb[t3.Ub] = e3, e3.Ub = t3.Ub;
                  var n2 = { cmd: "run", start_routine: t3.Ic, arg: t3.zc, pthread_ptr: t3.Ub };
                  return e3.$b = () => {
                    n2.time = performance.now(), e3.postMessage(n2, t3.Nc);
                  }, e3.loaded && (e3.$b(), delete e3.$b), 0;
                }
                function pt(t3) {
                  if (x)
                    return qt(1, 1, t3);
                  J() || (dt.oc(), s.onExit && s.onExit(t3), M = true), y(t3, new ut(t3));
                }
                function ft(t3, e3) {
                  if (!e3 && x)
                    throw bt(t3), "unwind";
                  J() || x || (me(), ht(K), be(0), re[1].length && ie(1, 10), re[2].length && ie(2, 10), dt.oc()), pt(t3);
                }
                var dt = { Yb: [], ac: [], qc: [], Vb: {}, fc: function() {
                  x && dt.Ec();
                }, Pc: function() {
                }, Ec: function() {
                  dt.receiveObjectTransfer = dt.Gc, dt.threadInitTLS = dt.pc, dt.setExitStatus = dt.nc, D = false;
                }, nc: function() {
                }, oc: function() {
                  for (var t3 of Object.values(dt.Vb))
                    dt.mc(t3);
                  for (t3 of dt.Yb)
                    t3.terminate();
                  dt.Yb = [];
                }, mc: function(t3) {
                  var e3 = t3.Ub;
                  delete dt.Vb[e3], dt.Yb.push(t3), dt.ac.splice(dt.ac.indexOf(t3), 1), t3.Ub = 0, xe(e3);
                }, Gc: function() {
                }, pc: function() {
                  dt.qc.forEach((t3) => t3());
                }, Fc: function(t3, e3) {
                  t3.onmessage = (n2) => {
                    var r3 = (n2 = n2.data).cmd;
                    if (t3.Ub && (dt.Bc = t3.Ub), n2.targetThread && n2.targetThread != de()) {
                      var i2 = dt.Vb[n2.Qc];
                      i2 ? i2.postMessage(n2, n2.transferList) : P('Internal error! Worker sent a message "' + r3 + '" to target pthread ' + n2.targetThread + ", but that thread no longer exists!");
                    } else
                      "processProxyingQueue" === r3 ? Vt(n2.queue) : "spawnThread" === r3 ? lt(n2) : "cleanupThread" === r3 ? ct(n2.thread) : "killThread" === r3 ? (n2 = n2.thread, r3 = dt.Vb[n2], delete dt.Vb[n2], r3.terminate(), xe(n2), dt.ac.splice(dt.ac.indexOf(r3), 1), r3.Ub = 0) : "cancelThread" === r3 ? dt.Vb[n2.thread].postMessage({ cmd: "cancel" }) : "loaded" === r3 ? (t3.loaded = true, e3 && e3(t3), t3.$b && (t3.$b(), delete t3.$b)) : "print" === r3 ? I("Thread " + n2.threadId + ": " + n2.text) : "printErr" === r3 ? P("Thread " + n2.threadId + ": " + n2.text) : "alert" === r3 ? alert("Thread " + n2.threadId + ": " + n2.text) : "setimmediate" === n2.target ? t3.postMessage(n2) : "onAbort" === r3 ? s.onAbort && s.onAbort(n2.arg) : r3 && P("worker sent an unknown command " + r3);
                    dt.Bc = void 0;
                  }, t3.onerror = (t4) => {
                    throw P("worker sent an error! " + t4.filename + ":" + t4.lineno + ": " + t4.message), t4;
                  }, w && (t3.on("message", function(e4) {
                    t3.onmessage({ data: e4 });
                  }), t3.on("error", function(e4) {
                    t3.onerror(e4);
                  }), t3.on("detachedExit", function() {
                  })), t3.postMessage({ cmd: "load", urlOrBlob: s.mainScriptUrlOrBlob || _scriptDir, wasmMemory: $, wasmModule: k });
                }, yc: function() {
                  var t3 = S("ort-wasm-threaded.worker.js");
                  dt.Yb.push(new Worker(t3));
                }, Cc: function() {
                  return 0 == dt.Yb.length && (dt.yc(), dt.Fc(dt.Yb[0])), dt.Yb.pop();
                } };
                function ht(t3) {
                  for (; 0 < t3.length; )
                    t3.shift()(s);
                }
                function gt(t3) {
                  var e3 = Ae();
                  return t3 = t3(), Ee(e3), t3;
                }
                function bt(t3) {
                  if (x)
                    return qt(2, 0, t3);
                  try {
                    ft(t3);
                  } catch (t4) {
                    t4 instanceof ut || "unwind" == t4 || y(1, t4);
                  }
                }
                s.PThread = dt, s.establishStackSpace = function() {
                  var t3 = de(), e3 = i()[t3 + 44 >> 2 >>> 0];
                  t3 = i()[t3 + 48 >> 2 >>> 0], Oe(e3, e3 - t3), Ee(e3);
                };
                var mt = [];
                function yt(t3) {
                  var e3 = mt[t3];
                  return e3 || (t3 >= mt.length && (mt.length = t3 + 1), mt[t3] = e3 = q.get(t3)), e3;
                }
                s.invokeEntryPoint = function(t3, e3) {
                  t3 = yt(t3)(e3), J() ? dt.nc(t3) : Te(t3);
                };
                var _t, vt, wt = [], xt = 0, Tt = 0;
                function St(t3) {
                  this.Zb = t3, this.Sb = t3 - 24, this.xc = function(t4) {
                    o()[this.Sb + 4 >> 2 >>> 0] = t4;
                  }, this.bc = function() {
                    return o()[this.Sb + 4 >> 2 >>> 0];
                  }, this.wc = function(t4) {
                    o()[this.Sb + 8 >> 2 >>> 0] = t4;
                  }, this.Dc = function() {
                    return o()[this.Sb + 8 >> 2 >>> 0];
                  }, this.rc = function() {
                    i()[this.Sb >> 2 >>> 0] = 0;
                  }, this.hc = function(t4) {
                    t4 = t4 ? 1 : 0, e2()[this.Sb + 12 >> 0 >>> 0] = t4;
                  }, this.uc = function() {
                    return 0 != e2()[this.Sb + 12 >> 0 >>> 0];
                  }, this.ic = function(t4) {
                    t4 = t4 ? 1 : 0, e2()[this.Sb + 13 >> 0 >>> 0] = t4;
                  }, this.kc = function() {
                    return 0 != e2()[this.Sb + 13 >> 0 >>> 0];
                  }, this.fc = function(t4, e3) {
                    this.cc(0), this.xc(t4), this.wc(e3), this.rc(), this.hc(false), this.ic(false);
                  }, this.sc = function() {
                    Atomics.add(i(), this.Sb >> 2, 1);
                  }, this.Hc = function() {
                    return 1 === Atomics.sub(i(), this.Sb >> 2, 1);
                  }, this.cc = function(t4) {
                    o()[this.Sb + 16 >> 2 >>> 0] = t4;
                  }, this.tc = function() {
                    return o()[this.Sb + 16 >> 2 >>> 0];
                  }, this.vc = function() {
                    if (De(this.bc()))
                      return o()[this.Zb >> 2 >>> 0];
                    var t4 = this.tc();
                    return 0 !== t4 ? t4 : this.Zb;
                  };
                }
                function Ot(t3) {
                  return ge(new St(t3).Sb);
                }
                function At(t3, e3, n2, r3) {
                  return x ? qt(3, 1, t3, e3, n2, r3) : Et(t3, e3, n2, r3);
                }
                function Et(t3, e3, n2, r3) {
                  if ("undefined" == typeof SharedArrayBuffer)
                    return P("Current environment does not support SharedArrayBuffer, pthreads are not available!"), 6;
                  var i2 = [];
                  return x && 0 === i2.length ? At(t3, e3, n2, r3) : (t3 = { Ic: n2, Ub: t3, zc: r3, Nc: i2 }, x ? (t3.Oc = "spawnThread", postMessage(t3, i2), 0) : lt(t3));
                }
                function It(t3, e3, n2) {
                  return x ? qt(4, 1, t3, e3, n2) : 0;
                }
                function Pt(t3, e3) {
                  if (x)
                    return qt(5, 1, t3, e3);
                }
                function Dt(t3, e3) {
                  if (x)
                    return qt(6, 1, t3, e3);
                }
                function $t(t3, e3, n2) {
                  if (x)
                    return qt(7, 1, t3, e3, n2);
                }
                function kt(t3, e3, n2) {
                  return x ? qt(8, 1, t3, e3, n2) : 0;
                }
                function Ct(t3, e3) {
                  if (x)
                    return qt(9, 1, t3, e3);
                }
                function Ft(t3, e3, n2) {
                  if (x)
                    return qt(10, 1, t3, e3, n2);
                }
                function Nt(t3, e3, n2, r3) {
                  if (x)
                    return qt(11, 1, t3, e3, n2, r3);
                }
                function Lt(t3, e3, n2, r3) {
                  if (x)
                    return qt(12, 1, t3, e3, n2, r3);
                }
                function Rt(t3, e3, n2, r3) {
                  if (x)
                    return qt(13, 1, t3, e3, n2, r3);
                }
                function jt(t3) {
                  if (x)
                    return qt(14, 1, t3);
                }
                function Mt(t3, e3) {
                  if (x)
                    return qt(15, 1, t3, e3);
                }
                function Ut(t3, e3, n2) {
                  if (x)
                    return qt(16, 1, t3, e3, n2);
                }
                function Vt(t3) {
                  Atomics.store(i(), t3 >> 2, 1), de() && we(t3), Atomics.compareExchange(i(), t3 >> 2, 1, 0);
                }
                function Bt(t3) {
                  return o()[t3 >>> 2] + 4294967296 * i()[t3 + 4 >>> 2];
                }
                function zt(t3, e3, n2, r3, i2, o2) {
                  return x ? qt(17, 1, t3, e3, n2, r3, i2, o2) : -52;
                }
                function Gt(t3, e3, n2, r3, i2, o2) {
                  if (x)
                    return qt(18, 1, t3, e3, n2, r3, i2, o2);
                }
                function Ht(t3) {
                  var n2 = G(t3) + 1, r3 = he(n2);
                  return r3 && z(t3, e2(), r3, n2), r3;
                }
                function Wt(t3, e3, n2) {
                  function r3(t4) {
                    return (t4 = t4.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? t4[1] : "GMT";
                  }
                  if (x)
                    return qt(19, 1, t3, e3, n2);
                  var a2 = new Date().getFullYear(), s2 = new Date(a2, 0, 1), u2 = new Date(a2, 6, 1);
                  a2 = s2.getTimezoneOffset();
                  var c2 = u2.getTimezoneOffset(), l2 = Math.max(a2, c2);
                  i()[t3 >> 2 >>> 0] = 60 * l2, i()[e3 >> 2 >>> 0] = Number(a2 != c2), t3 = r3(s2), e3 = r3(u2), t3 = Ht(t3), e3 = Ht(e3), c2 < a2 ? (o()[n2 >> 2 >>> 0] = t3, o()[n2 + 4 >> 2 >>> 0] = e3) : (o()[n2 >> 2 >>> 0] = e3, o()[n2 + 4 >> 2 >>> 0] = t3);
                }
                function qt(t3, e3) {
                  var n2 = arguments.length - 2, r3 = arguments;
                  return gt(() => {
                    for (var i2 = Ie(8 * n2), o2 = i2 >> 3, s2 = 0; s2 < n2; s2++) {
                      var u2 = r3[2 + s2];
                      a()[o2 + s2 >>> 0] = u2;
                    }
                    return ve(t3, n2, i2, e3);
                  });
                }
                s.executeNotifiedProxyingQueue = Vt, vt = w ? () => {
                  var t3 = process.hrtime();
                  return 1e3 * t3[0] + t3[1] / 1e6;
                } : x ? () => performance.now() - s.__performance_now_clock_drift : () => performance.now();
                var Xt, Yt = [], Kt = {};
                function Zt() {
                  if (!Xt) {
                    var t3, e3 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: m || "./this.program" };
                    for (t3 in Kt)
                      void 0 === Kt[t3] ? delete e3[t3] : e3[t3] = Kt[t3];
                    var n2 = [];
                    for (t3 in e3)
                      n2.push(t3 + "=" + e3[t3]);
                    Xt = n2;
                  }
                  return Xt;
                }
                function Jt(t3, n2) {
                  if (x)
                    return qt(20, 1, t3, n2);
                  var r3 = 0;
                  return Zt().forEach(function(i2, a2) {
                    var s2 = n2 + r3;
                    for (a2 = o()[t3 + 4 * a2 >> 2 >>> 0] = s2, s2 = 0; s2 < i2.length; ++s2)
                      e2()[a2++ >> 0 >>> 0] = i2.charCodeAt(s2);
                    e2()[a2 >> 0 >>> 0] = 0, r3 += i2.length + 1;
                  }), 0;
                }
                function Qt(t3, e3) {
                  if (x)
                    return qt(21, 1, t3, e3);
                  var n2 = Zt();
                  o()[t3 >> 2 >>> 0] = n2.length;
                  var r3 = 0;
                  return n2.forEach(function(t4) {
                    r3 += t4.length + 1;
                  }), o()[e3 >> 2 >>> 0] = r3, 0;
                }
                function te(t3) {
                  return x ? qt(22, 1, t3) : 52;
                }
                function ee(t3, e3, n2, r3) {
                  return x ? qt(23, 1, t3, e3, n2, r3) : 52;
                }
                function ne(t3, e3, n2, r3, i2) {
                  return x ? qt(24, 1, t3, e3, n2, r3, i2) : 70;
                }
                var re = [null, [], []];
                function ie(t3, e3) {
                  var n2 = re[t3];
                  0 === e3 || 10 === e3 ? ((1 === t3 ? I : P)(V(n2, 0)), n2.length = 0) : n2.push(e3);
                }
                function oe(t3, e3, n2, i2) {
                  if (x)
                    return qt(25, 1, t3, e3, n2, i2);
                  for (var a2 = 0, s2 = 0; s2 < n2; s2++) {
                    var u2 = o()[e3 >> 2 >>> 0], c2 = o()[e3 + 4 >> 2 >>> 0];
                    e3 += 8;
                    for (var l2 = 0; l2 < c2; l2++)
                      ie(t3, r2()[u2 + l2 >>> 0]);
                    a2 += c2;
                  }
                  return o()[i2 >> 2 >>> 0] = a2, 0;
                }
                var ae = 0;
                function se(t3) {
                  return 0 == t3 % 4 && (0 != t3 % 100 || 0 == t3 % 400);
                }
                var ue = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], ce = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                function le(t3, n2, r3, o2) {
                  function a2(t4, e3, n3) {
                    for (t4 = "number" == typeof t4 ? t4.toString() : t4 || ""; t4.length < e3; )
                      t4 = n3[0] + t4;
                    return t4;
                  }
                  function s2(t4, e3) {
                    return a2(t4, e3, "0");
                  }
                  function u2(t4, e3) {
                    function n3(t5) {
                      return 0 > t5 ? -1 : 0 < t5 ? 1 : 0;
                    }
                    var r4;
                    return 0 === (r4 = n3(t4.getFullYear() - e3.getFullYear())) && 0 === (r4 = n3(t4.getMonth() - e3.getMonth())) && (r4 = n3(t4.getDate() - e3.getDate())), r4;
                  }
                  function c2(t4) {
                    switch (t4.getDay()) {
                      case 0:
                        return new Date(t4.getFullYear() - 1, 11, 29);
                      case 1:
                        return t4;
                      case 2:
                        return new Date(t4.getFullYear(), 0, 3);
                      case 3:
                        return new Date(t4.getFullYear(), 0, 2);
                      case 4:
                        return new Date(t4.getFullYear(), 0, 1);
                      case 5:
                        return new Date(t4.getFullYear() - 1, 11, 31);
                      case 6:
                        return new Date(t4.getFullYear() - 1, 11, 30);
                    }
                  }
                  function l2(t4) {
                    var e3 = t4.Wb;
                    for (t4 = new Date(new Date(t4.Xb + 1900, 0, 1).getTime()); 0 < e3; ) {
                      var n3 = t4.getMonth(), r4 = (se(t4.getFullYear()) ? ue : ce)[n3];
                      if (!(e3 > r4 - t4.getDate())) {
                        t4.setDate(t4.getDate() + e3);
                        break;
                      }
                      e3 -= r4 - t4.getDate() + 1, t4.setDate(1), 11 > n3 ? t4.setMonth(n3 + 1) : (t4.setMonth(0), t4.setFullYear(t4.getFullYear() + 1));
                    }
                    return n3 = new Date(t4.getFullYear() + 1, 0, 4), e3 = c2(new Date(t4.getFullYear(), 0, 4)), n3 = c2(n3), 0 >= u2(e3, t4) ? 0 >= u2(n3, t4) ? t4.getFullYear() + 1 : t4.getFullYear() : t4.getFullYear() - 1;
                  }
                  var p2 = i()[o2 + 40 >> 2 >>> 0];
                  for (var f2 in o2 = { Lc: i()[o2 >> 2 >>> 0], Kc: i()[o2 + 4 >> 2 >>> 0], dc: i()[o2 + 8 >> 2 >>> 0], jc: i()[o2 + 12 >> 2 >>> 0], ec: i()[o2 + 16 >> 2 >>> 0], Xb: i()[o2 + 20 >> 2 >>> 0], Tb: i()[o2 + 24 >> 2 >>> 0], Wb: i()[o2 + 28 >> 2 >>> 0], Rc: i()[o2 + 32 >> 2 >>> 0], Jc: i()[o2 + 36 >> 2 >>> 0], Mc: p2 ? B(p2) : "" }, r3 = B(r3), p2 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" })
                    r3 = r3.replace(new RegExp(f2, "g"), p2[f2]);
                  var d2 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), h2 = "January February March April May June July August September October November December".split(" ");
                  for (f2 in p2 = { "%a": function(t4) {
                    return d2[t4.Tb].substring(0, 3);
                  }, "%A": function(t4) {
                    return d2[t4.Tb];
                  }, "%b": function(t4) {
                    return h2[t4.ec].substring(0, 3);
                  }, "%B": function(t4) {
                    return h2[t4.ec];
                  }, "%C": function(t4) {
                    return s2((t4.Xb + 1900) / 100 | 0, 2);
                  }, "%d": function(t4) {
                    return s2(t4.jc, 2);
                  }, "%e": function(t4) {
                    return a2(t4.jc, 2, " ");
                  }, "%g": function(t4) {
                    return l2(t4).toString().substring(2);
                  }, "%G": function(t4) {
                    return l2(t4);
                  }, "%H": function(t4) {
                    return s2(t4.dc, 2);
                  }, "%I": function(t4) {
                    return 0 == (t4 = t4.dc) ? t4 = 12 : 12 < t4 && (t4 -= 12), s2(t4, 2);
                  }, "%j": function(t4) {
                    for (var e3 = 0, n3 = 0; n3 <= t4.ec - 1; e3 += (se(t4.Xb + 1900) ? ue : ce)[n3++])
                      ;
                    return s2(t4.jc + e3, 3);
                  }, "%m": function(t4) {
                    return s2(t4.ec + 1, 2);
                  }, "%M": function(t4) {
                    return s2(t4.Kc, 2);
                  }, "%n": function() {
                    return "\n";
                  }, "%p": function(t4) {
                    return 0 <= t4.dc && 12 > t4.dc ? "AM" : "PM";
                  }, "%S": function(t4) {
                    return s2(t4.Lc, 2);
                  }, "%t": function() {
                    return "	";
                  }, "%u": function(t4) {
                    return t4.Tb || 7;
                  }, "%U": function(t4) {
                    return s2(Math.floor((t4.Wb + 7 - t4.Tb) / 7), 2);
                  }, "%V": function(t4) {
                    var e3 = Math.floor((t4.Wb + 7 - (t4.Tb + 6) % 7) / 7);
                    if (2 >= (t4.Tb + 371 - t4.Wb - 2) % 7 && e3++, e3)
                      53 == e3 && (4 == (n3 = (t4.Tb + 371 - t4.Wb) % 7) || 3 == n3 && se(t4.Xb) || (e3 = 1));
                    else {
                      e3 = 52;
                      var n3 = (t4.Tb + 7 - t4.Wb - 1) % 7;
                      (4 == n3 || 5 == n3 && se(t4.Xb % 400 - 1)) && e3++;
                    }
                    return s2(e3, 2);
                  }, "%w": function(t4) {
                    return t4.Tb;
                  }, "%W": function(t4) {
                    return s2(Math.floor((t4.Wb + 7 - (t4.Tb + 6) % 7) / 7), 2);
                  }, "%y": function(t4) {
                    return (t4.Xb + 1900).toString().substring(2);
                  }, "%Y": function(t4) {
                    return t4.Xb + 1900;
                  }, "%z": function(t4) {
                    var e3 = 0 <= (t4 = t4.Jc);
                    return t4 = Math.abs(t4) / 60, (e3 ? "+" : "-") + String("0000" + (t4 / 60 * 100 + t4 % 60)).slice(-4);
                  }, "%Z": function(t4) {
                    return t4.Mc;
                  }, "%%": function() {
                    return "%";
                  } }, r3 = r3.replace(/%%/g, "\0\0"), p2)
                    r3.includes(f2) && (r3 = r3.replace(new RegExp(f2, "g"), p2[f2](o2)));
                  return f2 = function(t4) {
                    var e3 = Array(G(t4) + 1);
                    return z(t4, e3, 0, e3.length), e3;
                  }(r3 = r3.replace(/\0\0/g, "%")), f2.length > n2 ? 0 : (function(t4, n3) {
                    e2().set(t4, n3 >>> 0);
                  }(f2, t3), f2.length - 1);
                }
                dt.fc();
                var pe = [null, pt, bt, At, It, Pt, Dt, $t, kt, Ct, Ft, Nt, Lt, Rt, jt, Mt, Ut, zt, Gt, Wt, Jt, Qt, te, ee, ne, oe], fe = { b: function(t3) {
                  return he(t3 + 24) + 24;
                }, n: function(t3) {
                  return (t3 = new St(t3)).uc() || (t3.hc(true), xt--), t3.ic(false), wt.push(t3), t3.sc(), t3.vc();
                }, ma: function(t3) {
                  throw P("Unexpected exception thrown, this is not properly supported - aborting"), M = true, t3;
                }, x: function() {
                  Se(0);
                  var t3 = wt.pop();
                  if (t3.Hc() && !t3.kc()) {
                    var e3 = t3.Dc();
                    e3 && yt(e3)(t3.Zb), Ot(t3.Zb);
                  }
                  Tt = 0;
                }, e: function() {
                  var t3 = Tt;
                  if (!t3)
                    return ae = 0;
                  var e3 = new St(t3);
                  e3.cc(t3);
                  var n2 = e3.bc();
                  if (!n2)
                    return ae = 0, t3;
                  for (var r3 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r3.length; i2++) {
                    var o2 = r3[i2];
                    if (0 === o2 || o2 === n2)
                      break;
                    if (Pe(o2, n2, e3.Sb + 16))
                      return ae = o2, t3;
                  }
                  return ae = n2, t3;
                }, l: function() {
                  var t3 = Tt;
                  if (!t3)
                    return ae = 0;
                  var e3 = new St(t3);
                  e3.cc(t3);
                  var n2 = e3.bc();
                  if (!n2)
                    return ae = 0, t3;
                  for (var r3 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r3.length; i2++) {
                    var o2 = r3[i2];
                    if (0 === o2 || o2 === n2)
                      break;
                    if (Pe(o2, n2, e3.Sb + 16))
                      return ae = o2, t3;
                  }
                  return ae = n2, t3;
                }, h: function() {
                  var t3 = Tt;
                  if (!t3)
                    return ae = 0;
                  var e3 = new St(t3);
                  e3.cc(t3);
                  var n2 = e3.bc();
                  if (!n2)
                    return ae = 0, t3;
                  for (var r3 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r3.length; i2++) {
                    var o2 = r3[i2];
                    if (0 === o2 || o2 === n2)
                      break;
                    if (Pe(o2, n2, e3.Sb + 16))
                      return ae = o2, t3;
                  }
                  return ae = n2, t3;
                }, t: Ot, M: function() {
                  var t3 = wt.pop();
                  t3 || it("no exception to throw");
                  var e3 = t3.Zb;
                  throw t3.kc() || (wt.push(t3), t3.ic(true), t3.hc(false), xt++), Tt = e3, e3;
                }, c: function(t3, e3, n2) {
                  throw new St(t3).fc(e3, n2), Tt = t3, xt++, t3;
                }, pa: function() {
                  return xt;
                }, Fa: function(t3) {
                  ye(t3, !v, 1, !_), dt.pc();
                }, T: function(t3) {
                  x ? postMessage({ cmd: "cleanupThread", thread: t3 }) : ct(t3);
                }, xa: Et, j: function(t3) {
                  throw Tt || (Tt = t3), t3;
                }, H: It, Ma: Pt, ua: Dt, wa: $t, oa: kt, Ka: Ct, Ca: Ft, Ja: Nt, V: Lt, va: Rt, sa: jt, La: Mt, ta: Ut, Ta: function() {
                }, X: function() {
                  it("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
                }, Ua: function() {
                  it("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
                }, W: function() {
                  return Date.now();
                }, ya: function() {
                  return 2097152;
                }, Oa: function() {
                  return true;
                }, za: function(t3, e3, n2, r3) {
                  if (t3 == e3)
                    setTimeout(() => Vt(r3));
                  else if (x)
                    postMessage({ targetThread: t3, cmd: "processProxyingQueue", queue: r3 });
                  else {
                    if (!(t3 = dt.Vb[t3]))
                      return;
                    t3.postMessage({ cmd: "processProxyingQueue", queue: r3 });
                  }
                  return 1;
                }, Ea: function() {
                  return -1;
                }, Pa: function(t3, e3) {
                  t3 = new Date(1e3 * Bt(t3)), i()[e3 >> 2 >>> 0] = t3.getUTCSeconds(), i()[e3 + 4 >> 2 >>> 0] = t3.getUTCMinutes(), i()[e3 + 8 >> 2 >>> 0] = t3.getUTCHours(), i()[e3 + 12 >> 2 >>> 0] = t3.getUTCDate(), i()[e3 + 16 >> 2 >>> 0] = t3.getUTCMonth(), i()[e3 + 20 >> 2 >>> 0] = t3.getUTCFullYear() - 1900, i()[e3 + 24 >> 2 >>> 0] = t3.getUTCDay(), t3 = (t3.getTime() - Date.UTC(t3.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0, i()[e3 + 28 >> 2 >>> 0] = t3;
                }, Qa: function(t3, e3) {
                  t3 = new Date(1e3 * Bt(t3)), i()[e3 >> 2 >>> 0] = t3.getSeconds(), i()[e3 + 4 >> 2 >>> 0] = t3.getMinutes(), i()[e3 + 8 >> 2 >>> 0] = t3.getHours(), i()[e3 + 12 >> 2 >>> 0] = t3.getDate(), i()[e3 + 16 >> 2 >>> 0] = t3.getMonth(), i()[e3 + 20 >> 2 >>> 0] = t3.getFullYear() - 1900, i()[e3 + 24 >> 2 >>> 0] = t3.getDay();
                  var n2 = new Date(t3.getFullYear(), 0, 1), r3 = (t3.getTime() - n2.getTime()) / 864e5 | 0;
                  i()[e3 + 28 >> 2 >>> 0] = r3, i()[e3 + 36 >> 2 >>> 0] = -60 * t3.getTimezoneOffset(), r3 = new Date(t3.getFullYear(), 6, 1).getTimezoneOffset(), t3 = 0 | (r3 != (n2 = n2.getTimezoneOffset()) && t3.getTimezoneOffset() == Math.min(n2, r3)), i()[e3 + 32 >> 2 >>> 0] = t3;
                }, Ra: function(t3) {
                  var e3 = new Date(i()[t3 + 20 >> 2 >>> 0] + 1900, i()[t3 + 16 >> 2 >>> 0], i()[t3 + 12 >> 2 >>> 0], i()[t3 + 8 >> 2 >>> 0], i()[t3 + 4 >> 2 >>> 0], i()[t3 >> 2 >>> 0], 0), n2 = i()[t3 + 32 >> 2 >>> 0], r3 = e3.getTimezoneOffset(), o2 = new Date(e3.getFullYear(), 0, 1), a2 = new Date(e3.getFullYear(), 6, 1).getTimezoneOffset(), s2 = o2.getTimezoneOffset(), u2 = Math.min(s2, a2);
                  return 0 > n2 ? i()[t3 + 32 >> 2 >>> 0] = Number(a2 != s2 && u2 == r3) : 0 < n2 != (u2 == r3) && (a2 = Math.max(s2, a2), e3.setTime(e3.getTime() + 6e4 * ((0 < n2 ? u2 : a2) - r3))), i()[t3 + 24 >> 2 >>> 0] = e3.getDay(), n2 = (e3.getTime() - o2.getTime()) / 864e5 | 0, i()[t3 + 28 >> 2 >>> 0] = n2, i()[t3 >> 2 >>> 0] = e3.getSeconds(), i()[t3 + 4 >> 2 >>> 0] = e3.getMinutes(), i()[t3 + 8 >> 2 >>> 0] = e3.getHours(), i()[t3 + 12 >> 2 >>> 0] = e3.getDate(), i()[t3 + 16 >> 2 >>> 0] = e3.getMonth(), e3.getTime() / 1e3 | 0;
                }, Aa: zt, Ba: Gt, Sa: function t3(e3, n2, r3) {
                  t3.Ac || (t3.Ac = true, Wt(e3, n2, r3));
                }, y: function() {
                  it("");
                }, U: function() {
                  if (!w && !v) {
                    var t3 = "Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";
                    _t || (_t = {}), _t[t3] || (_t[t3] = 1, w && (t3 = "warning: " + t3), P(t3));
                  }
                }, ra: function() {
                  return 4294901760;
                }, B: vt, Ia: function(t3, e3, n2) {
                  r2().copyWithin(t3 >>> 0, e3 >>> 0, e3 + n2 >>> 0);
                }, F: function() {
                  return w ? n(3993).cpus().length : navigator.hardwareConcurrency;
                }, Da: function(t3, e3, n2) {
                  Yt.length = e3, n2 >>= 3;
                  for (var r3 = 0; r3 < e3; r3++)
                    Yt[r3] = a()[n2 + r3 >>> 0];
                  return (0 > t3 ? st[-t3 - 1] : pe[t3]).apply(null, Yt);
                }, qa: function(t3) {
                  var e3 = r2().length;
                  if ((t3 >>>= 0) <= e3 || 4294901760 < t3)
                    return false;
                  for (var n2 = 1; 4 >= n2; n2 *= 2) {
                    var i2 = e3 * (1 + 0.2 / n2);
                    i2 = Math.min(i2, t3 + 100663296);
                    var o2 = Math;
                    i2 = Math.max(t3, i2), o2 = o2.min.call(o2, 4294901760, i2 + (65536 - i2 % 65536) % 65536);
                    t: {
                      try {
                        $.grow(o2 - C.byteLength + 65535 >>> 16), H($.buffer);
                        var a2 = 1;
                        break t;
                      } catch (t4) {
                      }
                      a2 = void 0;
                    }
                    if (a2)
                      return true;
                  }
                  return false;
                }, Na: function() {
                  throw "unwind";
                }, Ga: Jt, Ha: Qt, J: ft, I: te, S: ee, ga: ne, R: oe, d: function() {
                  return ae;
                }, na: function t3(r3, i2) {
                  t3.lc || (t3.lc = function() {
                    if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues) {
                      var t4 = new Uint8Array(1);
                      return () => (crypto.getRandomValues(t4), t4[0]);
                    }
                    if (w)
                      try {
                        var e3 = n(Object(function() {
                          var t5 = new Error("Cannot find module 'crypto'");
                          throw t5.code = "MODULE_NOT_FOUND", t5;
                        }()));
                        return () => e3.randomBytes(1)[0];
                      } catch (t5) {
                      }
                    return () => it("randomDevice");
                  }());
                  for (var o2 = 0; o2 < i2; o2++)
                    e2()[r3 + o2 >> 0 >>> 0] = t3.lc();
                  return 0;
                }, ia: function(t3, e3, n2) {
                  var r3 = Ae();
                  try {
                    return yt(t3)(e3, n2);
                  } catch (t4) {
                    if (Ee(r3), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, ja: function(t3, e3, n2) {
                  var r3 = Ae();
                  try {
                    return yt(t3)(e3, n2);
                  } catch (t4) {
                    if (Ee(r3), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, K: function(t3) {
                  var e3 = Ae();
                  try {
                    return yt(t3)();
                  } catch (t4) {
                    if (Ee(e3), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, f: function(t3, e3) {
                  var n2 = Ae();
                  try {
                    return yt(t3)(e3);
                  } catch (t4) {
                    if (Ee(n2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, P: function(t3, e3, n2) {
                  var r3 = Ae();
                  try {
                    return yt(t3)(e3, n2);
                  } catch (t4) {
                    if (Ee(r3), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, Q: function(t3, e3, n2) {
                  var r3 = Ae();
                  try {
                    return yt(t3)(e3, n2);
                  } catch (t4) {
                    if (Ee(r3), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, k: function(t3, e3, n2) {
                  var r3 = Ae();
                  try {
                    return yt(t3)(e3, n2);
                  } catch (t4) {
                    if (Ee(r3), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, p: function(t3, e3, n2, r3) {
                  var i2 = Ae();
                  try {
                    return yt(t3)(e3, n2, r3);
                  } catch (t4) {
                    if (Ee(i2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, q: function(t3, e3, n2, r3, i2) {
                  var o2 = Ae();
                  try {
                    return yt(t3)(e3, n2, r3, i2);
                  } catch (t4) {
                    if (Ee(o2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, N: function(t3, e3, n2, r3, i2, o2) {
                  var a2 = Ae();
                  try {
                    return yt(t3)(e3, n2, r3, i2, o2);
                  } catch (t4) {
                    if (Ee(a2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, s: function(t3, e3, n2, r3, i2, o2) {
                  var a2 = Ae();
                  try {
                    return yt(t3)(e3, n2, r3, i2, o2);
                  } catch (t4) {
                    if (Ee(a2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, w: function(t3, e3, n2, r3, i2, o2, a2) {
                  var s2 = Ae();
                  try {
                    return yt(t3)(e3, n2, r3, i2, o2, a2);
                  } catch (t4) {
                    if (Ee(s2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, L: function(t3, e3, n2, r3, i2, o2, a2, s2) {
                  var u2 = Ae();
                  try {
                    return yt(t3)(e3, n2, r3, i2, o2, a2, s2);
                  } catch (t4) {
                    if (Ee(u2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, E: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2) {
                  var f2 = Ae();
                  try {
                    return yt(t3)(e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2);
                  } catch (t4) {
                    if (Ee(f2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, aa: function(t3, e3, n2, r3, i2, o2, a2, s2) {
                  var u2 = Ae();
                  try {
                    return Me(t3, e3, n2, r3, i2, o2, a2, s2);
                  } catch (t4) {
                    if (Ee(u2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, _: function(t3, e3, n2, r3, i2, o2, a2) {
                  var s2 = Ae();
                  try {
                    return ke(t3, e3, n2, r3, i2, o2, a2);
                  } catch (t4) {
                    if (Ee(s2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, Z: function(t3, e3, n2, r3, i2) {
                  var o2 = Ae();
                  try {
                    return Ue(t3, e3, n2, r3, i2);
                  } catch (t4) {
                    if (Ee(o2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, ca: function(t3, e3, n2, r3) {
                  var i2 = Ae();
                  try {
                    return Re(t3, e3, n2, r3);
                  } catch (t4) {
                    if (Ee(i2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, $: function(t3) {
                  var e3 = Ae();
                  try {
                    return $e(t3);
                  } catch (t4) {
                    if (Ee(e3), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, ba: function(t3, e3) {
                  var n2 = Ae();
                  try {
                    return je(t3, e3);
                  } catch (t4) {
                    if (Ee(n2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, Y: function(t3, e3, n2) {
                  var r3 = Ae();
                  try {
                    return Ce(t3, e3, n2);
                  } catch (t4) {
                    if (Ee(r3), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, g: function(t3) {
                  var e3 = Ae();
                  try {
                    yt(t3)();
                  } catch (t4) {
                    if (Ee(e3), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, r: function(t3, e3) {
                  var n2 = Ae();
                  try {
                    yt(t3)(e3);
                  } catch (t4) {
                    if (Ee(n2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, i: function(t3, e3, n2) {
                  var r3 = Ae();
                  try {
                    yt(t3)(e3, n2);
                  } catch (t4) {
                    if (Ee(r3), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, ha: function(t3, e3, n2, r3) {
                  var i2 = Ae();
                  try {
                    yt(t3)(e3, n2, r3);
                  } catch (t4) {
                    if (Ee(i2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, m: function(t3, e3, n2, r3) {
                  var i2 = Ae();
                  try {
                    yt(t3)(e3, n2, r3);
                  } catch (t4) {
                    if (Ee(i2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, v: function(t3, e3, n2, r3, i2) {
                  var o2 = Ae();
                  try {
                    yt(t3)(e3, n2, r3, i2);
                  } catch (t4) {
                    if (Ee(o2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, u: function(t3, e3, n2, r3, i2, o2) {
                  var a2 = Ae();
                  try {
                    yt(t3)(e3, n2, r3, i2, o2);
                  } catch (t4) {
                    if (Ee(a2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, O: function(t3, e3, n2, r3, i2, o2, a2) {
                  var s2 = Ae();
                  try {
                    yt(t3)(e3, n2, r3, i2, o2, a2);
                  } catch (t4) {
                    if (Ee(s2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, A: function(t3, e3, n2, r3, i2, o2, a2, s2) {
                  var u2 = Ae();
                  try {
                    yt(t3)(e3, n2, r3, i2, o2, a2, s2);
                  } catch (t4) {
                    if (Ee(u2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, ka: function(t3, e3, n2, r3, i2, o2, a2, s2, u2) {
                  var c2 = Ae();
                  try {
                    yt(t3)(e3, n2, r3, i2, o2, a2, s2, u2);
                  } catch (t4) {
                    if (Ee(c2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, C: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2) {
                  var p2 = Ae();
                  try {
                    yt(t3)(e3, n2, r3, i2, o2, a2, s2, u2, c2, l2);
                  } catch (t4) {
                    if (Ee(p2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, D: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2, f2, d2, h2, g2) {
                  var b2 = Ae();
                  try {
                    yt(t3)(e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2, f2, d2, h2, g2);
                  } catch (t4) {
                    if (Ee(b2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, fa: function(t3, e3, n2, r3, i2, o2, a2, s2) {
                  var u2 = Ae();
                  try {
                    Fe(t3, e3, n2, r3, i2, o2, a2, s2);
                  } catch (t4) {
                    if (Ee(u2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, da: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2) {
                  var f2 = Ae();
                  try {
                    Le(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2);
                  } catch (t4) {
                    if (Ee(f2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, ea: function(t3, e3, n2, r3, i2, o2) {
                  var a2 = Ae();
                  try {
                    Ne(t3, e3, n2, r3, i2, o2);
                  } catch (t4) {
                    if (Ee(a2), t4 !== t4 + 0)
                      throw t4;
                    Se(1, 0);
                  }
                }, o: function(t3) {
                  return t3;
                }, a: $ || s.wasmMemory, G: function(t3) {
                  ae = t3;
                }, la: le, z: function(t3, e3, n2, r3) {
                  return le(t3, e3, n2, r3);
                } };
                !function() {
                  function t3(t4, e4) {
                    s.asm = t4.exports, dt.qc.push(s.asm.sb), q = s.asm.ub, Y.unshift(s.asm.Va), k = e4, x || (et--, s.monitorRunDependencies && s.monitorRunDependencies(et), 0 == et && (null !== nt && (clearInterval(nt), nt = null), rt && (t4 = rt, rt = null, t4())));
                  }
                  function e3(e4) {
                    t3(e4.instance, e4.module);
                  }
                  function n2(t4) {
                    return function() {
                      if (!E && (_ || v)) {
                        if ("function" == typeof fetch && !tt.startsWith("file://"))
                          return fetch(tt, { credentials: "same-origin" }).then(function(t5) {
                            if (!t5.ok)
                              throw "failed to load wasm binary file at '" + tt + "'";
                            return t5.arrayBuffer();
                          }).catch(function() {
                            return at();
                          });
                        if (p)
                          return new Promise(function(t5, e4) {
                            p(tt, function(e5) {
                              t5(new Uint8Array(e5));
                            }, e4);
                          });
                      }
                      return Promise.resolve().then(function() {
                        return at();
                      });
                    }().then(function(t5) {
                      return WebAssembly.instantiate(t5, r3);
                    }).then(function(t5) {
                      return t5;
                    }).then(t4, function(t5) {
                      P("failed to asynchronously prepare wasm: " + t5), it(t5);
                    });
                  }
                  var r3 = { a: fe };
                  if (x || (et++, s.monitorRunDependencies && s.monitorRunDependencies(et)), s.instantiateWasm)
                    try {
                      return s.instantiateWasm(r3, t3);
                    } catch (t4) {
                      return P("Module.instantiateWasm callback failed with error: " + t4), false;
                    }
                  (E || "function" != typeof WebAssembly.instantiateStreaming || ot() || tt.startsWith("file://") || w || "function" != typeof fetch ? n2(e3) : fetch(tt, { credentials: "same-origin" }).then(function(t4) {
                    return WebAssembly.instantiateStreaming(t4, r3).then(e3, function(t5) {
                      return P("wasm streaming compile failed: " + t5), P("falling back to ArrayBuffer instantiation"), n2(e3);
                    });
                  })).catch(c);
                }(), s.___wasm_call_ctors = function() {
                  return (s.___wasm_call_ctors = s.asm.Va).apply(null, arguments);
                }, s._OrtInit = function() {
                  return (s._OrtInit = s.asm.Wa).apply(null, arguments);
                }, s._OrtCreateSessionOptions = function() {
                  return (s._OrtCreateSessionOptions = s.asm.Xa).apply(null, arguments);
                }, s._OrtAppendExecutionProvider = function() {
                  return (s._OrtAppendExecutionProvider = s.asm.Ya).apply(null, arguments);
                }, s._OrtAddSessionConfigEntry = function() {
                  return (s._OrtAddSessionConfigEntry = s.asm.Za).apply(null, arguments);
                }, s._OrtReleaseSessionOptions = function() {
                  return (s._OrtReleaseSessionOptions = s.asm._a).apply(null, arguments);
                }, s._OrtCreateSession = function() {
                  return (s._OrtCreateSession = s.asm.$a).apply(null, arguments);
                }, s._OrtReleaseSession = function() {
                  return (s._OrtReleaseSession = s.asm.ab).apply(null, arguments);
                }, s._OrtGetInputCount = function() {
                  return (s._OrtGetInputCount = s.asm.bb).apply(null, arguments);
                }, s._OrtGetOutputCount = function() {
                  return (s._OrtGetOutputCount = s.asm.cb).apply(null, arguments);
                }, s._OrtGetInputName = function() {
                  return (s._OrtGetInputName = s.asm.db).apply(null, arguments);
                }, s._OrtGetOutputName = function() {
                  return (s._OrtGetOutputName = s.asm.eb).apply(null, arguments);
                }, s._OrtFree = function() {
                  return (s._OrtFree = s.asm.fb).apply(null, arguments);
                }, s._OrtCreateTensor = function() {
                  return (s._OrtCreateTensor = s.asm.gb).apply(null, arguments);
                }, s._OrtGetTensorData = function() {
                  return (s._OrtGetTensorData = s.asm.hb).apply(null, arguments);
                }, s._OrtReleaseTensor = function() {
                  return (s._OrtReleaseTensor = s.asm.ib).apply(null, arguments);
                }, s._OrtCreateRunOptions = function() {
                  return (s._OrtCreateRunOptions = s.asm.jb).apply(null, arguments);
                }, s._OrtAddRunConfigEntry = function() {
                  return (s._OrtAddRunConfigEntry = s.asm.kb).apply(null, arguments);
                }, s._OrtReleaseRunOptions = function() {
                  return (s._OrtReleaseRunOptions = s.asm.lb).apply(null, arguments);
                }, s._OrtRun = function() {
                  return (s._OrtRun = s.asm.mb).apply(null, arguments);
                }, s._OrtEndProfiling = function() {
                  return (s._OrtEndProfiling = s.asm.nb).apply(null, arguments);
                };
                var de = s._pthread_self = function() {
                  return (de = s._pthread_self = s.asm.ob).apply(null, arguments);
                }, he = s._malloc = function() {
                  return (he = s._malloc = s.asm.pb).apply(null, arguments);
                }, ge = s._free = function() {
                  return (ge = s._free = s.asm.qb).apply(null, arguments);
                }, be = s._fflush = function() {
                  return (be = s._fflush = s.asm.rb).apply(null, arguments);
                };
                s.__emscripten_tls_init = function() {
                  return (s.__emscripten_tls_init = s.asm.sb).apply(null, arguments);
                };
                var me = s.___funcs_on_exit = function() {
                  return (me = s.___funcs_on_exit = s.asm.tb).apply(null, arguments);
                }, ye = s.__emscripten_thread_init = function() {
                  return (ye = s.__emscripten_thread_init = s.asm.vb).apply(null, arguments);
                };
                s.__emscripten_thread_crashed = function() {
                  return (s.__emscripten_thread_crashed = s.asm.wb).apply(null, arguments);
                };
                var _e, ve = s._emscripten_run_in_main_runtime_thread_js = function() {
                  return (ve = s._emscripten_run_in_main_runtime_thread_js = s.asm.xb).apply(null, arguments);
                }, we = s.__emscripten_proxy_execute_task_queue = function() {
                  return (we = s.__emscripten_proxy_execute_task_queue = s.asm.yb).apply(null, arguments);
                }, xe = s.__emscripten_thread_free_data = function() {
                  return (xe = s.__emscripten_thread_free_data = s.asm.zb).apply(null, arguments);
                }, Te = s.__emscripten_thread_exit = function() {
                  return (Te = s.__emscripten_thread_exit = s.asm.Ab).apply(null, arguments);
                }, Se = s._setThrew = function() {
                  return (Se = s._setThrew = s.asm.Bb).apply(null, arguments);
                }, Oe = s._emscripten_stack_set_limits = function() {
                  return (Oe = s._emscripten_stack_set_limits = s.asm.Cb).apply(null, arguments);
                }, Ae = s.stackSave = function() {
                  return (Ae = s.stackSave = s.asm.Db).apply(null, arguments);
                }, Ee = s.stackRestore = function() {
                  return (Ee = s.stackRestore = s.asm.Eb).apply(null, arguments);
                }, Ie = s.stackAlloc = function() {
                  return (Ie = s.stackAlloc = s.asm.Fb).apply(null, arguments);
                }, Pe = s.___cxa_can_catch = function() {
                  return (Pe = s.___cxa_can_catch = s.asm.Gb).apply(null, arguments);
                }, De = s.___cxa_is_pointer_type = function() {
                  return (De = s.___cxa_is_pointer_type = s.asm.Hb).apply(null, arguments);
                }, $e = s.dynCall_j = function() {
                  return ($e = s.dynCall_j = s.asm.Ib).apply(null, arguments);
                }, ke = s.dynCall_iiiiij = function() {
                  return (ke = s.dynCall_iiiiij = s.asm.Jb).apply(null, arguments);
                }, Ce = s.dynCall_jii = function() {
                  return (Ce = s.dynCall_jii = s.asm.Kb).apply(null, arguments);
                }, Fe = s.dynCall_viiiiij = function() {
                  return (Fe = s.dynCall_viiiiij = s.asm.Lb).apply(null, arguments);
                }, Ne = s.dynCall_vjji = function() {
                  return (Ne = s.dynCall_vjji = s.asm.Mb).apply(null, arguments);
                }, Le = s.dynCall_viiijjjii = function() {
                  return (Le = s.dynCall_viiijjjii = s.asm.Nb).apply(null, arguments);
                }, Re = s.dynCall_iij = function() {
                  return (Re = s.dynCall_iij = s.asm.Ob).apply(null, arguments);
                }, je = s.dynCall_ji = function() {
                  return (je = s.dynCall_ji = s.asm.Pb).apply(null, arguments);
                }, Me = s.dynCall_iiiiiij = function() {
                  return (Me = s.dynCall_iiiiiij = s.asm.Qb).apply(null, arguments);
                }, Ue = s.dynCall_iiij = function() {
                  return (Ue = s.dynCall_iiij = s.asm.Rb).apply(null, arguments);
                };
                function Ve() {
                  function t3() {
                    if (!_e && (_e = true, s.calledRun = true, !M) && (x || ht(Y), u(s), s.onRuntimeInitialized && s.onRuntimeInitialized(), !x)) {
                      if (s.postRun)
                        for ("function" == typeof s.postRun && (s.postRun = [s.postRun]); s.postRun.length; ) {
                          var t4 = s.postRun.shift();
                          Z.unshift(t4);
                        }
                      ht(Z);
                    }
                  }
                  if (!(0 < et))
                    if (x)
                      u(s), x || ht(Y), postMessage({ cmd: "loaded" });
                    else {
                      if (s.preRun)
                        for ("function" == typeof s.preRun && (s.preRun = [s.preRun]); s.preRun.length; )
                          Q();
                      ht(X), 0 < et || (s.setStatus ? (s.setStatus("Running..."), setTimeout(function() {
                        setTimeout(function() {
                          s.setStatus("");
                        }, 1), t3();
                      }, 1)) : t3());
                    }
                }
                if (s.UTF8ToString = B, s.stringToUTF8 = function(t3, e3, n2) {
                  return z(t3, r2(), e3, n2);
                }, s.lengthBytesUTF8 = G, s.keepRuntimeAlive = J, s.wasmMemory = $, s.stackSave = Ae, s.stackRestore = Ee, s.stackAlloc = Ie, s.ExitStatus = ut, s.PThread = dt, rt = function t3() {
                  _e || Ve(), _e || (rt = t3);
                }, s.preInit)
                  for ("function" == typeof s.preInit && (s.preInit = [s.preInit]); 0 < s.preInit.length; )
                    s.preInit.pop()();
                return Ve(), t2.ready;
              });
              t.exports = r;
            }, 932: (t, e, n) => {
              var _scriptDir, r = (_scriptDir = (_scriptDir = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0) || "/index.js", function(t2) {
                var e2, r2, i;
                t2 = t2 || {}, e2 || (e2 = void 0 !== t2 ? t2 : {}), e2.ready = new Promise(function(t3, e3) {
                  r2 = t3, i = e3;
                });
                var o, a, s, u, c, l, p = Object.assign({}, e2), f = "./this.program", d = (t3, e3) => {
                  throw e3;
                }, h = "object" == typeof window, g = "function" == typeof importScripts, b = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, m = "";
                b ? (m = g ? n(908).dirname(m) + "/" : "//", l = () => {
                  c || (u = n(1384), c = n(908));
                }, o = function(t3, e3) {
                  return l(), t3 = c.normalize(t3), u.readFileSync(t3, e3 ? void 0 : "utf8");
                }, s = (t3) => ((t3 = o(t3, true)).buffer || (t3 = new Uint8Array(t3)), t3), a = (t3, e3, n2) => {
                  l(), t3 = c.normalize(t3), u.readFile(t3, function(t4, r3) {
                    t4 ? n2(t4) : e3(r3.buffer);
                  });
                }, 1 < process.argv.length && (f = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), process.on("uncaughtException", function(t3) {
                  if (!(t3 instanceof K))
                    throw t3;
                }), process.on("unhandledRejection", function(t3) {
                  throw t3;
                }), d = (t3, e3) => {
                  if (w || 0 < U)
                    throw process.exitCode = t3, e3;
                  e3 instanceof K || v("exiting due to exception: " + e3), process.exit(t3);
                }, e2.inspect = function() {
                  return "[Emscripten Module object]";
                }) : (h || g) && (g ? m = self.location.href : "undefined" != typeof document && document.currentScript && (m = document.currentScript.src), _scriptDir && (m = _scriptDir), m = 0 !== m.indexOf("blob:") ? m.substr(0, m.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", o = (t3) => {
                  var e3 = new XMLHttpRequest();
                  return e3.open("GET", t3, false), e3.send(null), e3.responseText;
                }, g && (s = (t3) => {
                  var e3 = new XMLHttpRequest();
                  return e3.open("GET", t3, false), e3.responseType = "arraybuffer", e3.send(null), new Uint8Array(e3.response);
                }), a = (t3, e3, n2) => {
                  var r3 = new XMLHttpRequest();
                  r3.open("GET", t3, true), r3.responseType = "arraybuffer", r3.onload = () => {
                    200 == r3.status || 0 == r3.status && r3.response ? e3(r3.response) : n2();
                  }, r3.onerror = n2, r3.send(null);
                });
                var y, _ = e2.print || console.log.bind(console), v = e2.printErr || console.warn.bind(console);
                Object.assign(e2, p), p = null, e2.thisProgram && (f = e2.thisProgram), e2.quit && (d = e2.quit), e2.wasmBinary && (y = e2.wasmBinary);
                var w = e2.noExitRuntime || false;
                "object" != typeof WebAssembly && W("no native wasm support detected");
                var x, T, S, O, A, E, I = false, P = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
                function D(t3, e3, n2) {
                  var r3 = (e3 >>>= 0) + n2;
                  for (n2 = e3; t3[n2] && !(n2 >= r3); )
                    ++n2;
                  if (16 < n2 - e3 && t3.buffer && P)
                    return P.decode(t3.subarray(e3, n2));
                  for (r3 = ""; e3 < n2; ) {
                    var i2 = t3[e3++];
                    if (128 & i2) {
                      var o2 = 63 & t3[e3++];
                      if (192 == (224 & i2))
                        r3 += String.fromCharCode((31 & i2) << 6 | o2);
                      else {
                        var a2 = 63 & t3[e3++];
                        65536 > (i2 = 224 == (240 & i2) ? (15 & i2) << 12 | o2 << 6 | a2 : (7 & i2) << 18 | o2 << 12 | a2 << 6 | 63 & t3[e3++]) ? r3 += String.fromCharCode(i2) : (i2 -= 65536, r3 += String.fromCharCode(55296 | i2 >> 10, 56320 | 1023 & i2));
                      }
                    } else
                      r3 += String.fromCharCode(i2);
                  }
                  return r3;
                }
                function $(t3, e3) {
                  return (t3 >>>= 0) ? D(O, t3, e3) : "";
                }
                function k(t3, e3, n2, r3) {
                  if (!(0 < r3))
                    return 0;
                  var i2 = n2 >>>= 0;
                  r3 = n2 + r3 - 1;
                  for (var o2 = 0; o2 < t3.length; ++o2) {
                    var a2 = t3.charCodeAt(o2);
                    if (55296 <= a2 && 57343 >= a2 && (a2 = 65536 + ((1023 & a2) << 10) | 1023 & t3.charCodeAt(++o2)), 127 >= a2) {
                      if (n2 >= r3)
                        break;
                      e3[n2++ >>> 0] = a2;
                    } else {
                      if (2047 >= a2) {
                        if (n2 + 1 >= r3)
                          break;
                        e3[n2++ >>> 0] = 192 | a2 >> 6;
                      } else {
                        if (65535 >= a2) {
                          if (n2 + 2 >= r3)
                            break;
                          e3[n2++ >>> 0] = 224 | a2 >> 12;
                        } else {
                          if (n2 + 3 >= r3)
                            break;
                          e3[n2++ >>> 0] = 240 | a2 >> 18, e3[n2++ >>> 0] = 128 | a2 >> 12 & 63;
                        }
                        e3[n2++ >>> 0] = 128 | a2 >> 6 & 63;
                      }
                      e3[n2++ >>> 0] = 128 | 63 & a2;
                    }
                  }
                  return e3[n2 >>> 0] = 0, n2 - i2;
                }
                function C(t3) {
                  for (var e3 = 0, n2 = 0; n2 < t3.length; ++n2) {
                    var r3 = t3.charCodeAt(n2);
                    127 >= r3 ? e3++ : 2047 >= r3 ? e3 += 2 : 55296 <= r3 && 57343 >= r3 ? (e3 += 4, ++n2) : e3 += 3;
                  }
                  return e3;
                }
                function F() {
                  var t3 = x.buffer;
                  T = t3, e2.HEAP8 = S = new Int8Array(t3), e2.HEAP16 = new Int16Array(t3), e2.HEAP32 = A = new Int32Array(t3), e2.HEAPU8 = O = new Uint8Array(t3), e2.HEAPU16 = new Uint16Array(t3), e2.HEAPU32 = E = new Uint32Array(t3), e2.HEAPF32 = new Float32Array(t3), e2.HEAPF64 = new Float64Array(t3);
                }
                var N, L = [], R = [], j = [], M = [], U = 0;
                function V() {
                  var t3 = e2.preRun.shift();
                  L.unshift(t3);
                }
                var B, z = 0, G = null, H = null;
                function W(t3) {
                  throw e2.onAbort && e2.onAbort(t3), v(t3 = "Aborted(" + t3 + ")"), I = true, t3 = new WebAssembly.RuntimeError(t3 + ". Build with -sASSERTIONS for more info."), i(t3), t3;
                }
                function q() {
                  return B.startsWith("data:application/octet-stream;base64,");
                }
                if (B = "ort-wasm.wasm", !q()) {
                  var X = B;
                  B = e2.locateFile ? e2.locateFile(X, m) : m + X;
                }
                function Y() {
                  var t3 = B;
                  try {
                    if (t3 == B && y)
                      return new Uint8Array(y);
                    if (s)
                      return s(t3);
                    throw "both async and sync fetching of the wasm failed";
                  } catch (t4) {
                    W(t4);
                  }
                }
                function K(t3) {
                  this.name = "ExitStatus", this.message = "Program terminated with exit(" + t3 + ")", this.status = t3;
                }
                function Z(t3) {
                  for (; 0 < t3.length; )
                    t3.shift()(e2);
                }
                var J = [], Q = 0, tt = 0;
                function et(t3) {
                  this.Db = t3, this.zb = t3 - 24, this.Ub = function(t4) {
                    E[this.zb + 4 >> 2 >>> 0] = t4;
                  }, this.Eb = function() {
                    return E[this.zb + 4 >> 2 >>> 0];
                  }, this.Sb = function(t4) {
                    E[this.zb + 8 >> 2 >>> 0] = t4;
                  }, this.Wb = function() {
                    return E[this.zb + 8 >> 2 >>> 0];
                  }, this.Tb = function() {
                    A[this.zb >> 2 >>> 0] = 0;
                  }, this.Ib = function(t4) {
                    S[this.zb + 12 >> 0 >>> 0] = t4 ? 1 : 0;
                  }, this.Pb = function() {
                    return 0 != S[this.zb + 12 >> 0 >>> 0];
                  }, this.Jb = function(t4) {
                    S[this.zb + 13 >> 0 >>> 0] = t4 ? 1 : 0;
                  }, this.Lb = function() {
                    return 0 != S[this.zb + 13 >> 0 >>> 0];
                  }, this.Rb = function(t4, e3) {
                    this.Fb(0), this.Ub(t4), this.Sb(e3), this.Tb(), this.Ib(false), this.Jb(false);
                  }, this.Nb = function() {
                    A[this.zb >> 2 >>> 0] += 1;
                  }, this.Xb = function() {
                    var t4 = A[this.zb >> 2 >>> 0];
                    return A[this.zb >> 2 >>> 0] = t4 - 1, 1 === t4;
                  }, this.Fb = function(t4) {
                    E[this.zb + 16 >> 2 >>> 0] = t4;
                  }, this.Ob = function() {
                    return E[this.zb + 16 >> 2 >>> 0];
                  }, this.Qb = function() {
                    if (Et(this.Eb()))
                      return E[this.Db >> 2 >>> 0];
                    var t4 = this.Ob();
                    return 0 !== t4 ? t4 : this.Db;
                  };
                }
                function nt(t3) {
                  return _t(new et(t3).zb);
                }
                var rt = [];
                function it(t3) {
                  var e3 = rt[t3];
                  return e3 || (t3 >= rt.length && (rt.length = t3 + 1), rt[t3] = e3 = N.get(t3)), e3;
                }
                function ot(t3) {
                  var e3 = C(t3) + 1, n2 = yt(e3);
                  return n2 && k(t3, S, n2, e3), n2;
                }
                var at = {};
                function st() {
                  if (!ut) {
                    var t3, e3 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: f || "./this.program" };
                    for (t3 in at)
                      void 0 === at[t3] ? delete e3[t3] : e3[t3] = at[t3];
                    var n2 = [];
                    for (t3 in e3)
                      n2.push(t3 + "=" + e3[t3]);
                    ut = n2;
                  }
                  return ut;
                }
                var ut, ct = [null, [], []];
                function lt(t3, e3) {
                  var n2 = ct[t3];
                  0 === e3 || 10 === e3 ? ((1 === t3 ? _ : v)(D(n2, 0)), n2.length = 0) : n2.push(e3);
                }
                var pt = 0;
                function ft(t3) {
                  return 0 == t3 % 4 && (0 != t3 % 100 || 0 == t3 % 400);
                }
                var dt = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], ht = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                function gt(t3, e3, n2, r3) {
                  function i2(t4, e4, n3) {
                    for (t4 = "number" == typeof t4 ? t4.toString() : t4 || ""; t4.length < e4; )
                      t4 = n3[0] + t4;
                    return t4;
                  }
                  function o2(t4, e4) {
                    return i2(t4, e4, "0");
                  }
                  function a2(t4, e4) {
                    function n3(t5) {
                      return 0 > t5 ? -1 : 0 < t5 ? 1 : 0;
                    }
                    var r4;
                    return 0 === (r4 = n3(t4.getFullYear() - e4.getFullYear())) && 0 === (r4 = n3(t4.getMonth() - e4.getMonth())) && (r4 = n3(t4.getDate() - e4.getDate())), r4;
                  }
                  function s2(t4) {
                    switch (t4.getDay()) {
                      case 0:
                        return new Date(t4.getFullYear() - 1, 11, 29);
                      case 1:
                        return t4;
                      case 2:
                        return new Date(t4.getFullYear(), 0, 3);
                      case 3:
                        return new Date(t4.getFullYear(), 0, 2);
                      case 4:
                        return new Date(t4.getFullYear(), 0, 1);
                      case 5:
                        return new Date(t4.getFullYear() - 1, 11, 31);
                      case 6:
                        return new Date(t4.getFullYear() - 1, 11, 30);
                    }
                  }
                  function u2(t4) {
                    var e4 = t4.Bb;
                    for (t4 = new Date(new Date(t4.Cb + 1900, 0, 1).getTime()); 0 < e4; ) {
                      var n3 = t4.getMonth(), r4 = (ft(t4.getFullYear()) ? dt : ht)[n3];
                      if (!(e4 > r4 - t4.getDate())) {
                        t4.setDate(t4.getDate() + e4);
                        break;
                      }
                      e4 -= r4 - t4.getDate() + 1, t4.setDate(1), 11 > n3 ? t4.setMonth(n3 + 1) : (t4.setMonth(0), t4.setFullYear(t4.getFullYear() + 1));
                    }
                    return n3 = new Date(t4.getFullYear() + 1, 0, 4), e4 = s2(new Date(t4.getFullYear(), 0, 4)), n3 = s2(n3), 0 >= a2(e4, t4) ? 0 >= a2(n3, t4) ? t4.getFullYear() + 1 : t4.getFullYear() : t4.getFullYear() - 1;
                  }
                  var c2 = A[r3 + 40 >> 2 >>> 0];
                  for (var l2 in r3 = { $b: A[r3 >> 2 >>> 0], Zb: A[r3 + 4 >> 2 >>> 0], Gb: A[r3 + 8 >> 2 >>> 0], Kb: A[r3 + 12 >> 2 >>> 0], Hb: A[r3 + 16 >> 2 >>> 0], Cb: A[r3 + 20 >> 2 >>> 0], Ab: A[r3 + 24 >> 2 >>> 0], Bb: A[r3 + 28 >> 2 >>> 0], bc: A[r3 + 32 >> 2 >>> 0], Yb: A[r3 + 36 >> 2 >>> 0], ac: c2 ? $(c2) : "" }, n2 = $(n2), c2 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" })
                    n2 = n2.replace(new RegExp(l2, "g"), c2[l2]);
                  var p2 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), f2 = "January February March April May June July August September October November December".split(" ");
                  for (l2 in c2 = { "%a": function(t4) {
                    return p2[t4.Ab].substring(0, 3);
                  }, "%A": function(t4) {
                    return p2[t4.Ab];
                  }, "%b": function(t4) {
                    return f2[t4.Hb].substring(0, 3);
                  }, "%B": function(t4) {
                    return f2[t4.Hb];
                  }, "%C": function(t4) {
                    return o2((t4.Cb + 1900) / 100 | 0, 2);
                  }, "%d": function(t4) {
                    return o2(t4.Kb, 2);
                  }, "%e": function(t4) {
                    return i2(t4.Kb, 2, " ");
                  }, "%g": function(t4) {
                    return u2(t4).toString().substring(2);
                  }, "%G": function(t4) {
                    return u2(t4);
                  }, "%H": function(t4) {
                    return o2(t4.Gb, 2);
                  }, "%I": function(t4) {
                    return 0 == (t4 = t4.Gb) ? t4 = 12 : 12 < t4 && (t4 -= 12), o2(t4, 2);
                  }, "%j": function(t4) {
                    for (var e4 = 0, n3 = 0; n3 <= t4.Hb - 1; e4 += (ft(t4.Cb + 1900) ? dt : ht)[n3++])
                      ;
                    return o2(t4.Kb + e4, 3);
                  }, "%m": function(t4) {
                    return o2(t4.Hb + 1, 2);
                  }, "%M": function(t4) {
                    return o2(t4.Zb, 2);
                  }, "%n": function() {
                    return "\n";
                  }, "%p": function(t4) {
                    return 0 <= t4.Gb && 12 > t4.Gb ? "AM" : "PM";
                  }, "%S": function(t4) {
                    return o2(t4.$b, 2);
                  }, "%t": function() {
                    return "	";
                  }, "%u": function(t4) {
                    return t4.Ab || 7;
                  }, "%U": function(t4) {
                    return o2(Math.floor((t4.Bb + 7 - t4.Ab) / 7), 2);
                  }, "%V": function(t4) {
                    var e4 = Math.floor((t4.Bb + 7 - (t4.Ab + 6) % 7) / 7);
                    if (2 >= (t4.Ab + 371 - t4.Bb - 2) % 7 && e4++, e4)
                      53 == e4 && (4 == (n3 = (t4.Ab + 371 - t4.Bb) % 7) || 3 == n3 && ft(t4.Cb) || (e4 = 1));
                    else {
                      e4 = 52;
                      var n3 = (t4.Ab + 7 - t4.Bb - 1) % 7;
                      (4 == n3 || 5 == n3 && ft(t4.Cb % 400 - 1)) && e4++;
                    }
                    return o2(e4, 2);
                  }, "%w": function(t4) {
                    return t4.Ab;
                  }, "%W": function(t4) {
                    return o2(Math.floor((t4.Bb + 7 - (t4.Ab + 6) % 7) / 7), 2);
                  }, "%y": function(t4) {
                    return (t4.Cb + 1900).toString().substring(2);
                  }, "%Y": function(t4) {
                    return t4.Cb + 1900;
                  }, "%z": function(t4) {
                    var e4 = 0 <= (t4 = t4.Yb);
                    return t4 = Math.abs(t4) / 60, (e4 ? "+" : "-") + String("0000" + (t4 / 60 * 100 + t4 % 60)).slice(-4);
                  }, "%Z": function(t4) {
                    return t4.ac;
                  }, "%%": function() {
                    return "%";
                  } }, n2 = n2.replace(/%%/g, "\0\0"), c2)
                    n2.includes(l2) && (n2 = n2.replace(new RegExp(l2, "g"), c2[l2](r3)));
                  return l2 = function(t4) {
                    var e4 = Array(C(t4) + 1);
                    return k(t4, e4, 0, e4.length), e4;
                  }(n2 = n2.replace(/\0\0/g, "%")), l2.length > e3 ? 0 : (S.set(l2, t3 >>> 0), l2.length - 1);
                }
                var bt = { a: function(t3) {
                  return yt(t3 + 24) + 24;
                }, m: function(t3) {
                  return (t3 = new et(t3)).Pb() || (t3.Ib(true), Q--), t3.Jb(false), J.push(t3), t3.Nb(), t3.Qb();
                }, ia: function(t3) {
                  throw v("Unexpected exception thrown, this is not properly supported - aborting"), I = true, t3;
                }, w: function() {
                  xt(0);
                  var t3 = J.pop();
                  if (t3.Xb() && !t3.Lb()) {
                    var e3 = t3.Wb();
                    e3 && it(e3)(t3.Db), nt(t3.Db);
                  }
                  tt = 0;
                }, d: function() {
                  var t3 = tt;
                  if (!t3)
                    return pt = 0;
                  var e3 = new et(t3);
                  e3.Fb(t3);
                  var n2 = e3.Eb();
                  if (!n2)
                    return pt = 0, t3;
                  for (var r3 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r3.length; i2++) {
                    var o2 = r3[i2];
                    if (0 === o2 || o2 === n2)
                      break;
                    if (At(o2, n2, e3.zb + 16))
                      return pt = o2, t3;
                  }
                  return pt = n2, t3;
                }, k: function() {
                  var t3 = tt;
                  if (!t3)
                    return pt = 0;
                  var e3 = new et(t3);
                  e3.Fb(t3);
                  var n2 = e3.Eb();
                  if (!n2)
                    return pt = 0, t3;
                  for (var r3 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r3.length; i2++) {
                    var o2 = r3[i2];
                    if (0 === o2 || o2 === n2)
                      break;
                    if (At(o2, n2, e3.zb + 16))
                      return pt = o2, t3;
                  }
                  return pt = n2, t3;
                }, g: function() {
                  var t3 = tt;
                  if (!t3)
                    return pt = 0;
                  var e3 = new et(t3);
                  e3.Fb(t3);
                  var n2 = e3.Eb();
                  if (!n2)
                    return pt = 0, t3;
                  for (var r3 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r3.length; i2++) {
                    var o2 = r3[i2];
                    if (0 === o2 || o2 === n2)
                      break;
                    if (At(o2, n2, e3.zb + 16))
                      return pt = o2, t3;
                  }
                  return pt = n2, t3;
                }, s: nt, L: function() {
                  var t3 = J.pop();
                  t3 || W("no exception to throw");
                  var e3 = t3.Db;
                  throw t3.Lb() || (J.push(t3), t3.Jb(true), t3.Ib(false), Q++), tt = e3, e3;
                }, b: function(t3, e3, n2) {
                  throw new et(t3).Rb(e3, n2), tt = t3, Q++, t3;
                }, la: function() {
                  return Q;
                }, i: function(t3) {
                  throw tt || (tt = t3), t3;
                }, H: function() {
                  return 0;
                }, Ba: function() {
                }, pa: function() {
                }, ra: function() {
                }, ka: function() {
                  return 0;
                }, za: function() {
                }, ua: function() {
                }, ya: function() {
                }, R: function() {
                }, qa: function() {
                }, na: function() {
                }, Aa: function() {
                }, oa: function() {
                }, Ha: function() {
                }, Ja: function() {
                  W("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
                }, Ia: function() {
                  W("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
                }, S: function() {
                  return Date.now();
                }, Ca: function() {
                  return true;
                }, Da: function(t3, e3) {
                  t3 = new Date(1e3 * (E[t3 >>> 2] + 4294967296 * A[t3 + 4 >>> 2])), A[e3 >> 2 >>> 0] = t3.getUTCSeconds(), A[e3 + 4 >> 2 >>> 0] = t3.getUTCMinutes(), A[e3 + 8 >> 2 >>> 0] = t3.getUTCHours(), A[e3 + 12 >> 2 >>> 0] = t3.getUTCDate(), A[e3 + 16 >> 2 >>> 0] = t3.getUTCMonth(), A[e3 + 20 >> 2 >>> 0] = t3.getUTCFullYear() - 1900, A[e3 + 24 >> 2 >>> 0] = t3.getUTCDay(), A[e3 + 28 >> 2 >>> 0] = (t3.getTime() - Date.UTC(t3.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0;
                }, Ea: function(t3, e3) {
                  t3 = new Date(1e3 * (E[t3 >>> 2] + 4294967296 * A[t3 + 4 >>> 2])), A[e3 >> 2 >>> 0] = t3.getSeconds(), A[e3 + 4 >> 2 >>> 0] = t3.getMinutes(), A[e3 + 8 >> 2 >>> 0] = t3.getHours(), A[e3 + 12 >> 2 >>> 0] = t3.getDate(), A[e3 + 16 >> 2 >>> 0] = t3.getMonth(), A[e3 + 20 >> 2 >>> 0] = t3.getFullYear() - 1900, A[e3 + 24 >> 2 >>> 0] = t3.getDay();
                  var n2 = new Date(t3.getFullYear(), 0, 1);
                  A[e3 + 28 >> 2 >>> 0] = (t3.getTime() - n2.getTime()) / 864e5 | 0, A[e3 + 36 >> 2 >>> 0] = -60 * t3.getTimezoneOffset();
                  var r3 = new Date(t3.getFullYear(), 6, 1).getTimezoneOffset();
                  n2 = n2.getTimezoneOffset(), A[e3 + 32 >> 2 >>> 0] = 0 | (r3 != n2 && t3.getTimezoneOffset() == Math.min(n2, r3));
                }, Fa: function(t3) {
                  var e3 = new Date(A[t3 + 20 >> 2 >>> 0] + 1900, A[t3 + 16 >> 2 >>> 0], A[t3 + 12 >> 2 >>> 0], A[t3 + 8 >> 2 >>> 0], A[t3 + 4 >> 2 >>> 0], A[t3 >> 2 >>> 0], 0), n2 = A[t3 + 32 >> 2 >>> 0], r3 = e3.getTimezoneOffset(), i2 = new Date(e3.getFullYear(), 0, 1), o2 = new Date(e3.getFullYear(), 6, 1).getTimezoneOffset(), a2 = i2.getTimezoneOffset(), s2 = Math.min(a2, o2);
                  return 0 > n2 ? A[t3 + 32 >> 2 >>> 0] = Number(o2 != a2 && s2 == r3) : 0 < n2 != (s2 == r3) && (o2 = Math.max(a2, o2), e3.setTime(e3.getTime() + 6e4 * ((0 < n2 ? s2 : o2) - r3))), A[t3 + 24 >> 2 >>> 0] = e3.getDay(), A[t3 + 28 >> 2 >>> 0] = (e3.getTime() - i2.getTime()) / 864e5 | 0, A[t3 >> 2 >>> 0] = e3.getSeconds(), A[t3 + 4 >> 2 >>> 0] = e3.getMinutes(), A[t3 + 8 >> 2 >>> 0] = e3.getHours(), A[t3 + 12 >> 2 >>> 0] = e3.getDate(), A[t3 + 16 >> 2 >>> 0] = e3.getMonth(), e3.getTime() / 1e3 | 0;
                }, sa: function() {
                  return -52;
                }, ta: function() {
                }, Ga: function t3(e3, n2, r3) {
                  t3.Vb || (t3.Vb = true, function(t4, e4, n3) {
                    function r4(t5) {
                      return (t5 = t5.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? t5[1] : "GMT";
                    }
                    var i2 = new Date().getFullYear(), o2 = new Date(i2, 0, 1), a2 = new Date(i2, 6, 1);
                    i2 = o2.getTimezoneOffset();
                    var s2 = a2.getTimezoneOffset();
                    A[t4 >> 2 >>> 0] = 60 * Math.max(i2, s2), A[e4 >> 2 >>> 0] = Number(i2 != s2), t4 = r4(o2), e4 = r4(a2), t4 = ot(t4), e4 = ot(e4), s2 < i2 ? (E[n3 >> 2 >>> 0] = t4, E[n3 + 4 >> 2 >>> 0] = e4) : (E[n3 >> 2 >>> 0] = e4, E[n3 + 4 >> 2 >>> 0] = t4);
                  }(e3, n2, r3));
                }, B: function() {
                  W("");
                }, ma: function() {
                  return 4294901760;
                }, I: b ? () => {
                  var t3 = process.hrtime();
                  return 1e3 * t3[0] + t3[1] / 1e6;
                } : () => performance.now(), xa: function(t3, e3, n2) {
                  O.copyWithin(t3 >>> 0, e3 >>> 0, e3 + n2 >>> 0);
                }, G: function(t3) {
                  var e3 = O.length;
                  if (4294901760 < (t3 >>>= 0))
                    return false;
                  for (var n2 = 1; 4 >= n2; n2 *= 2) {
                    var r3 = e3 * (1 + 0.2 / n2);
                    r3 = Math.min(r3, t3 + 100663296);
                    var i2 = Math;
                    r3 = Math.max(t3, r3), i2 = i2.min.call(i2, 4294901760, r3 + (65536 - r3 % 65536) % 65536);
                    t: {
                      try {
                        x.grow(i2 - T.byteLength + 65535 >>> 16), F();
                        var o2 = 1;
                        break t;
                      } catch (t4) {
                      }
                      o2 = void 0;
                    }
                    if (o2)
                      return true;
                  }
                  return false;
                }, va: function(t3, e3) {
                  var n2 = 0;
                  return st().forEach(function(r3, i2) {
                    var o2 = e3 + n2;
                    for (i2 = E[t3 + 4 * i2 >> 2 >>> 0] = o2, o2 = 0; o2 < r3.length; ++o2)
                      S[i2++ >> 0 >>> 0] = r3.charCodeAt(o2);
                    S[i2 >> 0 >>> 0] = 0, n2 += r3.length + 1;
                  }), 0;
                }, wa: function(t3, e3) {
                  var n2 = st();
                  E[t3 >> 2 >>> 0] = n2.length;
                  var r3 = 0;
                  return n2.forEach(function(t4) {
                    r3 += t4.length + 1;
                  }), E[e3 >> 2 >>> 0] = r3, 0;
                }, ba: function(t3) {
                  w || 0 < U || (wt(), Z(j), vt(0), ct[1].length && lt(1, 10), ct[2].length && lt(2, 10)), w || 0 < U || (e2.onExit && e2.onExit(t3), I = true), d(t3, new K(t3));
                }, E: function() {
                  return 52;
                }, Q: function() {
                  return 52;
                }, ca: function() {
                  return 70;
                }, P: function(t3, e3, n2, r3) {
                  for (var i2 = 0, o2 = 0; o2 < n2; o2++) {
                    var a2 = E[e3 >> 2 >>> 0], s2 = E[e3 + 4 >> 2 >>> 0];
                    e3 += 8;
                    for (var u2 = 0; u2 < s2; u2++)
                      lt(t3, O[a2 + u2 >>> 0]);
                    i2 += s2;
                  }
                  return E[r3 >> 2 >>> 0] = i2, 0;
                }, c: function() {
                  return pt;
                }, ja: function t3(e3, r3) {
                  t3.Mb || (t3.Mb = function() {
                    if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues) {
                      var t4 = new Uint8Array(1);
                      return () => (crypto.getRandomValues(t4), t4[0]);
                    }
                    if (b)
                      try {
                        var e4 = n(Object(function() {
                          var t5 = new Error("Cannot find module 'crypto'");
                          throw t5.code = "MODULE_NOT_FOUND", t5;
                        }()));
                        return () => e4.randomBytes(1)[0];
                      } catch (t5) {
                      }
                    return () => W("randomDevice");
                  }());
                  for (var i2 = 0; i2 < r3; i2++)
                    S[e3 + i2 >> 0 >>> 0] = t3.Mb();
                  return 0;
                }, ea: function(t3, e3, n2) {
                  var r3 = Tt();
                  try {
                    return it(t3)(e3, n2);
                  } catch (t4) {
                    if (St(r3), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, fa: function(t3, e3, n2) {
                  var r3 = Tt();
                  try {
                    return it(t3)(e3, n2);
                  } catch (t4) {
                    if (St(r3), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, J: function(t3) {
                  var e3 = Tt();
                  try {
                    return it(t3)();
                  } catch (t4) {
                    if (St(e3), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, e: function(t3, e3) {
                  var n2 = Tt();
                  try {
                    return it(t3)(e3);
                  } catch (t4) {
                    if (St(n2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, N: function(t3, e3, n2) {
                  var r3 = Tt();
                  try {
                    return it(t3)(e3, n2);
                  } catch (t4) {
                    if (St(r3), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, O: function(t3, e3, n2) {
                  var r3 = Tt();
                  try {
                    return it(t3)(e3, n2);
                  } catch (t4) {
                    if (St(r3), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, j: function(t3, e3, n2) {
                  var r3 = Tt();
                  try {
                    return it(t3)(e3, n2);
                  } catch (t4) {
                    if (St(r3), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, o: function(t3, e3, n2, r3) {
                  var i2 = Tt();
                  try {
                    return it(t3)(e3, n2, r3);
                  } catch (t4) {
                    if (St(i2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, p: function(t3, e3, n2, r3, i2) {
                  var o2 = Tt();
                  try {
                    return it(t3)(e3, n2, r3, i2);
                  } catch (t4) {
                    if (St(o2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, M: function(t3, e3, n2, r3, i2, o2) {
                  var a2 = Tt();
                  try {
                    return it(t3)(e3, n2, r3, i2, o2);
                  } catch (t4) {
                    if (St(a2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, r: function(t3, e3, n2, r3, i2, o2) {
                  var a2 = Tt();
                  try {
                    return it(t3)(e3, n2, r3, i2, o2);
                  } catch (t4) {
                    if (St(a2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, v: function(t3, e3, n2, r3, i2, o2, a2) {
                  var s2 = Tt();
                  try {
                    return it(t3)(e3, n2, r3, i2, o2, a2);
                  } catch (t4) {
                    if (St(s2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, K: function(t3, e3, n2, r3, i2, o2, a2, s2) {
                  var u2 = Tt();
                  try {
                    return it(t3)(e3, n2, r3, i2, o2, a2, s2);
                  } catch (t4) {
                    if (St(u2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, D: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2) {
                  var f2 = Tt();
                  try {
                    return it(t3)(e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2);
                  } catch (t4) {
                    if (St(f2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, X: function(t3, e3, n2, r3, i2, o2, a2, s2) {
                  var u2 = Tt();
                  try {
                    return Lt(t3, e3, n2, r3, i2, o2, a2, s2);
                  } catch (t4) {
                    if (St(u2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, V: function(t3, e3, n2, r3, i2, o2, a2) {
                  var s2 = Tt();
                  try {
                    return Pt(t3, e3, n2, r3, i2, o2, a2);
                  } catch (t4) {
                    if (St(s2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, U: function(t3, e3, n2, r3, i2) {
                  var o2 = Tt();
                  try {
                    return Rt(t3, e3, n2, r3, i2);
                  } catch (t4) {
                    if (St(o2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, Z: function(t3, e3, n2, r3) {
                  var i2 = Tt();
                  try {
                    return Ft(t3, e3, n2, r3);
                  } catch (t4) {
                    if (St(i2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, W: function(t3) {
                  var e3 = Tt();
                  try {
                    return It(t3);
                  } catch (t4) {
                    if (St(e3), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, Y: function(t3, e3) {
                  var n2 = Tt();
                  try {
                    return Nt(t3, e3);
                  } catch (t4) {
                    if (St(n2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, T: function(t3, e3, n2) {
                  var r3 = Tt();
                  try {
                    return Dt(t3, e3, n2);
                  } catch (t4) {
                    if (St(r3), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, f: function(t3) {
                  var e3 = Tt();
                  try {
                    it(t3)();
                  } catch (t4) {
                    if (St(e3), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, q: function(t3, e3) {
                  var n2 = Tt();
                  try {
                    it(t3)(e3);
                  } catch (t4) {
                    if (St(n2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, h: function(t3, e3, n2) {
                  var r3 = Tt();
                  try {
                    it(t3)(e3, n2);
                  } catch (t4) {
                    if (St(r3), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, da: function(t3, e3, n2, r3) {
                  var i2 = Tt();
                  try {
                    it(t3)(e3, n2, r3);
                  } catch (t4) {
                    if (St(i2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, l: function(t3, e3, n2, r3) {
                  var i2 = Tt();
                  try {
                    it(t3)(e3, n2, r3);
                  } catch (t4) {
                    if (St(i2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, t: function(t3, e3, n2, r3, i2) {
                  var o2 = Tt();
                  try {
                    it(t3)(e3, n2, r3, i2);
                  } catch (t4) {
                    if (St(o2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, u: function(t3, e3, n2, r3, i2, o2) {
                  var a2 = Tt();
                  try {
                    it(t3)(e3, n2, r3, i2, o2);
                  } catch (t4) {
                    if (St(a2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, x: function(t3, e3, n2, r3, i2, o2, a2) {
                  var s2 = Tt();
                  try {
                    it(t3)(e3, n2, r3, i2, o2, a2);
                  } catch (t4) {
                    if (St(s2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, z: function(t3, e3, n2, r3, i2, o2, a2, s2) {
                  var u2 = Tt();
                  try {
                    it(t3)(e3, n2, r3, i2, o2, a2, s2);
                  } catch (t4) {
                    if (St(u2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, ga: function(t3, e3, n2, r3, i2, o2, a2, s2, u2) {
                  var c2 = Tt();
                  try {
                    it(t3)(e3, n2, r3, i2, o2, a2, s2, u2);
                  } catch (t4) {
                    if (St(c2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, A: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2) {
                  var p2 = Tt();
                  try {
                    it(t3)(e3, n2, r3, i2, o2, a2, s2, u2, c2, l2);
                  } catch (t4) {
                    if (St(p2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, C: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2, f2, d2, h2, g2) {
                  var b2 = Tt();
                  try {
                    it(t3)(e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2, f2, d2, h2, g2);
                  } catch (t4) {
                    if (St(b2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, aa: function(t3, e3, n2, r3, i2, o2, a2, s2) {
                  var u2 = Tt();
                  try {
                    $t(t3, e3, n2, r3, i2, o2, a2, s2);
                  } catch (t4) {
                    if (St(u2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, _: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2) {
                  var f2 = Tt();
                  try {
                    Ct(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2);
                  } catch (t4) {
                    if (St(f2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, $: function(t3, e3, n2, r3, i2, o2) {
                  var a2 = Tt();
                  try {
                    kt(t3, e3, n2, r3, i2, o2);
                  } catch (t4) {
                    if (St(a2), t4 !== t4 + 0)
                      throw t4;
                    xt(1, 0);
                  }
                }, n: function(t3) {
                  return t3;
                }, F: function(t3) {
                  pt = t3;
                }, ha: gt, y: function(t3, e3, n2, r3) {
                  return gt(t3, e3, n2, r3);
                } };
                !function() {
                  function t3(t4) {
                    e2.asm = t4.exports, x = e2.asm.Ka, F(), N = e2.asm.ib, R.unshift(e2.asm.La), z--, e2.monitorRunDependencies && e2.monitorRunDependencies(z), 0 == z && (null !== G && (clearInterval(G), G = null), H && (t4 = H, H = null, t4()));
                  }
                  function n2(e3) {
                    t3(e3.instance);
                  }
                  function r3(t4) {
                    return function() {
                      if (!y && (h || g)) {
                        if ("function" == typeof fetch && !B.startsWith("file://"))
                          return fetch(B, { credentials: "same-origin" }).then(function(t5) {
                            if (!t5.ok)
                              throw "failed to load wasm binary file at '" + B + "'";
                            return t5.arrayBuffer();
                          }).catch(function() {
                            return Y();
                          });
                        if (a)
                          return new Promise(function(t5, e3) {
                            a(B, function(e4) {
                              t5(new Uint8Array(e4));
                            }, e3);
                          });
                      }
                      return Promise.resolve().then(function() {
                        return Y();
                      });
                    }().then(function(t5) {
                      return WebAssembly.instantiate(t5, o2);
                    }).then(function(t5) {
                      return t5;
                    }).then(t4, function(t5) {
                      v("failed to asynchronously prepare wasm: " + t5), W(t5);
                    });
                  }
                  var o2 = { a: bt };
                  if (z++, e2.monitorRunDependencies && e2.monitorRunDependencies(z), e2.instantiateWasm)
                    try {
                      return e2.instantiateWasm(o2, t3);
                    } catch (t4) {
                      return v("Module.instantiateWasm callback failed with error: " + t4), false;
                    }
                  (y || "function" != typeof WebAssembly.instantiateStreaming || q() || B.startsWith("file://") || b || "function" != typeof fetch ? r3(n2) : fetch(B, { credentials: "same-origin" }).then(function(t4) {
                    return WebAssembly.instantiateStreaming(t4, o2).then(n2, function(t5) {
                      return v("wasm streaming compile failed: " + t5), v("falling back to ArrayBuffer instantiation"), r3(n2);
                    });
                  })).catch(i);
                }(), e2.___wasm_call_ctors = function() {
                  return (e2.___wasm_call_ctors = e2.asm.La).apply(null, arguments);
                }, e2._OrtInit = function() {
                  return (e2._OrtInit = e2.asm.Ma).apply(null, arguments);
                }, e2._OrtCreateSessionOptions = function() {
                  return (e2._OrtCreateSessionOptions = e2.asm.Na).apply(null, arguments);
                }, e2._OrtAppendExecutionProvider = function() {
                  return (e2._OrtAppendExecutionProvider = e2.asm.Oa).apply(null, arguments);
                }, e2._OrtAddSessionConfigEntry = function() {
                  return (e2._OrtAddSessionConfigEntry = e2.asm.Pa).apply(null, arguments);
                }, e2._OrtReleaseSessionOptions = function() {
                  return (e2._OrtReleaseSessionOptions = e2.asm.Qa).apply(null, arguments);
                }, e2._OrtCreateSession = function() {
                  return (e2._OrtCreateSession = e2.asm.Ra).apply(null, arguments);
                }, e2._OrtReleaseSession = function() {
                  return (e2._OrtReleaseSession = e2.asm.Sa).apply(null, arguments);
                }, e2._OrtGetInputCount = function() {
                  return (e2._OrtGetInputCount = e2.asm.Ta).apply(null, arguments);
                }, e2._OrtGetOutputCount = function() {
                  return (e2._OrtGetOutputCount = e2.asm.Ua).apply(null, arguments);
                }, e2._OrtGetInputName = function() {
                  return (e2._OrtGetInputName = e2.asm.Va).apply(null, arguments);
                }, e2._OrtGetOutputName = function() {
                  return (e2._OrtGetOutputName = e2.asm.Wa).apply(null, arguments);
                }, e2._OrtFree = function() {
                  return (e2._OrtFree = e2.asm.Xa).apply(null, arguments);
                }, e2._OrtCreateTensor = function() {
                  return (e2._OrtCreateTensor = e2.asm.Ya).apply(null, arguments);
                }, e2._OrtGetTensorData = function() {
                  return (e2._OrtGetTensorData = e2.asm.Za).apply(null, arguments);
                }, e2._OrtReleaseTensor = function() {
                  return (e2._OrtReleaseTensor = e2.asm._a).apply(null, arguments);
                }, e2._OrtCreateRunOptions = function() {
                  return (e2._OrtCreateRunOptions = e2.asm.$a).apply(null, arguments);
                }, e2._OrtAddRunConfigEntry = function() {
                  return (e2._OrtAddRunConfigEntry = e2.asm.ab).apply(null, arguments);
                }, e2._OrtReleaseRunOptions = function() {
                  return (e2._OrtReleaseRunOptions = e2.asm.bb).apply(null, arguments);
                }, e2._OrtRun = function() {
                  return (e2._OrtRun = e2.asm.cb).apply(null, arguments);
                }, e2._OrtEndProfiling = function() {
                  return (e2._OrtEndProfiling = e2.asm.db).apply(null, arguments);
                };
                var mt, yt = e2._malloc = function() {
                  return (yt = e2._malloc = e2.asm.eb).apply(null, arguments);
                }, _t = e2._free = function() {
                  return (_t = e2._free = e2.asm.fb).apply(null, arguments);
                }, vt = e2._fflush = function() {
                  return (vt = e2._fflush = e2.asm.gb).apply(null, arguments);
                }, wt = e2.___funcs_on_exit = function() {
                  return (wt = e2.___funcs_on_exit = e2.asm.hb).apply(null, arguments);
                }, xt = e2._setThrew = function() {
                  return (xt = e2._setThrew = e2.asm.jb).apply(null, arguments);
                }, Tt = e2.stackSave = function() {
                  return (Tt = e2.stackSave = e2.asm.kb).apply(null, arguments);
                }, St = e2.stackRestore = function() {
                  return (St = e2.stackRestore = e2.asm.lb).apply(null, arguments);
                }, Ot = e2.stackAlloc = function() {
                  return (Ot = e2.stackAlloc = e2.asm.mb).apply(null, arguments);
                }, At = e2.___cxa_can_catch = function() {
                  return (At = e2.___cxa_can_catch = e2.asm.nb).apply(null, arguments);
                }, Et = e2.___cxa_is_pointer_type = function() {
                  return (Et = e2.___cxa_is_pointer_type = e2.asm.ob).apply(null, arguments);
                }, It = e2.dynCall_j = function() {
                  return (It = e2.dynCall_j = e2.asm.pb).apply(null, arguments);
                }, Pt = e2.dynCall_iiiiij = function() {
                  return (Pt = e2.dynCall_iiiiij = e2.asm.qb).apply(null, arguments);
                }, Dt = e2.dynCall_jii = function() {
                  return (Dt = e2.dynCall_jii = e2.asm.rb).apply(null, arguments);
                }, $t = e2.dynCall_viiiiij = function() {
                  return ($t = e2.dynCall_viiiiij = e2.asm.sb).apply(null, arguments);
                }, kt = e2.dynCall_vjji = function() {
                  return (kt = e2.dynCall_vjji = e2.asm.tb).apply(null, arguments);
                }, Ct = e2.dynCall_viiijjjii = function() {
                  return (Ct = e2.dynCall_viiijjjii = e2.asm.ub).apply(null, arguments);
                }, Ft = e2.dynCall_iij = function() {
                  return (Ft = e2.dynCall_iij = e2.asm.vb).apply(null, arguments);
                }, Nt = e2.dynCall_ji = function() {
                  return (Nt = e2.dynCall_ji = e2.asm.wb).apply(null, arguments);
                }, Lt = e2.dynCall_iiiiiij = function() {
                  return (Lt = e2.dynCall_iiiiiij = e2.asm.xb).apply(null, arguments);
                }, Rt = e2.dynCall_iiij = function() {
                  return (Rt = e2.dynCall_iiij = e2.asm.yb).apply(null, arguments);
                };
                function jt() {
                  function t3() {
                    if (!mt && (mt = true, e2.calledRun = true, !I)) {
                      if (Z(R), r2(e2), e2.onRuntimeInitialized && e2.onRuntimeInitialized(), e2.postRun)
                        for ("function" == typeof e2.postRun && (e2.postRun = [e2.postRun]); e2.postRun.length; ) {
                          var t4 = e2.postRun.shift();
                          M.unshift(t4);
                        }
                      Z(M);
                    }
                  }
                  if (!(0 < z)) {
                    if (e2.preRun)
                      for ("function" == typeof e2.preRun && (e2.preRun = [e2.preRun]); e2.preRun.length; )
                        V();
                    Z(L), 0 < z || (e2.setStatus ? (e2.setStatus("Running..."), setTimeout(function() {
                      setTimeout(function() {
                        e2.setStatus("");
                      }, 1), t3();
                    }, 1)) : t3());
                  }
                }
                if (e2.UTF8ToString = $, e2.stringToUTF8 = function(t3, e3, n2) {
                  return k(t3, O, e3, n2);
                }, e2.lengthBytesUTF8 = C, e2.stackSave = Tt, e2.stackRestore = St, e2.stackAlloc = Ot, H = function t3() {
                  mt || jt(), mt || (H = t3);
                }, e2.preInit)
                  for ("function" == typeof e2.preInit && (e2.preInit = [e2.preInit]); 0 < e2.preInit.length; )
                    e2.preInit.pop()();
                return jt(), t2.ready;
              });
              t.exports = r;
            }, 4537: (t) => {
              "use strict";
              t.exports = function(t2, e) {
                for (var n = new Array(arguments.length - 1), r = 0, i = 2, o = true; i < arguments.length; )
                  n[r++] = arguments[i++];
                return new Promise(function(i2, a) {
                  n[r] = function(t3) {
                    if (o)
                      if (o = false, t3)
                        a(t3);
                      else {
                        for (var e2 = new Array(arguments.length - 1), n2 = 0; n2 < e2.length; )
                          e2[n2++] = arguments[n2];
                        i2.apply(null, e2);
                      }
                  };
                  try {
                    t2.apply(e || null, n);
                  } catch (t3) {
                    o && (o = false, a(t3));
                  }
                });
              };
            }, 7419: (t, e) => {
              "use strict";
              var n = e;
              n.length = function(t2) {
                var e2 = t2.length;
                if (!e2)
                  return 0;
                for (var n2 = 0; --e2 % 4 > 1 && "=" === t2.charAt(e2); )
                  ++n2;
                return Math.ceil(3 * t2.length) / 4 - n2;
              };
              for (var r = new Array(64), i = new Array(123), o = 0; o < 64; )
                i[r[o] = o < 26 ? o + 65 : o < 52 ? o + 71 : o < 62 ? o - 4 : o - 59 | 43] = o++;
              n.encode = function(t2, e2, n2) {
                for (var i2, o2 = null, a2 = [], s = 0, u = 0; e2 < n2; ) {
                  var c = t2[e2++];
                  switch (u) {
                    case 0:
                      a2[s++] = r[c >> 2], i2 = (3 & c) << 4, u = 1;
                      break;
                    case 1:
                      a2[s++] = r[i2 | c >> 4], i2 = (15 & c) << 2, u = 2;
                      break;
                    case 2:
                      a2[s++] = r[i2 | c >> 6], a2[s++] = r[63 & c], u = 0;
                  }
                  s > 8191 && ((o2 || (o2 = [])).push(String.fromCharCode.apply(String, a2)), s = 0);
                }
                return u && (a2[s++] = r[i2], a2[s++] = 61, 1 === u && (a2[s++] = 61)), o2 ? (s && o2.push(String.fromCharCode.apply(String, a2.slice(0, s))), o2.join("")) : String.fromCharCode.apply(String, a2.slice(0, s));
              };
              var a = "invalid encoding";
              n.decode = function(t2, e2, n2) {
                for (var r2, o2 = n2, s = 0, u = 0; u < t2.length; ) {
                  var c = t2.charCodeAt(u++);
                  if (61 === c && s > 1)
                    break;
                  if (void 0 === (c = i[c]))
                    throw Error(a);
                  switch (s) {
                    case 0:
                      r2 = c, s = 1;
                      break;
                    case 1:
                      e2[n2++] = r2 << 2 | (48 & c) >> 4, r2 = c, s = 2;
                      break;
                    case 2:
                      e2[n2++] = (15 & r2) << 4 | (60 & c) >> 2, r2 = c, s = 3;
                      break;
                    case 3:
                      e2[n2++] = (3 & r2) << 6 | c, s = 0;
                  }
                }
                if (1 === s)
                  throw Error(a);
                return n2 - o2;
              }, n.test = function(t2) {
                return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t2);
              };
            }, 9211: (t) => {
              "use strict";
              function e() {
                this._listeners = {};
              }
              t.exports = e, e.prototype.on = function(t2, e2, n) {
                return (this._listeners[t2] || (this._listeners[t2] = [])).push({ fn: e2, ctx: n || this }), this;
              }, e.prototype.off = function(t2, e2) {
                if (void 0 === t2)
                  this._listeners = {};
                else if (void 0 === e2)
                  this._listeners[t2] = [];
                else
                  for (var n = this._listeners[t2], r = 0; r < n.length; )
                    n[r].fn === e2 ? n.splice(r, 1) : ++r;
                return this;
              }, e.prototype.emit = function(t2) {
                var e2 = this._listeners[t2];
                if (e2) {
                  for (var n = [], r = 1; r < arguments.length; )
                    n.push(arguments[r++]);
                  for (r = 0; r < e2.length; )
                    e2[r].fn.apply(e2[r++].ctx, n);
                }
                return this;
              };
            }, 945: (t) => {
              "use strict";
              function e(t2) {
                return "undefined" != typeof Float32Array ? function() {
                  var e2 = new Float32Array([-0]), n2 = new Uint8Array(e2.buffer), r2 = 128 === n2[3];
                  function i2(t3, r3, i3) {
                    e2[0] = t3, r3[i3] = n2[0], r3[i3 + 1] = n2[1], r3[i3 + 2] = n2[2], r3[i3 + 3] = n2[3];
                  }
                  function o2(t3, r3, i3) {
                    e2[0] = t3, r3[i3] = n2[3], r3[i3 + 1] = n2[2], r3[i3 + 2] = n2[1], r3[i3 + 3] = n2[0];
                  }
                  function a(t3, r3) {
                    return n2[0] = t3[r3], n2[1] = t3[r3 + 1], n2[2] = t3[r3 + 2], n2[3] = t3[r3 + 3], e2[0];
                  }
                  function s(t3, r3) {
                    return n2[3] = t3[r3], n2[2] = t3[r3 + 1], n2[1] = t3[r3 + 2], n2[0] = t3[r3 + 3], e2[0];
                  }
                  t2.writeFloatLE = r2 ? i2 : o2, t2.writeFloatBE = r2 ? o2 : i2, t2.readFloatLE = r2 ? a : s, t2.readFloatBE = r2 ? s : a;
                }() : function() {
                  function e2(t3, e3, n2, r2) {
                    var i2 = e3 < 0 ? 1 : 0;
                    if (i2 && (e3 = -e3), 0 === e3)
                      t3(1 / e3 > 0 ? 0 : 2147483648, n2, r2);
                    else if (isNaN(e3))
                      t3(2143289344, n2, r2);
                    else if (e3 > 34028234663852886e22)
                      t3((i2 << 31 | 2139095040) >>> 0, n2, r2);
                    else if (e3 < 11754943508222875e-54)
                      t3((i2 << 31 | Math.round(e3 / 1401298464324817e-60)) >>> 0, n2, r2);
                    else {
                      var o2 = Math.floor(Math.log(e3) / Math.LN2);
                      t3((i2 << 31 | o2 + 127 << 23 | 8388607 & Math.round(e3 * Math.pow(2, -o2) * 8388608)) >>> 0, n2, r2);
                    }
                  }
                  function a(t3, e3, n2) {
                    var r2 = t3(e3, n2), i2 = 2 * (r2 >> 31) + 1, o2 = r2 >>> 23 & 255, a2 = 8388607 & r2;
                    return 255 === o2 ? a2 ? NaN : i2 * (1 / 0) : 0 === o2 ? 1401298464324817e-60 * i2 * a2 : i2 * Math.pow(2, o2 - 150) * (a2 + 8388608);
                  }
                  t2.writeFloatLE = e2.bind(null, n), t2.writeFloatBE = e2.bind(null, r), t2.readFloatLE = a.bind(null, i), t2.readFloatBE = a.bind(null, o);
                }(), "undefined" != typeof Float64Array ? function() {
                  var e2 = new Float64Array([-0]), n2 = new Uint8Array(e2.buffer), r2 = 128 === n2[7];
                  function i2(t3, r3, i3) {
                    e2[0] = t3, r3[i3] = n2[0], r3[i3 + 1] = n2[1], r3[i3 + 2] = n2[2], r3[i3 + 3] = n2[3], r3[i3 + 4] = n2[4], r3[i3 + 5] = n2[5], r3[i3 + 6] = n2[6], r3[i3 + 7] = n2[7];
                  }
                  function o2(t3, r3, i3) {
                    e2[0] = t3, r3[i3] = n2[7], r3[i3 + 1] = n2[6], r3[i3 + 2] = n2[5], r3[i3 + 3] = n2[4], r3[i3 + 4] = n2[3], r3[i3 + 5] = n2[2], r3[i3 + 6] = n2[1], r3[i3 + 7] = n2[0];
                  }
                  function a(t3, r3) {
                    return n2[0] = t3[r3], n2[1] = t3[r3 + 1], n2[2] = t3[r3 + 2], n2[3] = t3[r3 + 3], n2[4] = t3[r3 + 4], n2[5] = t3[r3 + 5], n2[6] = t3[r3 + 6], n2[7] = t3[r3 + 7], e2[0];
                  }
                  function s(t3, r3) {
                    return n2[7] = t3[r3], n2[6] = t3[r3 + 1], n2[5] = t3[r3 + 2], n2[4] = t3[r3 + 3], n2[3] = t3[r3 + 4], n2[2] = t3[r3 + 5], n2[1] = t3[r3 + 6], n2[0] = t3[r3 + 7], e2[0];
                  }
                  t2.writeDoubleLE = r2 ? i2 : o2, t2.writeDoubleBE = r2 ? o2 : i2, t2.readDoubleLE = r2 ? a : s, t2.readDoubleBE = r2 ? s : a;
                }() : function() {
                  function e2(t3, e3, n2, r2, i2, o2) {
                    var a2 = r2 < 0 ? 1 : 0;
                    if (a2 && (r2 = -r2), 0 === r2)
                      t3(0, i2, o2 + e3), t3(1 / r2 > 0 ? 0 : 2147483648, i2, o2 + n2);
                    else if (isNaN(r2))
                      t3(0, i2, o2 + e3), t3(2146959360, i2, o2 + n2);
                    else if (r2 > 17976931348623157e292)
                      t3(0, i2, o2 + e3), t3((a2 << 31 | 2146435072) >>> 0, i2, o2 + n2);
                    else {
                      var s;
                      if (r2 < 22250738585072014e-324)
                        t3((s = r2 / 5e-324) >>> 0, i2, o2 + e3), t3((a2 << 31 | s / 4294967296) >>> 0, i2, o2 + n2);
                      else {
                        var u = Math.floor(Math.log(r2) / Math.LN2);
                        1024 === u && (u = 1023), t3(4503599627370496 * (s = r2 * Math.pow(2, -u)) >>> 0, i2, o2 + e3), t3((a2 << 31 | u + 1023 << 20 | 1048576 * s & 1048575) >>> 0, i2, o2 + n2);
                      }
                    }
                  }
                  function a(t3, e3, n2, r2, i2) {
                    var o2 = t3(r2, i2 + e3), a2 = t3(r2, i2 + n2), s = 2 * (a2 >> 31) + 1, u = a2 >>> 20 & 2047, c = 4294967296 * (1048575 & a2) + o2;
                    return 2047 === u ? c ? NaN : s * (1 / 0) : 0 === u ? 5e-324 * s * c : s * Math.pow(2, u - 1075) * (c + 4503599627370496);
                  }
                  t2.writeDoubleLE = e2.bind(null, n, 0, 4), t2.writeDoubleBE = e2.bind(null, r, 4, 0), t2.readDoubleLE = a.bind(null, i, 0, 4), t2.readDoubleBE = a.bind(null, o, 4, 0);
                }(), t2;
              }
              function n(t2, e2, n2) {
                e2[n2] = 255 & t2, e2[n2 + 1] = t2 >>> 8 & 255, e2[n2 + 2] = t2 >>> 16 & 255, e2[n2 + 3] = t2 >>> 24;
              }
              function r(t2, e2, n2) {
                e2[n2] = t2 >>> 24, e2[n2 + 1] = t2 >>> 16 & 255, e2[n2 + 2] = t2 >>> 8 & 255, e2[n2 + 3] = 255 & t2;
              }
              function i(t2, e2) {
                return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16 | t2[e2 + 3] << 24) >>> 0;
              }
              function o(t2, e2) {
                return (t2[e2] << 24 | t2[e2 + 1] << 16 | t2[e2 + 2] << 8 | t2[e2 + 3]) >>> 0;
              }
              t.exports = e(e);
            }, 7199: (module) => {
              "use strict";
              function inquire(moduleName) {
                try {
                  var mod = eval("quire".replace(/^/, "re"))(moduleName);
                  if (mod && (mod.length || Object.keys(mod).length))
                    return mod;
                } catch (t) {
                }
                return null;
              }
              module.exports = inquire;
            }, 6662: (t) => {
              "use strict";
              t.exports = function(t2, e, n) {
                var r = n || 8192, i = r >>> 1, o = null, a = r;
                return function(n2) {
                  if (n2 < 1 || n2 > i)
                    return t2(n2);
                  a + n2 > r && (o = t2(r), a = 0);
                  var s = e.call(o, a, a += n2);
                  return 7 & a && (a = 1 + (7 | a)), s;
                };
              };
            }, 4997: (t, e) => {
              "use strict";
              var n = e;
              n.length = function(t2) {
                for (var e2 = 0, n2 = 0, r = 0; r < t2.length; ++r)
                  (n2 = t2.charCodeAt(r)) < 128 ? e2 += 1 : n2 < 2048 ? e2 += 2 : 55296 == (64512 & n2) && 56320 == (64512 & t2.charCodeAt(r + 1)) ? (++r, e2 += 4) : e2 += 3;
                return e2;
              }, n.read = function(t2, e2, n2) {
                if (n2 - e2 < 1)
                  return "";
                for (var r, i = null, o = [], a = 0; e2 < n2; )
                  (r = t2[e2++]) < 128 ? o[a++] = r : r > 191 && r < 224 ? o[a++] = (31 & r) << 6 | 63 & t2[e2++] : r > 239 && r < 365 ? (r = ((7 & r) << 18 | (63 & t2[e2++]) << 12 | (63 & t2[e2++]) << 6 | 63 & t2[e2++]) - 65536, o[a++] = 55296 + (r >> 10), o[a++] = 56320 + (1023 & r)) : o[a++] = (15 & r) << 12 | (63 & t2[e2++]) << 6 | 63 & t2[e2++], a > 8191 && ((i || (i = [])).push(String.fromCharCode.apply(String, o)), a = 0);
                return i ? (a && i.push(String.fromCharCode.apply(String, o.slice(0, a))), i.join("")) : String.fromCharCode.apply(String, o.slice(0, a));
              }, n.write = function(t2, e2, n2) {
                for (var r, i, o = n2, a = 0; a < t2.length; ++a)
                  (r = t2.charCodeAt(a)) < 128 ? e2[n2++] = r : r < 2048 ? (e2[n2++] = r >> 6 | 192, e2[n2++] = 63 & r | 128) : 55296 == (64512 & r) && 56320 == (64512 & (i = t2.charCodeAt(a + 1))) ? (r = 65536 + ((1023 & r) << 10) + (1023 & i), ++a, e2[n2++] = r >> 18 | 240, e2[n2++] = r >> 12 & 63 | 128, e2[n2++] = r >> 6 & 63 | 128, e2[n2++] = 63 & r | 128) : (e2[n2++] = r >> 12 | 224, e2[n2++] = r >> 6 & 63 | 128, e2[n2++] = 63 & r | 128);
                return n2 - o;
              };
            }, 3442: (t, e) => {
              "use strict";
              e.__esModule = true;
              var n = function() {
                function t2(e2) {
                  if (!e2)
                    throw new TypeError("Invalid argument; `value` has no value.");
                  this.value = t2.EMPTY, e2 && t2.isGuid(e2) && (this.value = e2);
                }
                return t2.isGuid = function(e2) {
                  var n2 = e2.toString();
                  return e2 && (e2 instanceof t2 || t2.validator.test(n2));
                }, t2.create = function() {
                  return new t2([t2.gen(2), t2.gen(1), t2.gen(1), t2.gen(1), t2.gen(3)].join("-"));
                }, t2.createEmpty = function() {
                  return new t2("emptyguid");
                }, t2.parse = function(e2) {
                  return new t2(e2);
                }, t2.raw = function() {
                  return [t2.gen(2), t2.gen(1), t2.gen(1), t2.gen(1), t2.gen(3)].join("-");
                }, t2.gen = function(t3) {
                  for (var e2 = "", n2 = 0; n2 < t3; n2++)
                    e2 += (65536 * (1 + Math.random()) | 0).toString(16).substring(1);
                  return e2;
                }, t2.prototype.equals = function(e2) {
                  return t2.isGuid(e2) && this.value === e2.toString();
                }, t2.prototype.isEmpty = function() {
                  return this.value === t2.EMPTY;
                }, t2.prototype.toString = function() {
                  return this.value;
                }, t2.prototype.toJSON = function() {
                  return { value: this.value };
                }, t2.validator = new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$", "i"), t2.EMPTY = "00000000-0000-0000-0000-000000000000", t2;
              }();
              e.Guid = n;
            }, 3720: (t) => {
              t.exports = n;
              var e = null;
              try {
                e = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
              } catch (t2) {
              }
              function n(t2, e2, n2) {
                this.low = 0 | t2, this.high = 0 | e2, this.unsigned = !!n2;
              }
              function r(t2) {
                return true === (t2 && t2.__isLong__);
              }
              n.prototype.__isLong__, Object.defineProperty(n.prototype, "__isLong__", { value: true }), n.isLong = r;
              var i = {}, o = {};
              function a(t2, e2) {
                var n2, r2, a2;
                return e2 ? (a2 = 0 <= (t2 >>>= 0) && t2 < 256) && (r2 = o[t2]) ? r2 : (n2 = u(t2, (0 | t2) < 0 ? -1 : 0, true), a2 && (o[t2] = n2), n2) : (a2 = -128 <= (t2 |= 0) && t2 < 128) && (r2 = i[t2]) ? r2 : (n2 = u(t2, t2 < 0 ? -1 : 0, false), a2 && (i[t2] = n2), n2);
              }
              function s(t2, e2) {
                if (isNaN(t2))
                  return e2 ? m : b;
                if (e2) {
                  if (t2 < 0)
                    return m;
                  if (t2 >= d)
                    return x;
                } else {
                  if (t2 <= -h)
                    return T;
                  if (t2 + 1 >= h)
                    return w;
                }
                return t2 < 0 ? s(-t2, e2).neg() : u(t2 % f | 0, t2 / f | 0, e2);
              }
              function u(t2, e2, r2) {
                return new n(t2, e2, r2);
              }
              n.fromInt = a, n.fromNumber = s, n.fromBits = u;
              var c = Math.pow;
              function l(t2, e2, n2) {
                if (0 === t2.length)
                  throw Error("empty string");
                if ("NaN" === t2 || "Infinity" === t2 || "+Infinity" === t2 || "-Infinity" === t2)
                  return b;
                if ("number" == typeof e2 ? (n2 = e2, e2 = false) : e2 = !!e2, (n2 = n2 || 10) < 2 || 36 < n2)
                  throw RangeError("radix");
                var r2;
                if ((r2 = t2.indexOf("-")) > 0)
                  throw Error("interior hyphen");
                if (0 === r2)
                  return l(t2.substring(1), e2, n2).neg();
                for (var i2 = s(c(n2, 8)), o2 = b, a2 = 0; a2 < t2.length; a2 += 8) {
                  var u2 = Math.min(8, t2.length - a2), p2 = parseInt(t2.substring(a2, a2 + u2), n2);
                  if (u2 < 8) {
                    var f2 = s(c(n2, u2));
                    o2 = o2.mul(f2).add(s(p2));
                  } else
                    o2 = (o2 = o2.mul(i2)).add(s(p2));
                }
                return o2.unsigned = e2, o2;
              }
              function p(t2, e2) {
                return "number" == typeof t2 ? s(t2, e2) : "string" == typeof t2 ? l(t2, e2) : u(t2.low, t2.high, "boolean" == typeof e2 ? e2 : t2.unsigned);
              }
              n.fromString = l, n.fromValue = p;
              var f = 4294967296, d = f * f, h = d / 2, g = a(1 << 24), b = a(0);
              n.ZERO = b;
              var m = a(0, true);
              n.UZERO = m;
              var y = a(1);
              n.ONE = y;
              var _ = a(1, true);
              n.UONE = _;
              var v = a(-1);
              n.NEG_ONE = v;
              var w = u(-1, 2147483647, false);
              n.MAX_VALUE = w;
              var x = u(-1, -1, true);
              n.MAX_UNSIGNED_VALUE = x;
              var T = u(0, -2147483648, false);
              n.MIN_VALUE = T;
              var S = n.prototype;
              S.toInt = function() {
                return this.unsigned ? this.low >>> 0 : this.low;
              }, S.toNumber = function() {
                return this.unsigned ? (this.high >>> 0) * f + (this.low >>> 0) : this.high * f + (this.low >>> 0);
              }, S.toString = function(t2) {
                if ((t2 = t2 || 10) < 2 || 36 < t2)
                  throw RangeError("radix");
                if (this.isZero())
                  return "0";
                if (this.isNegative()) {
                  if (this.eq(T)) {
                    var e2 = s(t2), n2 = this.div(e2), r2 = n2.mul(e2).sub(this);
                    return n2.toString(t2) + r2.toInt().toString(t2);
                  }
                  return "-" + this.neg().toString(t2);
                }
                for (var i2 = s(c(t2, 6), this.unsigned), o2 = this, a2 = ""; ; ) {
                  var u2 = o2.div(i2), l2 = (o2.sub(u2.mul(i2)).toInt() >>> 0).toString(t2);
                  if ((o2 = u2).isZero())
                    return l2 + a2;
                  for (; l2.length < 6; )
                    l2 = "0" + l2;
                  a2 = "" + l2 + a2;
                }
              }, S.getHighBits = function() {
                return this.high;
              }, S.getHighBitsUnsigned = function() {
                return this.high >>> 0;
              }, S.getLowBits = function() {
                return this.low;
              }, S.getLowBitsUnsigned = function() {
                return this.low >>> 0;
              }, S.getNumBitsAbs = function() {
                if (this.isNegative())
                  return this.eq(T) ? 64 : this.neg().getNumBitsAbs();
                for (var t2 = 0 != this.high ? this.high : this.low, e2 = 31; e2 > 0 && 0 == (t2 & 1 << e2); e2--)
                  ;
                return 0 != this.high ? e2 + 33 : e2 + 1;
              }, S.isZero = function() {
                return 0 === this.high && 0 === this.low;
              }, S.eqz = S.isZero, S.isNegative = function() {
                return !this.unsigned && this.high < 0;
              }, S.isPositive = function() {
                return this.unsigned || this.high >= 0;
              }, S.isOdd = function() {
                return 1 == (1 & this.low);
              }, S.isEven = function() {
                return 0 == (1 & this.low);
              }, S.equals = function(t2) {
                return r(t2) || (t2 = p(t2)), (this.unsigned === t2.unsigned || this.high >>> 31 != 1 || t2.high >>> 31 != 1) && this.high === t2.high && this.low === t2.low;
              }, S.eq = S.equals, S.notEquals = function(t2) {
                return !this.eq(t2);
              }, S.neq = S.notEquals, S.ne = S.notEquals, S.lessThan = function(t2) {
                return this.comp(t2) < 0;
              }, S.lt = S.lessThan, S.lessThanOrEqual = function(t2) {
                return this.comp(t2) <= 0;
              }, S.lte = S.lessThanOrEqual, S.le = S.lessThanOrEqual, S.greaterThan = function(t2) {
                return this.comp(t2) > 0;
              }, S.gt = S.greaterThan, S.greaterThanOrEqual = function(t2) {
                return this.comp(t2) >= 0;
              }, S.gte = S.greaterThanOrEqual, S.ge = S.greaterThanOrEqual, S.compare = function(t2) {
                if (r(t2) || (t2 = p(t2)), this.eq(t2))
                  return 0;
                var e2 = this.isNegative(), n2 = t2.isNegative();
                return e2 && !n2 ? -1 : !e2 && n2 ? 1 : this.unsigned ? t2.high >>> 0 > this.high >>> 0 || t2.high === this.high && t2.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(t2).isNegative() ? -1 : 1;
              }, S.comp = S.compare, S.negate = function() {
                return !this.unsigned && this.eq(T) ? T : this.not().add(y);
              }, S.neg = S.negate, S.add = function(t2) {
                r(t2) || (t2 = p(t2));
                var e2 = this.high >>> 16, n2 = 65535 & this.high, i2 = this.low >>> 16, o2 = 65535 & this.low, a2 = t2.high >>> 16, s2 = 65535 & t2.high, c2 = t2.low >>> 16, l2 = 0, f2 = 0, d2 = 0, h2 = 0;
                return d2 += (h2 += o2 + (65535 & t2.low)) >>> 16, f2 += (d2 += i2 + c2) >>> 16, l2 += (f2 += n2 + s2) >>> 16, l2 += e2 + a2, u((d2 &= 65535) << 16 | (h2 &= 65535), (l2 &= 65535) << 16 | (f2 &= 65535), this.unsigned);
              }, S.subtract = function(t2) {
                return r(t2) || (t2 = p(t2)), this.add(t2.neg());
              }, S.sub = S.subtract, S.multiply = function(t2) {
                if (this.isZero())
                  return b;
                if (r(t2) || (t2 = p(t2)), e)
                  return u(e.mul(this.low, this.high, t2.low, t2.high), e.get_high(), this.unsigned);
                if (t2.isZero())
                  return b;
                if (this.eq(T))
                  return t2.isOdd() ? T : b;
                if (t2.eq(T))
                  return this.isOdd() ? T : b;
                if (this.isNegative())
                  return t2.isNegative() ? this.neg().mul(t2.neg()) : this.neg().mul(t2).neg();
                if (t2.isNegative())
                  return this.mul(t2.neg()).neg();
                if (this.lt(g) && t2.lt(g))
                  return s(this.toNumber() * t2.toNumber(), this.unsigned);
                var n2 = this.high >>> 16, i2 = 65535 & this.high, o2 = this.low >>> 16, a2 = 65535 & this.low, c2 = t2.high >>> 16, l2 = 65535 & t2.high, f2 = t2.low >>> 16, d2 = 65535 & t2.low, h2 = 0, m2 = 0, y2 = 0, _2 = 0;
                return y2 += (_2 += a2 * d2) >>> 16, m2 += (y2 += o2 * d2) >>> 16, y2 &= 65535, m2 += (y2 += a2 * f2) >>> 16, h2 += (m2 += i2 * d2) >>> 16, m2 &= 65535, h2 += (m2 += o2 * f2) >>> 16, m2 &= 65535, h2 += (m2 += a2 * l2) >>> 16, h2 += n2 * d2 + i2 * f2 + o2 * l2 + a2 * c2, u((y2 &= 65535) << 16 | (_2 &= 65535), (h2 &= 65535) << 16 | (m2 &= 65535), this.unsigned);
              }, S.mul = S.multiply, S.divide = function(t2) {
                if (r(t2) || (t2 = p(t2)), t2.isZero())
                  throw Error("division by zero");
                var n2, i2, o2;
                if (e)
                  return this.unsigned || -2147483648 !== this.high || -1 !== t2.low || -1 !== t2.high ? u((this.unsigned ? e.div_u : e.div_s)(this.low, this.high, t2.low, t2.high), e.get_high(), this.unsigned) : this;
                if (this.isZero())
                  return this.unsigned ? m : b;
                if (this.unsigned) {
                  if (t2.unsigned || (t2 = t2.toUnsigned()), t2.gt(this))
                    return m;
                  if (t2.gt(this.shru(1)))
                    return _;
                  o2 = m;
                } else {
                  if (this.eq(T))
                    return t2.eq(y) || t2.eq(v) ? T : t2.eq(T) ? y : (n2 = this.shr(1).div(t2).shl(1)).eq(b) ? t2.isNegative() ? y : v : (i2 = this.sub(t2.mul(n2)), o2 = n2.add(i2.div(t2)));
                  if (t2.eq(T))
                    return this.unsigned ? m : b;
                  if (this.isNegative())
                    return t2.isNegative() ? this.neg().div(t2.neg()) : this.neg().div(t2).neg();
                  if (t2.isNegative())
                    return this.div(t2.neg()).neg();
                  o2 = b;
                }
                for (i2 = this; i2.gte(t2); ) {
                  n2 = Math.max(1, Math.floor(i2.toNumber() / t2.toNumber()));
                  for (var a2 = Math.ceil(Math.log(n2) / Math.LN2), l2 = a2 <= 48 ? 1 : c(2, a2 - 48), f2 = s(n2), d2 = f2.mul(t2); d2.isNegative() || d2.gt(i2); )
                    d2 = (f2 = s(n2 -= l2, this.unsigned)).mul(t2);
                  f2.isZero() && (f2 = y), o2 = o2.add(f2), i2 = i2.sub(d2);
                }
                return o2;
              }, S.div = S.divide, S.modulo = function(t2) {
                return r(t2) || (t2 = p(t2)), e ? u((this.unsigned ? e.rem_u : e.rem_s)(this.low, this.high, t2.low, t2.high), e.get_high(), this.unsigned) : this.sub(this.div(t2).mul(t2));
              }, S.mod = S.modulo, S.rem = S.modulo, S.not = function() {
                return u(~this.low, ~this.high, this.unsigned);
              }, S.and = function(t2) {
                return r(t2) || (t2 = p(t2)), u(this.low & t2.low, this.high & t2.high, this.unsigned);
              }, S.or = function(t2) {
                return r(t2) || (t2 = p(t2)), u(this.low | t2.low, this.high | t2.high, this.unsigned);
              }, S.xor = function(t2) {
                return r(t2) || (t2 = p(t2)), u(this.low ^ t2.low, this.high ^ t2.high, this.unsigned);
              }, S.shiftLeft = function(t2) {
                return r(t2) && (t2 = t2.toInt()), 0 == (t2 &= 63) ? this : t2 < 32 ? u(this.low << t2, this.high << t2 | this.low >>> 32 - t2, this.unsigned) : u(0, this.low << t2 - 32, this.unsigned);
              }, S.shl = S.shiftLeft, S.shiftRight = function(t2) {
                return r(t2) && (t2 = t2.toInt()), 0 == (t2 &= 63) ? this : t2 < 32 ? u(this.low >>> t2 | this.high << 32 - t2, this.high >> t2, this.unsigned) : u(this.high >> t2 - 32, this.high >= 0 ? 0 : -1, this.unsigned);
              }, S.shr = S.shiftRight, S.shiftRightUnsigned = function(t2) {
                if (r(t2) && (t2 = t2.toInt()), 0 == (t2 &= 63))
                  return this;
                var e2 = this.high;
                return t2 < 32 ? u(this.low >>> t2 | e2 << 32 - t2, e2 >>> t2, this.unsigned) : u(32 === t2 ? e2 : e2 >>> t2 - 32, 0, this.unsigned);
              }, S.shru = S.shiftRightUnsigned, S.shr_u = S.shiftRightUnsigned, S.toSigned = function() {
                return this.unsigned ? u(this.low, this.high, false) : this;
              }, S.toUnsigned = function() {
                return this.unsigned ? this : u(this.low, this.high, true);
              }, S.toBytes = function(t2) {
                return t2 ? this.toBytesLE() : this.toBytesBE();
              }, S.toBytesLE = function() {
                var t2 = this.high, e2 = this.low;
                return [255 & e2, e2 >>> 8 & 255, e2 >>> 16 & 255, e2 >>> 24, 255 & t2, t2 >>> 8 & 255, t2 >>> 16 & 255, t2 >>> 24];
              }, S.toBytesBE = function() {
                var t2 = this.high, e2 = this.low;
                return [t2 >>> 24, t2 >>> 16 & 255, t2 >>> 8 & 255, 255 & t2, e2 >>> 24, e2 >>> 16 & 255, e2 >>> 8 & 255, 255 & e2];
              }, n.fromBytes = function(t2, e2, r2) {
                return r2 ? n.fromBytesLE(t2, e2) : n.fromBytesBE(t2, e2);
              }, n.fromBytesLE = function(t2, e2) {
                return new n(t2[0] | t2[1] << 8 | t2[2] << 16 | t2[3] << 24, t2[4] | t2[5] << 8 | t2[6] << 16 | t2[7] << 24, e2);
              }, n.fromBytesBE = function(t2, e2) {
                return new n(t2[4] << 24 | t2[5] << 16 | t2[6] << 8 | t2[7], t2[0] << 24 | t2[1] << 16 | t2[2] << 8 | t2[3], e2);
              };
            }, 1446: (t, e, n) => {
              "use strict";
              var r, i, o, a = n(2100), s = a.Reader, u = a.Writer, c = a.util, l = a.roots.default || (a.roots.default = {});
              l.onnx = ((o = {}).Version = (r = {}, (i = Object.create(r))[r[0] = "_START_VERSION"] = 0, i[r[1] = "IR_VERSION_2017_10_10"] = 1, i[r[2] = "IR_VERSION_2017_10_30"] = 2, i[r[3] = "IR_VERSION_2017_11_3"] = 3, i[r[4] = "IR_VERSION_2019_1_22"] = 4, i[r[5] = "IR_VERSION"] = 5, i), o.AttributeProto = function() {
                function t2(t3) {
                  if (this.floats = [], this.ints = [], this.strings = [], this.tensors = [], this.graphs = [], t3)
                    for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                      null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
                }
                return t2.prototype.name = "", t2.prototype.refAttrName = "", t2.prototype.docString = "", t2.prototype.type = 0, t2.prototype.f = 0, t2.prototype.i = c.Long ? c.Long.fromBits(0, 0, false) : 0, t2.prototype.s = c.newBuffer([]), t2.prototype.t = null, t2.prototype.g = null, t2.prototype.floats = c.emptyArray, t2.prototype.ints = c.emptyArray, t2.prototype.strings = c.emptyArray, t2.prototype.tensors = c.emptyArray, t2.prototype.graphs = c.emptyArray, t2.create = function(e2) {
                  return new t2(e2);
                }, t2.encode = function(t3, e2) {
                  if (e2 || (e2 = u.create()), null != t3.name && t3.hasOwnProperty("name") && e2.uint32(10).string(t3.name), null != t3.f && t3.hasOwnProperty("f") && e2.uint32(21).float(t3.f), null != t3.i && t3.hasOwnProperty("i") && e2.uint32(24).int64(t3.i), null != t3.s && t3.hasOwnProperty("s") && e2.uint32(34).bytes(t3.s), null != t3.t && t3.hasOwnProperty("t") && l.onnx.TensorProto.encode(t3.t, e2.uint32(42).fork()).ldelim(), null != t3.g && t3.hasOwnProperty("g") && l.onnx.GraphProto.encode(t3.g, e2.uint32(50).fork()).ldelim(), null != t3.floats && t3.floats.length) {
                    e2.uint32(58).fork();
                    for (var n2 = 0; n2 < t3.floats.length; ++n2)
                      e2.float(t3.floats[n2]);
                    e2.ldelim();
                  }
                  if (null != t3.ints && t3.ints.length) {
                    for (e2.uint32(66).fork(), n2 = 0; n2 < t3.ints.length; ++n2)
                      e2.int64(t3.ints[n2]);
                    e2.ldelim();
                  }
                  if (null != t3.strings && t3.strings.length)
                    for (n2 = 0; n2 < t3.strings.length; ++n2)
                      e2.uint32(74).bytes(t3.strings[n2]);
                  if (null != t3.tensors && t3.tensors.length)
                    for (n2 = 0; n2 < t3.tensors.length; ++n2)
                      l.onnx.TensorProto.encode(t3.tensors[n2], e2.uint32(82).fork()).ldelim();
                  if (null != t3.graphs && t3.graphs.length)
                    for (n2 = 0; n2 < t3.graphs.length; ++n2)
                      l.onnx.GraphProto.encode(t3.graphs[n2], e2.uint32(90).fork()).ldelim();
                  return null != t3.docString && t3.hasOwnProperty("docString") && e2.uint32(106).string(t3.docString), null != t3.type && t3.hasOwnProperty("type") && e2.uint32(160).int32(t3.type), null != t3.refAttrName && t3.hasOwnProperty("refAttrName") && e2.uint32(170).string(t3.refAttrName), e2;
                }, t2.encodeDelimited = function(t3, e2) {
                  return this.encode(t3, e2).ldelim();
                }, t2.decode = function(t3, e2) {
                  t3 instanceof s || (t3 = s.create(t3));
                  for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.AttributeProto(); t3.pos < n2; ) {
                    var i2 = t3.uint32();
                    switch (i2 >>> 3) {
                      case 1:
                        r2.name = t3.string();
                        break;
                      case 21:
                        r2.refAttrName = t3.string();
                        break;
                      case 13:
                        r2.docString = t3.string();
                        break;
                      case 20:
                        r2.type = t3.int32();
                        break;
                      case 2:
                        r2.f = t3.float();
                        break;
                      case 3:
                        r2.i = t3.int64();
                        break;
                      case 4:
                        r2.s = t3.bytes();
                        break;
                      case 5:
                        r2.t = l.onnx.TensorProto.decode(t3, t3.uint32());
                        break;
                      case 6:
                        r2.g = l.onnx.GraphProto.decode(t3, t3.uint32());
                        break;
                      case 7:
                        if (r2.floats && r2.floats.length || (r2.floats = []), 2 == (7 & i2))
                          for (var o2 = t3.uint32() + t3.pos; t3.pos < o2; )
                            r2.floats.push(t3.float());
                        else
                          r2.floats.push(t3.float());
                        break;
                      case 8:
                        if (r2.ints && r2.ints.length || (r2.ints = []), 2 == (7 & i2))
                          for (o2 = t3.uint32() + t3.pos; t3.pos < o2; )
                            r2.ints.push(t3.int64());
                        else
                          r2.ints.push(t3.int64());
                        break;
                      case 9:
                        r2.strings && r2.strings.length || (r2.strings = []), r2.strings.push(t3.bytes());
                        break;
                      case 10:
                        r2.tensors && r2.tensors.length || (r2.tensors = []), r2.tensors.push(l.onnx.TensorProto.decode(t3, t3.uint32()));
                        break;
                      case 11:
                        r2.graphs && r2.graphs.length || (r2.graphs = []), r2.graphs.push(l.onnx.GraphProto.decode(t3, t3.uint32()));
                        break;
                      default:
                        t3.skipType(7 & i2);
                    }
                  }
                  return r2;
                }, t2.decodeDelimited = function(t3) {
                  return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
                }, t2.verify = function(t3) {
                  if ("object" != typeof t3 || null === t3)
                    return "object expected";
                  if (null != t3.name && t3.hasOwnProperty("name") && !c.isString(t3.name))
                    return "name: string expected";
                  if (null != t3.refAttrName && t3.hasOwnProperty("refAttrName") && !c.isString(t3.refAttrName))
                    return "refAttrName: string expected";
                  if (null != t3.docString && t3.hasOwnProperty("docString") && !c.isString(t3.docString))
                    return "docString: string expected";
                  if (null != t3.type && t3.hasOwnProperty("type"))
                    switch (t3.type) {
                      default:
                        return "type: enum value expected";
                      case 0:
                      case 1:
                      case 2:
                      case 3:
                      case 4:
                      case 5:
                      case 6:
                      case 7:
                      case 8:
                      case 9:
                      case 10:
                    }
                  if (null != t3.f && t3.hasOwnProperty("f") && "number" != typeof t3.f)
                    return "f: number expected";
                  if (null != t3.i && t3.hasOwnProperty("i") && !(c.isInteger(t3.i) || t3.i && c.isInteger(t3.i.low) && c.isInteger(t3.i.high)))
                    return "i: integer|Long expected";
                  if (null != t3.s && t3.hasOwnProperty("s") && !(t3.s && "number" == typeof t3.s.length || c.isString(t3.s)))
                    return "s: buffer expected";
                  if (null != t3.t && t3.hasOwnProperty("t") && (n2 = l.onnx.TensorProto.verify(t3.t)))
                    return "t." + n2;
                  if (null != t3.g && t3.hasOwnProperty("g") && (n2 = l.onnx.GraphProto.verify(t3.g)))
                    return "g." + n2;
                  if (null != t3.floats && t3.hasOwnProperty("floats")) {
                    if (!Array.isArray(t3.floats))
                      return "floats: array expected";
                    for (var e2 = 0; e2 < t3.floats.length; ++e2)
                      if ("number" != typeof t3.floats[e2])
                        return "floats: number[] expected";
                  }
                  if (null != t3.ints && t3.hasOwnProperty("ints")) {
                    if (!Array.isArray(t3.ints))
                      return "ints: array expected";
                    for (e2 = 0; e2 < t3.ints.length; ++e2)
                      if (!(c.isInteger(t3.ints[e2]) || t3.ints[e2] && c.isInteger(t3.ints[e2].low) && c.isInteger(t3.ints[e2].high)))
                        return "ints: integer|Long[] expected";
                  }
                  if (null != t3.strings && t3.hasOwnProperty("strings")) {
                    if (!Array.isArray(t3.strings))
                      return "strings: array expected";
                    for (e2 = 0; e2 < t3.strings.length; ++e2)
                      if (!(t3.strings[e2] && "number" == typeof t3.strings[e2].length || c.isString(t3.strings[e2])))
                        return "strings: buffer[] expected";
                  }
                  if (null != t3.tensors && t3.hasOwnProperty("tensors")) {
                    if (!Array.isArray(t3.tensors))
                      return "tensors: array expected";
                    for (e2 = 0; e2 < t3.tensors.length; ++e2)
                      if (n2 = l.onnx.TensorProto.verify(t3.tensors[e2]))
                        return "tensors." + n2;
                  }
                  if (null != t3.graphs && t3.hasOwnProperty("graphs")) {
                    if (!Array.isArray(t3.graphs))
                      return "graphs: array expected";
                    for (e2 = 0; e2 < t3.graphs.length; ++e2) {
                      var n2;
                      if (n2 = l.onnx.GraphProto.verify(t3.graphs[e2]))
                        return "graphs." + n2;
                    }
                  }
                  return null;
                }, t2.fromObject = function(t3) {
                  if (t3 instanceof l.onnx.AttributeProto)
                    return t3;
                  var e2 = new l.onnx.AttributeProto();
                  switch (null != t3.name && (e2.name = String(t3.name)), null != t3.refAttrName && (e2.refAttrName = String(t3.refAttrName)), null != t3.docString && (e2.docString = String(t3.docString)), t3.type) {
                    case "UNDEFINED":
                    case 0:
                      e2.type = 0;
                      break;
                    case "FLOAT":
                    case 1:
                      e2.type = 1;
                      break;
                    case "INT":
                    case 2:
                      e2.type = 2;
                      break;
                    case "STRING":
                    case 3:
                      e2.type = 3;
                      break;
                    case "TENSOR":
                    case 4:
                      e2.type = 4;
                      break;
                    case "GRAPH":
                    case 5:
                      e2.type = 5;
                      break;
                    case "FLOATS":
                    case 6:
                      e2.type = 6;
                      break;
                    case "INTS":
                    case 7:
                      e2.type = 7;
                      break;
                    case "STRINGS":
                    case 8:
                      e2.type = 8;
                      break;
                    case "TENSORS":
                    case 9:
                      e2.type = 9;
                      break;
                    case "GRAPHS":
                    case 10:
                      e2.type = 10;
                  }
                  if (null != t3.f && (e2.f = Number(t3.f)), null != t3.i && (c.Long ? (e2.i = c.Long.fromValue(t3.i)).unsigned = false : "string" == typeof t3.i ? e2.i = parseInt(t3.i, 10) : "number" == typeof t3.i ? e2.i = t3.i : "object" == typeof t3.i && (e2.i = new c.LongBits(t3.i.low >>> 0, t3.i.high >>> 0).toNumber())), null != t3.s && ("string" == typeof t3.s ? c.base64.decode(t3.s, e2.s = c.newBuffer(c.base64.length(t3.s)), 0) : t3.s.length && (e2.s = t3.s)), null != t3.t) {
                    if ("object" != typeof t3.t)
                      throw TypeError(".onnx.AttributeProto.t: object expected");
                    e2.t = l.onnx.TensorProto.fromObject(t3.t);
                  }
                  if (null != t3.g) {
                    if ("object" != typeof t3.g)
                      throw TypeError(".onnx.AttributeProto.g: object expected");
                    e2.g = l.onnx.GraphProto.fromObject(t3.g);
                  }
                  if (t3.floats) {
                    if (!Array.isArray(t3.floats))
                      throw TypeError(".onnx.AttributeProto.floats: array expected");
                    e2.floats = [];
                    for (var n2 = 0; n2 < t3.floats.length; ++n2)
                      e2.floats[n2] = Number(t3.floats[n2]);
                  }
                  if (t3.ints) {
                    if (!Array.isArray(t3.ints))
                      throw TypeError(".onnx.AttributeProto.ints: array expected");
                    for (e2.ints = [], n2 = 0; n2 < t3.ints.length; ++n2)
                      c.Long ? (e2.ints[n2] = c.Long.fromValue(t3.ints[n2])).unsigned = false : "string" == typeof t3.ints[n2] ? e2.ints[n2] = parseInt(t3.ints[n2], 10) : "number" == typeof t3.ints[n2] ? e2.ints[n2] = t3.ints[n2] : "object" == typeof t3.ints[n2] && (e2.ints[n2] = new c.LongBits(t3.ints[n2].low >>> 0, t3.ints[n2].high >>> 0).toNumber());
                  }
                  if (t3.strings) {
                    if (!Array.isArray(t3.strings))
                      throw TypeError(".onnx.AttributeProto.strings: array expected");
                    for (e2.strings = [], n2 = 0; n2 < t3.strings.length; ++n2)
                      "string" == typeof t3.strings[n2] ? c.base64.decode(t3.strings[n2], e2.strings[n2] = c.newBuffer(c.base64.length(t3.strings[n2])), 0) : t3.strings[n2].length && (e2.strings[n2] = t3.strings[n2]);
                  }
                  if (t3.tensors) {
                    if (!Array.isArray(t3.tensors))
                      throw TypeError(".onnx.AttributeProto.tensors: array expected");
                    for (e2.tensors = [], n2 = 0; n2 < t3.tensors.length; ++n2) {
                      if ("object" != typeof t3.tensors[n2])
                        throw TypeError(".onnx.AttributeProto.tensors: object expected");
                      e2.tensors[n2] = l.onnx.TensorProto.fromObject(t3.tensors[n2]);
                    }
                  }
                  if (t3.graphs) {
                    if (!Array.isArray(t3.graphs))
                      throw TypeError(".onnx.AttributeProto.graphs: array expected");
                    for (e2.graphs = [], n2 = 0; n2 < t3.graphs.length; ++n2) {
                      if ("object" != typeof t3.graphs[n2])
                        throw TypeError(".onnx.AttributeProto.graphs: object expected");
                      e2.graphs[n2] = l.onnx.GraphProto.fromObject(t3.graphs[n2]);
                    }
                  }
                  return e2;
                }, t2.toObject = function(t3, e2) {
                  e2 || (e2 = {});
                  var n2 = {};
                  if ((e2.arrays || e2.defaults) && (n2.floats = [], n2.ints = [], n2.strings = [], n2.tensors = [], n2.graphs = []), e2.defaults) {
                    if (n2.name = "", n2.f = 0, c.Long) {
                      var r2 = new c.Long(0, 0, false);
                      n2.i = e2.longs === String ? r2.toString() : e2.longs === Number ? r2.toNumber() : r2;
                    } else
                      n2.i = e2.longs === String ? "0" : 0;
                    e2.bytes === String ? n2.s = "" : (n2.s = [], e2.bytes !== Array && (n2.s = c.newBuffer(n2.s))), n2.t = null, n2.g = null, n2.docString = "", n2.type = e2.enums === String ? "UNDEFINED" : 0, n2.refAttrName = "";
                  }
                  if (null != t3.name && t3.hasOwnProperty("name") && (n2.name = t3.name), null != t3.f && t3.hasOwnProperty("f") && (n2.f = e2.json && !isFinite(t3.f) ? String(t3.f) : t3.f), null != t3.i && t3.hasOwnProperty("i") && ("number" == typeof t3.i ? n2.i = e2.longs === String ? String(t3.i) : t3.i : n2.i = e2.longs === String ? c.Long.prototype.toString.call(t3.i) : e2.longs === Number ? new c.LongBits(t3.i.low >>> 0, t3.i.high >>> 0).toNumber() : t3.i), null != t3.s && t3.hasOwnProperty("s") && (n2.s = e2.bytes === String ? c.base64.encode(t3.s, 0, t3.s.length) : e2.bytes === Array ? Array.prototype.slice.call(t3.s) : t3.s), null != t3.t && t3.hasOwnProperty("t") && (n2.t = l.onnx.TensorProto.toObject(t3.t, e2)), null != t3.g && t3.hasOwnProperty("g") && (n2.g = l.onnx.GraphProto.toObject(t3.g, e2)), t3.floats && t3.floats.length) {
                    n2.floats = [];
                    for (var i2 = 0; i2 < t3.floats.length; ++i2)
                      n2.floats[i2] = e2.json && !isFinite(t3.floats[i2]) ? String(t3.floats[i2]) : t3.floats[i2];
                  }
                  if (t3.ints && t3.ints.length)
                    for (n2.ints = [], i2 = 0; i2 < t3.ints.length; ++i2)
                      "number" == typeof t3.ints[i2] ? n2.ints[i2] = e2.longs === String ? String(t3.ints[i2]) : t3.ints[i2] : n2.ints[i2] = e2.longs === String ? c.Long.prototype.toString.call(t3.ints[i2]) : e2.longs === Number ? new c.LongBits(t3.ints[i2].low >>> 0, t3.ints[i2].high >>> 0).toNumber() : t3.ints[i2];
                  if (t3.strings && t3.strings.length)
                    for (n2.strings = [], i2 = 0; i2 < t3.strings.length; ++i2)
                      n2.strings[i2] = e2.bytes === String ? c.base64.encode(t3.strings[i2], 0, t3.strings[i2].length) : e2.bytes === Array ? Array.prototype.slice.call(t3.strings[i2]) : t3.strings[i2];
                  if (t3.tensors && t3.tensors.length)
                    for (n2.tensors = [], i2 = 0; i2 < t3.tensors.length; ++i2)
                      n2.tensors[i2] = l.onnx.TensorProto.toObject(t3.tensors[i2], e2);
                  if (t3.graphs && t3.graphs.length)
                    for (n2.graphs = [], i2 = 0; i2 < t3.graphs.length; ++i2)
                      n2.graphs[i2] = l.onnx.GraphProto.toObject(t3.graphs[i2], e2);
                  return null != t3.docString && t3.hasOwnProperty("docString") && (n2.docString = t3.docString), null != t3.type && t3.hasOwnProperty("type") && (n2.type = e2.enums === String ? l.onnx.AttributeProto.AttributeType[t3.type] : t3.type), null != t3.refAttrName && t3.hasOwnProperty("refAttrName") && (n2.refAttrName = t3.refAttrName), n2;
                }, t2.prototype.toJSON = function() {
                  return this.constructor.toObject(this, a.util.toJSONOptions);
                }, t2.AttributeType = function() {
                  var t3 = {}, e2 = Object.create(t3);
                  return e2[t3[0] = "UNDEFINED"] = 0, e2[t3[1] = "FLOAT"] = 1, e2[t3[2] = "INT"] = 2, e2[t3[3] = "STRING"] = 3, e2[t3[4] = "TENSOR"] = 4, e2[t3[5] = "GRAPH"] = 5, e2[t3[6] = "FLOATS"] = 6, e2[t3[7] = "INTS"] = 7, e2[t3[8] = "STRINGS"] = 8, e2[t3[9] = "TENSORS"] = 9, e2[t3[10] = "GRAPHS"] = 10, e2;
                }(), t2;
              }(), o.ValueInfoProto = function() {
                function t2(t3) {
                  if (t3)
                    for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                      null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
                }
                return t2.prototype.name = "", t2.prototype.type = null, t2.prototype.docString = "", t2.create = function(e2) {
                  return new t2(e2);
                }, t2.encode = function(t3, e2) {
                  return e2 || (e2 = u.create()), null != t3.name && t3.hasOwnProperty("name") && e2.uint32(10).string(t3.name), null != t3.type && t3.hasOwnProperty("type") && l.onnx.TypeProto.encode(t3.type, e2.uint32(18).fork()).ldelim(), null != t3.docString && t3.hasOwnProperty("docString") && e2.uint32(26).string(t3.docString), e2;
                }, t2.encodeDelimited = function(t3, e2) {
                  return this.encode(t3, e2).ldelim();
                }, t2.decode = function(t3, e2) {
                  t3 instanceof s || (t3 = s.create(t3));
                  for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.ValueInfoProto(); t3.pos < n2; ) {
                    var i2 = t3.uint32();
                    switch (i2 >>> 3) {
                      case 1:
                        r2.name = t3.string();
                        break;
                      case 2:
                        r2.type = l.onnx.TypeProto.decode(t3, t3.uint32());
                        break;
                      case 3:
                        r2.docString = t3.string();
                        break;
                      default:
                        t3.skipType(7 & i2);
                    }
                  }
                  return r2;
                }, t2.decodeDelimited = function(t3) {
                  return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
                }, t2.verify = function(t3) {
                  if ("object" != typeof t3 || null === t3)
                    return "object expected";
                  if (null != t3.name && t3.hasOwnProperty("name") && !c.isString(t3.name))
                    return "name: string expected";
                  if (null != t3.type && t3.hasOwnProperty("type")) {
                    var e2 = l.onnx.TypeProto.verify(t3.type);
                    if (e2)
                      return "type." + e2;
                  }
                  return null != t3.docString && t3.hasOwnProperty("docString") && !c.isString(t3.docString) ? "docString: string expected" : null;
                }, t2.fromObject = function(t3) {
                  if (t3 instanceof l.onnx.ValueInfoProto)
                    return t3;
                  var e2 = new l.onnx.ValueInfoProto();
                  if (null != t3.name && (e2.name = String(t3.name)), null != t3.type) {
                    if ("object" != typeof t3.type)
                      throw TypeError(".onnx.ValueInfoProto.type: object expected");
                    e2.type = l.onnx.TypeProto.fromObject(t3.type);
                  }
                  return null != t3.docString && (e2.docString = String(t3.docString)), e2;
                }, t2.toObject = function(t3, e2) {
                  e2 || (e2 = {});
                  var n2 = {};
                  return e2.defaults && (n2.name = "", n2.type = null, n2.docString = ""), null != t3.name && t3.hasOwnProperty("name") && (n2.name = t3.name), null != t3.type && t3.hasOwnProperty("type") && (n2.type = l.onnx.TypeProto.toObject(t3.type, e2)), null != t3.docString && t3.hasOwnProperty("docString") && (n2.docString = t3.docString), n2;
                }, t2.prototype.toJSON = function() {
                  return this.constructor.toObject(this, a.util.toJSONOptions);
                }, t2;
              }(), o.NodeProto = function() {
                function t2(t3) {
                  if (this.input = [], this.output = [], this.attribute = [], t3)
                    for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                      null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
                }
                return t2.prototype.input = c.emptyArray, t2.prototype.output = c.emptyArray, t2.prototype.name = "", t2.prototype.opType = "", t2.prototype.domain = "", t2.prototype.attribute = c.emptyArray, t2.prototype.docString = "", t2.create = function(e2) {
                  return new t2(e2);
                }, t2.encode = function(t3, e2) {
                  if (e2 || (e2 = u.create()), null != t3.input && t3.input.length)
                    for (var n2 = 0; n2 < t3.input.length; ++n2)
                      e2.uint32(10).string(t3.input[n2]);
                  if (null != t3.output && t3.output.length)
                    for (n2 = 0; n2 < t3.output.length; ++n2)
                      e2.uint32(18).string(t3.output[n2]);
                  if (null != t3.name && t3.hasOwnProperty("name") && e2.uint32(26).string(t3.name), null != t3.opType && t3.hasOwnProperty("opType") && e2.uint32(34).string(t3.opType), null != t3.attribute && t3.attribute.length)
                    for (n2 = 0; n2 < t3.attribute.length; ++n2)
                      l.onnx.AttributeProto.encode(t3.attribute[n2], e2.uint32(42).fork()).ldelim();
                  return null != t3.docString && t3.hasOwnProperty("docString") && e2.uint32(50).string(t3.docString), null != t3.domain && t3.hasOwnProperty("domain") && e2.uint32(58).string(t3.domain), e2;
                }, t2.encodeDelimited = function(t3, e2) {
                  return this.encode(t3, e2).ldelim();
                }, t2.decode = function(t3, e2) {
                  t3 instanceof s || (t3 = s.create(t3));
                  for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.NodeProto(); t3.pos < n2; ) {
                    var i2 = t3.uint32();
                    switch (i2 >>> 3) {
                      case 1:
                        r2.input && r2.input.length || (r2.input = []), r2.input.push(t3.string());
                        break;
                      case 2:
                        r2.output && r2.output.length || (r2.output = []), r2.output.push(t3.string());
                        break;
                      case 3:
                        r2.name = t3.string();
                        break;
                      case 4:
                        r2.opType = t3.string();
                        break;
                      case 7:
                        r2.domain = t3.string();
                        break;
                      case 5:
                        r2.attribute && r2.attribute.length || (r2.attribute = []), r2.attribute.push(l.onnx.AttributeProto.decode(t3, t3.uint32()));
                        break;
                      case 6:
                        r2.docString = t3.string();
                        break;
                      default:
                        t3.skipType(7 & i2);
                    }
                  }
                  return r2;
                }, t2.decodeDelimited = function(t3) {
                  return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
                }, t2.verify = function(t3) {
                  if ("object" != typeof t3 || null === t3)
                    return "object expected";
                  if (null != t3.input && t3.hasOwnProperty("input")) {
                    if (!Array.isArray(t3.input))
                      return "input: array expected";
                    for (var e2 = 0; e2 < t3.input.length; ++e2)
                      if (!c.isString(t3.input[e2]))
                        return "input: string[] expected";
                  }
                  if (null != t3.output && t3.hasOwnProperty("output")) {
                    if (!Array.isArray(t3.output))
                      return "output: array expected";
                    for (e2 = 0; e2 < t3.output.length; ++e2)
                      if (!c.isString(t3.output[e2]))
                        return "output: string[] expected";
                  }
                  if (null != t3.name && t3.hasOwnProperty("name") && !c.isString(t3.name))
                    return "name: string expected";
                  if (null != t3.opType && t3.hasOwnProperty("opType") && !c.isString(t3.opType))
                    return "opType: string expected";
                  if (null != t3.domain && t3.hasOwnProperty("domain") && !c.isString(t3.domain))
                    return "domain: string expected";
                  if (null != t3.attribute && t3.hasOwnProperty("attribute")) {
                    if (!Array.isArray(t3.attribute))
                      return "attribute: array expected";
                    for (e2 = 0; e2 < t3.attribute.length; ++e2) {
                      var n2 = l.onnx.AttributeProto.verify(t3.attribute[e2]);
                      if (n2)
                        return "attribute." + n2;
                    }
                  }
                  return null != t3.docString && t3.hasOwnProperty("docString") && !c.isString(t3.docString) ? "docString: string expected" : null;
                }, t2.fromObject = function(t3) {
                  if (t3 instanceof l.onnx.NodeProto)
                    return t3;
                  var e2 = new l.onnx.NodeProto();
                  if (t3.input) {
                    if (!Array.isArray(t3.input))
                      throw TypeError(".onnx.NodeProto.input: array expected");
                    e2.input = [];
                    for (var n2 = 0; n2 < t3.input.length; ++n2)
                      e2.input[n2] = String(t3.input[n2]);
                  }
                  if (t3.output) {
                    if (!Array.isArray(t3.output))
                      throw TypeError(".onnx.NodeProto.output: array expected");
                    for (e2.output = [], n2 = 0; n2 < t3.output.length; ++n2)
                      e2.output[n2] = String(t3.output[n2]);
                  }
                  if (null != t3.name && (e2.name = String(t3.name)), null != t3.opType && (e2.opType = String(t3.opType)), null != t3.domain && (e2.domain = String(t3.domain)), t3.attribute) {
                    if (!Array.isArray(t3.attribute))
                      throw TypeError(".onnx.NodeProto.attribute: array expected");
                    for (e2.attribute = [], n2 = 0; n2 < t3.attribute.length; ++n2) {
                      if ("object" != typeof t3.attribute[n2])
                        throw TypeError(".onnx.NodeProto.attribute: object expected");
                      e2.attribute[n2] = l.onnx.AttributeProto.fromObject(t3.attribute[n2]);
                    }
                  }
                  return null != t3.docString && (e2.docString = String(t3.docString)), e2;
                }, t2.toObject = function(t3, e2) {
                  e2 || (e2 = {});
                  var n2 = {};
                  if ((e2.arrays || e2.defaults) && (n2.input = [], n2.output = [], n2.attribute = []), e2.defaults && (n2.name = "", n2.opType = "", n2.docString = "", n2.domain = ""), t3.input && t3.input.length) {
                    n2.input = [];
                    for (var r2 = 0; r2 < t3.input.length; ++r2)
                      n2.input[r2] = t3.input[r2];
                  }
                  if (t3.output && t3.output.length)
                    for (n2.output = [], r2 = 0; r2 < t3.output.length; ++r2)
                      n2.output[r2] = t3.output[r2];
                  if (null != t3.name && t3.hasOwnProperty("name") && (n2.name = t3.name), null != t3.opType && t3.hasOwnProperty("opType") && (n2.opType = t3.opType), t3.attribute && t3.attribute.length)
                    for (n2.attribute = [], r2 = 0; r2 < t3.attribute.length; ++r2)
                      n2.attribute[r2] = l.onnx.AttributeProto.toObject(t3.attribute[r2], e2);
                  return null != t3.docString && t3.hasOwnProperty("docString") && (n2.docString = t3.docString), null != t3.domain && t3.hasOwnProperty("domain") && (n2.domain = t3.domain), n2;
                }, t2.prototype.toJSON = function() {
                  return this.constructor.toObject(this, a.util.toJSONOptions);
                }, t2;
              }(), o.ModelProto = function() {
                function t2(t3) {
                  if (this.opsetImport = [], this.metadataProps = [], t3)
                    for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                      null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
                }
                return t2.prototype.irVersion = c.Long ? c.Long.fromBits(0, 0, false) : 0, t2.prototype.opsetImport = c.emptyArray, t2.prototype.producerName = "", t2.prototype.producerVersion = "", t2.prototype.domain = "", t2.prototype.modelVersion = c.Long ? c.Long.fromBits(0, 0, false) : 0, t2.prototype.docString = "", t2.prototype.graph = null, t2.prototype.metadataProps = c.emptyArray, t2.create = function(e2) {
                  return new t2(e2);
                }, t2.encode = function(t3, e2) {
                  if (e2 || (e2 = u.create()), null != t3.irVersion && t3.hasOwnProperty("irVersion") && e2.uint32(8).int64(t3.irVersion), null != t3.producerName && t3.hasOwnProperty("producerName") && e2.uint32(18).string(t3.producerName), null != t3.producerVersion && t3.hasOwnProperty("producerVersion") && e2.uint32(26).string(t3.producerVersion), null != t3.domain && t3.hasOwnProperty("domain") && e2.uint32(34).string(t3.domain), null != t3.modelVersion && t3.hasOwnProperty("modelVersion") && e2.uint32(40).int64(t3.modelVersion), null != t3.docString && t3.hasOwnProperty("docString") && e2.uint32(50).string(t3.docString), null != t3.graph && t3.hasOwnProperty("graph") && l.onnx.GraphProto.encode(t3.graph, e2.uint32(58).fork()).ldelim(), null != t3.opsetImport && t3.opsetImport.length)
                    for (var n2 = 0; n2 < t3.opsetImport.length; ++n2)
                      l.onnx.OperatorSetIdProto.encode(t3.opsetImport[n2], e2.uint32(66).fork()).ldelim();
                  if (null != t3.metadataProps && t3.metadataProps.length)
                    for (n2 = 0; n2 < t3.metadataProps.length; ++n2)
                      l.onnx.StringStringEntryProto.encode(t3.metadataProps[n2], e2.uint32(114).fork()).ldelim();
                  return e2;
                }, t2.encodeDelimited = function(t3, e2) {
                  return this.encode(t3, e2).ldelim();
                }, t2.decode = function(t3, e2) {
                  t3 instanceof s || (t3 = s.create(t3));
                  for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.ModelProto(); t3.pos < n2; ) {
                    var i2 = t3.uint32();
                    switch (i2 >>> 3) {
                      case 1:
                        r2.irVersion = t3.int64();
                        break;
                      case 8:
                        r2.opsetImport && r2.opsetImport.length || (r2.opsetImport = []), r2.opsetImport.push(l.onnx.OperatorSetIdProto.decode(t3, t3.uint32()));
                        break;
                      case 2:
                        r2.producerName = t3.string();
                        break;
                      case 3:
                        r2.producerVersion = t3.string();
                        break;
                      case 4:
                        r2.domain = t3.string();
                        break;
                      case 5:
                        r2.modelVersion = t3.int64();
                        break;
                      case 6:
                        r2.docString = t3.string();
                        break;
                      case 7:
                        r2.graph = l.onnx.GraphProto.decode(t3, t3.uint32());
                        break;
                      case 14:
                        r2.metadataProps && r2.metadataProps.length || (r2.metadataProps = []), r2.metadataProps.push(l.onnx.StringStringEntryProto.decode(t3, t3.uint32()));
                        break;
                      default:
                        t3.skipType(7 & i2);
                    }
                  }
                  return r2;
                }, t2.decodeDelimited = function(t3) {
                  return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
                }, t2.verify = function(t3) {
                  if ("object" != typeof t3 || null === t3)
                    return "object expected";
                  if (null != t3.irVersion && t3.hasOwnProperty("irVersion") && !(c.isInteger(t3.irVersion) || t3.irVersion && c.isInteger(t3.irVersion.low) && c.isInteger(t3.irVersion.high)))
                    return "irVersion: integer|Long expected";
                  if (null != t3.opsetImport && t3.hasOwnProperty("opsetImport")) {
                    if (!Array.isArray(t3.opsetImport))
                      return "opsetImport: array expected";
                    for (var e2 = 0; e2 < t3.opsetImport.length; ++e2)
                      if (n2 = l.onnx.OperatorSetIdProto.verify(t3.opsetImport[e2]))
                        return "opsetImport." + n2;
                  }
                  if (null != t3.producerName && t3.hasOwnProperty("producerName") && !c.isString(t3.producerName))
                    return "producerName: string expected";
                  if (null != t3.producerVersion && t3.hasOwnProperty("producerVersion") && !c.isString(t3.producerVersion))
                    return "producerVersion: string expected";
                  if (null != t3.domain && t3.hasOwnProperty("domain") && !c.isString(t3.domain))
                    return "domain: string expected";
                  if (null != t3.modelVersion && t3.hasOwnProperty("modelVersion") && !(c.isInteger(t3.modelVersion) || t3.modelVersion && c.isInteger(t3.modelVersion.low) && c.isInteger(t3.modelVersion.high)))
                    return "modelVersion: integer|Long expected";
                  if (null != t3.docString && t3.hasOwnProperty("docString") && !c.isString(t3.docString))
                    return "docString: string expected";
                  if (null != t3.graph && t3.hasOwnProperty("graph") && (n2 = l.onnx.GraphProto.verify(t3.graph)))
                    return "graph." + n2;
                  if (null != t3.metadataProps && t3.hasOwnProperty("metadataProps")) {
                    if (!Array.isArray(t3.metadataProps))
                      return "metadataProps: array expected";
                    for (e2 = 0; e2 < t3.metadataProps.length; ++e2) {
                      var n2;
                      if (n2 = l.onnx.StringStringEntryProto.verify(t3.metadataProps[e2]))
                        return "metadataProps." + n2;
                    }
                  }
                  return null;
                }, t2.fromObject = function(t3) {
                  if (t3 instanceof l.onnx.ModelProto)
                    return t3;
                  var e2 = new l.onnx.ModelProto();
                  if (null != t3.irVersion && (c.Long ? (e2.irVersion = c.Long.fromValue(t3.irVersion)).unsigned = false : "string" == typeof t3.irVersion ? e2.irVersion = parseInt(t3.irVersion, 10) : "number" == typeof t3.irVersion ? e2.irVersion = t3.irVersion : "object" == typeof t3.irVersion && (e2.irVersion = new c.LongBits(t3.irVersion.low >>> 0, t3.irVersion.high >>> 0).toNumber())), t3.opsetImport) {
                    if (!Array.isArray(t3.opsetImport))
                      throw TypeError(".onnx.ModelProto.opsetImport: array expected");
                    e2.opsetImport = [];
                    for (var n2 = 0; n2 < t3.opsetImport.length; ++n2) {
                      if ("object" != typeof t3.opsetImport[n2])
                        throw TypeError(".onnx.ModelProto.opsetImport: object expected");
                      e2.opsetImport[n2] = l.onnx.OperatorSetIdProto.fromObject(t3.opsetImport[n2]);
                    }
                  }
                  if (null != t3.producerName && (e2.producerName = String(t3.producerName)), null != t3.producerVersion && (e2.producerVersion = String(t3.producerVersion)), null != t3.domain && (e2.domain = String(t3.domain)), null != t3.modelVersion && (c.Long ? (e2.modelVersion = c.Long.fromValue(t3.modelVersion)).unsigned = false : "string" == typeof t3.modelVersion ? e2.modelVersion = parseInt(t3.modelVersion, 10) : "number" == typeof t3.modelVersion ? e2.modelVersion = t3.modelVersion : "object" == typeof t3.modelVersion && (e2.modelVersion = new c.LongBits(t3.modelVersion.low >>> 0, t3.modelVersion.high >>> 0).toNumber())), null != t3.docString && (e2.docString = String(t3.docString)), null != t3.graph) {
                    if ("object" != typeof t3.graph)
                      throw TypeError(".onnx.ModelProto.graph: object expected");
                    e2.graph = l.onnx.GraphProto.fromObject(t3.graph);
                  }
                  if (t3.metadataProps) {
                    if (!Array.isArray(t3.metadataProps))
                      throw TypeError(".onnx.ModelProto.metadataProps: array expected");
                    for (e2.metadataProps = [], n2 = 0; n2 < t3.metadataProps.length; ++n2) {
                      if ("object" != typeof t3.metadataProps[n2])
                        throw TypeError(".onnx.ModelProto.metadataProps: object expected");
                      e2.metadataProps[n2] = l.onnx.StringStringEntryProto.fromObject(t3.metadataProps[n2]);
                    }
                  }
                  return e2;
                }, t2.toObject = function(t3, e2) {
                  e2 || (e2 = {});
                  var n2 = {};
                  if ((e2.arrays || e2.defaults) && (n2.opsetImport = [], n2.metadataProps = []), e2.defaults) {
                    if (c.Long) {
                      var r2 = new c.Long(0, 0, false);
                      n2.irVersion = e2.longs === String ? r2.toString() : e2.longs === Number ? r2.toNumber() : r2;
                    } else
                      n2.irVersion = e2.longs === String ? "0" : 0;
                    n2.producerName = "", n2.producerVersion = "", n2.domain = "", c.Long ? (r2 = new c.Long(0, 0, false), n2.modelVersion = e2.longs === String ? r2.toString() : e2.longs === Number ? r2.toNumber() : r2) : n2.modelVersion = e2.longs === String ? "0" : 0, n2.docString = "", n2.graph = null;
                  }
                  if (null != t3.irVersion && t3.hasOwnProperty("irVersion") && ("number" == typeof t3.irVersion ? n2.irVersion = e2.longs === String ? String(t3.irVersion) : t3.irVersion : n2.irVersion = e2.longs === String ? c.Long.prototype.toString.call(t3.irVersion) : e2.longs === Number ? new c.LongBits(t3.irVersion.low >>> 0, t3.irVersion.high >>> 0).toNumber() : t3.irVersion), null != t3.producerName && t3.hasOwnProperty("producerName") && (n2.producerName = t3.producerName), null != t3.producerVersion && t3.hasOwnProperty("producerVersion") && (n2.producerVersion = t3.producerVersion), null != t3.domain && t3.hasOwnProperty("domain") && (n2.domain = t3.domain), null != t3.modelVersion && t3.hasOwnProperty("modelVersion") && ("number" == typeof t3.modelVersion ? n2.modelVersion = e2.longs === String ? String(t3.modelVersion) : t3.modelVersion : n2.modelVersion = e2.longs === String ? c.Long.prototype.toString.call(t3.modelVersion) : e2.longs === Number ? new c.LongBits(t3.modelVersion.low >>> 0, t3.modelVersion.high >>> 0).toNumber() : t3.modelVersion), null != t3.docString && t3.hasOwnProperty("docString") && (n2.docString = t3.docString), null != t3.graph && t3.hasOwnProperty("graph") && (n2.graph = l.onnx.GraphProto.toObject(t3.graph, e2)), t3.opsetImport && t3.opsetImport.length) {
                    n2.opsetImport = [];
                    for (var i2 = 0; i2 < t3.opsetImport.length; ++i2)
                      n2.opsetImport[i2] = l.onnx.OperatorSetIdProto.toObject(t3.opsetImport[i2], e2);
                  }
                  if (t3.metadataProps && t3.metadataProps.length)
                    for (n2.metadataProps = [], i2 = 0; i2 < t3.metadataProps.length; ++i2)
                      n2.metadataProps[i2] = l.onnx.StringStringEntryProto.toObject(t3.metadataProps[i2], e2);
                  return n2;
                }, t2.prototype.toJSON = function() {
                  return this.constructor.toObject(this, a.util.toJSONOptions);
                }, t2;
              }(), o.StringStringEntryProto = function() {
                function t2(t3) {
                  if (t3)
                    for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                      null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
                }
                return t2.prototype.key = "", t2.prototype.value = "", t2.create = function(e2) {
                  return new t2(e2);
                }, t2.encode = function(t3, e2) {
                  return e2 || (e2 = u.create()), null != t3.key && t3.hasOwnProperty("key") && e2.uint32(10).string(t3.key), null != t3.value && t3.hasOwnProperty("value") && e2.uint32(18).string(t3.value), e2;
                }, t2.encodeDelimited = function(t3, e2) {
                  return this.encode(t3, e2).ldelim();
                }, t2.decode = function(t3, e2) {
                  t3 instanceof s || (t3 = s.create(t3));
                  for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.StringStringEntryProto(); t3.pos < n2; ) {
                    var i2 = t3.uint32();
                    switch (i2 >>> 3) {
                      case 1:
                        r2.key = t3.string();
                        break;
                      case 2:
                        r2.value = t3.string();
                        break;
                      default:
                        t3.skipType(7 & i2);
                    }
                  }
                  return r2;
                }, t2.decodeDelimited = function(t3) {
                  return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
                }, t2.verify = function(t3) {
                  return "object" != typeof t3 || null === t3 ? "object expected" : null != t3.key && t3.hasOwnProperty("key") && !c.isString(t3.key) ? "key: string expected" : null != t3.value && t3.hasOwnProperty("value") && !c.isString(t3.value) ? "value: string expected" : null;
                }, t2.fromObject = function(t3) {
                  if (t3 instanceof l.onnx.StringStringEntryProto)
                    return t3;
                  var e2 = new l.onnx.StringStringEntryProto();
                  return null != t3.key && (e2.key = String(t3.key)), null != t3.value && (e2.value = String(t3.value)), e2;
                }, t2.toObject = function(t3, e2) {
                  e2 || (e2 = {});
                  var n2 = {};
                  return e2.defaults && (n2.key = "", n2.value = ""), null != t3.key && t3.hasOwnProperty("key") && (n2.key = t3.key), null != t3.value && t3.hasOwnProperty("value") && (n2.value = t3.value), n2;
                }, t2.prototype.toJSON = function() {
                  return this.constructor.toObject(this, a.util.toJSONOptions);
                }, t2;
              }(), o.TensorAnnotation = function() {
                function t2(t3) {
                  if (this.quantParameterTensorNames = [], t3)
                    for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                      null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
                }
                return t2.prototype.tensorName = "", t2.prototype.quantParameterTensorNames = c.emptyArray, t2.create = function(e2) {
                  return new t2(e2);
                }, t2.encode = function(t3, e2) {
                  if (e2 || (e2 = u.create()), null != t3.tensorName && t3.hasOwnProperty("tensorName") && e2.uint32(10).string(t3.tensorName), null != t3.quantParameterTensorNames && t3.quantParameterTensorNames.length)
                    for (var n2 = 0; n2 < t3.quantParameterTensorNames.length; ++n2)
                      l.onnx.StringStringEntryProto.encode(t3.quantParameterTensorNames[n2], e2.uint32(18).fork()).ldelim();
                  return e2;
                }, t2.encodeDelimited = function(t3, e2) {
                  return this.encode(t3, e2).ldelim();
                }, t2.decode = function(t3, e2) {
                  t3 instanceof s || (t3 = s.create(t3));
                  for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.TensorAnnotation(); t3.pos < n2; ) {
                    var i2 = t3.uint32();
                    switch (i2 >>> 3) {
                      case 1:
                        r2.tensorName = t3.string();
                        break;
                      case 2:
                        r2.quantParameterTensorNames && r2.quantParameterTensorNames.length || (r2.quantParameterTensorNames = []), r2.quantParameterTensorNames.push(l.onnx.StringStringEntryProto.decode(t3, t3.uint32()));
                        break;
                      default:
                        t3.skipType(7 & i2);
                    }
                  }
                  return r2;
                }, t2.decodeDelimited = function(t3) {
                  return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
                }, t2.verify = function(t3) {
                  if ("object" != typeof t3 || null === t3)
                    return "object expected";
                  if (null != t3.tensorName && t3.hasOwnProperty("tensorName") && !c.isString(t3.tensorName))
                    return "tensorName: string expected";
                  if (null != t3.quantParameterTensorNames && t3.hasOwnProperty("quantParameterTensorNames")) {
                    if (!Array.isArray(t3.quantParameterTensorNames))
                      return "quantParameterTensorNames: array expected";
                    for (var e2 = 0; e2 < t3.quantParameterTensorNames.length; ++e2) {
                      var n2 = l.onnx.StringStringEntryProto.verify(t3.quantParameterTensorNames[e2]);
                      if (n2)
                        return "quantParameterTensorNames." + n2;
                    }
                  }
                  return null;
                }, t2.fromObject = function(t3) {
                  if (t3 instanceof l.onnx.TensorAnnotation)
                    return t3;
                  var e2 = new l.onnx.TensorAnnotation();
                  if (null != t3.tensorName && (e2.tensorName = String(t3.tensorName)), t3.quantParameterTensorNames) {
                    if (!Array.isArray(t3.quantParameterTensorNames))
                      throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");
                    e2.quantParameterTensorNames = [];
                    for (var n2 = 0; n2 < t3.quantParameterTensorNames.length; ++n2) {
                      if ("object" != typeof t3.quantParameterTensorNames[n2])
                        throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");
                      e2.quantParameterTensorNames[n2] = l.onnx.StringStringEntryProto.fromObject(t3.quantParameterTensorNames[n2]);
                    }
                  }
                  return e2;
                }, t2.toObject = function(t3, e2) {
                  e2 || (e2 = {});
                  var n2 = {};
                  if ((e2.arrays || e2.defaults) && (n2.quantParameterTensorNames = []), e2.defaults && (n2.tensorName = ""), null != t3.tensorName && t3.hasOwnProperty("tensorName") && (n2.tensorName = t3.tensorName), t3.quantParameterTensorNames && t3.quantParameterTensorNames.length) {
                    n2.quantParameterTensorNames = [];
                    for (var r2 = 0; r2 < t3.quantParameterTensorNames.length; ++r2)
                      n2.quantParameterTensorNames[r2] = l.onnx.StringStringEntryProto.toObject(t3.quantParameterTensorNames[r2], e2);
                  }
                  return n2;
                }, t2.prototype.toJSON = function() {
                  return this.constructor.toObject(this, a.util.toJSONOptions);
                }, t2;
              }(), o.GraphProto = function() {
                function t2(t3) {
                  if (this.node = [], this.initializer = [], this.input = [], this.output = [], this.valueInfo = [], this.quantizationAnnotation = [], t3)
                    for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                      null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
                }
                return t2.prototype.node = c.emptyArray, t2.prototype.name = "", t2.prototype.initializer = c.emptyArray, t2.prototype.docString = "", t2.prototype.input = c.emptyArray, t2.prototype.output = c.emptyArray, t2.prototype.valueInfo = c.emptyArray, t2.prototype.quantizationAnnotation = c.emptyArray, t2.create = function(e2) {
                  return new t2(e2);
                }, t2.encode = function(t3, e2) {
                  if (e2 || (e2 = u.create()), null != t3.node && t3.node.length)
                    for (var n2 = 0; n2 < t3.node.length; ++n2)
                      l.onnx.NodeProto.encode(t3.node[n2], e2.uint32(10).fork()).ldelim();
                  if (null != t3.name && t3.hasOwnProperty("name") && e2.uint32(18).string(t3.name), null != t3.initializer && t3.initializer.length)
                    for (n2 = 0; n2 < t3.initializer.length; ++n2)
                      l.onnx.TensorProto.encode(t3.initializer[n2], e2.uint32(42).fork()).ldelim();
                  if (null != t3.docString && t3.hasOwnProperty("docString") && e2.uint32(82).string(t3.docString), null != t3.input && t3.input.length)
                    for (n2 = 0; n2 < t3.input.length; ++n2)
                      l.onnx.ValueInfoProto.encode(t3.input[n2], e2.uint32(90).fork()).ldelim();
                  if (null != t3.output && t3.output.length)
                    for (n2 = 0; n2 < t3.output.length; ++n2)
                      l.onnx.ValueInfoProto.encode(t3.output[n2], e2.uint32(98).fork()).ldelim();
                  if (null != t3.valueInfo && t3.valueInfo.length)
                    for (n2 = 0; n2 < t3.valueInfo.length; ++n2)
                      l.onnx.ValueInfoProto.encode(t3.valueInfo[n2], e2.uint32(106).fork()).ldelim();
                  if (null != t3.quantizationAnnotation && t3.quantizationAnnotation.length)
                    for (n2 = 0; n2 < t3.quantizationAnnotation.length; ++n2)
                      l.onnx.TensorAnnotation.encode(t3.quantizationAnnotation[n2], e2.uint32(114).fork()).ldelim();
                  return e2;
                }, t2.encodeDelimited = function(t3, e2) {
                  return this.encode(t3, e2).ldelim();
                }, t2.decode = function(t3, e2) {
                  t3 instanceof s || (t3 = s.create(t3));
                  for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.GraphProto(); t3.pos < n2; ) {
                    var i2 = t3.uint32();
                    switch (i2 >>> 3) {
                      case 1:
                        r2.node && r2.node.length || (r2.node = []), r2.node.push(l.onnx.NodeProto.decode(t3, t3.uint32()));
                        break;
                      case 2:
                        r2.name = t3.string();
                        break;
                      case 5:
                        r2.initializer && r2.initializer.length || (r2.initializer = []), r2.initializer.push(l.onnx.TensorProto.decode(t3, t3.uint32()));
                        break;
                      case 10:
                        r2.docString = t3.string();
                        break;
                      case 11:
                        r2.input && r2.input.length || (r2.input = []), r2.input.push(l.onnx.ValueInfoProto.decode(t3, t3.uint32()));
                        break;
                      case 12:
                        r2.output && r2.output.length || (r2.output = []), r2.output.push(l.onnx.ValueInfoProto.decode(t3, t3.uint32()));
                        break;
                      case 13:
                        r2.valueInfo && r2.valueInfo.length || (r2.valueInfo = []), r2.valueInfo.push(l.onnx.ValueInfoProto.decode(t3, t3.uint32()));
                        break;
                      case 14:
                        r2.quantizationAnnotation && r2.quantizationAnnotation.length || (r2.quantizationAnnotation = []), r2.quantizationAnnotation.push(l.onnx.TensorAnnotation.decode(t3, t3.uint32()));
                        break;
                      default:
                        t3.skipType(7 & i2);
                    }
                  }
                  return r2;
                }, t2.decodeDelimited = function(t3) {
                  return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
                }, t2.verify = function(t3) {
                  if ("object" != typeof t3 || null === t3)
                    return "object expected";
                  if (null != t3.node && t3.hasOwnProperty("node")) {
                    if (!Array.isArray(t3.node))
                      return "node: array expected";
                    for (var e2 = 0; e2 < t3.node.length; ++e2)
                      if (n2 = l.onnx.NodeProto.verify(t3.node[e2]))
                        return "node." + n2;
                  }
                  if (null != t3.name && t3.hasOwnProperty("name") && !c.isString(t3.name))
                    return "name: string expected";
                  if (null != t3.initializer && t3.hasOwnProperty("initializer")) {
                    if (!Array.isArray(t3.initializer))
                      return "initializer: array expected";
                    for (e2 = 0; e2 < t3.initializer.length; ++e2)
                      if (n2 = l.onnx.TensorProto.verify(t3.initializer[e2]))
                        return "initializer." + n2;
                  }
                  if (null != t3.docString && t3.hasOwnProperty("docString") && !c.isString(t3.docString))
                    return "docString: string expected";
                  if (null != t3.input && t3.hasOwnProperty("input")) {
                    if (!Array.isArray(t3.input))
                      return "input: array expected";
                    for (e2 = 0; e2 < t3.input.length; ++e2)
                      if (n2 = l.onnx.ValueInfoProto.verify(t3.input[e2]))
                        return "input." + n2;
                  }
                  if (null != t3.output && t3.hasOwnProperty("output")) {
                    if (!Array.isArray(t3.output))
                      return "output: array expected";
                    for (e2 = 0; e2 < t3.output.length; ++e2)
                      if (n2 = l.onnx.ValueInfoProto.verify(t3.output[e2]))
                        return "output." + n2;
                  }
                  if (null != t3.valueInfo && t3.hasOwnProperty("valueInfo")) {
                    if (!Array.isArray(t3.valueInfo))
                      return "valueInfo: array expected";
                    for (e2 = 0; e2 < t3.valueInfo.length; ++e2)
                      if (n2 = l.onnx.ValueInfoProto.verify(t3.valueInfo[e2]))
                        return "valueInfo." + n2;
                  }
                  if (null != t3.quantizationAnnotation && t3.hasOwnProperty("quantizationAnnotation")) {
                    if (!Array.isArray(t3.quantizationAnnotation))
                      return "quantizationAnnotation: array expected";
                    for (e2 = 0; e2 < t3.quantizationAnnotation.length; ++e2) {
                      var n2;
                      if (n2 = l.onnx.TensorAnnotation.verify(t3.quantizationAnnotation[e2]))
                        return "quantizationAnnotation." + n2;
                    }
                  }
                  return null;
                }, t2.fromObject = function(t3) {
                  if (t3 instanceof l.onnx.GraphProto)
                    return t3;
                  var e2 = new l.onnx.GraphProto();
                  if (t3.node) {
                    if (!Array.isArray(t3.node))
                      throw TypeError(".onnx.GraphProto.node: array expected");
                    e2.node = [];
                    for (var n2 = 0; n2 < t3.node.length; ++n2) {
                      if ("object" != typeof t3.node[n2])
                        throw TypeError(".onnx.GraphProto.node: object expected");
                      e2.node[n2] = l.onnx.NodeProto.fromObject(t3.node[n2]);
                    }
                  }
                  if (null != t3.name && (e2.name = String(t3.name)), t3.initializer) {
                    if (!Array.isArray(t3.initializer))
                      throw TypeError(".onnx.GraphProto.initializer: array expected");
                    for (e2.initializer = [], n2 = 0; n2 < t3.initializer.length; ++n2) {
                      if ("object" != typeof t3.initializer[n2])
                        throw TypeError(".onnx.GraphProto.initializer: object expected");
                      e2.initializer[n2] = l.onnx.TensorProto.fromObject(t3.initializer[n2]);
                    }
                  }
                  if (null != t3.docString && (e2.docString = String(t3.docString)), t3.input) {
                    if (!Array.isArray(t3.input))
                      throw TypeError(".onnx.GraphProto.input: array expected");
                    for (e2.input = [], n2 = 0; n2 < t3.input.length; ++n2) {
                      if ("object" != typeof t3.input[n2])
                        throw TypeError(".onnx.GraphProto.input: object expected");
                      e2.input[n2] = l.onnx.ValueInfoProto.fromObject(t3.input[n2]);
                    }
                  }
                  if (t3.output) {
                    if (!Array.isArray(t3.output))
                      throw TypeError(".onnx.GraphProto.output: array expected");
                    for (e2.output = [], n2 = 0; n2 < t3.output.length; ++n2) {
                      if ("object" != typeof t3.output[n2])
                        throw TypeError(".onnx.GraphProto.output: object expected");
                      e2.output[n2] = l.onnx.ValueInfoProto.fromObject(t3.output[n2]);
                    }
                  }
                  if (t3.valueInfo) {
                    if (!Array.isArray(t3.valueInfo))
                      throw TypeError(".onnx.GraphProto.valueInfo: array expected");
                    for (e2.valueInfo = [], n2 = 0; n2 < t3.valueInfo.length; ++n2) {
                      if ("object" != typeof t3.valueInfo[n2])
                        throw TypeError(".onnx.GraphProto.valueInfo: object expected");
                      e2.valueInfo[n2] = l.onnx.ValueInfoProto.fromObject(t3.valueInfo[n2]);
                    }
                  }
                  if (t3.quantizationAnnotation) {
                    if (!Array.isArray(t3.quantizationAnnotation))
                      throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");
                    for (e2.quantizationAnnotation = [], n2 = 0; n2 < t3.quantizationAnnotation.length; ++n2) {
                      if ("object" != typeof t3.quantizationAnnotation[n2])
                        throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");
                      e2.quantizationAnnotation[n2] = l.onnx.TensorAnnotation.fromObject(t3.quantizationAnnotation[n2]);
                    }
                  }
                  return e2;
                }, t2.toObject = function(t3, e2) {
                  e2 || (e2 = {});
                  var n2 = {};
                  if ((e2.arrays || e2.defaults) && (n2.node = [], n2.initializer = [], n2.input = [], n2.output = [], n2.valueInfo = [], n2.quantizationAnnotation = []), e2.defaults && (n2.name = "", n2.docString = ""), t3.node && t3.node.length) {
                    n2.node = [];
                    for (var r2 = 0; r2 < t3.node.length; ++r2)
                      n2.node[r2] = l.onnx.NodeProto.toObject(t3.node[r2], e2);
                  }
                  if (null != t3.name && t3.hasOwnProperty("name") && (n2.name = t3.name), t3.initializer && t3.initializer.length)
                    for (n2.initializer = [], r2 = 0; r2 < t3.initializer.length; ++r2)
                      n2.initializer[r2] = l.onnx.TensorProto.toObject(t3.initializer[r2], e2);
                  if (null != t3.docString && t3.hasOwnProperty("docString") && (n2.docString = t3.docString), t3.input && t3.input.length)
                    for (n2.input = [], r2 = 0; r2 < t3.input.length; ++r2)
                      n2.input[r2] = l.onnx.ValueInfoProto.toObject(t3.input[r2], e2);
                  if (t3.output && t3.output.length)
                    for (n2.output = [], r2 = 0; r2 < t3.output.length; ++r2)
                      n2.output[r2] = l.onnx.ValueInfoProto.toObject(t3.output[r2], e2);
                  if (t3.valueInfo && t3.valueInfo.length)
                    for (n2.valueInfo = [], r2 = 0; r2 < t3.valueInfo.length; ++r2)
                      n2.valueInfo[r2] = l.onnx.ValueInfoProto.toObject(t3.valueInfo[r2], e2);
                  if (t3.quantizationAnnotation && t3.quantizationAnnotation.length)
                    for (n2.quantizationAnnotation = [], r2 = 0; r2 < t3.quantizationAnnotation.length; ++r2)
                      n2.quantizationAnnotation[r2] = l.onnx.TensorAnnotation.toObject(t3.quantizationAnnotation[r2], e2);
                  return n2;
                }, t2.prototype.toJSON = function() {
                  return this.constructor.toObject(this, a.util.toJSONOptions);
                }, t2;
              }(), o.TensorProto = function() {
                function t2(t3) {
                  if (this.dims = [], this.floatData = [], this.int32Data = [], this.stringData = [], this.int64Data = [], this.externalData = [], this.doubleData = [], this.uint64Data = [], t3)
                    for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                      null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
                }
                return t2.prototype.dims = c.emptyArray, t2.prototype.dataType = 0, t2.prototype.segment = null, t2.prototype.floatData = c.emptyArray, t2.prototype.int32Data = c.emptyArray, t2.prototype.stringData = c.emptyArray, t2.prototype.int64Data = c.emptyArray, t2.prototype.name = "", t2.prototype.docString = "", t2.prototype.rawData = c.newBuffer([]), t2.prototype.externalData = c.emptyArray, t2.prototype.dataLocation = 0, t2.prototype.doubleData = c.emptyArray, t2.prototype.uint64Data = c.emptyArray, t2.create = function(e2) {
                  return new t2(e2);
                }, t2.encode = function(t3, e2) {
                  if (e2 || (e2 = u.create()), null != t3.dims && t3.dims.length) {
                    e2.uint32(10).fork();
                    for (var n2 = 0; n2 < t3.dims.length; ++n2)
                      e2.int64(t3.dims[n2]);
                    e2.ldelim();
                  }
                  if (null != t3.dataType && t3.hasOwnProperty("dataType") && e2.uint32(16).int32(t3.dataType), null != t3.segment && t3.hasOwnProperty("segment") && l.onnx.TensorProto.Segment.encode(t3.segment, e2.uint32(26).fork()).ldelim(), null != t3.floatData && t3.floatData.length) {
                    for (e2.uint32(34).fork(), n2 = 0; n2 < t3.floatData.length; ++n2)
                      e2.float(t3.floatData[n2]);
                    e2.ldelim();
                  }
                  if (null != t3.int32Data && t3.int32Data.length) {
                    for (e2.uint32(42).fork(), n2 = 0; n2 < t3.int32Data.length; ++n2)
                      e2.int32(t3.int32Data[n2]);
                    e2.ldelim();
                  }
                  if (null != t3.stringData && t3.stringData.length)
                    for (n2 = 0; n2 < t3.stringData.length; ++n2)
                      e2.uint32(50).bytes(t3.stringData[n2]);
                  if (null != t3.int64Data && t3.int64Data.length) {
                    for (e2.uint32(58).fork(), n2 = 0; n2 < t3.int64Data.length; ++n2)
                      e2.int64(t3.int64Data[n2]);
                    e2.ldelim();
                  }
                  if (null != t3.name && t3.hasOwnProperty("name") && e2.uint32(66).string(t3.name), null != t3.rawData && t3.hasOwnProperty("rawData") && e2.uint32(74).bytes(t3.rawData), null != t3.doubleData && t3.doubleData.length) {
                    for (e2.uint32(82).fork(), n2 = 0; n2 < t3.doubleData.length; ++n2)
                      e2.double(t3.doubleData[n2]);
                    e2.ldelim();
                  }
                  if (null != t3.uint64Data && t3.uint64Data.length) {
                    for (e2.uint32(90).fork(), n2 = 0; n2 < t3.uint64Data.length; ++n2)
                      e2.uint64(t3.uint64Data[n2]);
                    e2.ldelim();
                  }
                  if (null != t3.docString && t3.hasOwnProperty("docString") && e2.uint32(98).string(t3.docString), null != t3.externalData && t3.externalData.length)
                    for (n2 = 0; n2 < t3.externalData.length; ++n2)
                      l.onnx.StringStringEntryProto.encode(t3.externalData[n2], e2.uint32(106).fork()).ldelim();
                  return null != t3.dataLocation && t3.hasOwnProperty("dataLocation") && e2.uint32(112).int32(t3.dataLocation), e2;
                }, t2.encodeDelimited = function(t3, e2) {
                  return this.encode(t3, e2).ldelim();
                }, t2.decode = function(t3, e2) {
                  t3 instanceof s || (t3 = s.create(t3));
                  for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.TensorProto(); t3.pos < n2; ) {
                    var i2 = t3.uint32();
                    switch (i2 >>> 3) {
                      case 1:
                        if (r2.dims && r2.dims.length || (r2.dims = []), 2 == (7 & i2))
                          for (var o2 = t3.uint32() + t3.pos; t3.pos < o2; )
                            r2.dims.push(t3.int64());
                        else
                          r2.dims.push(t3.int64());
                        break;
                      case 2:
                        r2.dataType = t3.int32();
                        break;
                      case 3:
                        r2.segment = l.onnx.TensorProto.Segment.decode(t3, t3.uint32());
                        break;
                      case 4:
                        if (r2.floatData && r2.floatData.length || (r2.floatData = []), 2 == (7 & i2))
                          for (o2 = t3.uint32() + t3.pos; t3.pos < o2; )
                            r2.floatData.push(t3.float());
                        else
                          r2.floatData.push(t3.float());
                        break;
                      case 5:
                        if (r2.int32Data && r2.int32Data.length || (r2.int32Data = []), 2 == (7 & i2))
                          for (o2 = t3.uint32() + t3.pos; t3.pos < o2; )
                            r2.int32Data.push(t3.int32());
                        else
                          r2.int32Data.push(t3.int32());
                        break;
                      case 6:
                        r2.stringData && r2.stringData.length || (r2.stringData = []), r2.stringData.push(t3.bytes());
                        break;
                      case 7:
                        if (r2.int64Data && r2.int64Data.length || (r2.int64Data = []), 2 == (7 & i2))
                          for (o2 = t3.uint32() + t3.pos; t3.pos < o2; )
                            r2.int64Data.push(t3.int64());
                        else
                          r2.int64Data.push(t3.int64());
                        break;
                      case 8:
                        r2.name = t3.string();
                        break;
                      case 12:
                        r2.docString = t3.string();
                        break;
                      case 9:
                        r2.rawData = t3.bytes();
                        break;
                      case 13:
                        r2.externalData && r2.externalData.length || (r2.externalData = []), r2.externalData.push(l.onnx.StringStringEntryProto.decode(t3, t3.uint32()));
                        break;
                      case 14:
                        r2.dataLocation = t3.int32();
                        break;
                      case 10:
                        if (r2.doubleData && r2.doubleData.length || (r2.doubleData = []), 2 == (7 & i2))
                          for (o2 = t3.uint32() + t3.pos; t3.pos < o2; )
                            r2.doubleData.push(t3.double());
                        else
                          r2.doubleData.push(t3.double());
                        break;
                      case 11:
                        if (r2.uint64Data && r2.uint64Data.length || (r2.uint64Data = []), 2 == (7 & i2))
                          for (o2 = t3.uint32() + t3.pos; t3.pos < o2; )
                            r2.uint64Data.push(t3.uint64());
                        else
                          r2.uint64Data.push(t3.uint64());
                        break;
                      default:
                        t3.skipType(7 & i2);
                    }
                  }
                  return r2;
                }, t2.decodeDelimited = function(t3) {
                  return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
                }, t2.verify = function(t3) {
                  if ("object" != typeof t3 || null === t3)
                    return "object expected";
                  if (null != t3.dims && t3.hasOwnProperty("dims")) {
                    if (!Array.isArray(t3.dims))
                      return "dims: array expected";
                    for (var e2 = 0; e2 < t3.dims.length; ++e2)
                      if (!(c.isInteger(t3.dims[e2]) || t3.dims[e2] && c.isInteger(t3.dims[e2].low) && c.isInteger(t3.dims[e2].high)))
                        return "dims: integer|Long[] expected";
                  }
                  if (null != t3.dataType && t3.hasOwnProperty("dataType") && !c.isInteger(t3.dataType))
                    return "dataType: integer expected";
                  if (null != t3.segment && t3.hasOwnProperty("segment") && (n2 = l.onnx.TensorProto.Segment.verify(t3.segment)))
                    return "segment." + n2;
                  if (null != t3.floatData && t3.hasOwnProperty("floatData")) {
                    if (!Array.isArray(t3.floatData))
                      return "floatData: array expected";
                    for (e2 = 0; e2 < t3.floatData.length; ++e2)
                      if ("number" != typeof t3.floatData[e2])
                        return "floatData: number[] expected";
                  }
                  if (null != t3.int32Data && t3.hasOwnProperty("int32Data")) {
                    if (!Array.isArray(t3.int32Data))
                      return "int32Data: array expected";
                    for (e2 = 0; e2 < t3.int32Data.length; ++e2)
                      if (!c.isInteger(t3.int32Data[e2]))
                        return "int32Data: integer[] expected";
                  }
                  if (null != t3.stringData && t3.hasOwnProperty("stringData")) {
                    if (!Array.isArray(t3.stringData))
                      return "stringData: array expected";
                    for (e2 = 0; e2 < t3.stringData.length; ++e2)
                      if (!(t3.stringData[e2] && "number" == typeof t3.stringData[e2].length || c.isString(t3.stringData[e2])))
                        return "stringData: buffer[] expected";
                  }
                  if (null != t3.int64Data && t3.hasOwnProperty("int64Data")) {
                    if (!Array.isArray(t3.int64Data))
                      return "int64Data: array expected";
                    for (e2 = 0; e2 < t3.int64Data.length; ++e2)
                      if (!(c.isInteger(t3.int64Data[e2]) || t3.int64Data[e2] && c.isInteger(t3.int64Data[e2].low) && c.isInteger(t3.int64Data[e2].high)))
                        return "int64Data: integer|Long[] expected";
                  }
                  if (null != t3.name && t3.hasOwnProperty("name") && !c.isString(t3.name))
                    return "name: string expected";
                  if (null != t3.docString && t3.hasOwnProperty("docString") && !c.isString(t3.docString))
                    return "docString: string expected";
                  if (null != t3.rawData && t3.hasOwnProperty("rawData") && !(t3.rawData && "number" == typeof t3.rawData.length || c.isString(t3.rawData)))
                    return "rawData: buffer expected";
                  if (null != t3.externalData && t3.hasOwnProperty("externalData")) {
                    if (!Array.isArray(t3.externalData))
                      return "externalData: array expected";
                    for (e2 = 0; e2 < t3.externalData.length; ++e2) {
                      var n2;
                      if (n2 = l.onnx.StringStringEntryProto.verify(t3.externalData[e2]))
                        return "externalData." + n2;
                    }
                  }
                  if (null != t3.dataLocation && t3.hasOwnProperty("dataLocation"))
                    switch (t3.dataLocation) {
                      default:
                        return "dataLocation: enum value expected";
                      case 0:
                      case 1:
                    }
                  if (null != t3.doubleData && t3.hasOwnProperty("doubleData")) {
                    if (!Array.isArray(t3.doubleData))
                      return "doubleData: array expected";
                    for (e2 = 0; e2 < t3.doubleData.length; ++e2)
                      if ("number" != typeof t3.doubleData[e2])
                        return "doubleData: number[] expected";
                  }
                  if (null != t3.uint64Data && t3.hasOwnProperty("uint64Data")) {
                    if (!Array.isArray(t3.uint64Data))
                      return "uint64Data: array expected";
                    for (e2 = 0; e2 < t3.uint64Data.length; ++e2)
                      if (!(c.isInteger(t3.uint64Data[e2]) || t3.uint64Data[e2] && c.isInteger(t3.uint64Data[e2].low) && c.isInteger(t3.uint64Data[e2].high)))
                        return "uint64Data: integer|Long[] expected";
                  }
                  return null;
                }, t2.fromObject = function(t3) {
                  if (t3 instanceof l.onnx.TensorProto)
                    return t3;
                  var e2 = new l.onnx.TensorProto();
                  if (t3.dims) {
                    if (!Array.isArray(t3.dims))
                      throw TypeError(".onnx.TensorProto.dims: array expected");
                    e2.dims = [];
                    for (var n2 = 0; n2 < t3.dims.length; ++n2)
                      c.Long ? (e2.dims[n2] = c.Long.fromValue(t3.dims[n2])).unsigned = false : "string" == typeof t3.dims[n2] ? e2.dims[n2] = parseInt(t3.dims[n2], 10) : "number" == typeof t3.dims[n2] ? e2.dims[n2] = t3.dims[n2] : "object" == typeof t3.dims[n2] && (e2.dims[n2] = new c.LongBits(t3.dims[n2].low >>> 0, t3.dims[n2].high >>> 0).toNumber());
                  }
                  if (null != t3.dataType && (e2.dataType = 0 | t3.dataType), null != t3.segment) {
                    if ("object" != typeof t3.segment)
                      throw TypeError(".onnx.TensorProto.segment: object expected");
                    e2.segment = l.onnx.TensorProto.Segment.fromObject(t3.segment);
                  }
                  if (t3.floatData) {
                    if (!Array.isArray(t3.floatData))
                      throw TypeError(".onnx.TensorProto.floatData: array expected");
                    for (e2.floatData = [], n2 = 0; n2 < t3.floatData.length; ++n2)
                      e2.floatData[n2] = Number(t3.floatData[n2]);
                  }
                  if (t3.int32Data) {
                    if (!Array.isArray(t3.int32Data))
                      throw TypeError(".onnx.TensorProto.int32Data: array expected");
                    for (e2.int32Data = [], n2 = 0; n2 < t3.int32Data.length; ++n2)
                      e2.int32Data[n2] = 0 | t3.int32Data[n2];
                  }
                  if (t3.stringData) {
                    if (!Array.isArray(t3.stringData))
                      throw TypeError(".onnx.TensorProto.stringData: array expected");
                    for (e2.stringData = [], n2 = 0; n2 < t3.stringData.length; ++n2)
                      "string" == typeof t3.stringData[n2] ? c.base64.decode(t3.stringData[n2], e2.stringData[n2] = c.newBuffer(c.base64.length(t3.stringData[n2])), 0) : t3.stringData[n2].length && (e2.stringData[n2] = t3.stringData[n2]);
                  }
                  if (t3.int64Data) {
                    if (!Array.isArray(t3.int64Data))
                      throw TypeError(".onnx.TensorProto.int64Data: array expected");
                    for (e2.int64Data = [], n2 = 0; n2 < t3.int64Data.length; ++n2)
                      c.Long ? (e2.int64Data[n2] = c.Long.fromValue(t3.int64Data[n2])).unsigned = false : "string" == typeof t3.int64Data[n2] ? e2.int64Data[n2] = parseInt(t3.int64Data[n2], 10) : "number" == typeof t3.int64Data[n2] ? e2.int64Data[n2] = t3.int64Data[n2] : "object" == typeof t3.int64Data[n2] && (e2.int64Data[n2] = new c.LongBits(t3.int64Data[n2].low >>> 0, t3.int64Data[n2].high >>> 0).toNumber());
                  }
                  if (null != t3.name && (e2.name = String(t3.name)), null != t3.docString && (e2.docString = String(t3.docString)), null != t3.rawData && ("string" == typeof t3.rawData ? c.base64.decode(t3.rawData, e2.rawData = c.newBuffer(c.base64.length(t3.rawData)), 0) : t3.rawData.length && (e2.rawData = t3.rawData)), t3.externalData) {
                    if (!Array.isArray(t3.externalData))
                      throw TypeError(".onnx.TensorProto.externalData: array expected");
                    for (e2.externalData = [], n2 = 0; n2 < t3.externalData.length; ++n2) {
                      if ("object" != typeof t3.externalData[n2])
                        throw TypeError(".onnx.TensorProto.externalData: object expected");
                      e2.externalData[n2] = l.onnx.StringStringEntryProto.fromObject(t3.externalData[n2]);
                    }
                  }
                  switch (t3.dataLocation) {
                    case "DEFAULT":
                    case 0:
                      e2.dataLocation = 0;
                      break;
                    case "EXTERNAL":
                    case 1:
                      e2.dataLocation = 1;
                  }
                  if (t3.doubleData) {
                    if (!Array.isArray(t3.doubleData))
                      throw TypeError(".onnx.TensorProto.doubleData: array expected");
                    for (e2.doubleData = [], n2 = 0; n2 < t3.doubleData.length; ++n2)
                      e2.doubleData[n2] = Number(t3.doubleData[n2]);
                  }
                  if (t3.uint64Data) {
                    if (!Array.isArray(t3.uint64Data))
                      throw TypeError(".onnx.TensorProto.uint64Data: array expected");
                    for (e2.uint64Data = [], n2 = 0; n2 < t3.uint64Data.length; ++n2)
                      c.Long ? (e2.uint64Data[n2] = c.Long.fromValue(t3.uint64Data[n2])).unsigned = true : "string" == typeof t3.uint64Data[n2] ? e2.uint64Data[n2] = parseInt(t3.uint64Data[n2], 10) : "number" == typeof t3.uint64Data[n2] ? e2.uint64Data[n2] = t3.uint64Data[n2] : "object" == typeof t3.uint64Data[n2] && (e2.uint64Data[n2] = new c.LongBits(t3.uint64Data[n2].low >>> 0, t3.uint64Data[n2].high >>> 0).toNumber(true));
                  }
                  return e2;
                }, t2.toObject = function(t3, e2) {
                  e2 || (e2 = {});
                  var n2 = {};
                  if ((e2.arrays || e2.defaults) && (n2.dims = [], n2.floatData = [], n2.int32Data = [], n2.stringData = [], n2.int64Data = [], n2.doubleData = [], n2.uint64Data = [], n2.externalData = []), e2.defaults && (n2.dataType = 0, n2.segment = null, n2.name = "", e2.bytes === String ? n2.rawData = "" : (n2.rawData = [], e2.bytes !== Array && (n2.rawData = c.newBuffer(n2.rawData))), n2.docString = "", n2.dataLocation = e2.enums === String ? "DEFAULT" : 0), t3.dims && t3.dims.length) {
                    n2.dims = [];
                    for (var r2 = 0; r2 < t3.dims.length; ++r2)
                      "number" == typeof t3.dims[r2] ? n2.dims[r2] = e2.longs === String ? String(t3.dims[r2]) : t3.dims[r2] : n2.dims[r2] = e2.longs === String ? c.Long.prototype.toString.call(t3.dims[r2]) : e2.longs === Number ? new c.LongBits(t3.dims[r2].low >>> 0, t3.dims[r2].high >>> 0).toNumber() : t3.dims[r2];
                  }
                  if (null != t3.dataType && t3.hasOwnProperty("dataType") && (n2.dataType = t3.dataType), null != t3.segment && t3.hasOwnProperty("segment") && (n2.segment = l.onnx.TensorProto.Segment.toObject(t3.segment, e2)), t3.floatData && t3.floatData.length)
                    for (n2.floatData = [], r2 = 0; r2 < t3.floatData.length; ++r2)
                      n2.floatData[r2] = e2.json && !isFinite(t3.floatData[r2]) ? String(t3.floatData[r2]) : t3.floatData[r2];
                  if (t3.int32Data && t3.int32Data.length)
                    for (n2.int32Data = [], r2 = 0; r2 < t3.int32Data.length; ++r2)
                      n2.int32Data[r2] = t3.int32Data[r2];
                  if (t3.stringData && t3.stringData.length)
                    for (n2.stringData = [], r2 = 0; r2 < t3.stringData.length; ++r2)
                      n2.stringData[r2] = e2.bytes === String ? c.base64.encode(t3.stringData[r2], 0, t3.stringData[r2].length) : e2.bytes === Array ? Array.prototype.slice.call(t3.stringData[r2]) : t3.stringData[r2];
                  if (t3.int64Data && t3.int64Data.length)
                    for (n2.int64Data = [], r2 = 0; r2 < t3.int64Data.length; ++r2)
                      "number" == typeof t3.int64Data[r2] ? n2.int64Data[r2] = e2.longs === String ? String(t3.int64Data[r2]) : t3.int64Data[r2] : n2.int64Data[r2] = e2.longs === String ? c.Long.prototype.toString.call(t3.int64Data[r2]) : e2.longs === Number ? new c.LongBits(t3.int64Data[r2].low >>> 0, t3.int64Data[r2].high >>> 0).toNumber() : t3.int64Data[r2];
                  if (null != t3.name && t3.hasOwnProperty("name") && (n2.name = t3.name), null != t3.rawData && t3.hasOwnProperty("rawData") && (n2.rawData = e2.bytes === String ? c.base64.encode(t3.rawData, 0, t3.rawData.length) : e2.bytes === Array ? Array.prototype.slice.call(t3.rawData) : t3.rawData), t3.doubleData && t3.doubleData.length)
                    for (n2.doubleData = [], r2 = 0; r2 < t3.doubleData.length; ++r2)
                      n2.doubleData[r2] = e2.json && !isFinite(t3.doubleData[r2]) ? String(t3.doubleData[r2]) : t3.doubleData[r2];
                  if (t3.uint64Data && t3.uint64Data.length)
                    for (n2.uint64Data = [], r2 = 0; r2 < t3.uint64Data.length; ++r2)
                      "number" == typeof t3.uint64Data[r2] ? n2.uint64Data[r2] = e2.longs === String ? String(t3.uint64Data[r2]) : t3.uint64Data[r2] : n2.uint64Data[r2] = e2.longs === String ? c.Long.prototype.toString.call(t3.uint64Data[r2]) : e2.longs === Number ? new c.LongBits(t3.uint64Data[r2].low >>> 0, t3.uint64Data[r2].high >>> 0).toNumber(true) : t3.uint64Data[r2];
                  if (null != t3.docString && t3.hasOwnProperty("docString") && (n2.docString = t3.docString), t3.externalData && t3.externalData.length)
                    for (n2.externalData = [], r2 = 0; r2 < t3.externalData.length; ++r2)
                      n2.externalData[r2] = l.onnx.StringStringEntryProto.toObject(t3.externalData[r2], e2);
                  return null != t3.dataLocation && t3.hasOwnProperty("dataLocation") && (n2.dataLocation = e2.enums === String ? l.onnx.TensorProto.DataLocation[t3.dataLocation] : t3.dataLocation), n2;
                }, t2.prototype.toJSON = function() {
                  return this.constructor.toObject(this, a.util.toJSONOptions);
                }, t2.DataType = function() {
                  var t3 = {}, e2 = Object.create(t3);
                  return e2[t3[0] = "UNDEFINED"] = 0, e2[t3[1] = "FLOAT"] = 1, e2[t3[2] = "UINT8"] = 2, e2[t3[3] = "INT8"] = 3, e2[t3[4] = "UINT16"] = 4, e2[t3[5] = "INT16"] = 5, e2[t3[6] = "INT32"] = 6, e2[t3[7] = "INT64"] = 7, e2[t3[8] = "STRING"] = 8, e2[t3[9] = "BOOL"] = 9, e2[t3[10] = "FLOAT16"] = 10, e2[t3[11] = "DOUBLE"] = 11, e2[t3[12] = "UINT32"] = 12, e2[t3[13] = "UINT64"] = 13, e2[t3[14] = "COMPLEX64"] = 14, e2[t3[15] = "COMPLEX128"] = 15, e2[t3[16] = "BFLOAT16"] = 16, e2;
                }(), t2.Segment = function() {
                  function t3(t4) {
                    if (t4)
                      for (var e2 = Object.keys(t4), n2 = 0; n2 < e2.length; ++n2)
                        null != t4[e2[n2]] && (this[e2[n2]] = t4[e2[n2]]);
                  }
                  return t3.prototype.begin = c.Long ? c.Long.fromBits(0, 0, false) : 0, t3.prototype.end = c.Long ? c.Long.fromBits(0, 0, false) : 0, t3.create = function(e2) {
                    return new t3(e2);
                  }, t3.encode = function(t4, e2) {
                    return e2 || (e2 = u.create()), null != t4.begin && t4.hasOwnProperty("begin") && e2.uint32(8).int64(t4.begin), null != t4.end && t4.hasOwnProperty("end") && e2.uint32(16).int64(t4.end), e2;
                  }, t3.encodeDelimited = function(t4, e2) {
                    return this.encode(t4, e2).ldelim();
                  }, t3.decode = function(t4, e2) {
                    t4 instanceof s || (t4 = s.create(t4));
                    for (var n2 = void 0 === e2 ? t4.len : t4.pos + e2, r2 = new l.onnx.TensorProto.Segment(); t4.pos < n2; ) {
                      var i2 = t4.uint32();
                      switch (i2 >>> 3) {
                        case 1:
                          r2.begin = t4.int64();
                          break;
                        case 2:
                          r2.end = t4.int64();
                          break;
                        default:
                          t4.skipType(7 & i2);
                      }
                    }
                    return r2;
                  }, t3.decodeDelimited = function(t4) {
                    return t4 instanceof s || (t4 = new s(t4)), this.decode(t4, t4.uint32());
                  }, t3.verify = function(t4) {
                    return "object" != typeof t4 || null === t4 ? "object expected" : null != t4.begin && t4.hasOwnProperty("begin") && !(c.isInteger(t4.begin) || t4.begin && c.isInteger(t4.begin.low) && c.isInteger(t4.begin.high)) ? "begin: integer|Long expected" : null != t4.end && t4.hasOwnProperty("end") && !(c.isInteger(t4.end) || t4.end && c.isInteger(t4.end.low) && c.isInteger(t4.end.high)) ? "end: integer|Long expected" : null;
                  }, t3.fromObject = function(t4) {
                    if (t4 instanceof l.onnx.TensorProto.Segment)
                      return t4;
                    var e2 = new l.onnx.TensorProto.Segment();
                    return null != t4.begin && (c.Long ? (e2.begin = c.Long.fromValue(t4.begin)).unsigned = false : "string" == typeof t4.begin ? e2.begin = parseInt(t4.begin, 10) : "number" == typeof t4.begin ? e2.begin = t4.begin : "object" == typeof t4.begin && (e2.begin = new c.LongBits(t4.begin.low >>> 0, t4.begin.high >>> 0).toNumber())), null != t4.end && (c.Long ? (e2.end = c.Long.fromValue(t4.end)).unsigned = false : "string" == typeof t4.end ? e2.end = parseInt(t4.end, 10) : "number" == typeof t4.end ? e2.end = t4.end : "object" == typeof t4.end && (e2.end = new c.LongBits(t4.end.low >>> 0, t4.end.high >>> 0).toNumber())), e2;
                  }, t3.toObject = function(t4, e2) {
                    e2 || (e2 = {});
                    var n2 = {};
                    if (e2.defaults) {
                      if (c.Long) {
                        var r2 = new c.Long(0, 0, false);
                        n2.begin = e2.longs === String ? r2.toString() : e2.longs === Number ? r2.toNumber() : r2;
                      } else
                        n2.begin = e2.longs === String ? "0" : 0;
                      c.Long ? (r2 = new c.Long(0, 0, false), n2.end = e2.longs === String ? r2.toString() : e2.longs === Number ? r2.toNumber() : r2) : n2.end = e2.longs === String ? "0" : 0;
                    }
                    return null != t4.begin && t4.hasOwnProperty("begin") && ("number" == typeof t4.begin ? n2.begin = e2.longs === String ? String(t4.begin) : t4.begin : n2.begin = e2.longs === String ? c.Long.prototype.toString.call(t4.begin) : e2.longs === Number ? new c.LongBits(t4.begin.low >>> 0, t4.begin.high >>> 0).toNumber() : t4.begin), null != t4.end && t4.hasOwnProperty("end") && ("number" == typeof t4.end ? n2.end = e2.longs === String ? String(t4.end) : t4.end : n2.end = e2.longs === String ? c.Long.prototype.toString.call(t4.end) : e2.longs === Number ? new c.LongBits(t4.end.low >>> 0, t4.end.high >>> 0).toNumber() : t4.end), n2;
                  }, t3.prototype.toJSON = function() {
                    return this.constructor.toObject(this, a.util.toJSONOptions);
                  }, t3;
                }(), t2.DataLocation = function() {
                  var t3 = {}, e2 = Object.create(t3);
                  return e2[t3[0] = "DEFAULT"] = 0, e2[t3[1] = "EXTERNAL"] = 1, e2;
                }(), t2;
              }(), o.TensorShapeProto = function() {
                function t2(t3) {
                  if (this.dim = [], t3)
                    for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                      null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
                }
                return t2.prototype.dim = c.emptyArray, t2.create = function(e2) {
                  return new t2(e2);
                }, t2.encode = function(t3, e2) {
                  if (e2 || (e2 = u.create()), null != t3.dim && t3.dim.length)
                    for (var n2 = 0; n2 < t3.dim.length; ++n2)
                      l.onnx.TensorShapeProto.Dimension.encode(t3.dim[n2], e2.uint32(10).fork()).ldelim();
                  return e2;
                }, t2.encodeDelimited = function(t3, e2) {
                  return this.encode(t3, e2).ldelim();
                }, t2.decode = function(t3, e2) {
                  t3 instanceof s || (t3 = s.create(t3));
                  for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.TensorShapeProto(); t3.pos < n2; ) {
                    var i2 = t3.uint32();
                    i2 >>> 3 == 1 ? (r2.dim && r2.dim.length || (r2.dim = []), r2.dim.push(l.onnx.TensorShapeProto.Dimension.decode(t3, t3.uint32()))) : t3.skipType(7 & i2);
                  }
                  return r2;
                }, t2.decodeDelimited = function(t3) {
                  return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
                }, t2.verify = function(t3) {
                  if ("object" != typeof t3 || null === t3)
                    return "object expected";
                  if (null != t3.dim && t3.hasOwnProperty("dim")) {
                    if (!Array.isArray(t3.dim))
                      return "dim: array expected";
                    for (var e2 = 0; e2 < t3.dim.length; ++e2) {
                      var n2 = l.onnx.TensorShapeProto.Dimension.verify(t3.dim[e2]);
                      if (n2)
                        return "dim." + n2;
                    }
                  }
                  return null;
                }, t2.fromObject = function(t3) {
                  if (t3 instanceof l.onnx.TensorShapeProto)
                    return t3;
                  var e2 = new l.onnx.TensorShapeProto();
                  if (t3.dim) {
                    if (!Array.isArray(t3.dim))
                      throw TypeError(".onnx.TensorShapeProto.dim: array expected");
                    e2.dim = [];
                    for (var n2 = 0; n2 < t3.dim.length; ++n2) {
                      if ("object" != typeof t3.dim[n2])
                        throw TypeError(".onnx.TensorShapeProto.dim: object expected");
                      e2.dim[n2] = l.onnx.TensorShapeProto.Dimension.fromObject(t3.dim[n2]);
                    }
                  }
                  return e2;
                }, t2.toObject = function(t3, e2) {
                  e2 || (e2 = {});
                  var n2 = {};
                  if ((e2.arrays || e2.defaults) && (n2.dim = []), t3.dim && t3.dim.length) {
                    n2.dim = [];
                    for (var r2 = 0; r2 < t3.dim.length; ++r2)
                      n2.dim[r2] = l.onnx.TensorShapeProto.Dimension.toObject(t3.dim[r2], e2);
                  }
                  return n2;
                }, t2.prototype.toJSON = function() {
                  return this.constructor.toObject(this, a.util.toJSONOptions);
                }, t2.Dimension = function() {
                  function t3(t4) {
                    if (t4)
                      for (var e3 = Object.keys(t4), n2 = 0; n2 < e3.length; ++n2)
                        null != t4[e3[n2]] && (this[e3[n2]] = t4[e3[n2]]);
                  }
                  var e2;
                  return t3.prototype.dimValue = c.Long ? c.Long.fromBits(0, 0, false) : 0, t3.prototype.dimParam = "", t3.prototype.denotation = "", Object.defineProperty(t3.prototype, "value", { get: c.oneOfGetter(e2 = ["dimValue", "dimParam"]), set: c.oneOfSetter(e2) }), t3.create = function(e3) {
                    return new t3(e3);
                  }, t3.encode = function(t4, e3) {
                    return e3 || (e3 = u.create()), null != t4.dimValue && t4.hasOwnProperty("dimValue") && e3.uint32(8).int64(t4.dimValue), null != t4.dimParam && t4.hasOwnProperty("dimParam") && e3.uint32(18).string(t4.dimParam), null != t4.denotation && t4.hasOwnProperty("denotation") && e3.uint32(26).string(t4.denotation), e3;
                  }, t3.encodeDelimited = function(t4, e3) {
                    return this.encode(t4, e3).ldelim();
                  }, t3.decode = function(t4, e3) {
                    t4 instanceof s || (t4 = s.create(t4));
                    for (var n2 = void 0 === e3 ? t4.len : t4.pos + e3, r2 = new l.onnx.TensorShapeProto.Dimension(); t4.pos < n2; ) {
                      var i2 = t4.uint32();
                      switch (i2 >>> 3) {
                        case 1:
                          r2.dimValue = t4.int64();
                          break;
                        case 2:
                          r2.dimParam = t4.string();
                          break;
                        case 3:
                          r2.denotation = t4.string();
                          break;
                        default:
                          t4.skipType(7 & i2);
                      }
                    }
                    return r2;
                  }, t3.decodeDelimited = function(t4) {
                    return t4 instanceof s || (t4 = new s(t4)), this.decode(t4, t4.uint32());
                  }, t3.verify = function(t4) {
                    if ("object" != typeof t4 || null === t4)
                      return "object expected";
                    var e3 = {};
                    if (null != t4.dimValue && t4.hasOwnProperty("dimValue") && (e3.value = 1, !(c.isInteger(t4.dimValue) || t4.dimValue && c.isInteger(t4.dimValue.low) && c.isInteger(t4.dimValue.high))))
                      return "dimValue: integer|Long expected";
                    if (null != t4.dimParam && t4.hasOwnProperty("dimParam")) {
                      if (1 === e3.value)
                        return "value: multiple values";
                      if (e3.value = 1, !c.isString(t4.dimParam))
                        return "dimParam: string expected";
                    }
                    return null != t4.denotation && t4.hasOwnProperty("denotation") && !c.isString(t4.denotation) ? "denotation: string expected" : null;
                  }, t3.fromObject = function(t4) {
                    if (t4 instanceof l.onnx.TensorShapeProto.Dimension)
                      return t4;
                    var e3 = new l.onnx.TensorShapeProto.Dimension();
                    return null != t4.dimValue && (c.Long ? (e3.dimValue = c.Long.fromValue(t4.dimValue)).unsigned = false : "string" == typeof t4.dimValue ? e3.dimValue = parseInt(t4.dimValue, 10) : "number" == typeof t4.dimValue ? e3.dimValue = t4.dimValue : "object" == typeof t4.dimValue && (e3.dimValue = new c.LongBits(t4.dimValue.low >>> 0, t4.dimValue.high >>> 0).toNumber())), null != t4.dimParam && (e3.dimParam = String(t4.dimParam)), null != t4.denotation && (e3.denotation = String(t4.denotation)), e3;
                  }, t3.toObject = function(t4, e3) {
                    e3 || (e3 = {});
                    var n2 = {};
                    return e3.defaults && (n2.denotation = ""), null != t4.dimValue && t4.hasOwnProperty("dimValue") && ("number" == typeof t4.dimValue ? n2.dimValue = e3.longs === String ? String(t4.dimValue) : t4.dimValue : n2.dimValue = e3.longs === String ? c.Long.prototype.toString.call(t4.dimValue) : e3.longs === Number ? new c.LongBits(t4.dimValue.low >>> 0, t4.dimValue.high >>> 0).toNumber() : t4.dimValue, e3.oneofs && (n2.value = "dimValue")), null != t4.dimParam && t4.hasOwnProperty("dimParam") && (n2.dimParam = t4.dimParam, e3.oneofs && (n2.value = "dimParam")), null != t4.denotation && t4.hasOwnProperty("denotation") && (n2.denotation = t4.denotation), n2;
                  }, t3.prototype.toJSON = function() {
                    return this.constructor.toObject(this, a.util.toJSONOptions);
                  }, t3;
                }(), t2;
              }(), o.TypeProto = function() {
                function t2(t3) {
                  if (t3)
                    for (var e3 = Object.keys(t3), n2 = 0; n2 < e3.length; ++n2)
                      null != t3[e3[n2]] && (this[e3[n2]] = t3[e3[n2]]);
                }
                var e2;
                return t2.prototype.tensorType = null, t2.prototype.denotation = "", Object.defineProperty(t2.prototype, "value", { get: c.oneOfGetter(e2 = ["tensorType"]), set: c.oneOfSetter(e2) }), t2.create = function(e3) {
                  return new t2(e3);
                }, t2.encode = function(t3, e3) {
                  return e3 || (e3 = u.create()), null != t3.tensorType && t3.hasOwnProperty("tensorType") && l.onnx.TypeProto.Tensor.encode(t3.tensorType, e3.uint32(10).fork()).ldelim(), null != t3.denotation && t3.hasOwnProperty("denotation") && e3.uint32(50).string(t3.denotation), e3;
                }, t2.encodeDelimited = function(t3, e3) {
                  return this.encode(t3, e3).ldelim();
                }, t2.decode = function(t3, e3) {
                  t3 instanceof s || (t3 = s.create(t3));
                  for (var n2 = void 0 === e3 ? t3.len : t3.pos + e3, r2 = new l.onnx.TypeProto(); t3.pos < n2; ) {
                    var i2 = t3.uint32();
                    switch (i2 >>> 3) {
                      case 1:
                        r2.tensorType = l.onnx.TypeProto.Tensor.decode(t3, t3.uint32());
                        break;
                      case 6:
                        r2.denotation = t3.string();
                        break;
                      default:
                        t3.skipType(7 & i2);
                    }
                  }
                  return r2;
                }, t2.decodeDelimited = function(t3) {
                  return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
                }, t2.verify = function(t3) {
                  if ("object" != typeof t3 || null === t3)
                    return "object expected";
                  if (null != t3.tensorType && t3.hasOwnProperty("tensorType")) {
                    var e3 = l.onnx.TypeProto.Tensor.verify(t3.tensorType);
                    if (e3)
                      return "tensorType." + e3;
                  }
                  return null != t3.denotation && t3.hasOwnProperty("denotation") && !c.isString(t3.denotation) ? "denotation: string expected" : null;
                }, t2.fromObject = function(t3) {
                  if (t3 instanceof l.onnx.TypeProto)
                    return t3;
                  var e3 = new l.onnx.TypeProto();
                  if (null != t3.tensorType) {
                    if ("object" != typeof t3.tensorType)
                      throw TypeError(".onnx.TypeProto.tensorType: object expected");
                    e3.tensorType = l.onnx.TypeProto.Tensor.fromObject(t3.tensorType);
                  }
                  return null != t3.denotation && (e3.denotation = String(t3.denotation)), e3;
                }, t2.toObject = function(t3, e3) {
                  e3 || (e3 = {});
                  var n2 = {};
                  return e3.defaults && (n2.denotation = ""), null != t3.tensorType && t3.hasOwnProperty("tensorType") && (n2.tensorType = l.onnx.TypeProto.Tensor.toObject(t3.tensorType, e3), e3.oneofs && (n2.value = "tensorType")), null != t3.denotation && t3.hasOwnProperty("denotation") && (n2.denotation = t3.denotation), n2;
                }, t2.prototype.toJSON = function() {
                  return this.constructor.toObject(this, a.util.toJSONOptions);
                }, t2.Tensor = function() {
                  function t3(t4) {
                    if (t4)
                      for (var e3 = Object.keys(t4), n2 = 0; n2 < e3.length; ++n2)
                        null != t4[e3[n2]] && (this[e3[n2]] = t4[e3[n2]]);
                  }
                  return t3.prototype.elemType = 0, t3.prototype.shape = null, t3.create = function(e3) {
                    return new t3(e3);
                  }, t3.encode = function(t4, e3) {
                    return e3 || (e3 = u.create()), null != t4.elemType && t4.hasOwnProperty("elemType") && e3.uint32(8).int32(t4.elemType), null != t4.shape && t4.hasOwnProperty("shape") && l.onnx.TensorShapeProto.encode(t4.shape, e3.uint32(18).fork()).ldelim(), e3;
                  }, t3.encodeDelimited = function(t4, e3) {
                    return this.encode(t4, e3).ldelim();
                  }, t3.decode = function(t4, e3) {
                    t4 instanceof s || (t4 = s.create(t4));
                    for (var n2 = void 0 === e3 ? t4.len : t4.pos + e3, r2 = new l.onnx.TypeProto.Tensor(); t4.pos < n2; ) {
                      var i2 = t4.uint32();
                      switch (i2 >>> 3) {
                        case 1:
                          r2.elemType = t4.int32();
                          break;
                        case 2:
                          r2.shape = l.onnx.TensorShapeProto.decode(t4, t4.uint32());
                          break;
                        default:
                          t4.skipType(7 & i2);
                      }
                    }
                    return r2;
                  }, t3.decodeDelimited = function(t4) {
                    return t4 instanceof s || (t4 = new s(t4)), this.decode(t4, t4.uint32());
                  }, t3.verify = function(t4) {
                    if ("object" != typeof t4 || null === t4)
                      return "object expected";
                    if (null != t4.elemType && t4.hasOwnProperty("elemType") && !c.isInteger(t4.elemType))
                      return "elemType: integer expected";
                    if (null != t4.shape && t4.hasOwnProperty("shape")) {
                      var e3 = l.onnx.TensorShapeProto.verify(t4.shape);
                      if (e3)
                        return "shape." + e3;
                    }
                    return null;
                  }, t3.fromObject = function(t4) {
                    if (t4 instanceof l.onnx.TypeProto.Tensor)
                      return t4;
                    var e3 = new l.onnx.TypeProto.Tensor();
                    if (null != t4.elemType && (e3.elemType = 0 | t4.elemType), null != t4.shape) {
                      if ("object" != typeof t4.shape)
                        throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");
                      e3.shape = l.onnx.TensorShapeProto.fromObject(t4.shape);
                    }
                    return e3;
                  }, t3.toObject = function(t4, e3) {
                    e3 || (e3 = {});
                    var n2 = {};
                    return e3.defaults && (n2.elemType = 0, n2.shape = null), null != t4.elemType && t4.hasOwnProperty("elemType") && (n2.elemType = t4.elemType), null != t4.shape && t4.hasOwnProperty("shape") && (n2.shape = l.onnx.TensorShapeProto.toObject(t4.shape, e3)), n2;
                  }, t3.prototype.toJSON = function() {
                    return this.constructor.toObject(this, a.util.toJSONOptions);
                  }, t3;
                }(), t2;
              }(), o.OperatorSetIdProto = function() {
                function t2(t3) {
                  if (t3)
                    for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                      null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
                }
                return t2.prototype.domain = "", t2.prototype.version = c.Long ? c.Long.fromBits(0, 0, false) : 0, t2.create = function(e2) {
                  return new t2(e2);
                }, t2.encode = function(t3, e2) {
                  return e2 || (e2 = u.create()), null != t3.domain && t3.hasOwnProperty("domain") && e2.uint32(10).string(t3.domain), null != t3.version && t3.hasOwnProperty("version") && e2.uint32(16).int64(t3.version), e2;
                }, t2.encodeDelimited = function(t3, e2) {
                  return this.encode(t3, e2).ldelim();
                }, t2.decode = function(t3, e2) {
                  t3 instanceof s || (t3 = s.create(t3));
                  for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.OperatorSetIdProto(); t3.pos < n2; ) {
                    var i2 = t3.uint32();
                    switch (i2 >>> 3) {
                      case 1:
                        r2.domain = t3.string();
                        break;
                      case 2:
                        r2.version = t3.int64();
                        break;
                      default:
                        t3.skipType(7 & i2);
                    }
                  }
                  return r2;
                }, t2.decodeDelimited = function(t3) {
                  return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
                }, t2.verify = function(t3) {
                  return "object" != typeof t3 || null === t3 ? "object expected" : null != t3.domain && t3.hasOwnProperty("domain") && !c.isString(t3.domain) ? "domain: string expected" : null != t3.version && t3.hasOwnProperty("version") && !(c.isInteger(t3.version) || t3.version && c.isInteger(t3.version.low) && c.isInteger(t3.version.high)) ? "version: integer|Long expected" : null;
                }, t2.fromObject = function(t3) {
                  if (t3 instanceof l.onnx.OperatorSetIdProto)
                    return t3;
                  var e2 = new l.onnx.OperatorSetIdProto();
                  return null != t3.domain && (e2.domain = String(t3.domain)), null != t3.version && (c.Long ? (e2.version = c.Long.fromValue(t3.version)).unsigned = false : "string" == typeof t3.version ? e2.version = parseInt(t3.version, 10) : "number" == typeof t3.version ? e2.version = t3.version : "object" == typeof t3.version && (e2.version = new c.LongBits(t3.version.low >>> 0, t3.version.high >>> 0).toNumber())), e2;
                }, t2.toObject = function(t3, e2) {
                  e2 || (e2 = {});
                  var n2 = {};
                  if (e2.defaults)
                    if (n2.domain = "", c.Long) {
                      var r2 = new c.Long(0, 0, false);
                      n2.version = e2.longs === String ? r2.toString() : e2.longs === Number ? r2.toNumber() : r2;
                    } else
                      n2.version = e2.longs === String ? "0" : 0;
                  return null != t3.domain && t3.hasOwnProperty("domain") && (n2.domain = t3.domain), null != t3.version && t3.hasOwnProperty("version") && ("number" == typeof t3.version ? n2.version = e2.longs === String ? String(t3.version) : t3.version : n2.version = e2.longs === String ? c.Long.prototype.toString.call(t3.version) : e2.longs === Number ? new c.LongBits(t3.version.low >>> 0, t3.version.high >>> 0).toNumber() : t3.version), n2;
                }, t2.prototype.toJSON = function() {
                  return this.constructor.toObject(this, a.util.toJSONOptions);
                }, t2;
              }(), o), t.exports = l;
            }, 2100: (t, e, n) => {
              "use strict";
              t.exports = n(9482);
            }, 9482: (t, e, n) => {
              "use strict";
              var r = e;
              function i() {
                r.util._configure(), r.Writer._configure(r.BufferWriter), r.Reader._configure(r.BufferReader);
              }
              r.build = "minimal", r.Writer = n(1173), r.BufferWriter = n(3155), r.Reader = n(1408), r.BufferReader = n(593), r.util = n(9693), r.rpc = n(5994), r.roots = n(5054), r.configure = i, i();
            }, 1408: (t, e, n) => {
              "use strict";
              t.exports = u;
              var r, i = n(9693), o = i.LongBits, a = i.utf8;
              function s(t2, e2) {
                return RangeError("index out of range: " + t2.pos + " + " + (e2 || 1) + " > " + t2.len);
              }
              function u(t2) {
                this.buf = t2, this.pos = 0, this.len = t2.length;
              }
              var c, l = "undefined" != typeof Uint8Array ? function(t2) {
                if (t2 instanceof Uint8Array || Array.isArray(t2))
                  return new u(t2);
                throw Error("illegal buffer");
              } : function(t2) {
                if (Array.isArray(t2))
                  return new u(t2);
                throw Error("illegal buffer");
              }, p = function() {
                return i.Buffer ? function(t2) {
                  return (u.create = function(t3) {
                    return i.Buffer.isBuffer(t3) ? new r(t3) : l(t3);
                  })(t2);
                } : l;
              };
              function f() {
                var t2 = new o(0, 0), e2 = 0;
                if (!(this.len - this.pos > 4)) {
                  for (; e2 < 3; ++e2) {
                    if (this.pos >= this.len)
                      throw s(this);
                    if (t2.lo = (t2.lo | (127 & this.buf[this.pos]) << 7 * e2) >>> 0, this.buf[this.pos++] < 128)
                      return t2;
                  }
                  return t2.lo = (t2.lo | (127 & this.buf[this.pos++]) << 7 * e2) >>> 0, t2;
                }
                for (; e2 < 4; ++e2)
                  if (t2.lo = (t2.lo | (127 & this.buf[this.pos]) << 7 * e2) >>> 0, this.buf[this.pos++] < 128)
                    return t2;
                if (t2.lo = (t2.lo | (127 & this.buf[this.pos]) << 28) >>> 0, t2.hi = (t2.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128)
                  return t2;
                if (e2 = 0, this.len - this.pos > 4) {
                  for (; e2 < 5; ++e2)
                    if (t2.hi = (t2.hi | (127 & this.buf[this.pos]) << 7 * e2 + 3) >>> 0, this.buf[this.pos++] < 128)
                      return t2;
                } else
                  for (; e2 < 5; ++e2) {
                    if (this.pos >= this.len)
                      throw s(this);
                    if (t2.hi = (t2.hi | (127 & this.buf[this.pos]) << 7 * e2 + 3) >>> 0, this.buf[this.pos++] < 128)
                      return t2;
                  }
                throw Error("invalid varint encoding");
              }
              function d(t2, e2) {
                return (t2[e2 - 4] | t2[e2 - 3] << 8 | t2[e2 - 2] << 16 | t2[e2 - 1] << 24) >>> 0;
              }
              function h() {
                if (this.pos + 8 > this.len)
                  throw s(this, 8);
                return new o(d(this.buf, this.pos += 4), d(this.buf, this.pos += 4));
              }
              u.create = p(), u.prototype._slice = i.Array.prototype.subarray || i.Array.prototype.slice, u.prototype.uint32 = (c = 4294967295, function() {
                if (c = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128)
                  return c;
                if (c = (c | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128)
                  return c;
                if (c = (c | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128)
                  return c;
                if (c = (c | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128)
                  return c;
                if (c = (c | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128)
                  return c;
                if ((this.pos += 5) > this.len)
                  throw this.pos = this.len, s(this, 10);
                return c;
              }), u.prototype.int32 = function() {
                return 0 | this.uint32();
              }, u.prototype.sint32 = function() {
                var t2 = this.uint32();
                return t2 >>> 1 ^ -(1 & t2) | 0;
              }, u.prototype.bool = function() {
                return 0 !== this.uint32();
              }, u.prototype.fixed32 = function() {
                if (this.pos + 4 > this.len)
                  throw s(this, 4);
                return d(this.buf, this.pos += 4);
              }, u.prototype.sfixed32 = function() {
                if (this.pos + 4 > this.len)
                  throw s(this, 4);
                return 0 | d(this.buf, this.pos += 4);
              }, u.prototype.float = function() {
                if (this.pos + 4 > this.len)
                  throw s(this, 4);
                var t2 = i.float.readFloatLE(this.buf, this.pos);
                return this.pos += 4, t2;
              }, u.prototype.double = function() {
                if (this.pos + 8 > this.len)
                  throw s(this, 4);
                var t2 = i.float.readDoubleLE(this.buf, this.pos);
                return this.pos += 8, t2;
              }, u.prototype.bytes = function() {
                var t2 = this.uint32(), e2 = this.pos, n2 = this.pos + t2;
                if (n2 > this.len)
                  throw s(this, t2);
                return this.pos += t2, Array.isArray(this.buf) ? this.buf.slice(e2, n2) : e2 === n2 ? new this.buf.constructor(0) : this._slice.call(this.buf, e2, n2);
              }, u.prototype.string = function() {
                var t2 = this.bytes();
                return a.read(t2, 0, t2.length);
              }, u.prototype.skip = function(t2) {
                if ("number" == typeof t2) {
                  if (this.pos + t2 > this.len)
                    throw s(this, t2);
                  this.pos += t2;
                } else
                  do {
                    if (this.pos >= this.len)
                      throw s(this);
                  } while (128 & this.buf[this.pos++]);
                return this;
              }, u.prototype.skipType = function(t2) {
                switch (t2) {
                  case 0:
                    this.skip();
                    break;
                  case 1:
                    this.skip(8);
                    break;
                  case 2:
                    this.skip(this.uint32());
                    break;
                  case 3:
                    for (; 4 != (t2 = 7 & this.uint32()); )
                      this.skipType(t2);
                    break;
                  case 5:
                    this.skip(4);
                    break;
                  default:
                    throw Error("invalid wire type " + t2 + " at offset " + this.pos);
                }
                return this;
              }, u._configure = function(t2) {
                r = t2, u.create = p(), r._configure();
                var e2 = i.Long ? "toLong" : "toNumber";
                i.merge(u.prototype, { int64: function() {
                  return f.call(this)[e2](false);
                }, uint64: function() {
                  return f.call(this)[e2](true);
                }, sint64: function() {
                  return f.call(this).zzDecode()[e2](false);
                }, fixed64: function() {
                  return h.call(this)[e2](true);
                }, sfixed64: function() {
                  return h.call(this)[e2](false);
                } });
              };
            }, 593: (t, e, n) => {
              "use strict";
              t.exports = o;
              var r = n(1408);
              (o.prototype = Object.create(r.prototype)).constructor = o;
              var i = n(9693);
              function o(t2) {
                r.call(this, t2);
              }
              o._configure = function() {
                i.Buffer && (o.prototype._slice = i.Buffer.prototype.slice);
              }, o.prototype.string = function() {
                var t2 = this.uint32();
                return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + t2, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + t2, this.len));
              }, o._configure();
            }, 5054: (t) => {
              "use strict";
              t.exports = {};
            }, 5994: (t, e, n) => {
              "use strict";
              e.Service = n(7948);
            }, 7948: (t, e, n) => {
              "use strict";
              t.exports = i;
              var r = n(9693);
              function i(t2, e2, n2) {
                if ("function" != typeof t2)
                  throw TypeError("rpcImpl must be a function");
                r.EventEmitter.call(this), this.rpcImpl = t2, this.requestDelimited = Boolean(e2), this.responseDelimited = Boolean(n2);
              }
              (i.prototype = Object.create(r.EventEmitter.prototype)).constructor = i, i.prototype.rpcCall = function t2(e2, n2, i2, o, a) {
                if (!o)
                  throw TypeError("request must be specified");
                var s = this;
                if (!a)
                  return r.asPromise(t2, s, e2, n2, i2, o);
                if (s.rpcImpl)
                  try {
                    return s.rpcImpl(e2, n2[s.requestDelimited ? "encodeDelimited" : "encode"](o).finish(), function(t3, n3) {
                      if (t3)
                        return s.emit("error", t3, e2), a(t3);
                      if (null !== n3) {
                        if (!(n3 instanceof i2))
                          try {
                            n3 = i2[s.responseDelimited ? "decodeDelimited" : "decode"](n3);
                          } catch (t4) {
                            return s.emit("error", t4, e2), a(t4);
                          }
                        return s.emit("data", n3, e2), a(null, n3);
                      }
                      s.end(true);
                    });
                  } catch (t3) {
                    return s.emit("error", t3, e2), void setTimeout(function() {
                      a(t3);
                    }, 0);
                  }
                else
                  setTimeout(function() {
                    a(Error("already ended"));
                  }, 0);
              }, i.prototype.end = function(t2) {
                return this.rpcImpl && (t2 || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
              };
            }, 1945: (t, e, n) => {
              "use strict";
              t.exports = i;
              var r = n(9693);
              function i(t2, e2) {
                this.lo = t2 >>> 0, this.hi = e2 >>> 0;
              }
              var o = i.zero = new i(0, 0);
              o.toNumber = function() {
                return 0;
              }, o.zzEncode = o.zzDecode = function() {
                return this;
              }, o.length = function() {
                return 1;
              };
              var a = i.zeroHash = "\0\0\0\0\0\0\0\0";
              i.fromNumber = function(t2) {
                if (0 === t2)
                  return o;
                var e2 = t2 < 0;
                e2 && (t2 = -t2);
                var n2 = t2 >>> 0, r2 = (t2 - n2) / 4294967296 >>> 0;
                return e2 && (r2 = ~r2 >>> 0, n2 = ~n2 >>> 0, ++n2 > 4294967295 && (n2 = 0, ++r2 > 4294967295 && (r2 = 0))), new i(n2, r2);
              }, i.from = function(t2) {
                if ("number" == typeof t2)
                  return i.fromNumber(t2);
                if (r.isString(t2)) {
                  if (!r.Long)
                    return i.fromNumber(parseInt(t2, 10));
                  t2 = r.Long.fromString(t2);
                }
                return t2.low || t2.high ? new i(t2.low >>> 0, t2.high >>> 0) : o;
              }, i.prototype.toNumber = function(t2) {
                if (!t2 && this.hi >>> 31) {
                  var e2 = 1 + ~this.lo >>> 0, n2 = ~this.hi >>> 0;
                  return e2 || (n2 = n2 + 1 >>> 0), -(e2 + 4294967296 * n2);
                }
                return this.lo + 4294967296 * this.hi;
              }, i.prototype.toLong = function(t2) {
                return r.Long ? new r.Long(0 | this.lo, 0 | this.hi, Boolean(t2)) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: Boolean(t2) };
              };
              var s = String.prototype.charCodeAt;
              i.fromHash = function(t2) {
                return t2 === a ? o : new i((s.call(t2, 0) | s.call(t2, 1) << 8 | s.call(t2, 2) << 16 | s.call(t2, 3) << 24) >>> 0, (s.call(t2, 4) | s.call(t2, 5) << 8 | s.call(t2, 6) << 16 | s.call(t2, 7) << 24) >>> 0);
              }, i.prototype.toHash = function() {
                return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
              }, i.prototype.zzEncode = function() {
                var t2 = this.hi >> 31;
                return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ t2) >>> 0, this.lo = (this.lo << 1 ^ t2) >>> 0, this;
              }, i.prototype.zzDecode = function() {
                var t2 = -(1 & this.lo);
                return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ t2) >>> 0, this.hi = (this.hi >>> 1 ^ t2) >>> 0, this;
              }, i.prototype.length = function() {
                var t2 = this.lo, e2 = (this.lo >>> 28 | this.hi << 4) >>> 0, n2 = this.hi >>> 24;
                return 0 === n2 ? 0 === e2 ? t2 < 16384 ? t2 < 128 ? 1 : 2 : t2 < 2097152 ? 3 : 4 : e2 < 16384 ? e2 < 128 ? 5 : 6 : e2 < 2097152 ? 7 : 8 : n2 < 128 ? 9 : 10;
              };
            }, 9693: function(t, e, n) {
              "use strict";
              var r = e;
              function i(t2, e2, n2) {
                for (var r2 = Object.keys(e2), i2 = 0; i2 < r2.length; ++i2)
                  void 0 !== t2[r2[i2]] && n2 || (t2[r2[i2]] = e2[r2[i2]]);
                return t2;
              }
              function o(t2) {
                function e2(t3, n2) {
                  if (!(this instanceof e2))
                    return new e2(t3, n2);
                  Object.defineProperty(this, "message", { get: function() {
                    return t3;
                  } }), Error.captureStackTrace ? Error.captureStackTrace(this, e2) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), n2 && i(this, n2);
                }
                return (e2.prototype = Object.create(Error.prototype)).constructor = e2, Object.defineProperty(e2.prototype, "name", { get: function() {
                  return t2;
                } }), e2.prototype.toString = function() {
                  return this.name + ": " + this.message;
                }, e2;
              }
              r.asPromise = n(4537), r.base64 = n(7419), r.EventEmitter = n(9211), r.float = n(945), r.inquire = n(7199), r.utf8 = n(4997), r.pool = n(6662), r.LongBits = n(1945), r.isNode = Boolean(void 0 !== n.g && n.g && n.g.process && n.g.process.versions && n.g.process.versions.node), r.global = r.isNode && n.g || "undefined" != typeof window && window || "undefined" != typeof self && self || this, r.emptyArray = Object.freeze ? Object.freeze([]) : [], r.emptyObject = Object.freeze ? Object.freeze({}) : {}, r.isInteger = Number.isInteger || function(t2) {
                return "number" == typeof t2 && isFinite(t2) && Math.floor(t2) === t2;
              }, r.isString = function(t2) {
                return "string" == typeof t2 || t2 instanceof String;
              }, r.isObject = function(t2) {
                return t2 && "object" == typeof t2;
              }, r.isset = r.isSet = function(t2, e2) {
                var n2 = t2[e2];
                return !(null == n2 || !t2.hasOwnProperty(e2)) && ("object" != typeof n2 || (Array.isArray(n2) ? n2.length : Object.keys(n2).length) > 0);
              }, r.Buffer = function() {
                try {
                  var t2 = r.inquire("buffer").Buffer;
                  return t2.prototype.utf8Write ? t2 : null;
                } catch (t3) {
                  return null;
                }
              }(), r._Buffer_from = null, r._Buffer_allocUnsafe = null, r.newBuffer = function(t2) {
                return "number" == typeof t2 ? r.Buffer ? r._Buffer_allocUnsafe(t2) : new r.Array(t2) : r.Buffer ? r._Buffer_from(t2) : "undefined" == typeof Uint8Array ? t2 : new Uint8Array(t2);
              }, r.Array = "undefined" != typeof Uint8Array ? Uint8Array : Array, r.Long = r.global.dcodeIO && r.global.dcodeIO.Long || r.global.Long || r.inquire("long"), r.key2Re = /^true|false|0|1$/, r.key32Re = /^-?(?:0|[1-9][0-9]*)$/, r.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, r.longToHash = function(t2) {
                return t2 ? r.LongBits.from(t2).toHash() : r.LongBits.zeroHash;
              }, r.longFromHash = function(t2, e2) {
                var n2 = r.LongBits.fromHash(t2);
                return r.Long ? r.Long.fromBits(n2.lo, n2.hi, e2) : n2.toNumber(Boolean(e2));
              }, r.merge = i, r.lcFirst = function(t2) {
                return t2.charAt(0).toLowerCase() + t2.substring(1);
              }, r.newError = o, r.ProtocolError = o("ProtocolError"), r.oneOfGetter = function(t2) {
                for (var e2 = {}, n2 = 0; n2 < t2.length; ++n2)
                  e2[t2[n2]] = 1;
                return function() {
                  for (var t3 = Object.keys(this), n3 = t3.length - 1; n3 > -1; --n3)
                    if (1 === e2[t3[n3]] && void 0 !== this[t3[n3]] && null !== this[t3[n3]])
                      return t3[n3];
                };
              }, r.oneOfSetter = function(t2) {
                return function(e2) {
                  for (var n2 = 0; n2 < t2.length; ++n2)
                    t2[n2] !== e2 && delete this[t2[n2]];
                };
              }, r.toJSONOptions = { longs: String, enums: String, bytes: String, json: true }, r._configure = function() {
                var t2 = r.Buffer;
                t2 ? (r._Buffer_from = t2.from !== Uint8Array.from && t2.from || function(e2, n2) {
                  return new t2(e2, n2);
                }, r._Buffer_allocUnsafe = t2.allocUnsafe || function(e2) {
                  return new t2(e2);
                }) : r._Buffer_from = r._Buffer_allocUnsafe = null;
              };
            }, 1173: (t, e, n) => {
              "use strict";
              t.exports = p;
              var r, i = n(9693), o = i.LongBits, a = i.base64, s = i.utf8;
              function u(t2, e2, n2) {
                this.fn = t2, this.len = e2, this.next = void 0, this.val = n2;
              }
              function c() {
              }
              function l(t2) {
                this.head = t2.head, this.tail = t2.tail, this.len = t2.len, this.next = t2.states;
              }
              function p() {
                this.len = 0, this.head = new u(c, 0, 0), this.tail = this.head, this.states = null;
              }
              var f = function() {
                return i.Buffer ? function() {
                  return (p.create = function() {
                    return new r();
                  })();
                } : function() {
                  return new p();
                };
              };
              function d(t2, e2, n2) {
                e2[n2] = 255 & t2;
              }
              function h(t2, e2) {
                this.len = t2, this.next = void 0, this.val = e2;
              }
              function g(t2, e2, n2) {
                for (; t2.hi; )
                  e2[n2++] = 127 & t2.lo | 128, t2.lo = (t2.lo >>> 7 | t2.hi << 25) >>> 0, t2.hi >>>= 7;
                for (; t2.lo > 127; )
                  e2[n2++] = 127 & t2.lo | 128, t2.lo = t2.lo >>> 7;
                e2[n2++] = t2.lo;
              }
              function b(t2, e2, n2) {
                e2[n2] = 255 & t2, e2[n2 + 1] = t2 >>> 8 & 255, e2[n2 + 2] = t2 >>> 16 & 255, e2[n2 + 3] = t2 >>> 24;
              }
              p.create = f(), p.alloc = function(t2) {
                return new i.Array(t2);
              }, i.Array !== Array && (p.alloc = i.pool(p.alloc, i.Array.prototype.subarray)), p.prototype._push = function(t2, e2, n2) {
                return this.tail = this.tail.next = new u(t2, e2, n2), this.len += e2, this;
              }, h.prototype = Object.create(u.prototype), h.prototype.fn = function(t2, e2, n2) {
                for (; t2 > 127; )
                  e2[n2++] = 127 & t2 | 128, t2 >>>= 7;
                e2[n2] = t2;
              }, p.prototype.uint32 = function(t2) {
                return this.len += (this.tail = this.tail.next = new h((t2 >>>= 0) < 128 ? 1 : t2 < 16384 ? 2 : t2 < 2097152 ? 3 : t2 < 268435456 ? 4 : 5, t2)).len, this;
              }, p.prototype.int32 = function(t2) {
                return t2 < 0 ? this._push(g, 10, o.fromNumber(t2)) : this.uint32(t2);
              }, p.prototype.sint32 = function(t2) {
                return this.uint32((t2 << 1 ^ t2 >> 31) >>> 0);
              }, p.prototype.uint64 = function(t2) {
                var e2 = o.from(t2);
                return this._push(g, e2.length(), e2);
              }, p.prototype.int64 = p.prototype.uint64, p.prototype.sint64 = function(t2) {
                var e2 = o.from(t2).zzEncode();
                return this._push(g, e2.length(), e2);
              }, p.prototype.bool = function(t2) {
                return this._push(d, 1, t2 ? 1 : 0);
              }, p.prototype.fixed32 = function(t2) {
                return this._push(b, 4, t2 >>> 0);
              }, p.prototype.sfixed32 = p.prototype.fixed32, p.prototype.fixed64 = function(t2) {
                var e2 = o.from(t2);
                return this._push(b, 4, e2.lo)._push(b, 4, e2.hi);
              }, p.prototype.sfixed64 = p.prototype.fixed64, p.prototype.float = function(t2) {
                return this._push(i.float.writeFloatLE, 4, t2);
              }, p.prototype.double = function(t2) {
                return this._push(i.float.writeDoubleLE, 8, t2);
              };
              var m = i.Array.prototype.set ? function(t2, e2, n2) {
                e2.set(t2, n2);
              } : function(t2, e2, n2) {
                for (var r2 = 0; r2 < t2.length; ++r2)
                  e2[n2 + r2] = t2[r2];
              };
              p.prototype.bytes = function(t2) {
                var e2 = t2.length >>> 0;
                if (!e2)
                  return this._push(d, 1, 0);
                if (i.isString(t2)) {
                  var n2 = p.alloc(e2 = a.length(t2));
                  a.decode(t2, n2, 0), t2 = n2;
                }
                return this.uint32(e2)._push(m, e2, t2);
              }, p.prototype.string = function(t2) {
                var e2 = s.length(t2);
                return e2 ? this.uint32(e2)._push(s.write, e2, t2) : this._push(d, 1, 0);
              }, p.prototype.fork = function() {
                return this.states = new l(this), this.head = this.tail = new u(c, 0, 0), this.len = 0, this;
              }, p.prototype.reset = function() {
                return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new u(c, 0, 0), this.len = 0), this;
              }, p.prototype.ldelim = function() {
                var t2 = this.head, e2 = this.tail, n2 = this.len;
                return this.reset().uint32(n2), n2 && (this.tail.next = t2.next, this.tail = e2, this.len += n2), this;
              }, p.prototype.finish = function() {
                for (var t2 = this.head.next, e2 = this.constructor.alloc(this.len), n2 = 0; t2; )
                  t2.fn(t2.val, e2, n2), n2 += t2.len, t2 = t2.next;
                return e2;
              }, p._configure = function(t2) {
                r = t2, p.create = f(), r._configure();
              };
            }, 3155: (t, e, n) => {
              "use strict";
              t.exports = o;
              var r = n(1173);
              (o.prototype = Object.create(r.prototype)).constructor = o;
              var i = n(9693);
              function o() {
                r.call(this);
              }
              function a(t2, e2, n2) {
                t2.length < 40 ? i.utf8.write(t2, e2, n2) : e2.utf8Write ? e2.utf8Write(t2, n2) : e2.write(t2, n2);
              }
              o._configure = function() {
                o.alloc = i._Buffer_allocUnsafe, o.writeBytesBuffer = i.Buffer && i.Buffer.prototype instanceof Uint8Array && "set" === i.Buffer.prototype.set.name ? function(t2, e2, n2) {
                  e2.set(t2, n2);
                } : function(t2, e2, n2) {
                  if (t2.copy)
                    t2.copy(e2, n2, 0, t2.length);
                  else
                    for (var r2 = 0; r2 < t2.length; )
                      e2[n2++] = t2[r2++];
                };
              }, o.prototype.bytes = function(t2) {
                i.isString(t2) && (t2 = i._Buffer_from(t2, "base64"));
                var e2 = t2.length >>> 0;
                return this.uint32(e2), e2 && this._push(o.writeBytesBuffer, e2, t2), this;
              }, o.prototype.string = function(t2) {
                var e2 = i.Buffer.byteLength(t2);
                return this.uint32(e2), e2 && this._push(a, e2, t2), this;
              }, o._configure();
            }, 7714: (t, e, n) => {
              "use strict";
              e.R = void 0;
              const r = n(6919), i = n(7448);
              e.R = new class {
                async init() {
                }
                async createSessionHandler(t2, e2) {
                  const n2 = new r.Session(e2);
                  return await n2.loadModel(t2), new i.OnnxjsSessionHandler(n2);
                }
              }();
            }, 4200: (t, e, n) => {
              "use strict";
              e.c8 = e.rX = void 0;
              const r = n(1670), i = n(5381), o = n(2157), a = n(2306);
              e.rX = () => {
                if (("number" != typeof r.env.wasm.initTimeout || r.env.wasm.initTimeout < 0) && (r.env.wasm.initTimeout = 0), "boolean" != typeof r.env.wasm.simd && (r.env.wasm.simd = true), "boolean" != typeof r.env.wasm.proxy && (r.env.wasm.proxy = false), "number" != typeof r.env.wasm.numThreads || !Number.isInteger(r.env.wasm.numThreads) || r.env.wasm.numThreads <= 0) {
                  const t2 = "undefined" == typeof navigator ? (0, i.cpus)().length : navigator.hardwareConcurrency;
                  r.env.wasm.numThreads = Math.min(4, Math.ceil((t2 || 1) / 2));
                }
              }, e.c8 = new class {
                async init() {
                  (0, e.rX)(), await (0, o.initWasm)();
                }
                async createSessionHandler(t2, e2) {
                  const n2 = new a.OnnxruntimeWebAssemblySessionHandler();
                  return await n2.loadModel(t2, e2), Promise.resolve(n2);
                }
              }();
            }, 6018: function(t, e, n) {
              "use strict";
              var r = this && this.__createBinding || (Object.create ? function(t2, e2, n2, r2) {
                void 0 === r2 && (r2 = n2);
                var i2 = Object.getOwnPropertyDescriptor(e2, n2);
                i2 && !("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
                  return e2[n2];
                } }), Object.defineProperty(t2, r2, i2);
              } : function(t2, e2, n2, r2) {
                void 0 === r2 && (r2 = n2), t2[r2] = e2[n2];
              }), i = this && this.__exportStar || function(t2, e2) {
                for (var n2 in t2)
                  "default" === n2 || Object.prototype.hasOwnProperty.call(e2, n2) || r(e2, t2, n2);
              };
              Object.defineProperty(e, "__esModule", { value: true }), i(n(1670), e);
              const o = n(1670);
              {
                const t2 = n(7714).R;
                (0, o.registerBackend)("webgl", t2, -10);
              }
              {
                const t2 = n(4200).c8;
                (0, o.registerBackend)("cpu", t2, 10), (0, o.registerBackend)("wasm", t2, 10), (0, o.registerBackend)("xnnpack", t2, 9);
              }
            }, 246: (t, e) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.createAttributeWithCacheKey = void 0;
              class n {
                constructor(t2) {
                  Object.assign(this, t2);
                }
                get cacheKey() {
                  return this._cacheKey || (this._cacheKey = Object.getOwnPropertyNames(this).sort().map((t2) => `${this[t2]}`).join(";")), this._cacheKey;
                }
              }
              e.createAttributeWithCacheKey = (t2) => new n(t2);
            }, 7778: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.Attribute = void 0;
              const r = n(1446), i = n(9395), o = n(9162), a = n(2517);
              var s = i.onnxruntime.experimental.fbs;
              class u {
                constructor(t2) {
                  if (this._attributes = /* @__PURE__ */ new Map(), null != t2) {
                    for (const e2 of t2)
                      e2 instanceof r.onnx.AttributeProto ? this._attributes.set(e2.name, [u.getValue(e2), u.getType(e2)]) : e2 instanceof s.Attribute && this._attributes.set(e2.name(), [u.getValue(e2), u.getType(e2)]);
                    if (this._attributes.size < t2.length)
                      throw new Error("duplicated attribute names");
                  }
                }
                set(t2, e2, n2) {
                  this._attributes.set(t2, [n2, e2]);
                }
                delete(t2) {
                  this._attributes.delete(t2);
                }
                getFloat(t2, e2) {
                  return this.get(t2, "float", e2);
                }
                getInt(t2, e2) {
                  return this.get(t2, "int", e2);
                }
                getString(t2, e2) {
                  return this.get(t2, "string", e2);
                }
                getTensor(t2, e2) {
                  return this.get(t2, "tensor", e2);
                }
                getFloats(t2, e2) {
                  return this.get(t2, "floats", e2);
                }
                getInts(t2, e2) {
                  return this.get(t2, "ints", e2);
                }
                getStrings(t2, e2) {
                  return this.get(t2, "strings", e2);
                }
                getTensors(t2, e2) {
                  return this.get(t2, "tensors", e2);
                }
                get(t2, e2, n2) {
                  const r2 = this._attributes.get(t2);
                  if (void 0 === r2) {
                    if (void 0 !== n2)
                      return n2;
                    throw new Error(`required attribute not found: ${t2}`);
                  }
                  if (r2[1] !== e2)
                    throw new Error(`type mismatch: expected ${e2} but got ${r2[1]}`);
                  return r2[0];
                }
                static getType(t2) {
                  const e2 = t2 instanceof r.onnx.AttributeProto ? t2.type : t2.type();
                  switch (e2) {
                    case r.onnx.AttributeProto.AttributeType.FLOAT:
                      return "float";
                    case r.onnx.AttributeProto.AttributeType.INT:
                      return "int";
                    case r.onnx.AttributeProto.AttributeType.STRING:
                      return "string";
                    case r.onnx.AttributeProto.AttributeType.TENSOR:
                      return "tensor";
                    case r.onnx.AttributeProto.AttributeType.FLOATS:
                      return "floats";
                    case r.onnx.AttributeProto.AttributeType.INTS:
                      return "ints";
                    case r.onnx.AttributeProto.AttributeType.STRINGS:
                      return "strings";
                    case r.onnx.AttributeProto.AttributeType.TENSORS:
                      return "tensors";
                    default:
                      throw new Error(`attribute type is not supported yet: ${r.onnx.AttributeProto.AttributeType[e2]}`);
                  }
                }
                static getValue(t2) {
                  const e2 = t2 instanceof r.onnx.AttributeProto ? t2.type : t2.type();
                  if (e2 === r.onnx.AttributeProto.AttributeType.GRAPH || e2 === r.onnx.AttributeProto.AttributeType.GRAPHS)
                    throw new Error("graph attribute is not supported yet");
                  const n2 = this.getValueNoCheck(t2);
                  if (e2 === r.onnx.AttributeProto.AttributeType.INT && a.LongUtil.isLong(n2))
                    return a.LongUtil.longToNumber(n2);
                  if (e2 === r.onnx.AttributeProto.AttributeType.INTS) {
                    const t3 = n2, e3 = new Array(t3.length);
                    for (let n3 = 0; n3 < t3.length; n3++) {
                      const r2 = t3[n3];
                      e3[n3] = a.LongUtil.longToNumber(r2);
                    }
                    return e3;
                  }
                  if (e2 === r.onnx.AttributeProto.AttributeType.TENSOR)
                    return t2 instanceof r.onnx.AttributeProto ? o.Tensor.fromProto(n2) : o.Tensor.fromOrtTensor(n2);
                  if (e2 === r.onnx.AttributeProto.AttributeType.TENSORS) {
                    if (t2 instanceof r.onnx.AttributeProto)
                      return n2.map((t3) => o.Tensor.fromProto(t3));
                    if (t2 instanceof s.Attribute)
                      return n2.map((t3) => o.Tensor.fromOrtTensor(t3));
                  }
                  if (e2 === r.onnx.AttributeProto.AttributeType.STRING && t2 instanceof r.onnx.AttributeProto) {
                    const t3 = n2;
                    return (0, a.decodeUtf8String)(t3);
                  }
                  return e2 === r.onnx.AttributeProto.AttributeType.STRINGS && t2 instanceof r.onnx.AttributeProto ? n2.map(a.decodeUtf8String) : n2;
                }
                static getValueNoCheck(t2) {
                  return t2 instanceof r.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(t2) : this.getValueNoCheckFromOrtFormat(t2);
                }
                static getValueNoCheckFromOnnxFormat(t2) {
                  switch (t2.type) {
                    case r.onnx.AttributeProto.AttributeType.FLOAT:
                      return t2.f;
                    case r.onnx.AttributeProto.AttributeType.INT:
                      return t2.i;
                    case r.onnx.AttributeProto.AttributeType.STRING:
                      return t2.s;
                    case r.onnx.AttributeProto.AttributeType.TENSOR:
                      return t2.t;
                    case r.onnx.AttributeProto.AttributeType.GRAPH:
                      return t2.g;
                    case r.onnx.AttributeProto.AttributeType.FLOATS:
                      return t2.floats;
                    case r.onnx.AttributeProto.AttributeType.INTS:
                      return t2.ints;
                    case r.onnx.AttributeProto.AttributeType.STRINGS:
                      return t2.strings;
                    case r.onnx.AttributeProto.AttributeType.TENSORS:
                      return t2.tensors;
                    case r.onnx.AttributeProto.AttributeType.GRAPHS:
                      return t2.graphs;
                    default:
                      throw new Error(`unsupported attribute type: ${r.onnx.AttributeProto.AttributeType[t2.type]}`);
                  }
                }
                static getValueNoCheckFromOrtFormat(t2) {
                  switch (t2.type()) {
                    case s.AttributeType.FLOAT:
                      return t2.f();
                    case s.AttributeType.INT:
                      return t2.i();
                    case s.AttributeType.STRING:
                      return t2.s();
                    case s.AttributeType.TENSOR:
                      return t2.t();
                    case s.AttributeType.GRAPH:
                      return t2.g();
                    case s.AttributeType.FLOATS:
                      return t2.floatsArray();
                    case s.AttributeType.INTS: {
                      const e2 = [];
                      for (let n2 = 0; n2 < t2.intsLength(); n2++)
                        e2.push(t2.ints(n2));
                      return e2;
                    }
                    case s.AttributeType.STRINGS: {
                      const e2 = [];
                      for (let n2 = 0; n2 < t2.stringsLength(); n2++)
                        e2.push(t2.strings(n2));
                      return e2;
                    }
                    case s.AttributeType.TENSORS: {
                      const e2 = [];
                      for (let n2 = 0; n2 < t2.tensorsLength(); n2++)
                        e2.push(t2.tensors(n2));
                      return e2;
                    }
                    default:
                      throw new Error(`unsupported attribute type: ${s.AttributeType[t2.type()]}`);
                  }
                }
              }
              e.Attribute = u;
            }, 7091: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.resolveBackend = e.backend = void 0;
              const r = n(5038), i = /* @__PURE__ */ new Map();
              async function o(t2) {
                const n2 = e.backend;
                if (void 0 !== n2[t2] && function(t3) {
                  const e2 = t3;
                  return "initialize" in e2 && "function" == typeof e2.initialize && "createSessionHandler" in e2 && "function" == typeof e2.createSessionHandler && "dispose" in e2 && "function" == typeof e2.dispose;
                }(n2[t2])) {
                  const e2 = n2[t2];
                  let r2 = e2.initialize();
                  if ("object" == typeof r2 && "then" in r2 && (r2 = await r2), r2)
                    return i.set(t2, e2), e2;
                }
              }
              e.backend = { webgl: new r.WebGLBackend() }, e.resolveBackend = async function t2(e2) {
                if (!e2)
                  return t2(["webgl"]);
                {
                  const t3 = "string" == typeof e2 ? [e2] : e2;
                  for (const e3 of t3) {
                    const t4 = i.get(e3);
                    if (t4)
                      return t4;
                    const n2 = await o(e3);
                    if (n2)
                      return n2;
                  }
                }
                throw new Error("no available backend to use");
              };
            }, 5038: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.WebGLBackend = void 0;
              const r = n(1670), i = n(6231), o = n(6416), a = n(7305);
              e.WebGLBackend = class {
                get contextId() {
                  return r.env.webgl.contextId;
                }
                set contextId(t2) {
                  r.env.webgl.contextId = t2;
                }
                get matmulMaxBatchSize() {
                  return r.env.webgl.matmulMaxBatchSize;
                }
                set matmulMaxBatchSize(t2) {
                  r.env.webgl.matmulMaxBatchSize = t2;
                }
                get textureCacheMode() {
                  return r.env.webgl.textureCacheMode;
                }
                set textureCacheMode(t2) {
                  r.env.webgl.textureCacheMode = t2;
                }
                get pack() {
                  return r.env.webgl.pack;
                }
                set pack(t2) {
                  r.env.webgl.pack = t2;
                }
                get async() {
                  return r.env.webgl.async;
                }
                set async(t2) {
                  r.env.webgl.async = t2;
                }
                initialize() {
                  try {
                    return this.glContext = (0, a.createWebGLContext)(this.contextId), "number" != typeof this.matmulMaxBatchSize && (this.matmulMaxBatchSize = 16), "string" != typeof this.textureCacheMode && (this.textureCacheMode = "full"), "boolean" != typeof this.pack && (this.pack = false), "boolean" != typeof this.async && (this.async = false), i.Logger.setWithEnv(r.env), i.Logger.verbose("WebGLBackend", `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`), true;
                  } catch (t2) {
                    return i.Logger.warning("WebGLBackend", `Unable to initialize WebGLBackend. ${t2}`), false;
                  }
                }
                createSessionHandler(t2) {
                  return new o.WebGLSessionHandler(this, t2);
                }
                dispose() {
                  this.glContext.dispose();
                }
              };
            }, 5107: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.CoordsGlslLib = void 0;
              const r = n(2517), i = n(8520), o = n(5060), a = n(7859), s = n(9390);
              class u extends i.GlslLib {
                constructor(t2) {
                  super(t2);
                }
                getFunctions() {
                  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.offsetToCoords()), this.coordsToOffset()), this.toVec()), this.valueFrom()), this.getCommonUtilFuncs()), this.getInputsSamplingSnippets()), this.getOutputSamplingSnippet());
                }
                getCustomTypes() {
                  return {};
                }
                offsetToCoords() {
                  return { offsetToCoords: new i.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ") };
                }
                coordsToOffset() {
                  return { coordsToOffset: new i.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ") };
                }
                getOutputSamplingSnippet() {
                  const t2 = this.context.outputTextureLayout;
                  return t2.isPacked ? this.getPackedOutputSamplingSnippet(t2) : this.getUnpackedOutputSamplingSnippet(t2);
                }
                getPackedOutputSamplingSnippet(t2) {
                  const e2 = t2.unpackedShape, n2 = [t2.width, t2.height], r2 = {}, a2 = "getOutputCoords";
                  switch (e2.length) {
                    case 0:
                      r2[a2] = this.getOutputScalarCoords();
                      break;
                    case 1:
                      r2[a2] = this.getOutputPacked1DCoords(e2, n2);
                      break;
                    case 2:
                      r2[a2] = this.getOutputPacked2DCoords(e2, n2);
                      break;
                    case 3:
                      r2[a2] = this.getOutputPacked3DCoords(e2, n2);
                      break;
                    default:
                      r2[a2] = this.getOutputPackedNDCoords(e2, n2);
                  }
                  const s2 = `
      void setOutput(vec4 val) {
        ${(0, o.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;
                  return r2.floatTextureSetRGBA = new i.GlslLibRoutine(s2), r2;
                }
                getUnpackedOutputSamplingSnippet(t2) {
                  const e2 = t2.unpackedShape, n2 = [t2.width, t2.height], r2 = {}, a2 = "getOutputCoords";
                  switch (e2.length) {
                    case 0:
                      r2[a2] = this.getOutputScalarCoords();
                      break;
                    case 1:
                      r2[a2] = this.getOutputUnpacked1DCoords(e2, n2);
                      break;
                    case 2:
                      r2[a2] = this.getOutputUnpacked2DCoords(e2, n2);
                      break;
                    case 3:
                      r2[a2] = this.getOutputUnpacked3DCoords(e2, n2);
                      break;
                    case 4:
                      r2[a2] = this.getOutputUnpacked4DCoords(e2, n2);
                      break;
                    case 5:
                      r2[a2] = this.getOutputUnpacked5DCoords(e2, n2);
                      break;
                    case 6:
                      r2[a2] = this.getOutputUnpacked6DCoords(e2, n2);
                      break;
                    default:
                      throw new Error(`Unsupported output dimensionality: ${e2.length}`);
                  }
                  const s2 = `
        void setOutput(float val) {
          ${(0, o.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;
                  return r2.floatTextureSetR = new i.GlslLibRoutine(s2), r2;
                }
                getOutputScalarCoords() {
                  return new i.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ");
                }
                getOutputPacked1DCoords(t2, e2) {
                  const n2 = e2;
                  let r2 = "";
                  return 1 === n2[0] ? (r2 = `
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${n2[1]}.0);
          }
        `, new i.GlslLibRoutine(r2)) : 1 === n2[1] ? (r2 = `
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${n2[0]}.0);
          }
        `, new i.GlslLibRoutine(r2)) : (r2 = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${n2[0]}, ${n2[1]}));
          return 2 * (resTexRC.y * ${n2[0]} + resTexRC.x);
        }
      `, new i.GlslLibRoutine(r2));
                }
                getOutputPacked2DCoords(t2, e2) {
                  let n2 = "";
                  if (r.ArrayUtil.arraysEqual(t2, e2))
                    return n2 = `
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${e2[0]}, ${e2[1]}));
        }
      `, new i.GlslLibRoutine(n2);
                  const o2 = e2, a2 = Math.ceil(t2[1] / 2);
                  return n2 = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${o2[0]}, ${o2[1]}));

          int index = resTexRC.y * ${o2[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${a2}) * 2;
          int c = 2 * (index / ${a2});

          return ivec2(r, c);
        }
      `, new i.GlslLibRoutine(n2);
                }
                getOutputPacked3DCoords(t2, e2) {
                  const n2 = [e2[0], e2[1]], r2 = Math.ceil(t2[2] / 2), o2 = r2 * Math.ceil(t2[1] / 2), a2 = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n2[0]}, ${n2[1]}));
          int index = resTexRC.y * ${n2[0]} + resTexRC.x;

          int b = index / ${o2};
          index -= b * ${o2};

          // reverse r and c order for packed texture
          int r = imod(index, ${r2}) * 2;
          int c = 2 * (index / ${r2});

          return ivec3(b, r, c);
        }
      `;
                  return new i.GlslLibRoutine(a2);
                }
                getOutputPackedNDCoords(t2, e2) {
                  const n2 = [e2[0], e2[1]], r2 = Math.ceil(t2[t2.length - 1] / 2), o2 = r2 * Math.ceil(t2[t2.length - 2] / 2);
                  let a2 = o2, s2 = "", u2 = "b, r, c";
                  for (let e3 = 2; e3 < t2.length - 1; e3++)
                    a2 *= t2[t2.length - e3 - 1], s2 = `
      int b${e3} = index / ${a2};
      index -= b${e3} * ${a2};
    ` + s2, u2 = `b${e3}, ` + u2;
                  const c = `
      ivec${t2.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${n2[0]}, ${n2[1]}));
        int index = resTexRC.y * ${n2[0]} + resTexRC.x;

        ${s2}

        int b = index / ${o2};
        index -= b * ${o2};

        // reverse r and c order for packed texture
        int r = imod(index, ${r2}) * 2;
        int c = 2 * (index / ${r2});

        return ivec${t2.length}(${u2});
      }
    `;
                  return new i.GlslLibRoutine(c);
                }
                getOutputUnpacked1DCoords(t2, e2) {
                  const n2 = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e2[0]}, ${e2[1]}));
          return resTexRC.y * ${e2[0]} + resTexRC.x;
        }
      `;
                  return new i.GlslLibRoutine(n2);
                }
                getOutputUnpacked2DCoords(t2, e2) {
                  const n2 = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e2[0]}, ${e2[1]}));
          int index = resTexRC.y * ${e2[0]} + resTexRC.x;
          int r = index / ${t2[1]};
          int c = index - r * ${t2[1]};
          return ivec2(r, c);
        }
      `;
                  return new i.GlslLibRoutine(n2);
                }
                getOutputUnpacked3DCoords(t2, e2) {
                  let n2 = "";
                  const r2 = t2.length;
                  let o2 = null;
                  r2 < 2 && (o2 = []), o2 = new Array(r2 - 1), o2[r2 - 2] = t2[r2 - 1];
                  for (let e3 = r2 - 3; e3 >= 0; --e3)
                    o2[e3] = o2[e3 + 1] * t2[e3 + 1];
                  const a2 = ["r", "c", "d"], s2 = o2.map((t3, e3) => `int ${a2[e3]} = index / ${t3}; ${e3 === o2.length - 1 ? `int ${a2[e3 + 1]} = index - ${a2[e3]} * ${t3}` : `index -= ${a2[e3]} * ${t3}`};`).join("");
                  return n2 = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e2[0]}, ${e2[1]}));
          int index = resTexRC.y * ${e2[0]} + resTexRC.x;
          ${s2}
          return ivec3(r, c, d);
        }
      `, new i.GlslLibRoutine(n2);
                }
                getOutputUnpacked4DCoords(t2, e2) {
                  let n2 = "";
                  const r2 = t2.length;
                  let o2 = null;
                  r2 < 2 && (o2 = []), o2 = new Array(r2 - 1), o2[r2 - 2] = t2[r2 - 1];
                  for (let e3 = r2 - 3; e3 >= 0; --e3)
                    o2[e3] = o2[e3 + 1] * t2[e3 + 1];
                  const a2 = ["r", "c", "d", "d2"], s2 = o2.map((t3, e3) => `int ${a2[e3]} = index / ${t3}; ${e3 === o2.length - 1 ? `int ${a2[e3 + 1]} = index - ${a2[e3]} * ${t3}` : `index -= ${a2[e3]} * ${t3}`};`).join("");
                  return n2 = `
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e2[0]}, ${e2[1]}));
          int index = resTexRC.y * ${e2[0]} + resTexRC.x;
          ${s2}
          return ivec4(r, c, d, d2);
        }
      `, new i.GlslLibRoutine(n2);
                }
                getOutputUnpacked5DCoords(t2, e2) {
                  let n2 = "";
                  const r2 = t2.length;
                  let o2 = null;
                  r2 < 2 && (o2 = []), o2 = new Array(r2 - 1), o2[r2 - 2] = t2[r2 - 1];
                  for (let e3 = r2 - 3; e3 >= 0; --e3)
                    o2[e3] = o2[e3 + 1] * t2[e3 + 1];
                  const a2 = ["r", "c", "d", "d2", "d3"], s2 = o2.map((t3, e3) => `int ${a2[e3]} = index / ${t3}; ${e3 === o2.length - 1 ? `int ${a2[e3 + 1]} = index - ${a2[e3]} * ${t3}` : `index -= ${a2[e3]} * ${t3}`};`).join("");
                  return n2 = `
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e2[0]}, ${e2[1]}));
          int index = resTexRC.y * ${e2[0]} + resTexRC.x;
          ${s2}
          return ivec5(r, c, d, d2, d3);
        }
      `, new i.GlslLibRoutine(n2);
                }
                getOutputUnpacked6DCoords(t2, e2) {
                  let n2 = "";
                  const r2 = t2.length;
                  let o2 = null;
                  r2 < 2 && (o2 = []), o2 = new Array(r2 - 1), o2[r2 - 2] = t2[r2 - 1];
                  for (let e3 = r2 - 3; e3 >= 0; --e3)
                    o2[e3] = o2[e3 + 1] * t2[e3 + 1];
                  const a2 = ["r", "c", "d", "d2", "d3", "d4"], s2 = o2.map((t3, e3) => `int ${a2[e3]} = index / ${t3}; ${e3 === o2.length - 1 ? `int ${a2[e3 + 1]} = index - ${a2[e3]} * ${t3}` : `index -= ${a2[e3]} * ${t3}`};`).join("");
                  return n2 = `
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${e2[0]}, ${e2[1]}));
         int index = resTexRC.y * ${e2[0]} + resTexRC.x;
         ${s2}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `, new i.GlslLibRoutine(n2);
                }
                getCommonUtilFuncs() {
                  const t2 = {};
                  let e2 = "uvFromFlat";
                  t2[e2] = new i.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "), e2 = "packedUVfrom1D", t2[e2] = new i.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), e2 = "packedUVfrom2D", t2[e2] = new i.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), e2 = "packedUVfrom3D", t2[e2] = new i.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), e2 = "sampleTexture";
                  const n2 = (0, o.getGlsl)(this.context.glContext.version);
                  return t2[e2] = new i.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${n2.texture2D}(textureSampler, uv).r;
        }`), t2;
                }
                getInputsSamplingSnippets() {
                  const t2 = {}, e2 = this.context.outputTextureLayout;
                  return this.context.programInfo.inputNames.forEach((n2, r2) => {
                    const i2 = this.context.inputTextureLayouts[r2], o2 = (0, s.generateShaderFuncNameFromInputSamplerName)(n2);
                    i2.isPacked ? t2[o2] = this.getPackedSamplerFromInput(o2, n2, i2) : t2[o2] = this.getUnpackedSamplerFromInput(o2, n2, i2);
                    const a2 = (0, s.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(n2);
                    i2.unpackedShape.length <= e2.unpackedShape.length && (i2.isPacked ? t2[a2] = this.getPackedSamplerAtOutputCoords(a2, i2, e2, n2) : t2[a2] = this.getUnpackedSamplerAtOutputCoords(a2, i2, e2, n2));
                  }), t2;
                }
                getPackedSamplerAtOutputCoords(t2, e2, n2, o2) {
                  const a2 = e2.unpackedShape, u2 = n2.unpackedShape, c = o2, l = (0, s.generateShaderFuncNameFromInputSamplerName)(c), p = a2.length, f = u2.length, d = r.BroadcastUtil.getBroadcastDims(a2, u2), h = (0, s.getCoordsDataType)(f), g = f - p;
                  let b;
                  const m = (0, s.getGlChannels)();
                  b = 0 === p ? "" : f < 2 && d.length >= 1 ? "coords = 0;" : d.map((t3) => `coords.${m[t3 + g]} = 0;`).join("\n");
                  let y = "";
                  y = f < 2 && p > 0 ? "coords" : a2.map((t3, e3) => `coords.${m[e3 + g]}`).join(", ");
                  let _ = "return outputValue;";
                  const v = 1 === r.ShapeUtil.size(a2), w = 1 === r.ShapeUtil.size(u2);
                  if (1 !== p || v || w) {
                    if (v && !w)
                      _ = 1 === f ? "\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        " : "\n          return vec4(outputValue.x);\n        ";
                    else if (d.length) {
                      const t3 = p - 2, e3 = p - 1;
                      d.indexOf(t3) > -1 && d.indexOf(e3) > -1 ? _ = "return vec4(outputValue.x);" : d.indexOf(t3) > -1 ? _ = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : d.indexOf(e3) > -1 && (_ = "return vec4(outputValue.xx, outputValue.zz);");
                    }
                  } else
                    _ = "\n        return vec4(outputValue.xy, outputValue.xy);\n      ";
                  const x = `
      vec4 ${t2}() {
        ${h} coords = getOutputCoords();
        
        int lastDim = coords.${m[f - 1]};
        coords.${m[f - 1]} = coords.${m[f - 2]};
        coords.${m[f - 2]} = lastDim;
      
        ${b}
        vec4 outputValue = ${l}(${y});
        ${_}
      }
    `;
                  return new i.GlslLibRoutine(x, ["coordinates.getOutputCoords"]);
                }
                getUnpackedSamplerAtOutputCoords(t2, e2, n2, o2) {
                  const a2 = [n2.width, n2.height], u2 = [e2.width, e2.height], c = e2.unpackedShape.length, l = n2.unpackedShape.length, p = e2.unpackedShape, f = n2.unpackedShape, d = (0, s.generateShaderFuncNameFromInputSamplerName)(o2);
                  if (c === l && r.ArrayUtil.arraysEqual(u2, a2)) {
                    const e3 = `
          float ${t2}() {
            return sampleTexture(${o2}, TexCoords);
          }
        `;
                    return new i.GlslLibRoutine(e3, ["coordinates.sampleTexture"]);
                  }
                  const h = (0, s.getCoordsDataType)(l), g = r.BroadcastUtil.getBroadcastDims(p, f), b = l - c;
                  let m;
                  const y = (0, s.getGlChannels)();
                  m = 0 === c ? "" : l < 2 && g.length >= 1 ? "coords = 0;" : g.map((t3) => `coords.${y[t3 + b]} = 0;`).join("\n");
                  let _ = "";
                  _ = l < 2 && c > 0 ? "coords" : e2.unpackedShape.map((t3, e3) => `coords.${y[e3 + b]}`).join(", ");
                  const v = `
        float ${t2}() {
          ${h} coords = getOutputCoords();
          ${m}
          return ${d}(${_});
        }
      `;
                  return new i.GlslLibRoutine(v, ["coordinates.getOutputCoords"]);
                }
                getPackedSamplerFromInput(t2, e2, n2) {
                  switch (n2.unpackedShape.length) {
                    case 0:
                      return this.getPackedSamplerScalar(t2, e2);
                    case 1:
                      return this.getPackedSampler1D(t2, e2, n2);
                    case 2:
                      return this.getPackedSampler2D(t2, e2, n2);
                    case 3:
                      return this.getPackedSampler3D(t2, e2, n2);
                    default:
                      return this.getPackedSamplerND(t2, e2, n2);
                  }
                }
                getUnpackedSamplerFromInput(t2, e2, n2) {
                  const r2 = n2.unpackedShape;
                  switch (r2.length) {
                    case 0:
                      return this.getUnpackedSamplerScalar(t2, e2, n2);
                    case 1:
                      return this.getUnpackedSampler1D(t2, e2, n2);
                    case 2:
                      return this.getUnpackedSampler2D(t2, e2, n2);
                    case 3:
                      return this.getUnpackedSampler3D(t2, e2, n2);
                    case 4:
                      return this.getUnpackedSampler4D(t2, e2, n2);
                    case 5:
                      return this.getUnpackedSampler5D(t2, e2, n2);
                    case 6:
                      return this.getUnpackedSampler6D(t2, e2, n2);
                    default:
                      throw new Error(`Unsupported dimension ${r2.length}-D`);
                  }
                }
                getPackedSamplerScalar(t2, e2) {
                  const n2 = `
          vec4 ${t2}() {
            return ${(0, o.getGlsl)(this.context.glContext.version).texture2D}(${e2}, halfCR);
          }
        `;
                  return new i.GlslLibRoutine(n2);
                }
                getPackedSampler1D(t2, e2, n2) {
                  const r2 = [n2.width, n2.height], a2 = [r2[1], r2[0]], s2 = (0, o.getGlsl)(this.context.glContext.version), u2 = `vec4 ${t2}(int index) {
      vec2 uv = packedUVfrom1D(
      ${a2[0]}, ${a2[1]}, index);
      return ${s2.texture2D}(${e2}, uv);
    }`;
                  return new i.GlslLibRoutine(u2, ["coordinates.packedUVfrom1D"]);
                }
                getPackedSampler2D(t2, e2, n2) {
                  const a2 = n2.unpackedShape, s2 = [n2.width, n2.height], u2 = (0, o.getGlsl)(this.context.glContext.version), c = s2[0], l = s2[1];
                  if (null != s2 && r.ArrayUtil.arraysEqual(a2, s2)) {
                    const n3 = `vec4 ${t2}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${c}.0);
        return ${u2.texture2D}(${e2}, uv);
      }`;
                    return new i.GlslLibRoutine(n3);
                  }
                  const p = s2, f = Math.ceil(a2[1] / 2), d = `vec4 ${t2}(int row, int col) {
      vec2 uv = packedUVfrom2D(${p[1]}, ${p[0]}, ${f}, row, col);
      return ${u2.texture2D}(${e2}, uv);
    }`;
                  return new i.GlslLibRoutine(d, ["coordinates.packedUVfrom2D"]);
                }
                getPackedSampler3D(t2, e2, n2) {
                  const r2 = n2.unpackedShape, a2 = [n2.width, n2.height], u2 = [a2[0], a2[1]], c = (0, o.getGlsl)(this.context.glContext.version);
                  if (1 === r2[0]) {
                    const o2 = r2.slice(1), a3 = [1, 2], u3 = (0, s.squeezeInputShape)(r2, o2), c2 = ["b", "row", "col"], l2 = JSON.parse(JSON.stringify(n2));
                    l2.unpackedShape = u3;
                    const p2 = this.getPackedSamplerFromInput(t2, e2, l2), f2 = `${p2.routineBody}
      vec4 ${t2}(int b, int row, int col) {
        return ${t2}(${(0, s.getSqueezedParams)(c2, a3)});
      } `;
                    return new i.GlslLibRoutine(f2, p2.dependencies);
                  }
                  const l = u2[0], p = u2[1], f = Math.ceil(r2[2] / 2), d = `vec4 ${t2}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${p}, ${l}, ${f * Math.ceil(r2[1] / 2)}, ${f}, b, row, col);
      return ${c.texture2D}(${e2}, uv);}`;
                  return new i.GlslLibRoutine(d, ["coordinates.packedUVfrom3D"]);
                }
                getPackedSamplerND(t2, e2, n2) {
                  const r2 = n2.unpackedShape, a2 = r2.length, s2 = [n2.width, n2.height], u2 = (0, o.getGlsl)(this.context.glContext.version), c = [s2[0], s2[1]], l = c[1], p = c[0], f = Math.ceil(r2[a2 - 1] / 2);
                  let d = f * Math.ceil(r2[a2 - 2] / 2), h = "int b, int row, int col", g = `b * ${d} + (row / 2) * ${f} + (col / 2)`;
                  for (let t3 = 2; t3 < a2 - 1; t3++)
                    h = `int b${t3}, ` + h, d *= r2[a2 - t3 - 1], g = `b${t3} * ${d} + ` + g;
                  const b = `vec4 ${t2}(${h}) {
      int index = ${g};
      int texR = index / ${p};
      int texC = index - texR * ${p};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${l});
      return ${u2.texture2D}(${e2}, uv);
    }`;
                  return new i.GlslLibRoutine(b);
                }
                getUnpackedSamplerScalar(t2, e2, n2) {
                  const [r2, o2] = [n2.width, n2.height];
                  if (1 === r2 && 1 === o2) {
                    const n3 = `
          float ${t2}() {
            return sampleTexture(${e2}, halfCR);
          }
        `;
                    return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
                  }
                  const a2 = `
        float ${t2}() {
          int offset_${e2} = coordsToOffset(TexCoords, ${r2}, ${o2});
          vec2 uv = uvFromFlat(${r2}, ${o2}, offset_${e2});
          return sampleTexture(${e2}, uv);
        }
      `;
                  return new i.GlslLibRoutine(a2, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
                }
                getUnpackedSampler1D(t2, e2, n2) {
                  const r2 = n2.width, o2 = n2.height;
                  if (1 === o2 && 1 === r2) {
                    const n3 = `
        float ${t2}(int index) {
          return sampleTexture(${e2}, halfCR);
        }
      `;
                    return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
                  }
                  if (1 === o2) {
                    const n3 = `
          float ${t2}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${r2}.0, 0.5);
            return sampleTexture(${e2}, uv);
          }
        `;
                    return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
                  }
                  if (1 === r2) {
                    const n3 = `
          float ${t2}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${o2}.0);
            return sampleTexture(${e2}, uv);
          }
        `;
                    return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
                  }
                  const a2 = `
        float ${t2}(int index) {
          vec2 uv = uvFromFlat(${r2}, ${o2}, index);
          return sampleTexture(${e2}, uv);
        }
      `;
                  return new i.GlslLibRoutine(a2, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
                }
                getUnpackedSampler2D(t2, e2, n2) {
                  const o2 = n2.unpackedShape, u2 = [n2.height, n2.width];
                  if (null != u2 && r.ArrayUtil.arraysEqual(o2, u2)) {
                    const n3 = `
          float ${t2}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${u2[1]}.0, ${u2[0]}.0);
            return sampleTexture(${e2}, uv);
          }
        `;
                    return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
                  }
                  const { newShape: c, keptDims: l } = (0, a.squeezeShape)(o2), p = c;
                  if (p.length < o2.length) {
                    const r2 = (0, s.squeezeInputShape)(o2, p), a2 = JSON.parse(JSON.stringify(n2));
                    a2.unpackedShape = r2;
                    const u3 = ["col", "row"], c2 = `
          ${this.getUnpackedSamplerFromInput(t2, e2, a2).routineBody}
          float ${t2}(int row, int col) {
            return ${t2}(${(0, s.getSqueezedParams)(u3, l)});
          }
        `;
                    return new i.GlslLibRoutine(c2, ["coordinates.sampleTexture"]);
                  }
                  const f = u2[1], d = u2[0];
                  if (1 === d) {
                    const n3 = `
          float ${t2}(int row, int col) {
            int offset_${e2} = coordsToOffset(TexCoords, ${f}, ${d});
            float index = dot(vec3(row, col, offset_${e2}), vec3(${o2[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${f}.0);
            return sampleTexture(${e2}, uv);
          }
        `;
                    return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
                  }
                  if (1 === f) {
                    const n3 = `
          float ${t2}(int row, int col) {
            int offset_${e2} = coordsToOffset(TexCoords, ${f}, ${d});
            float index = dot(vec3(row, col, offset_${e2}), vec3(${o2[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);
            return sampleTexture(${e2}, uv);
          }
        `;
                    return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
                  }
                  const h = `
        float ${t2}(int row, int col) {
          int index = col * ${o2[1]} + row;
          vec2 uv = uvFromFlat(${f}, ${d}, index);
          return sampleTexture(${e2}, uv);
        }
      `;
                  return new i.GlslLibRoutine(h, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
                }
                getUnpackedSampler3D(t2, e2, n2) {
                  const r2 = n2.unpackedShape, o2 = r2[1] * r2[2], u2 = r2[2], { newShape: c, keptDims: l } = (0, a.squeezeShape)(r2), p = c;
                  if (p.length < r2.length) {
                    const o3 = (0, s.squeezeInputShape)(r2, p), a2 = ["batch", "col", "row"], u3 = JSON.parse(JSON.stringify(n2));
                    u3.unpackedShape = o3;
                    const c2 = this.getUnpackedSamplerFromInput(t2, e2, u3), f2 = l.reverse(), d = `
          ${c2.routineBody}
          float ${t2}(int batch, int row, int col) {
            return ${t2}(${(0, s.getSqueezedParams)(a2, f2)});
          }
        `;
                    return new i.GlslLibRoutine(d, c2.dependencies);
                  }
                  const f = `
          float ${t2}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${o2} + col * ${u2} + row;
            vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
            return sampleTexture(${e2}, uv);
          }
      `;
                  return new i.GlslLibRoutine(f, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
                }
                getUnpackedSampler4D(t2, e2, n2) {
                  const r2 = n2.unpackedShape, o2 = r2[3], a2 = r2[2] * o2, s2 = `
        float ${t2}(int row, int col, int depth, int depth2) {
          int index = row * ${r2[1] * a2} + col * ${a2} +
              depth2 * ${o2} + depth;
          vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
          return sampleTexture(${e2}, uv);
        }
      `;
                  return new i.GlslLibRoutine(s2, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
                }
                getUnpackedSampler5D(t2, e2, n2) {
                  const r2 = n2.unpackedShape, o2 = r2[4], u2 = r2[3] * o2, c = r2[2] * u2, l = r2[1] * c, { newShape: p, keptDims: f } = (0, a.squeezeShape)(r2);
                  if (p.length < r2.length) {
                    const o3 = (0, s.squeezeInputShape)(r2, p), a2 = ["row", "col", "depth", "depth2", "depth3"], u3 = JSON.parse(JSON.stringify(n2));
                    u3.unpackedShape = o3;
                    const c2 = `
          ${this.getUnpackedSamplerFromInput(t2, e2, u3).routineBody}
          float ${t2}(int row, int col, int depth, int depth2, int depth3) {
            return ${t2}(${(0, s.getSqueezedParams)(a2, f)});
          }
        `;
                    return new i.GlslLibRoutine(c2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
                  }
                  const d = `
        float ${t2}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${l} + col * ${c} + depth * ${u2} +
          depth3 * ${o2} + depth2;
          vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
          return sampleTexture(${e2}, uv);
        }
      `;
                  return new i.GlslLibRoutine(d, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
                }
                getUnpackedSampler6D(t2, e2, n2) {
                  const r2 = n2.unpackedShape, o2 = r2[5], u2 = r2[4] * o2, c = r2[3] * u2, l = r2[2] * c, p = r2[1] * l, { newShape: f, keptDims: d } = (0, a.squeezeShape)(r2);
                  if (f.length < r2.length) {
                    const o3 = (0, s.squeezeInputShape)(r2, f), a2 = ["row", "col", "depth", "depth2", "depth3", "depth4"], u3 = JSON.parse(JSON.stringify(n2));
                    u3.unpackedShape = o3;
                    const c2 = `
            ${this.getUnpackedSamplerFromInput(t2, e2, u3).routineBody}
            float ${t2}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${t2}(${(0, s.getSqueezedParams)(a2, d)});
            }
          `;
                    return new i.GlslLibRoutine(c2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
                  }
                  const h = `
          float ${t2}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${p} + col * ${l} + depth * ${c} +
            depth2 * ${u2} + depth3 * ${o2} + depth4;
            vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
            return sampleTexture(${e2}, uv);
          }
        `;
                  return new i.GlslLibRoutine(h, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
                }
                toVec() {
                  const t2 = this.context.outputTextureLayout, e2 = t2.shape.length, n2 = t2.strides, r2 = t2.width, o2 = t2.height, a2 = [];
                  for (let t3 = 0; t3 < e2 - 1; ++t3)
                    a2.push(`
        c[${t3}] = offset / ${n2[t3]};`), a2.push(`
        offset -= c[${t3}] * ${n2[t3]};`);
                  a2.push(`
        c[${e2 - 1}] = offset;`);
                  const s2 = `
      void toVec(vec2 texCoords, out int c[${e2}]) {
        int offset = coordsToOffset(texCoords, ${r2}, ${o2});
        ${a2.join("")}
      }
      void toVec(int offset, out int c[${e2}]) {
        ${a2.join("")}
      }
    `;
                  return { toVec: new i.GlslLibRoutine(s2, ["coordinates.coordsToOffset"]) };
                }
                valueFrom() {
                  const t2 = {};
                  return this.context.programInfo.inputNames.forEach((e2, n2) => {
                    const r2 = this.context.inputTextureLayouts[n2], o2 = (r2.unpackedShape.length > 0 ? r2.unpackedShape : r2.shape).length;
                    let a2 = `_${e2}`;
                    t2[a2] = new i.GlslLibRoutine(this.getValueFromSingle(e2, o2, r2.width, r2.height, false), [`shapeUtils.indicesToOffset${a2}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]), a2 += "_T", t2[a2] = new i.GlslLibRoutine(this.getValueFromSingle(e2, o2, r2.width, r2.height, true), [`shapeUtils.indicesToOffset${a2}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]);
                  }), t2;
                }
                getValueFromSingle(t2, e2, n2, r2, i2) {
                  let a2 = `_${t2}`;
                  return i2 && (a2 += "_T"), `
        float ${a2}(int m[${e2}]) {
          int offset = indicesToOffset${a2}(m);
          vec2 coords = offsetToCoords(offset, ${n2}, ${r2});
          float value = getColorAsFloat(${(0, o.getGlsl)(this.context.glContext.version).texture2D}(${t2}, coords));
          return value;
        }
        `;
                }
                getPackedValueFrom(t2, e2, n2, r2, i2) {
                  let a2 = `_${t2}_Pack`;
                  return i2 && (a2 += "_T"), `
        vec4 ${a2}(int m[${e2}]) {
          int offset = indicesToOffset_${t2}(m);
          vec2 coords = offsetToCoords(offset, ${n2}, ${r2});
          return ${(0, o.getGlsl)(this.context.glContext.version).texture2D}(${t2}, coords);
        }
        `;
                }
              }
              e.CoordsGlslLib = u;
            }, 8520: (t, e) => {
              "use strict";
              var n;
              Object.defineProperty(e, "__esModule", { value: true }), e.TopologicalSortGlslRoutines = e.GlslLibRoutineNode = e.GlslLibRoutine = e.GlslLib = e.GlslContext = e.FunctionType = void 0, (n = e.FunctionType || (e.FunctionType = {}))[n.ValueBased = 0] = "ValueBased", n[n.Positional = 1] = "Positional", e.GlslContext = class {
                constructor(t2, e2, n2, r) {
                  this.glContext = t2, this.programInfo = e2, this.inputTextureLayouts = n2, this.outputTextureLayout = r;
                }
              }, e.GlslLib = class {
                constructor(t2) {
                  this.context = t2;
                }
              }, e.GlslLibRoutine = class {
                constructor(t2, e2) {
                  this.routineBody = t2, this.dependencies = e2;
                }
              }, e.GlslLibRoutineNode = class {
                constructor(t2, e2, n2) {
                  this.name = t2, this.dependencies = n2 || [], e2 && (this.routineBody = e2);
                }
                addDependency(t2) {
                  t2 && this.dependencies.push(t2);
                }
              }, e.TopologicalSortGlslRoutines = class {
                static returnOrderedNodes(t2) {
                  if (!t2 || 0 === t2.length)
                    return [];
                  if (1 === t2.length)
                    return t2;
                  const e2 = /* @__PURE__ */ new Set(), n2 = /* @__PURE__ */ new Set(), r = new Array();
                  return this.createOrderedNodes(t2, e2, n2, r), r;
                }
                static createOrderedNodes(t2, e2, n2, r) {
                  for (let i = 0; i < t2.length; ++i)
                    this.dfsTraverse(t2[i], e2, n2, r);
                }
                static dfsTraverse(t2, e2, n2, r) {
                  if (!t2 || n2.has(t2.name))
                    return;
                  if (e2.has(t2.name))
                    throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");
                  e2.add(t2.name);
                  const i = t2.dependencies;
                  if (i && i.length > 0)
                    for (let t3 = 0; t3 < i.length; ++t3)
                      this.dfsTraverse(i[t3], e2, n2, r);
                  r.push(t2), n2.add(t2.name), e2.delete(t2.name);
                }
              };
            }, 7341: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.EncodingGlslLib = void 0;
              const r = n(8520);
              class i extends r.GlslLib {
                constructor(t2) {
                  super(t2);
                }
                getFunctions() {
                  return Object.assign(Object.assign({}, this.encodeFloat32()), this.decodeFloat32());
                }
                getCustomTypes() {
                  return {};
                }
                encodeFloat32() {
                  return { encode: new r.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ") };
                }
                decodeFloat32() {
                  return { decode: new r.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ") };
                }
                encodeUint8() {
                  const t2 = i.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
                  return { encode: new r.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${t2}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `) };
                }
                decodeUint8() {
                  const t2 = i.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
                  return { decode: new r.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${t2}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `) };
                }
                static isLittleEndian() {
                  const t2 = new ArrayBuffer(4), e2 = new Uint32Array(t2), n2 = new Uint8Array(t2);
                  if (e2[0] = 3735928559, 239 === n2[0])
                    return true;
                  if (222 === n2[0])
                    return false;
                  throw new Error("unknown endianness");
                }
              }
              e.EncodingGlslLib = i;
            }, 9894: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.FragColorGlslLib = void 0;
              const r = n(8520), i = n(5060);
              class o extends r.GlslLib {
                constructor(t2) {
                  super(t2);
                }
                getFunctions() {
                  return Object.assign(Object.assign({}, this.setFragColor()), this.getColorAsFloat());
                }
                getCustomTypes() {
                  return {};
                }
                setFragColor() {
                  const t2 = (0, i.getGlsl)(this.context.glContext.version);
                  return { setFragColor: new r.GlslLibRoutine(`
        void setFragColor(float value) {
            ${t2.output} = encode(value);
        }
        `, ["encoding.encode"]) };
                }
                getColorAsFloat() {
                  return { getColorAsFloat: new r.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ", ["encoding.decode"]) };
                }
              }
              e.FragColorGlslLib = o;
            }, 2848: (t, e) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.replaceInlines = void 0;
              const n = /@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;
              e.replaceInlines = function(t2) {
                const e2 = {};
                let r;
                for (; null !== (r = n.exec(t2)); ) {
                  const t3 = r[3].split(",").map((t4) => {
                    const e3 = t4.trim().split(" ");
                    return e3 && 2 === e3.length ? { type: e3[0], name: e3[1] } : null;
                  }).filter((t4) => null !== t4);
                  e2[r[2]] = { params: t3, body: r[4] };
                }
                for (const n2 in e2) {
                  const i = "(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__", n2), o = new RegExp(i, "gm");
                  for (; null !== (r = o.exec(t2)); ) {
                    const i2 = r[1], o2 = r[2], a = r[3].split(","), s = i2 ? `${i2} ${o2};` : "";
                    let u = e2[n2].body, c = "";
                    e2[n2].params.forEach((t3, e3) => {
                      t3 && (c += `${t3.type} ${t3.name} = ${a[e3]};
`);
                    }), u = `${c}
 ${u}`, u = u.replace("return", `${o2} = `);
                    const l = `
      ${s}
      {
        ${u}
      }
      `;
                    t2 = t2.replace(r[0], l);
                  }
                }
                return t2.replace(n, "");
              };
            }, 8879: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.GlslPreprocessor = void 0;
              const r = n(8520), i = n(2848), o = n(5483), a = n(5060);
              e.GlslPreprocessor = class {
                constructor(t2, e2, n2, i2) {
                  this.libs = {}, this.glslLibRoutineDependencyGraph = {}, this.context = new r.GlslContext(t2, e2, n2, i2), Object.keys(o.glslRegistry).forEach((t3) => {
                    const e3 = new o.glslRegistry[t3](this.context);
                    this.libs[t3] = e3;
                  });
                  const a2 = this.glslLibRoutineDependencyGraph;
                  for (const t3 in this.libs) {
                    const e3 = this.libs[t3].getFunctions();
                    for (const n3 in e3) {
                      const i3 = t3 + "." + n3;
                      let o2;
                      a2[i3] ? (o2 = a2[i3], o2.routineBody = e3[n3].routineBody) : (o2 = new r.GlslLibRoutineNode(i3, e3[n3].routineBody), a2[i3] = o2);
                      const s = e3[n3].dependencies;
                      if (s)
                        for (let t4 = 0; t4 < s.length; ++t4)
                          if (a2[s[t4]])
                            o2.addDependency(a2[s[t4]]);
                          else {
                            const e4 = new r.GlslLibRoutineNode(s[t4]);
                            a2[s[t4]] = e4, o2.addDependency(e4);
                          }
                    }
                  }
                }
                preprocess() {
                  const t2 = this.context.programInfo;
                  let e2 = t2.shaderSource;
                  return this.context.programInfo.hasMain || (e2 = `${e2}
      ${(0, a.getDefaultFragShaderMain)(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`), e2 = (0, i.replaceInlines)(e2), `${(0, a.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(t2.inputNames, t2.variables)}
    ${this.getImports(e2)}
    ${e2}`;
                }
                getImports(t2) {
                  const e2 = this.selectGlslLibRoutinesToBeIncluded(t2);
                  if (0 === e2.length)
                    return "";
                  let n2 = "";
                  for (let t3 = 0; t3 < e2.length; ++t3) {
                    if (!e2[t3].routineBody)
                      throw new Error(`Missing body for the Glsl Library routine: ${e2[t3].name}`);
                    n2 += e2[t3].routineBody + "\n";
                  }
                  return n2;
                }
                selectGlslLibRoutinesToBeIncluded(t2) {
                  const e2 = [];
                  return Object.keys(this.glslLibRoutineDependencyGraph).forEach((n2) => {
                    const r2 = n2.split(".")[1];
                    -1 !== t2.indexOf(r2) && e2.push(this.glslLibRoutineDependencyGraph[n2]);
                  }), r.TopologicalSortGlslRoutines.returnOrderedNodes(e2);
                }
                getUniforms(t2, e2) {
                  const n2 = [];
                  if (t2)
                    for (const e3 of t2)
                      n2.push(`uniform sampler2D ${e3};`);
                  if (e2)
                    for (const t3 of e2)
                      n2.push(`uniform ${t3.type} ${t3.name}${t3.arrayLength ? `[${t3.arrayLength}]` : ""};`);
                  return n2.join("\n");
                }
              };
            }, 5483: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.glslRegistry = void 0;
              const r = n(5107), i = n(7341), o = n(9894), a = n(2655), s = n(3891);
              e.glslRegistry = { encoding: i.EncodingGlslLib, fragcolor: o.FragColorGlslLib, vec: s.VecGlslLib, shapeUtils: a.ShapeUtilsGlslLib, coordinates: r.CoordsGlslLib };
            }, 2655: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.ShapeUtilsGlslLib = void 0;
              const r = n(8520);
              class i extends r.GlslLib {
                constructor(t2) {
                  super(t2);
                }
                getFunctions() {
                  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.bcastIndex()), this.bcastMatmulIndex()), this.offsetToIndices()), this.indicesToOffset()), this.incrementIndices());
                }
                getCustomTypes() {
                  return {};
                }
                bcastIndex() {
                  const t2 = this.context.outputTextureLayout.shape.length, e2 = {};
                  return this.context.programInfo.inputNames.forEach((n2, i2) => {
                    const o = this.context.inputTextureLayouts[i2].unpackedShape;
                    if (o.length <= t2) {
                      const i3 = o.length, a = t2 - i3, s = `bcastIndices_${n2}`;
                      let u = "";
                      for (let t3 = 0; t3 < i3; ++t3)
                        u += `
          realIndices[${t3}] = int( mod(float(bcastedIndices[${a + t3}]), ${o[t3]}.0) );
          `;
                      const c = `
        void ${s} (int bcastedIndices[${t2}], out int realIndices[${i3}]) {
          ${u}
        }
        `;
                      e2[s] = new r.GlslLibRoutine(c);
                    }
                  }), e2;
                }
                bcastMatmulIndex() {
                  const t2 = this.context.outputTextureLayout.shape.length, e2 = {};
                  return this.context.programInfo.inputNames.forEach((n2, i2) => {
                    const o = this.context.inputTextureLayouts[i2].shape;
                    if (!(o.length < 2 || o.length > t2)) {
                      const i3 = o.length, a = t2 - i3, s = `bcastMatmulIndices_${n2}`;
                      let u = "";
                      for (let t3 = 0; t3 < i3 - 2; ++t3)
                        u += `
          realIndices[${t3}] = int( mod(float(bcastedIndices[${a + t3}]), ${o[t3]}.0) );
          `;
                      const c = `
        void ${s}(int bcastedIndices[${t2}], out int realIndices[${i3}]) {
          ${u}
          realIndices[${i3 - 1}] = bcastedIndices[${t2 - 1}];
          realIndices[${i3 - 2}] = bcastedIndices[${t2 - 2}];
        }
        `;
                      e2[s] = new r.GlslLibRoutine(c);
                    }
                  }), e2;
                }
                indicesToOffset() {
                  const t2 = {};
                  return this.context.programInfo.inputNames.forEach((e2, n2) => {
                    const o = this.context.inputTextureLayouts[n2].shape, a = this.context.inputTextureLayouts[n2].strides, s = o.length;
                    let u = `indicesToOffset_${e2}`;
                    t2[u] = new r.GlslLibRoutine(i.indexToOffsetSingle(u, s, a)), u = `indicesToOffset_${e2}_T`, t2[u] = new r.GlslLibRoutine(i.indexToOffsetSingle(u, s, a.slice().reverse()));
                  }), t2;
                }
                static indexToOffsetSingle(t2, e2, n2) {
                  let r2 = "";
                  for (let t3 = e2 - 1; t3 >= 0; --t3)
                    r2 += `
        offset += indices[${t3}] * ${n2[t3]};
        `;
                  return `
      int ${t2}(int indices[${e2}]) {
        int offset = 0;
        ${r2}
        return offset;
      }
      `;
                }
                offsetToIndices() {
                  const t2 = {};
                  return this.context.programInfo.inputNames.forEach((e2, n2) => {
                    const o = this.context.inputTextureLayouts[n2].shape, a = this.context.inputTextureLayouts[n2].strides, s = o.length;
                    let u = `offsetToIndices_${e2}`;
                    t2[u] = new r.GlslLibRoutine(i.offsetToIndicesSingle(u, s, a)), u = `offsetToIndices_${e2}_T`, t2[u] = new r.GlslLibRoutine(i.offsetToIndicesSingle(u, s, a.slice().reverse()));
                  }), t2;
                }
                static offsetToIndicesSingle(t2, e2, n2) {
                  const r2 = [];
                  for (let t3 = 0; t3 < e2 - 1; ++t3)
                    r2.push(`
      indices[${t3}] = offset / ${n2[t3]};`), r2.push(`
        offset -= indices[${t3}] * ${n2[t3]};`);
                  return r2.push(`
      indices[${e2 - 1}] = offset;`), `
      void ${t2}(int offset, out int indices[${e2}]) {
        ${r2.join("")}
      }
      `;
                }
                incrementIndices() {
                  const t2 = {};
                  return this.context.programInfo.inputNames.forEach((e2, n2) => {
                    const i2 = this.context.inputTextureLayouts[n2].shape, o = i2.length, a = `incrementIndices_${e2}`;
                    let s = "";
                    for (let t3 = 0; t3 < o; ++t3)
                      s += `
        shape[${t3}] = ${i2[t3]};`;
                    const u = `
        void ${a}(int axis, out int indices[${o}]) {
          int shape[${o}];
          ${s};
          for(int i = ${o} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;
                    t2[a] = new r.GlslLibRoutine(u);
                  }), t2;
                }
              }
              e.ShapeUtilsGlslLib = i;
            }, 5060: (t, e) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.getDefaultFragShaderMain = e.getFragShaderPreamble = e.getVertexShaderSource = e.getGlsl = void 0;
              const n = { version: "", attribute: "attribute", varyingVertex: "varying", varyingFrag: "varying", texture2D: "texture2D", output: "gl_FragColor", outputDeclaration: "" }, r = { version: "#version 300 es", attribute: "in", varyingVertex: "out", varyingFrag: "in", texture2D: "texture", output: "outputColor", outputDeclaration: "out vec4 outputColor;" };
              function i(t2) {
                return 1 === t2 ? n : r;
              }
              e.getGlsl = i, e.getVertexShaderSource = function(t2) {
                const e2 = i(t2);
                return `${e2.version}
      precision highp float;
      ${e2.attribute} vec3 position;
      ${e2.attribute} vec2 textureCoord;

      ${e2.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`;
              }, e.getFragShaderPreamble = function(t2) {
                const e2 = i(t2);
                return `${e2.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e2.varyingFrag} vec2 TexCoords;
    ${e2.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `;
              }, e.getDefaultFragShaderMain = function(t2, e2) {
                return `
  void main() {
    int indices[${e2}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${i(t2).output} = result;
  }
  `;
              };
            }, 3891: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.VecGlslLib = void 0;
              const r = n(8520);
              class i extends r.GlslLib {
                constructor(t2) {
                  super(t2);
                }
                getCustomTypes() {
                  return {};
                }
                getFunctions() {
                  return Object.assign(Object.assign(Object.assign(Object.assign({}, this.binaryVecFunctions()), this.copyVec()), this.setVecItem()), this.getVecItem());
                }
                binaryVecFunctions() {
                  const t2 = this.context.outputTextureLayout.shape.length, e2 = { add: "+=", sub: "-=", mul: "*=", div: "/=" }, n2 = {};
                  for (const i2 in e2) {
                    const o = `${i2}Vec`;
                    let a = "";
                    for (let n3 = 0; n3 < t2; ++n3)
                      a += `
          dest[${n3}] ${e2[i2]} src[${n3}];
          `;
                    const s = `
        void ${o}(int src[${t2}], out int dest[${t2}]) {
          ${a}
        }
        `;
                    n2[o] = new r.GlslLibRoutine(s);
                  }
                  return n2;
                }
                copyVec() {
                  const t2 = this.context.outputTextureLayout.shape.length;
                  let e2 = "";
                  for (let n3 = 0; n3 < t2; ++n3)
                    e2 += `
        dest[${n3}] = src[${n3}];
        `;
                  const n2 = `
      void copyVec(int src[${t2}], out int dest[${t2}]) {
        ${e2}
      }
      `;
                  return { copyVec: new r.GlslLibRoutine(n2) };
                }
                setVecItem() {
                  const t2 = this.context.outputTextureLayout.shape.length;
                  let e2 = `
        if(index < 0)
            index =${t2} + index;
        if (index == 0)
            m[0] = value;
        `;
                  for (let n3 = 1; n3 < t2 - 1; ++n3)
                    e2 += `
        else if (index == ${n3})
            m[${n3}] = value;
            `;
                  e2 += `
        else
            m[${t2 - 1}] = value;
        `;
                  const n2 = `
      void setVecItem(out int m[${t2}], int index, int value) {
        ${e2}
      }
        `;
                  return { setVecItem: new r.GlslLibRoutine(n2) };
                }
                getVecItem() {
                  const t2 = this.context.outputTextureLayout.shape.length;
                  let e2 = `
        if(index < 0)
            index = ${t2} + index;
        if (index == 0)
            return m[0];
      `;
                  for (let n3 = 1; n3 < t2 - 1; ++n3)
                    e2 += `
        else if (index == ${n3})
            return m[${n3}];
      `;
                  e2 += `
        else
            return m[${t2 - 1}];
        `;
                  const n2 = `
      int getVecItem(int m[${t2}], int index) {
        ${e2}
      }
    `;
                  return { getVecItem: new r.GlslLibRoutine(n2) };
                }
              }
              e.VecGlslLib = i;
            }, 8316: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.WebGLInferenceHandler = void 0;
              const r = n(6231), i = n(9162), o = n(2517), a = n(2403), s = n(7019), u = n(8710), c = n(5611), l = n(4057), p = n(2039);
              e.WebGLInferenceHandler = class {
                constructor(t2) {
                  this.session = t2, this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
                }
                calculateTextureWidthAndHeight(t2, e2) {
                  return (0, l.calculateTextureWidthAndHeight)(this.session.layoutStrategy, t2, e2);
                }
                executeProgram(t2, e2) {
                  if (e2.length < t2.inputNames.length)
                    throw new Error(`Input size mustn't be less than ${t2.inputNames.length}.`);
                  if (t2.inputNames.length !== t2.inputTypes.length)
                    throw new Error("input names size does not match input types");
                  const n2 = [];
                  for (let r3 = 0; r3 < t2.inputNames.length; ++r3)
                    n2[r3] = this.getOrCreateTextureData(e2[r3], t2.inputTypes[r3]);
                  const r2 = ((t3, e3) => {
                    const n3 = e3.map((t4) => `${t4.unpackedShape.join(",")};${t4.width}x${t4.height}`).join("_");
                    let r3 = t3.name;
                    return t3.cacheHint && (r3 += "[" + t3.cacheHint + "]"), r3 += ":" + n3, r3;
                  })(t2, n2);
                  let i2 = this.session.programManager.getArtifact(r2);
                  const o2 = i2 ? i2.programInfo : "function" == typeof t2.get ? t2.get() : t2, a2 = (0, l.createTextureLayoutFromTextureType)(this.session.layoutStrategy, o2.output.dims, o2.output.textureType), s2 = this.createTextureData(a2, o2.output.type);
                  return i2 || (i2 = this.session.programManager.build(o2, n2, s2), this.session.programManager.setArtifact(r2, i2)), this.runProgram(i2, n2, s2), s2;
                }
                run(t2, e2) {
                  return this.executeProgram(t2, e2).tensor;
                }
                runProgram(t2, e2, n2) {
                  for (let n3 = 0; n3 < e2.length; ++n3)
                    if (!!e2[n3].isPacked != (t2.programInfo.inputTypes[n3] === p.TextureType.packed))
                      throw new Error(`input[${n3}] property packed inconsistent`);
                  if (!!n2.isPacked != (t2.programInfo.output.textureType === p.TextureType.packed))
                    throw new Error("output property packed inconsistent");
                  this.session.programManager.run(t2, e2, n2);
                }
                getOrCreateTextureData(t2, e2) {
                  let n2 = this.getTextureData(t2.dataId, e2 === p.TextureType.packed);
                  if (!n2 && (n2 = this.getTextureData(t2.dataId, e2 !== p.TextureType.packed), n2))
                    return e2 === p.TextureType.packed ? this.pack(n2) : this.unpack(n2);
                  if (!n2) {
                    const r2 = (0, l.createTextureLayoutFromTextureType)(this.session.layoutStrategy, t2.dims, e2);
                    if (e2 === p.TextureType.packedLastDimension) {
                      const n3 = 1, r3 = 4, i2 = t2.dims;
                      if (4 === i2.length) {
                        const o2 = [i2[0], Math.ceil(i2[1] * i2[2] * i2[3] / r3)], a2 = (0, l.createTextureLayoutFromTextureType)(this.session.layoutStrategy, o2, e2);
                        let s2 = t2.numberData;
                        if (i2[1] * i2[2] * i2[3] % r3 != 0) {
                          const e3 = i2[0], o3 = i2[1] * i2[2] * i2[3], a3 = Math.ceil(o3 * n3 / r3) * r3;
                          s2 = new Float32Array(e3 * a3);
                          for (let r4 = 0; r4 < e3; ++r4) {
                            const e4 = r4 * o3, i3 = r4 * a3 + r4 % n3 * o3;
                            s2.set(t2.numberData.subarray(e4, e4 + o3), i3);
                          }
                        }
                        return this.createTextureData(a2, t2.type, s2, t2, 1);
                      }
                    }
                    if (e2 === p.TextureType.packed) {
                      const e3 = (0, l.createTextureLayoutFromShape)(this.session.layoutStrategy, t2.dims, 1, [], { reverseWH: true }), r3 = this.createTextureData(e3, t2.type, t2.numberData, t2, 1);
                      n2 = this.pack(r3);
                    } else
                      n2 = this.createTextureData(r2, t2.type, t2.numberData, t2, 1);
                  }
                  return n2;
                }
                createTextureDataFromLayoutBindTensor(t2, e2, n2, r2) {
                  return this.createTextureData(t2, e2, n2, r2, 1);
                }
                createTextureData(t2, e2, n2, i2, o2) {
                  r.Logger.verbose("InferenceHandler", `Creating TextureData: layout:[${JSON.stringify(t2)}]`);
                  const a2 = this.session.textureManager.createTextureFromLayout(e2, t2, n2, o2);
                  return this.createTextureDataFromTexture(t2, e2, a2, i2);
                }
                reshapeUnpacked(t2, e2) {
                  const n2 = this.getOrCreateTextureData(t2, p.TextureType.unpacked), r2 = { channels: n2.channels, height: n2.height, width: n2.width, shape: 0 !== e2.length ? e2 : [1], strides: o.ShapeUtil.computeStrides(e2), unpackedShape: e2 };
                  return this.createTextureDataFromTexture(r2, t2.type, n2.texture).tensor;
                }
                reshapePacked(t2, e2) {
                  const n2 = this.getOrCreateTextureData(t2, p.TextureType.packed);
                  if ((0, s.isReshapeCheap)(t2.dims, e2)) {
                    const r3 = { channels: n2.channels, height: n2.height, width: n2.width, shape: 0 !== e2.length ? e2 : [1], strides: o.ShapeUtil.computeStrides(e2), unpackedShape: e2, isPacked: true };
                    return this.createTextureDataFromTexture(r3, t2.type, n2.texture).tensor;
                  }
                  const r2 = (0, s.processDims3D)(t2.dims), i2 = (0, s.processDims3D)(e2), a2 = this.reshapePacked(t2, r2), u2 = this.run((0, s.createPackedReshape3DProgramInfoLoader)(this, a2, i2), [a2]);
                  return this.reshapePacked(u2, e2);
                }
                cast(t2, e2) {
                  const n2 = this.getOrCreateTextureData(t2, p.TextureType.unpacked);
                  return this.createTextureDataFromTexture(n2, e2, n2.texture).tensor;
                }
                createTextureDataFromTexture(t2, e2, n2, r2, o2) {
                  const a2 = Object.assign(Object.assign({}, t2), { tensor: r2 || new i.Tensor(t2.unpackedShape, e2, (t3) => this.readTexture(a2), async (t3) => this.readTextureAsync(a2), void 0, o2), texture: n2 });
                  return this.setTextureData(a2.tensor.dataId, a2, t2.isPacked), a2;
                }
                getTextureData(t2, e2 = false) {
                  return this.session.isInitializer(t2) ? this.session.getTextureData(t2, e2) : e2 ? this.packedTextureDataCache.get(t2) : this.unpackedTextureDataCache.get(t2);
                }
                setTextureData(t2, e2, n2 = false) {
                  this.session.isInitializer(t2) ? this.session.setTextureData(t2, e2, n2) : (n2 ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(t2, e2);
                }
                isTextureLayoutCached(t2, e2 = false) {
                  return !!this.getTextureData(t2.dataId, e2);
                }
                dispose() {
                  this.session.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((t2) => this.session.textureManager.releaseTexture(t2)), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache.forEach((t2) => this.session.textureManager.releaseTexture(t2)), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
                }
                readTexture(t2) {
                  return t2.isPacked ? this.readTexture(this.unpack(t2)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTexture(t2, t2.tensor.type, t2.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u.encodeAsUint8)(this, t2));
                }
                async readTextureAsync(t2) {
                  return t2.isPacked ? this.readTextureAsync(this.unpack(t2)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTextureAsync(t2, t2.tensor.type, t2.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u.encodeAsUint8)(this, t2));
                }
                pack(t2) {
                  return this.executeProgram((0, a.createPackProgramInfoLoader)(this, t2.tensor), [t2.tensor]);
                }
                unpack(t2) {
                  return this.executeProgram((0, c.createUnpackProgramInfoLoader)(this, t2.tensor), [t2.tensor]);
                }
              };
            }, 1640: function(t, e, n) {
              "use strict";
              var r = this && this.__createBinding || (Object.create ? function(t2, e2, n2, r2) {
                void 0 === r2 && (r2 = n2);
                var i2 = Object.getOwnPropertyDescriptor(e2, n2);
                i2 && !("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
                  return e2[n2];
                } }), Object.defineProperty(t2, r2, i2);
              } : function(t2, e2, n2, r2) {
                void 0 === r2 && (r2 = n2), t2[r2] = e2[n2];
              }), i = this && this.__setModuleDefault || (Object.create ? function(t2, e2) {
                Object.defineProperty(t2, "default", { enumerable: true, value: e2 });
              } : function(t2, e2) {
                t2.default = e2;
              }), o = this && this.__importStar || function(t2) {
                if (t2 && t2.__esModule)
                  return t2;
                var e2 = {};
                if (null != t2)
                  for (var n2 in t2)
                    "default" !== n2 && Object.prototype.hasOwnProperty.call(t2, n2) && r(e2, t2, n2);
                return i(e2, t2), e2;
              };
              Object.defineProperty(e, "__esModule", { value: true }), e.WEBGL_OP_RESOLVE_RULES = void 0;
              const a = n(2898), s = o(n(7839)), u = n(4196), c = n(2069), l = n(8138), p = n(9663), f = n(5193), d = n(7992), h = n(1253), g = n(4776), b = n(6572), m = n(3346), y = n(5623), _ = n(2870), v = n(2143), w = n(4939), x = n(718), T = n(2268), S = n(8117), O = n(2278), A = n(5524), E = n(5975), I = n(3933), P = n(6558), D = n(5723), $ = n(3738), k = o(n(4909)), C = n(8428), F = n(9793);
              e.WEBGL_OP_RESOLVE_RULES = [["Abs", "", "6+", k.abs], ["Acos", "", "7+", k.acos], ["Add", "", "7+", s.add], ["And", "", "7+", s.and], ["Asin", "", "7+", k.asin], ["Atan", "", "7+", k.atan], ["AveragePool", "", "7+", v.averagePool, v.parseAveragePoolAttributes], ["BatchNormalization", "", "7+", a.batchNormalization, a.parseBatchNormalizationAttributes], ["Cast", "", "6+", u.cast, u.parseCastAttributes], ["Ceil", "", "6+", k.ceil], ["Clip", "", "6-10", k.clip, k.parseClipAttributes], ["Clip", "", "11+", k.clipV11], ["Concat", "", "4+", c.concat, c.parseConcatAttributes], ["Conv", "", "1+", l.conv, l.parseConvAttributes], ["ConvTranspose", "", "1+", p.convTranspose, p.parseConvTransposeAttributes], ["Cos", "", "7+", k.cos], ["Div", "", "7+", s.div], ["Dropout", "", "7+", k.identity], ["DepthToSpace", "", "1+", f.depthToSpace, f.parseDepthToSpaceAttributes], ["Equal", "", "7+", s.equal], ["Elu", "", "6+", k.elu, k.parseEluAttributes], ["Exp", "", "6+", k.exp], ["Flatten", "", "1+", d.flatten, d.parseFlattenAttributes], ["Floor", "", "6+", k.floor], ["FusedConv", "com.microsoft", "1+", l.conv, l.parseConvAttributes], ["Gather", "", "1+", h.gather, h.parseGatherAttributes], ["Gemm", "", "7-10", g.gemm, g.parseGemmAttributesV7], ["Gemm", "", "11+", g.gemm, g.parseGemmAttributesV11], ["GlobalAveragePool", "", "1+", v.globalAveragePool, v.parseGlobalAveragePoolAttributes], ["GlobalMaxPool", "", "1+", v.globalMaxPool], ["Greater", "", "7+", s.greater], ["Identity", "", "1+", k.identity], ["ImageScaler", "", "1+", b.imageScaler, b.parseImageScalerAttributes], ["InstanceNormalization", "", "6+", m.instanceNormalization, m.parseInstanceNormalizationAttributes], ["LeakyRelu", "", "6+", k.leakyRelu, k.parseLeakyReluAttributes], ["Less", "", "7+", s.less], ["Log", "", "6+", k.log], ["MatMul", "", "1+", y.matMul, y.parseMatMulAttributes], ["MaxPool", "", "1+", v.maxPool, v.parseMaxPoolAttributes], ["Mul", "", "7+", s.mul], ["Neg", "", "6+", k.neg], ["Not", "", "1+", k.not], ["Or", "", "7+", s.or], ["Pad", "", "2-10", _.padV2, _.parsePadAttributesV2], ["Pad", "", "11+", _.padV11, _.parsePadAttributesV11], ["Pow", "", "7+", s.pow], ["PRelu", "", "7+", s.pRelu], ["ReduceLogSum", "", "1+", w.reduceLogSum, w.parseReduceAttributes], ["ReduceMax", "", "1+", w.reduceMax, w.parseReduceAttributes], ["ReduceMean", "", "1+", w.reduceMean, w.parseReduceAttributes], ["ReduceMin", "", "1+", w.reduceMin, w.parseReduceAttributes], ["ReduceProd", "", "1+", w.reduceProd, w.parseReduceAttributes], ["ReduceSum", "", "1-12", w.reduceSum, w.parseReduceAttributes], ["ReduceSumSquare", "", "1+", w.reduceLogSumSquare, w.parseReduceAttributes], ["Relu", "", "6+", k.relu], ["Reshape", "", "5+", x.reshape], ["Resize", "", "10", T.resize, T.parseResizeAttributesV10], ["Resize", "", "11+", T.resize, T.parseResizeAttributesV11], ["Shape", "", "1+", S.shape], ["Sigmoid", "", "6+", k.sigmoid], ["Sin", "", "7+", k.sin], ["Slice", "", "10+", O.sliceV10], ["Slice", "", "1-9", O.slice, O.parseSliceAttributes], ["Softmax", "", "1-12", A.softmax, A.parseSoftmaxAttributes], ["Softmax", "", "13+", A.softmaxV13, A.parseSoftmaxAttributesV13], ["Split", "", "2-12", E.split, E.parseSplitAttributes], ["Sqrt", "", "6+", k.sqrt], ["Squeeze", "", "1-12", I.squeeze, I.parseSqueezeAttributes], ["Squeeze", "", "13+", I.squeezeV13], ["Sub", "", "7+", s.sub], ["Sum", "", "6+", P.sum], ["Tan", "", "7+", k.tan], ["Tanh", "", "6+", k.tanh], ["Tile", "", "6+", D.tile], ["Transpose", "", "1+", $.transpose, $.parseTransposeAttributes], ["Upsample", "", "7-8", F.upsample, F.parseUpsampleAttributesV7], ["Upsample", "", "9", F.upsample, F.parseUpsampleAttributesV9], ["Unsqueeze", "", "1-12", C.unsqueeze, C.parseUnsqueezeAttributes], ["Unsqueeze", "", "13+", C.unsqueezeV13], ["Xor", "", "7+", s.xor]];
            }, 2898: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.parseBatchNormalizationAttributes = e.batchNormalization = void 0;
              const r = n(246), i = n(5060), o = n(2039), a = { name: "BatchNormalization", inputNames: ["A", "Scale", "B", "Mean", "Variance"], inputTypes: [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] };
              e.batchNormalization = (t2, e2, n2) => (u(e2), [t2.run(Object.assign(Object.assign({}, a), { cacheHint: n2.cacheKey, get: () => s(t2, e2, n2) }), e2)]), e.parseBatchNormalizationAttributes = (t2) => {
                const e2 = t2.attributes.getFloat("epsilon", 1e-5), n2 = t2.attributes.getFloat("momentum", 0.9), i2 = t2.attributes.getInt("spatial", 1);
                return (0, r.createAttributeWithCacheKey)({ epsilon: e2, momentum: n2, spatial: i2 });
              };
              const s = (t2, e2, n2) => {
                const r2 = (0, i.getGlsl)(t2.session.backend.glContext.version), s2 = e2[0].dims.length, [u2, c] = t2.calculateTextureWidthAndHeight(e2[1].dims, o.TextureType.unpacked), l = `
  float process(int[${s2}] indices) {
    vec2 position = offsetToCoords(indices[1], ${u2}, ${c});
    float scale = getColorAsFloat(${r2.texture2D}(Scale, position));
    float mean = getColorAsFloat(${r2.texture2D}(Mean, position));
    float variance = getColorAsFloat(${r2.texture2D}(Variance, position));
    float b = getColorAsFloat(${r2.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n2.epsilon})) ) + b;
  }`;
                return Object.assign(Object.assign({}, a), { output: { dims: e2[0].dims, type: e2[0].type, textureType: o.TextureType.unpacked }, shaderSource: l });
              }, u = (t2) => {
                if (!t2 || 5 !== t2.length)
                  throw new Error("BatchNormalization requires 5 inputs.");
                const e2 = t2[0], n2 = t2[1], r2 = t2[2], i2 = t2[3], o2 = t2[4];
                if (e2.dims.length < 3 || 1 !== n2.dims.length || 1 !== r2.dims.length || 1 !== i2.dims.length || 1 !== o2.dims.length)
                  throw new Error("invalid input shape.");
                if (n2.dims[0] !== e2.dims[1] || r2.dims[0] !== e2.dims[1] || i2.dims[0] !== e2.dims[1] || o2.dims[0] !== e2.dims[1])
                  throw new Error("invalid input shape.");
                if ("float32" !== e2.type && "float64" !== e2.type || "float32" !== n2.type && "float64" !== n2.type || "float32" !== r2.type && "float64" !== r2.type || "float32" !== i2.type && "float64" !== i2.type || "float32" !== o2.type && "float64" !== o2.type)
                  throw new Error("invalid input tensor types.");
              };
            }, 7839: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.xor = e.sub = e.pRelu = e.pow = e.or = e.mul = e.less = e.greater = e.equal = e.div = e.and = e.add = e.glslPRelu = e.glslPow = e.glslXor = e.glslOr = e.glslAnd = e.glslLess = e.glslGreater = e.glslEqual = e.glslSub = e.glslMul = e.glslDiv = e.glslAdd = void 0;
              const r = n(2517), i = n(8520), o = n(5060), a = n(2039);
              function s() {
                const t2 = "add_";
                return { body: `
  float ${t2}(float a, float b) {
    return a + b;
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `, name: t2, type: i.FunctionType.ValueBased };
              }
              function u() {
                const t2 = "div_";
                return { body: `
  float ${t2}(float a, float b) {
    return a / b;
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `, name: t2, type: i.FunctionType.ValueBased };
              }
              function c() {
                const t2 = "mul_";
                return { body: `
  float ${t2}(float a, float b) {
    return a * b;
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `, name: t2, type: i.FunctionType.ValueBased };
              }
              function l() {
                const t2 = "sub_";
                return { body: `
  float ${t2}(float a, float b) {
    return a - b;
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `, name: t2, type: i.FunctionType.ValueBased };
              }
              function p() {
                const t2 = "equal_";
                return { body: `
  float ${t2}(float a, float b) {
    return float(a == b);
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `, name: t2, type: i.FunctionType.ValueBased };
              }
              function f() {
                const t2 = "greater_";
                return { body: `
  float ${t2}(float a, float b) {
    return float(a > b);
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `, name: t2, type: i.FunctionType.ValueBased };
              }
              function d() {
                const t2 = "less_";
                return { body: `
  float ${t2}(float a, float b) {
    return float(a < b);
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `, name: t2, type: i.FunctionType.ValueBased };
              }
              function h() {
                const t2 = "and_";
                return { body: `
  float ${t2}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `, name: t2, type: i.FunctionType.ValueBased };
              }
              function g() {
                const t2 = "or_";
                return { body: `
  float ${t2}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `, name: t2, type: i.FunctionType.ValueBased };
              }
              function b() {
                const t2 = "xor_";
                return { body: `
  float ${t2}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `, name: t2, type: i.FunctionType.ValueBased };
              }
              function m() {
                return function(t2) {
                  const e2 = `${t2}_`;
                  return { body: `
  float ${e2}(float a, float b) {
    return ${t2}(a, b);
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return ${t2}(v1, v2);
  }
  `, name: e2, type: i.FunctionType.ValueBased };
                }("pow");
              }
              function y() {
                const t2 = "prelu_";
                return { body: `
  float ${t2}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `, name: t2, type: i.FunctionType.ValueBased };
              }
              e.glslAdd = s, e.glslDiv = u, e.glslMul = c, e.glslSub = l, e.glslEqual = p, e.glslGreater = f, e.glslLess = d, e.glslAnd = h, e.glslOr = g, e.glslXor = b, e.glslPow = m, e.glslPRelu = y;
              const _ = (t2, e2, n2, r2 = e2[0].type, i2) => {
                const o2 = t2.session.pack ? a.TextureType.packed : a.TextureType.unpacked;
                return { name: n2.name, inputNames: ["A", "B"], inputTypes: [o2, o2], cacheHint: i2, get: () => v(t2, e2, n2, r2) };
              }, v = (t2, e2, n2, i2 = e2[0].type) => {
                const s2 = t2.session.pack ? a.TextureType.packed : a.TextureType.unpacked, u2 = !r.ShapeUtil.areEqual(e2[0].dims, e2[1].dims);
                let c2 = e2[0].dims;
                const l2 = t2.session.pack;
                if (u2) {
                  const a2 = r.BroadcastUtil.calcShape(e2[0].dims, e2[1].dims, false);
                  if (!a2)
                    throw new Error("Can't perform binary op on the given tensors");
                  c2 = a2;
                  const u3 = c2.length, p3 = 0 !== e2[0].dims.length ? e2[0].dims.length : 1, f3 = 0 !== e2[1].dims.length ? e2[1].dims.length : 1, d2 = 0 !== e2[0].dims.length ? "bcastIndices_A(indices, aindices);" : "aindices[0] = 0;", h2 = 0 !== e2[1].dims.length ? "bcastIndices_B(indices, bindices);" : "bindices[0] = 0;", g2 = (0, o.getGlsl)(t2.session.backend.glContext.version), b2 = l2 ? `
      ${n2.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${n2.name}(a, b);
        ${g2.output} = result;
      }` : `
      ${n2.body}
      float process(int indices[${u3}]) {
        int aindices[${p3}];
        int bindices[${f3}];
        ${d2}
        ${h2}
        return ${n2.name}(_A(aindices), _B(bindices));
      }`;
                  return { name: n2.name, inputNames: ["A", "B"], inputTypes: [s2, s2], output: { dims: c2, type: i2, textureType: s2 }, shaderSource: b2, hasMain: l2 };
                }
                const p2 = (0, o.getGlsl)(t2.session.backend.glContext.version), f2 = `
    ${n2.body}
    void main() {
      vec4 v1 = ${p2.texture2D}(A, TexCoords);
      vec4 v2 = ${p2.texture2D}(B, TexCoords);
      vec4 result = ${n2.name}(v1, v2);
      ${p2.output} = result;
    }
    `;
                return { name: n2.name, inputNames: ["A", "B"], inputTypes: [s2, s2], output: { dims: e2[0].dims, type: i2, textureType: s2 }, shaderSource: f2, hasMain: true };
              };
              e.add = (t2, e2) => [t2.run(_(t2, e2, s()), e2)], e.and = (t2, e2) => [t2.run(_(t2, e2, h(), "bool"), e2)], e.div = (t2, e2) => [t2.run(_(t2, e2, u()), e2)], e.equal = (t2, e2) => [t2.run(_(t2, e2, p(), "bool"), e2)], e.greater = (t2, e2) => [t2.run(_(t2, e2, f(), "bool"), e2)], e.less = (t2, e2) => [t2.run(_(t2, e2, d(), "bool"), e2)], e.mul = (t2, e2) => [t2.run(_(t2, e2, c()), e2)], e.or = (t2, e2) => [t2.run(_(t2, e2, g(), "bool"), e2)], e.pow = (t2, e2) => [t2.run(_(t2, e2, m()), e2)], e.pRelu = (t2, e2) => [t2.run(_(t2, e2, y()), e2)], e.sub = (t2, e2) => [t2.run(_(t2, e2, l()), e2)], e.xor = (t2, e2) => [t2.run(_(t2, e2, b(), "bool"), e2)];
            }, 4196: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.parseCastAttributes = e.cast = void 0;
              const r = n(2517);
              e.cast = (t2, e2, n2) => (i(e2), [t2.cast(e2[0], n2)]), e.parseCastAttributes = (t2) => r.ProtoUtil.tensorDataTypeFromProto(t2.attributes.getInt("to"));
              const i = (t2) => {
                if (!t2 || 1 !== t2.length)
                  throw new Error("Cast requires 1 input.");
                if ("string" === t2[0].type)
                  throw new Error("Invalid input type.");
              };
            }, 1163: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.createPackedConcatProgramInfoLoader = void 0;
              const r = n(5060), i = n(2039), o = n(9390), a = n(2827);
              e.createPackedConcatProgramInfoLoader = (t2, e2, n2) => {
                const u = (c = e2.length, l = n2.cacheKey, { name: "Concat (packed)", inputNames: Array.from({ length: c }, (t3, e3) => `X${e3}`), inputTypes: Array(c).fill(i.TextureType.packed), cacheHint: l });
                var c, l;
                return Object.assign(Object.assign({}, u), { get: () => ((t3, e3, n3, u2) => {
                  const c2 = n3[0].dims.slice();
                  if (u2 >= c2.length || u2 < -1 * c2.length)
                    throw new Error("axis specified for concat doesn't match input dimensionality");
                  u2 < 0 && (u2 = c2.length + u2);
                  const l2 = c2.slice(0);
                  for (let t4 = 1; t4 < n3.length; t4++) {
                    const e4 = n3[t4].dims.slice();
                    for (let t5 = 0; t5 < c2.length; t5++)
                      if (t5 === u2)
                        l2[u2] += e4[t5];
                      else if (c2[t5] !== e4[t5])
                        throw new Error("non concat dimensions must match");
                  }
                  const p = l2.length, f = (0, a.getChannels)("coords", p), d = (0, o.getCoordsDataType)(p), h = (0, a.unpackFromChannel)(), g = n3.map((t4) => t4.dims), b = (0, o.getGlChannels)(p), m = new Array(g.length - 1);
                  m[0] = g[0][u2];
                  for (let t4 = 1; t4 < m.length; t4++)
                    m[t4] = m[t4 - 1] + g[t4][u2];
                  const y = b[u2], _ = b.slice(-2), v = b.join();
                  let w = `if (${y} < ${m[0]}) {
        return getChannel(
            getX0(${v}), vec2(${_.join()}));
        }`;
                  for (let t4 = 1; t4 < m.length; t4++) {
                    const e4 = m[t4 - 1];
                    w += `
            if (${y} < ${m[t4]}  && ${y} >= ${m[t4 - 1]}) {
              return getChannel(
                getX${t4}(${s(b, y, e4)}),
                vec2(${s(_, y, e4)}));
            }`;
                  }
                  const x = m.length, T = m[m.length - 1];
                  w += `
            return getChannel(
              getX${x}(${s(b, y, T)}),
              vec2(${s(_, y, T)}));`;
                  const S = (0, r.getGlsl)(t3.session.backend.glContext.version), O = `
          ${h}
          float getValue(${b.map((t4) => "int " + t4)}) {
            ${w}
          }

          void main() {
            ${d} coords = getOutputCoords();
            int lastDim = coords.${b[p - 1]};
            coords.${b[p - 1]} = coords.${b[p - 2]};
            coords.${b[p - 2]} = lastDim;

            vec4 result = vec4(getValue(${f}), 0., 0., 0.);

            ${f[p - 1]} = ${f[p - 1]} + 1;
            if (${f[p - 1]} < ${l2[p - 1]}) {
              result.g = getValue(${f});
            }

            ${f[p - 2]} = ${f[p - 2]} + 1;
            if (${f[p - 2]} < ${l2[p - 2]}) {
              result.a = getValue(${f});
            }

            ${f[p - 1]} = ${f[p - 1]} - 1;
            if (${f[p - 2]} < ${l2[p - 2]} &&
                ${f[p - 1]} < ${l2[p - 1]}) {
              result.b = getValue(${f});
            }
            ${S.output} = result;
          }
        `;
                  return Object.assign(Object.assign({}, e3), { output: { dims: l2, type: n3[0].type, textureType: i.TextureType.packed }, shaderSource: O, hasMain: true });
                })(t2, u, e2, n2.axis) });
              };
              const s = (t2, e2, n2) => {
                const r2 = t2.indexOf(e2);
                return t2.map((t3, e3) => e3 === r2 ? `${t3} - ${n2}` : t3).join();
              };
            }, 2069: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.parseConcatAttributes = e.concat = void 0;
              const r = n(246), i = n(2039), o = n(1163);
              e.concat = (t2, e2, n2) => (p(e2), t2.session.pack && e2[0].dims.length > 1 ? [t2.run((0, o.createPackedConcatProgramInfoLoader)(t2, e2, n2), e2)] : [t2.run(a(t2, e2, n2), e2)]);
              const a = (t2, e2, n2) => {
                const r2 = (o2 = e2.length, a2 = n2.cacheKey, { name: "Concat", inputNames: Array.from({ length: o2 }, (t3, e3) => `X${e3}`), inputTypes: Array(o2).fill(i.TextureType.unpacked), cacheHint: a2 });
                var o2, a2;
                return Object.assign(Object.assign({}, r2), { get: () => ((t3, e3, n3, r3) => {
                  const o3 = n3[0].dims.slice();
                  if (r3 >= o3.length || r3 < -1 * o3.length)
                    throw new Error("axis specified for concat doesn't match input dimensionality");
                  r3 < 0 && (r3 = o3.length + r3);
                  const a3 = o3.slice(0);
                  for (let t4 = 1; t4 < n3.length; t4++) {
                    const e4 = n3[t4].dims.slice();
                    for (let t5 = 0; t5 < o3.length; t5++)
                      if (t5 === r3)
                        a3[r3] += e4[t5];
                      else if (o3[t5] !== e4[t5])
                        throw new Error("non concat dimensions must match");
                  }
                  const p2 = a3.length, f = new Array(n3.length);
                  let d = 0;
                  for (let t4 = 0; t4 < f.length; ++t4)
                    d += n3[t4].dims[r3], f[t4] = d;
                  let h = "";
                  h = n3.length < 5 ? s(f) : u(f);
                  const g = `
        ${c(n3.length, p2)}
        ${l(f)}
        ${h}
        float process(int indices[${p2}]) {
          int textureIndex = getTextureWhereDataResides (indices[${r3}]);

          if(textureIndex != 0) {
            indices[${r3}] = indices[${r3}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;
                  return Object.assign(Object.assign({}, e3), { output: { dims: a3, type: n3[0].type, textureType: i.TextureType.unpacked }, shaderSource: g });
                })(0, r2, e2, n2.axis) });
              }, s = (t2) => `int getTextureWhereDataResides(int index) {
      ${t2.map((t3, e2) => `if(index<${t3}) {return ${e2};}
`).join("")}
    }`, u = (t2) => s(t2), c = (t2, e2) => {
                const n2 = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${e2}]) {`];
                for (let e3 = 0; e3 < t2; ++e3)
                  0 === e3 ? n2.push(`	if (textureIndex == ${e3}) { return _X${e3}(indices); }`) : e3 === t2 - 1 ? n2.push(`	else { return _X${e3}(indices); }`) : n2.push(`	else if (textureIndex == ${e3}) { return _X${e3}(indices); }`);
                return n2.push("	}"), n2.join("\n");
              }, l = (t2) => {
                const e2 = ["int getSizeInConcatAxisValueFromIndex(int index) {"];
                for (let n2 = 0; n2 < t2.length; ++n2)
                  0 === n2 ? e2.push(`	if (index == ${n2}) { return ${t2[n2]}; }`) : n2 === t2.length - 1 ? e2.push(`	else { return ${t2[n2]}; }`) : e2.push(`	else if (index == ${n2}) { return ${t2[n2]}; }`);
                return e2.push("	}"), e2.join("\n");
              };
              e.parseConcatAttributes = (t2) => (0, r.createAttributeWithCacheKey)({ axis: t2.attributes.getInt("axis") });
              const p = (t2) => {
                if (!t2 || t2.length < 1)
                  throw new Error("too few inputs");
                const e2 = t2[0].type, n2 = t2[0].dims.length;
                if ("string" === e2)
                  throw new Error("string tensor is not supported yet");
                for (const r2 of t2) {
                  if (r2.type !== e2)
                    throw new Error("input tensors should be one type");
                  if (r2.dims.length !== n2)
                    throw new Error("input tensors should have the same shape");
                }
              };
            }, 4770: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.createUnpackedGroupedConvProgramInfoLoader = void 0;
              const r = n(6231), i = n(5060), o = n(2039), a = n(8138), s = n(2823);
              e.createUnpackedGroupedConvProgramInfoLoader = (t2, e2, n2) => {
                const u = (c = e2.length > 2, l = n2.cacheKey, { name: "GroupedConv", inputNames: c ? ["X", "W", "Bias"] : ["X", "W"], inputTypes: c ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked], cacheHint: l });
                var c, l;
                return Object.assign(Object.assign({}, u), { get: () => ((t3, e3, n3, u2) => {
                  const c2 = e3.length > 2 ? "value += getBias(output_channel);" : "", l2 = e3[0].dims.slice(), p = e3[1].dims.slice(), f = p[0] / u2.group;
                  r.Logger.verbose("GroupedConv", `autpPad:${u2.autoPad}, dilations:${u2.dilations}, group:${u2.group}, kernelShape:${u2.kernelShape}, pads:${u2.pads}, strides:${u2.strides}`);
                  const d = (0, a.calculateOutputShape)(l2, p, u2.dilations, u2.pads, u2.strides), h = (0, i.getGlsl)(t3.session.backend.glContext.version), { activationFunction: g, applyActivation: b } = (0, s.getActivationSnippet)(u2), m = `
  const ivec2 strides = ivec2(${u2.strides[0]}, ${u2.strides[1]});
  const ivec2 pads = ivec2(${u2.pads[0]}, ${u2.pads[1]});
  ${g}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${f};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${p[1]}; wInChannel++) {
      int input_channel = group_id * ${p[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${p[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${u2.dilations[0]};

        if (xHeight < 0 || xHeight >= ${l2[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${p[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${u2.dilations[1]};
          if (xWidth < 0 || xWidth >= ${l2[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${c2}
    ${b}
    ${h.output} = vec4(value, .0, .0, .0);
  }
`;
                  return Object.assign(Object.assign({}, n3), { output: { dims: d, type: e3[0].type, textureType: o.TextureType.unpacked }, shaderSource: m, hasMain: true });
                })(t2, e2, u, n2) });
              };
            }, 1386: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.conv2DPacked = e.conv2DPackedPointwise = void 0;
              const r = n(8138), i = n(8555), o = n(708);
              e.conv2DPackedPointwise = (t2, e2, n2) => {
                const i2 = e2[0].dims, a = e2[1].dims, s = (0, r.calculateOutputShape)(i2, a, n2.dilations, n2.pads, n2.strides), u = t2.reshapePacked(e2[0], [i2[1], i2[2] * i2[3]]), c = t2.reshapePacked(e2[1], [a[0], a[1]]), l = e2.length > 2 ? [c, u, e2[2]] : [c, u], p = t2.run((0, o.createPackedMatmulProgramInfoLoader)(t2, l, n2), l);
                return t2.reshapePacked(p, s);
              }, e.conv2DPacked = (t2, e2, n2) => {
                const a = e2[0].dims, s = e2[1].dims, u = (0, r.calculateOutputShape)(a, s, n2.dilations, n2.pads, n2.strides), c = t2.run((0, i.createPackedIm2ColProgramInfoLoader)(t2, e2[0], e2[1], u, n2), [e2[0]]), l = t2.reshapePacked(e2[1], [s[0], s[1] * s[2] * s[3]]), p = 3 === e2.length ? [l, c, e2[2]] : [l, c], f = t2.run((0, o.createPackedMatmulProgramInfoLoader)(t2, p, n2), p);
                return t2.reshapePacked(f, u);
              };
            }, 9663: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.parseConvTransposeAttributes = e.convTranspose = void 0;
              const r = n(246), i = n(5060), o = n(2039), a = n(2823), s = (t2, e2, n2, r2, i2, o2) => (t2 - 1) * e2 + n2 + (r2 - 1) * i2 + 1 - o2, u = (t2, e2, n2, r2, i2) => {
                const o2 = Math.floor(t2 / 2);
                "SAME_UPPER" === e2 ? (n2[r2] = o2, n2[i2] = t2 - o2) : "SAME_LOWER" === e2 && (n2[r2] = t2 - o2, n2[i2] = o2);
              };
              e.convTranspose = (t2, e2, n2) => (f(e2, n2), c(t2, e2, n2));
              const c = (t2, e2, n2) => {
                const r2 = p(n2, e2);
                return [l(t2, e2, r2)];
              }, l = (t2, e2, n2) => t2.run(((t3, e3, n3) => {
                const r2 = (s2 = e3.length > 2, u2 = n3.cacheKey, { name: "ConvTranspose", inputNames: s2 ? ["X", "W", "B"] : ["X", "W"], inputTypes: s2 ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked], cacheHint: u2 });
                var s2, u2;
                return Object.assign(Object.assign({}, r2), { get: () => ((t4, e4, n4, r3) => {
                  const s3 = e4.length > 2 ? "getB(output_channel)" : "0.0", u3 = e4[0].dims, c2 = e4[1].dims, l2 = c2[1], p2 = c2[0] / r3.group, f2 = [e4[0].dims[0], e4[1].dims[1] * r3.group, ...r3.outputShape], d = (0, i.getGlsl)(t4.session.backend.glContext.version), { activationFunction: h, applyActivation: g } = (0, a.getActivationSnippet)(r3), b = `
  const ivec2 strides = ivec2(${r3.strides[0]}, ${r3.strides[1]});
  const ivec2 pads = ivec2(${r3.pads[0]}, ${r3.pads[1]});
  ${h}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${l2};
    int wOutChannel = output_channel - group_id * ${l2};

    float value = ${s3};
    for (int inChannelOffset = 0; inChannelOffset < ${p2}; inChannelOffset++) {
      int input_channel = group_id * ${p2} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${c2[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${c2[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${r3.dilations[0]}, wHOff * ${r3.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${u3[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${u3[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${g}
    ${d.output} = vec4(value, .0, .0, .0);
  }
`;
                  return Object.assign(Object.assign({}, n4), { output: { dims: f2, type: e4[0].type, textureType: o.TextureType.unpacked }, shaderSource: b, hasMain: true });
                })(t3, e3, r2, n3) });
              })(t2, e2, n2), e2), p = (t2, e2) => {
                const n2 = t2.kernelShape.slice();
                if (0 === t2.kernelShape.length)
                  for (let t3 = 2; t3 < e2[1].dims.length; ++t3)
                    n2.push(e2[1].dims[t3]);
                const r2 = t2.pads.slice(), i2 = t2.outputShape.slice();
                ((t3, e3, n3, r3, i3, o3, a2, c2) => {
                  const l2 = t3.length - 2, p2 = 0 === c2.length;
                  for (let f2 = 0; f2 < l2; ++f2) {
                    const d = p2 ? t3[f2 + 2] * o3[f2] : c2[f2], h = s(t3[f2 + 2], o3[f2], i3[f2], e3[f2], n3[f2], d);
                    u(h, r3, i3, f2, f2 + l2), p2 && c2.push(o3[f2] * (t3[f2 + 2] - 1) + a2[f2] + (e3[f2] - 1) * n3[f2] + 1 - i3[f2] - i3[f2 + l2]);
                  }
                })(e2[0].dims, n2, t2.dilations, t2.autoPad, r2, t2.strides, t2.outputPadding, i2);
                const o2 = Object.assign({}, t2);
                return Object.assign(o2, { kernelShape: n2, pads: r2, outputShape: i2, cacheKey: t2.cacheKey }), o2;
              };
              e.parseConvTransposeAttributes = (t2) => {
                const e2 = t2.attributes, n2 = (0, a.parseInternalActivationAttributes)(e2), i2 = e2.getString("auto_pad", "NOTSET"), o2 = e2.getInts("dilations", [1, 1]), s2 = e2.getInt("group", 1), u2 = e2.getInts("kernel_shape", []), c2 = e2.getInts("output_padding", [0, 0]), l2 = e2.getInts("output_shape", []), p2 = e2.getInts("pads", [0, 0, 0, 0]), f2 = e2.getInts("strides", [1, 1]);
                return (0, r.createAttributeWithCacheKey)(Object.assign({ autoPad: i2, dilations: o2, group: s2, kernelShape: u2, outputPadding: c2, outputShape: l2, pads: p2, strides: f2 }, n2));
              };
              const f = (t2, e2) => {
                if (!t2 || 2 !== t2.length && 3 !== t2.length)
                  throw new Error("Conv requires 2 or 3 inputs");
                if (4 !== t2[0].dims.length || 4 !== t2[1].dims.length)
                  throw new Error("currently only support 2-dimensional conv");
                if (t2[0].dims[1] !== t2[1].dims[0])
                  throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
                const n2 = t2[1].dims[1] * e2.group;
                if (3 === t2.length && (1 !== t2[2].dims.length || t2[2].dims[0] !== n2))
                  throw new Error("invalid bias");
                const r2 = t2[0].dims.length - 2;
                if (e2.dilations.length !== r2)
                  throw new Error(`dilations should be ${r2}D`);
                if (e2.strides.length !== r2)
                  throw new Error(`strides should be ${r2}D`);
                if (e2.pads.length !== 2 * r2)
                  throw new Error(`pads should be ${2 * r2}D`);
                if (e2.outputPadding.length !== r2)
                  throw new Error(`output_padding should be ${r2}D`);
                if (0 !== e2.kernelShape.length && e2.kernelShape.length !== t2[1].dims.length - 2)
                  throw new Error("invalid kernel shape");
                if (0 !== e2.outputShape.length && e2.outputShape.length !== t2[0].dims.length - 2)
                  throw new Error("invalid output shape");
                if ("float32" !== t2[0].type || "float32" !== t2[1].type)
                  throw new Error("ConvTranspose input(X,W) should be float tensor");
                if (3 === t2.length && "float32" !== t2[2].type)
                  throw new Error("ConvTranspose input(bias) should be float tensor");
              };
            }, 8138: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.parseConvAttributes = e.conv = e.calculateOutputShape = void 0;
              const r = n(246), i = n(2517), o = n(4770), a = n(1386), s = n(9828), u = n(2823), c = n(3248), l = n(5623);
              e.calculateOutputShape = (t2, e2, n2, r2, i2) => {
                const o2 = t2[0], a2 = t2.slice(2), s2 = a2.length, u2 = e2[0], c2 = e2.slice(2).map((t3, e3) => t3 + (t3 - 1) * (n2[e3] - 1)), l2 = a2.map((t3, e3) => t3 + r2[e3] + r2[e3 + s2]).map((t3, e3) => Math.floor((t3 - c2[e3] + i2[e3]) / i2[e3]));
                return [o2, u2].concat(...l2);
              }, e.conv = (t2, e2, n2) => (g(e2, n2), p(t2, e2, n2));
              const p = (t2, e2, n2) => {
                const r2 = h(n2, e2), i2 = t2.session.pack, s2 = 1 === r2.kernelShape[0] && 1 === r2.kernelShape[1];
                return r2.group > 1 ? [t2.run((0, o.createUnpackedGroupedConvProgramInfoLoader)(t2, e2, r2), e2)] : s2 && i2 ? [f(t2, e2, r2)] : i2 && 4 === e2[0].dims.length && 1 === e2[0].dims[0] && !s2 ? [(0, a.conv2DPacked)(t2, e2, r2)] : [d(t2, e2, r2)];
              }, f = (t2, n2, r2) => {
                const i2 = n2[0].dims, o2 = n2[1].dims, a2 = (0, e.calculateOutputShape)(i2, o2, r2.dilations, r2.pads, r2.strides), s2 = t2.reshapeUnpacked(n2[0], [i2[1], i2[2] * i2[3]]), u2 = t2.reshapeUnpacked(n2[1], [o2[0], o2[1]]), c2 = n2.length > 2 ? [u2, s2, n2[2]] : [u2, s2], p2 = t2.run((0, l.createMatmulProgramInfoLoader)(c2, r2), c2);
                return t2.reshapeUnpacked(p2, a2);
              }, d = (t2, n2, r2) => {
                const i2 = n2[0].dims, o2 = n2[1].dims, a2 = (0, e.calculateOutputShape)(i2, o2, r2.dilations, r2.pads, r2.strides), u2 = t2.run((0, c.createIm2ColProgramInfoLoader)(t2, n2[0], n2[1], a2, r2), [n2[0]]), l2 = 3 === n2.length ? [u2, n2[1], n2[2]] : [u2, n2[1]];
                return t2.run((0, s.createDotProductProgramInfoLoader)(t2, n2, a2, r2), l2);
              }, h = (t2, e2) => {
                const n2 = t2.kernelShape.slice();
                if (0 === t2.kernelShape.length)
                  for (let t3 = 2; t3 < e2[1].dims.length; ++t3)
                    n2.push(e2[1].dims[t3]);
                const r2 = t2.pads.slice();
                i.PoolConvUtil.adjustPadsBasedOnAutoPad(e2[0].dims, t2.strides, t2.dilations, n2, r2, t2.autoPad);
                const o2 = Object.assign({}, t2);
                return Object.assign(o2, { kernelShape: n2, pads: r2, cacheKey: t2.cacheKey }), o2;
              };
              e.parseConvAttributes = (t2) => {
                const e2 = t2.attributes, n2 = (0, u.parseInternalActivationAttributes)(e2), i2 = e2.getString("auto_pad", "NOTSET"), o2 = e2.getInts("dilations", [1, 1]), a2 = e2.getInt("group", 1), s2 = e2.getInts("kernel_shape", []), c2 = e2.getInts("pads", [0, 0, 0, 0]), l2 = e2.getInts("strides", [1, 1]);
                return (0, r.createAttributeWithCacheKey)(Object.assign({ autoPad: i2, dilations: o2, group: a2, kernelShape: s2, pads: c2, strides: l2 }, n2));
              };
              const g = (t2, e2) => {
                if (!t2 || 2 !== t2.length && 3 !== t2.length)
                  throw new Error("Conv requires 2 or 3 inputs");
                if (4 !== t2[0].dims.length || 4 !== t2[1].dims.length)
                  throw new Error("currently only support 2-dimensional conv");
                if (t2[0].dims[1] !== t2[1].dims[1] * e2.group)
                  throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
                if (3 === t2.length && (1 !== t2[2].dims.length || t2[1].dims[0] !== t2[2].dims[0]))
                  throw new Error("invalid bias");
                const n2 = t2[0].dims.length - 2;
                if (e2.dilations.length !== n2)
                  throw new Error(`dilations should be ${n2}D`);
                if (e2.strides.length !== n2)
                  throw new Error(`strides should be ${n2}D`);
                if (e2.pads.length !== 2 * n2)
                  throw new Error(`pads should be ${2 * n2}D`);
                if (0 !== e2.kernelShape.length && e2.kernelShape.length !== t2[1].dims.length - 2)
                  throw new Error("invalid kernel shape");
                if ("float32" !== t2[0].type || "float32" !== t2[1].type)
                  throw new Error("Conv input(X,W) should be float tensor");
                if (3 === t2.length && "float32" !== t2[2].type)
                  throw new Error("Conv input(bias) should be float tensor");
              };
            }, 5193: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.parseDepthToSpaceAttributes = e.depthToSpace = void 0;
              const r = n(3738);
              e.depthToSpace = (t2, e2, n2) => {
                i(e2);
                const o = n2.blocksize, a = o * o, s = "DCR" === n2.mode ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3], u = "DCR" === n2.mode ? [e2[0].dims[0], o, o, e2[0].dims[1] / a, e2[0].dims[2], e2[0].dims[3]] : [e2[0].dims[0], e2[0].dims[1] / a, o, o, e2[0].dims[2], e2[0].dims[3]], c = t2.reshapeUnpacked(e2[0], u), l = { perm: s, cacheKey: `${s}` }, [p] = (0, r.transpose)(t2, [c], l), f = [e2[0].dims[0], e2[0].dims[1] / a, e2[0].dims[2] * o, e2[0].dims[3] * o];
                return [t2.reshapeUnpacked(p, f)];
              }, e.parseDepthToSpaceAttributes = (t2) => {
                const e2 = t2.attributes.getInt("blocksize");
                if (e2 < 1)
                  throw new Error(`blocksize must be >= 1, but got : ${e2} for DepthToSpace`);
                const n2 = t2.attributes.getString("mode", "DCR");
                if ("DCR" !== n2 && "CRD" !== n2)
                  throw new Error(`unrecognized mode: ${n2} for DepthToSpace`);
                return { mode: n2, blocksize: e2 };
              };
              const i = (t2) => {
                if (1 !== t2.length)
                  throw new Error(`DepthToSpace expect 1 inputs, but got ${t2.length}`);
                if ("string" === t2[0].type || 4 !== t2[0].dims.length)
                  throw new TypeError("DepthToSpace input should be a 4-D numeric tensor");
              };
            }, 9828: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.createDotProductProgramInfoLoader = void 0;
              const r = n(2517), i = n(5060), o = n(2039), a = n(2823), s = n(3248);
              e.createDotProductProgramInfoLoader = (t2, e2, n2, u) => {
                const c = ((t3, e3) => ({ name: "ConvDotProduct", inputNames: t3 ? ["Im2Col", "K", "B"] : ["Im2Col", "K"], inputTypes: t3 ? [o.TextureType.unpacked, o.TextureType.packedLastDimension, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.packedLastDimension], cacheKey: e3.activationCacheKey }))(e2.length > 2, u);
                return Object.assign(Object.assign({}, c), { get: () => ((t3, e3, n3, u2, c2) => {
                  const l = n3[0].dims, p = n3[1].dims, f = [p[0], Math.ceil(l[1] * p[2] * p[3] / 4)], d = (0, s.calculateIm2ColDims)(l, p, u2), [h, g] = t3.calculateTextureWidthAndHeight(f, o.TextureType.packedLastDimension), b = r.ShapeUtil.computeStrides(d), [m, y] = t3.calculateTextureWidthAndHeight(d, o.TextureType.packedLastDimension), _ = u2.length, v = n3.length < 3 ? "0.0" : "_B(b)", w = Math.ceil(l[1] * p[2] * p[3] / 4), { activationFunction: x, applyActivation: T } = (0, a.getActivationSnippet)(c2), S = (0, i.getGlsl)(t3.session.backend.glContext.version), O = `
${x}
float process(int indices[${_}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${b[0]} + im2col[1] * ${b[1]} + im2col[2] * ${b[2]};
  int kernelOffset = indices[1] * ${f[1]};
  float value = ${v};
  for (int i = 0; i < ${w}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${m}, ${y});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${h}, ${g});
    value += dot(${S.texture2D}(Im2Col, im2colCoords), ${S.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${T}
  return value;
}`;
                  return Object.assign(Object.assign({}, e3), { output: { dims: u2, type: n3[0].type, textureType: o.TextureType.unpacked }, shaderSource: O });
                })(t2, c, e2, n2, u) });
              };
            }, 7992: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.parseFlattenAttributes = e.flatten = void 0;
              const r = n(2517);
              e.flatten = (t2, e2, n2) => {
                i(e2, n2);
                const o = r.ShapeUtil.flattenShape(e2[0].dims, n2);
                return [t2.reshapeUnpacked(e2[0], o)];
              }, e.parseFlattenAttributes = (t2) => t2.attributes.getInt("axis", 1);
              const i = (t2, e2) => {
                if (!t2 || 1 !== t2.length)
                  throw new Error("Flatten requires 1 input.");
                const n2 = t2[0].dims.length;
                if (0 === n2)
                  throw new Error("scalar tensor is not supported.");
                if (e2 < -n2 || e2 > n2)
                  throw new Error("Invalid axis");
                if ("string" === t2[0].type)
                  throw new Error("string tensor is not supported.");
              };
            }, 2823: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.parseInternalActivationAttributes = e.getActivationSnippet = void 0;
              const r = n(2517), i = n(4909);
              e.getActivationSnippet = function(t2) {
                let e2;
                switch (t2.activation) {
                  case "Relu":
                    e2 = (0, i.glslRelu)();
                    break;
                  case "Sigmoid":
                    e2 = (0, i.glslSigmoid)();
                    break;
                  case "Clip":
                    e2 = (0, i.glslClip)(t2.clipMin, t2.clipMax);
                    break;
                  default:
                    return { activationFunction: "", applyActivation: "" };
                }
                const n2 = e2.name;
                return { activationFunction: e2.body, applyActivation: `value = ${n2}_(value);` };
              }, e.parseInternalActivationAttributes = (t2) => {
                const e2 = t2.getString("activation", "");
                if ("Clip" === e2) {
                  const [n2, i2] = t2.getFloats("activation_params", [r.MIN_CLIP, r.MAX_CLIP]);
                  return { activation: e2, clipMax: i2, clipMin: n2, activationCacheKey: `${e2}:${n2},${i2}` };
                }
                return { activation: e2, activationCacheKey: e2 };
              };
            }, 1253: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.parseGatherAttributes = e.gather = void 0;
              const r = n(246), i = n(782), o = n(2517), a = n(2039);
              e.gather = (t2, e2, n2) => (c(e2, n2.axis), [t2.run(u(t2, e2, n2), e2)]), e.parseGatherAttributes = (t2) => (0, r.createAttributeWithCacheKey)({ axis: t2.attributes.getInt("axis", 0) });
              const s = { name: "Gather", inputNames: ["A", "B"], inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked] }, u = (t2, e2, n2) => {
                const r2 = Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey });
                return Object.assign(Object.assign({}, r2), { get: () => ((t3, e3, n3, r3) => {
                  const i2 = n3[0].dims.slice(), s2 = n3[1].dims.slice(), u2 = new Array(i2.length + s2.length - 1);
                  r3 = o.ShapeUtil.normalizeAxis(r3, i2.length);
                  const c2 = [];
                  for (let t4 = 0; t4 < u2.length; t4++)
                    t4 < r3 ? (u2[t4] = i2[t4], c2.push(`inputIdx[${t4}] = outputIdx[${t4}];`)) : t4 < r3 + s2.length ? (u2[t4] = s2[t4 - r3], c2.push(`indexDataIdx[${t4 - r3}] = outputIdx[${t4}];`)) : (u2[t4] = i2[t4 - s2.length + 1], c2.push(`inputIdx[${t4 - s2.length + 1}] = outputIdx[${t4}];`));
                  const l = `
      float process(int outputIdx[${u2.length || 1}]) {
        int inputIdx[${i2.length}];
        int indexDataIdx[${s2.length || 1}];
        indexDataIdx[0] = 0;
        ${c2.join("\n        ")}
        int idx = int(_B(indexDataIdx));
        inputIdx[${r3}] = idx < 0 ? idx + ${i2[r3]} : idx;
        return _A(inputIdx);
      }`;
                  return Object.assign(Object.assign({}, e3), { output: { dims: u2, type: n3[0].type, textureType: a.TextureType.unpacked }, shaderSource: l });
                })(0, r2, e2, n2.axis) });
              }, c = (t2, e2) => {
                if (!t2 || 2 !== t2.length)
                  throw new Error("Gather requires 2 inputs.");
                const n2 = t2[0].dims.length;
                if (n2 < 1)
                  throw new Error("Invalid input shape.");
                if (e2 < -n2 || e2 > n2 - 1)
                  throw new Error("Invalid axis.");
                if (-1 === i.NUMBER_TYPES.indexOf(t2[0].type))
                  throw new Error("Invaid input type.");
                if ("int32" !== t2[1].type && "int16" !== t2[1].type)
                  throw new Error("Invaid input type.");
              };
            }, 4776: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.parseGemmAttributesV11 = e.parseGemmAttributesV7 = e.gemm = void 0;
              const r = n(246), i = n(2517), o = n(2039);
              e.gemm = (t2, e2, n2) => (c(e2, n2), [t2.run(s(e2, n2), e2)]);
              const a = (t2, e2) => {
                const n2 = 0 !== t2.attributes.getInt("transA", 0), i2 = 0 !== t2.attributes.getInt("transB", 0), o2 = t2.attributes.getFloat("alpha", 1), a2 = t2.attributes.getFloat("beta", 1);
                return (0, r.createAttributeWithCacheKey)({ transA: n2, transB: i2, alpha: o2, beta: a2, isOptionalC: e2 });
              };
              e.parseGemmAttributesV7 = (t2) => a(t2, false), e.parseGemmAttributesV11 = (t2) => a(t2, true);
              const s = (t2, e2) => {
                const n2 = { name: "Gemm", inputNames: 3 === t2.length ? ["A", "B", "C"] : ["A", "B"], inputTypes: 3 === t2.length ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked], key: e2.cacheKey };
                return Object.assign(Object.assign({}, n2), { get: () => u(n2, t2, e2) });
              }, u = (t2, e2, n2) => {
                const r2 = e2[0].dims.slice(), a2 = e2[1].dims.slice(), [s2, u2] = i.GemmUtil.getShapeOfGemmResult(r2, n2.transA, a2, n2.transB, 3 === e2.length ? e2[2].dims : void 0), c2 = [s2, u2];
                if (!c2)
                  throw new Error("Can't use gemm on the given tensors");
                let l = r2[r2.length - 1], p = "";
                n2.transA && (l = r2[0]), n2.transA && n2.transB ? p = "value += _A_T(a) * _B_T(b);" : n2.transA && !n2.transB ? p = "value += _A_T(a) * _B(b);" : !n2.transA && n2.transB ? p = "value += _A(a) * _B_T(b);" : n2.transA || n2.transB || (p = "value += _A(a) * _B(b);");
                const f = c2.length, d = `
      float process(int indices[${f}]) {
          int a[${f}];
          int b[${f}];
          ${3 === e2.length ? `int c[${e2[2].dims.length}];` : ""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${3 === e2.length ? "bcastIndices_C(indices, c);" : ""}

          float value = 0.0;
          for (int k=0; k<${l}; ++k) {
              a[${f - 1}] = k;
              b[${f - 2}] = k;
              ${p}
          }

          value = value * alpha;
          ${3 === e2.length ? "value += beta * _C(c);" : ""}
          return value;
      }`;
                return Object.assign(Object.assign({}, t2), { output: { dims: c2, type: e2[0].type, textureType: o.TextureType.unpacked }, variables: [{ name: "alpha", type: "float", data: n2.alpha }, { name: "beta", type: "float", data: n2.beta }], shaderSource: d });
              }, c = (t2, e2) => {
                if (!t2)
                  throw new Error("Input is missing");
                if (e2.isOptionalC && (t2.length < 2 || t2.length > 3))
                  throw new Error("Invaid input shape.");
                if (!e2.isOptionalC && 3 !== t2.length)
                  throw new Error("Gemm requires 3 inputs");
                if (3 === t2.length && 1 !== t2[2].dims.length && 2 !== t2[2].dims.length)
                  throw new Error("Invalid input shape of C");
                if ("float32" !== t2[0].type && "float64" !== t2[0].type || "float32" !== t2[1].type && "float64" !== t2[1].type || 3 === t2.length && "float32" !== t2[2].type && "float64" !== t2[2].type)
                  throw new Error("Invalid input type.");
                if (t2[0].type !== t2[1].type || 3 === t2.length && t2[0].type !== t2[2].type)
                  throw new Error("Input types are mismatched");
              };
            }, 8555: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.createPackedIm2ColProgramInfoLoader = void 0;
              const r = n(5060), i = n(2039), o = n(2827);
              e.createPackedIm2ColProgramInfoLoader = (t2, e2, n2, a, s) => {
                const u = (c = s.cacheKey, { name: "Im2Col (packed)", inputNames: ["A"], inputTypes: [i.TextureType.packed], cacheHint: c });
                var c;
                return Object.assign(Object.assign({}, u), { get: () => ((t3, e3, n3, a2, s2, u2) => {
                  const c2 = n3.dims, l = a2.dims, p = s2.length, f = [l[1] * l[2] * l[3], s2[2] * s2[3]], d = l[2] * l[3], h = (0, o.unpackFromChannel)(), g = (0, r.getGlsl)(t3.session.backend.glContext.version);
                  let b = "";
                  for (let t4 = 0; t4 <= 1; t4++)
                    for (let e4 = 0; e4 <= 1; e4++)
                      b += `
            blockIndex = rc.x + ${e4};
            pos = rc.y + ${t4};

            if(blockIndex < ${f[1]} && pos < ${f[0]}) {
              offsetY = int(blockIndex / (${s2[p - 1]})) * ${u2.strides[0]} -
                ${u2.pads[0]};
              d0 = offsetY + ${u2.dilations[0]} * (imod(pos, ${d}) / ${l[2]});

              if(d0 < ${c2[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${s2[p - 1]}) * ${u2.strides[1]} -
                  ${u2.pads[1]};
                d1 = offsetX + ${u2.dilations[1]} * imod(imod(pos, ${d}), ${l[2]});

                if(d1 < ${c2[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${d}.);
                    innerDims = vec2(d0, d1);
                    result[${2 * t4 + e4}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;
                  const m = `
      ${h}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${b}
          ${g.output} = result;
      }
            `;
                  return Object.assign(Object.assign({}, e3), { output: { dims: f, type: n3.type, textureType: i.TextureType.packed }, shaderSource: m, hasMain: true });
                })(t2, u, e2, n2, a, s) });
              };
            }, 3248: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.calculateIm2ColDims = e.createIm2ColProgramInfoLoader = void 0;
              const r = n(2039);
              e.createIm2ColProgramInfoLoader = (t2, n2, i, o, a) => {
                const s = (u = a.cacheKey, { name: "Im2Col", inputNames: ["X"], inputTypes: [r.TextureType.unpacked], cacheHint: u });
                var u;
                return Object.assign(Object.assign({}, s), { get: () => ((t3, n3, i2, o2, a2, s2) => {
                  const u2 = i2.dims, c = o2.dims, l = a2.length, p = (0, e.calculateIm2ColDims)(u2, c, a2, 4), f = `
        const int XC = ${u2[1]};
        const int XH = ${u2[2]};
        const int XW = ${u2[3]};
        const int KH = ${s2.kernelShape[0]};
        const int KW = ${s2.kernelShape[1]};
        const int dilationH = ${s2.dilations[0]};
        const int dilationW = ${s2.dilations[1]};
        const int strideH = ${s2.strides[0]};
        const int strideW = ${s2.strides[1]};
        const int padH = ${s2.pads[0]};
        const int padW = ${s2.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${l}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${u2.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;
                  return Object.assign(Object.assign({}, n3), { output: { dims: p, type: i2.type, textureType: r.TextureType.packedLastDimension }, shaderSource: f });
                })(0, s, n2, i, o, a) });
              }, e.calculateIm2ColDims = (t2, e2, n2, r2 = 4) => [n2[0], n2[2], n2[3], Math.ceil(t2[1] * e2[2] * e2[3] / r2)];
            }, 6572: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.parseImageScalerAttributes = e.imageScaler = void 0;
              const r = n(246), i = n(2039);
              e.imageScaler = (t2, e2, n2) => (u(e2), [t2.run(a(t2, e2, n2), e2)]), e.parseImageScalerAttributes = (t2) => {
                const e2 = t2.attributes.getFloat("scale"), n2 = t2.attributes.getFloats("bias");
                return (0, r.createAttributeWithCacheKey)({ scale: e2, bias: n2 });
              };
              const o = { name: "ImageScaler", inputNames: ["X"], inputTypes: [i.TextureType.unpacked] }, a = (t2, e2, n2) => {
                const r2 = Object.assign(Object.assign({}, o), { cacheHint: n2.cacheKey });
                return Object.assign(Object.assign({}, r2), { get: () => ((t3, e3, n3, r3) => {
                  const o2 = n3[0].dims.slice(), a2 = o2.length, u2 = `
      ${s(r3.bias.length)}
      float process(int indices[${a2}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;
                  return Object.assign(Object.assign({}, e3), { output: { dims: o2, type: n3[0].type, textureType: i.TextureType.unpacked }, variables: [{ name: "bias", type: "float", arrayLength: r3.bias.length, data: r3.bias }, { name: "scale", type: "float", data: r3.scale }], shaderSource: u2 });
                })(0, r2, e2, n2) });
              }, s = (t2) => {
                const e2 = [`float getBias(float bias[${t2}], int channel) {`];
                for (let n2 = 0; n2 < t2; ++n2)
                  0 === n2 ? e2.push(`	if (channel == ${n2}) { return bias[${n2}]; }`) : n2 === t2 - 1 ? e2.push(`	else { return bias[${n2}]; }`) : e2.push(`	else if (channel == ${n2}) { return bias[${n2}]; }`);
                return e2.push("	}"), e2.join("\n");
              }, u = (t2) => {
                if (!t2 || 1 !== t2.length)
                  throw new Error("ImageScaler requires 1 input.");
                if (4 !== t2[0].dims.length)
                  throw new Error("Invalid input shape.");
                if ("float32" !== t2[0].type && "float64" !== t2[0].type)
                  throw new Error("Invalid input type.");
              };
            }, 3346: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.parseInstanceNormalizationAttributes = e.instanceNormalization = void 0;
              const r = n(5060), i = n(2039);
              e.instanceNormalization = (t2, e2, n2) => {
                c(e2);
                const r2 = t2.run(a(e2[0]), e2);
                return [t2.run(u(t2, e2[0], n2, r2.dims), [e2[0], r2, e2[1], e2[2]])];
              }, e.parseInstanceNormalizationAttributes = (t2) => t2.attributes.getFloat("epsilon", 1e-5);
              const o = { name: "InstanceNormalization_MeanAndVariance", inputNames: ["X"], inputTypes: [i.TextureType.unpacked] }, a = (t2) => Object.assign(Object.assign({}, o), { get: () => ((t3, e2) => {
                const n2 = e2.dims.slice(), r2 = n2[1], o2 = n2[2] * n2[3], a2 = [n2[0], r2], s2 = `
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${n2[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n2[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${o2});
        temp = 0.0;
        for(int a2=0; a2<${n2[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n2[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${o2});

        return v;
      }`;
                return Object.assign(Object.assign({}, t3), { output: { dims: a2, type: e2.type, textureType: i.TextureType.packedLastDimension }, shaderSource: s2 });
              })(o, t2) }), s = { name: "InstanceNormalization_ComputeOutput", inputNames: ["X", "MeanAndVariance", "Scale", "B"], inputTypes: [i.TextureType.unpacked, i.TextureType.packedLastDimension, i.TextureType.unpacked, i.TextureType.unpacked] }, u = (t2, e2, n2, o2) => {
                const a2 = Object.assign(Object.assign({}, s), { cacheHint: `${n2}` });
                return Object.assign(Object.assign({}, a2), { get: () => ((t3, e3, n3, o3, a3) => {
                  const s2 = (0, r.getGlsl)(t3.session.backend.glContext.version), [u2, c2] = t3.calculateTextureWidthAndHeight(a3, i.TextureType.packedLastDimension), [l, p] = [u2 / 4, c2], f = `
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${l}, ${p});
        return ${s2.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;
                  return Object.assign(Object.assign({}, e3), { output: { dims: n3.dims, type: n3.type, textureType: i.TextureType.unpacked }, variables: [{ name: "epsilon", type: "float", data: o3 }], shaderSource: f });
                })(t2, a2, e2, n2, o2) });
              }, c = (t2) => {
                if (!t2 || 3 !== t2.length)
                  throw new Error("InstanceNormalization requires 3 inputs.");
                const e2 = t2[0], n2 = t2[1], r2 = t2[2];
                if (e2.dims.length < 3 || 1 !== n2.dims.length || 1 !== r2.dims.length)
                  throw new Error("Invalid input shape.");
                if (n2.dims[0] !== e2.dims[1] || r2.dims[0] !== e2.dims[1])
                  throw new Error("Input shapes are mismatched.");
                if ("float32" !== e2.type && "float64" !== e2.type || "float32" !== n2.type && "float64" !== n2.type || "float32" !== r2.type && "float64" !== r2.type)
                  throw new Error("Invalid input type.");
                if (4 !== t2[0].dims.length)
                  throw new Error("Only support 4-D input shape.");
              };
            }, 708: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.createPackedMatmulProgramInfoLoader = void 0;
              const r = n(2517), i = n(5060), o = n(2039), a = n(9390), s = n(2823), u = n(5623);
              e.createPackedMatmulProgramInfoLoader = (t2, e2, n2) => {
                const c = (l = e2.length > 2, p = n2.activationCacheKey, { name: "MatMul (packed)", inputNames: l ? ["A", "B", "Bias"] : ["A", "B"], inputTypes: l ? [o.TextureType.packed, o.TextureType.packed, o.TextureType.packed] : [o.TextureType.packed, o.TextureType.packed], cacheHint: p });
                var l, p;
                return Object.assign(Object.assign({}, c), { get: () => ((t3, e3, n3, c2) => {
                  const l2 = n3.length > 2, p2 = l2 ? "value += getBiasForMatmul();" : "", f = n3[0].dims, d = n3[1].dims, h = r.BroadcastUtil.calcShape(f, d, true), g = !r.ShapeUtil.areEqual(n3[0].dims, n3[1].dims);
                  if (!h)
                    throw new Error("Can't use matmul on the given tensors");
                  const b = f[f.length - 1], m = Math.ceil(b / 2), y = f.length, _ = d.length, v = (0, i.getGlsl)(t3.session.backend.glContext.version), w = (0, a.getCoordsDataType)(h.length), x = h.length, T = (0, a.getGlChannels)(), { activationFunction: S, applyActivation: O } = (0, s.getActivationSnippet)(c2), A = l2 ? `${(0, u.getBiasForMatmul)(w, T, n3[2].dims, h, true)}` : "", E = g ? `${function(t4, e4, n4, i2) {
                    let o2 = [], a2 = [];
                    const s2 = n4[0].dims, u2 = n4[1].dims, c3 = s2.length, l3 = u2.length, p3 = i2.length, f2 = p3 - c3, d2 = p3 - l3;
                    o2 = s2.map((t5, n5) => `coords.${e4[n5 + f2]}`), o2[c3 - 1] = "i*2", o2.join(", "), a2 = u2.map((t5, n5) => `coords.${e4[n5 + d2]}`), a2[l3 - 2] = "i*2", a2.join(", ");
                    const h2 = r.BroadcastUtil.getBroadcastDims(s2, i2), g2 = r.BroadcastUtil.getBroadcastDims(u2, i2), b2 = h2.map((t5) => `coords.${e4[t5 + f2]} = 0;`).join("\n"), m2 = g2.map((t5) => `coords.${e4[t5 + d2]} = 0;`).join("\n"), y2 = `int lastDim = coords.${e4[p3 - 1]};
  coords.${e4[p3 - 1]} = coords.${e4[p3 - 2]};
  coords.${e4[p3 - 2]} = lastDim;`;
                    return `
vec4 getAAtOutCoordsMatmul(int i) {
  ${t4} coords = getOutputCoords();
  ${y2}
  ${b2}
  vec4 outputValue = getA(${o2});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${t4} coords = getOutputCoords();
  ${y2}
  ${m2}
  vec4 outputValue = getB(${a2});
  return outputValue;
}`;
                  }(w, T, n3, h)}` : "", I = g ? "getAAtOutCoordsMatmul(i)" : `getA(${function(t4, e4) {
                    let n4 = "";
                    for (let r2 = 0; r2 < e4 - 2; r2++)
                      n4 += `rc.${t4[r2]}, `;
                    return n4 += `rc.${t4[e4 - 2]}, i*2`, n4;
                  }(T, y)})`, P = g ? "getBAtOutCoordsMatmul(i)" : `getB(${function(t4, e4) {
                    let n4 = "";
                    for (let r2 = 0; r2 < e4 - 2; r2++)
                      n4 += `rc.${t4[r2]}, `;
                    return n4 += `i*2, rc.${t4[e4 - 1]}`, n4;
                  }(T, _)})`, D = `
            ${E}
            ${A}
            ${S}
            void main() {
              ${g ? "" : `${w} rc =
          getOutputCoords(); int lastDim = rc.${T[x - 1]}; rc.${T[x - 1]} =
          rc.${T[x - 2]}; rc.${T[x - 2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${m}; i++) {
                vec4 a = ${I};
                vec4 b = ${P};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${p2}
              ${O}
              ${v.output} = value;
            }`;
                  return Object.assign(Object.assign({}, e3), { output: { dims: h, type: n3[0].type, textureType: o.TextureType.packed }, shaderSource: D, hasMain: true });
                })(t2, c, e2, n2) });
              };
            }, 5623: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.getBiasForMatmul = e.createMatmulProgramInfoLoader = e.parseMatMulAttributes = e.matMul = void 0;
              const r = n(2517), i = n(2039), o = n(9390), a = n(2823), s = n(708);
              function u(t2, e2) {
                const n2 = (s2 = t2.length > 2, u2 = e2.activationCacheKey, { name: "MatMul", inputNames: s2 ? ["A", "B", "Bias"] : ["A", "B"], inputTypes: s2 ? [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.unpacked], cacheHint: u2 });
                var s2, u2;
                return Object.assign(Object.assign({}, n2), { get: () => function(t3, e3, n3) {
                  const s3 = e3[0].dims, u3 = e3[1].dims, c2 = r.BroadcastUtil.calcShape(s3, u3, true);
                  if (!c2)
                    throw new Error("Can't use matmul on the given tensors");
                  const p = (0, o.getCoordsDataType)(c2.length), f = (0, o.getGlChannels)(), { activationFunction: d, applyActivation: h } = (0, a.getActivationSnippet)(n3), g = e3.length > 2, b = g ? "value += getBiasForMatmul();" : "", m = g ? `${l(p, f, e3[2].dims, c2, false)}` : "", y = c2.length, _ = s3.length, v = u3.length, w = `
    ${d}
    ${m}
    float process(int indices[${y}]) {
        int a[${_}];
        int b[${v}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${s3[s3.length - 1]}; ++k) {
            a[${_ - 1}] = k;
            b[${v - 2}] = k;
            value += _A(a) * _B(b);
        }
        ${b}
        ${h}
        return value;
    }`;
                  return Object.assign(Object.assign({}, t3), { output: { dims: c2, type: e3[0].type, textureType: i.TextureType.unpacked }, shaderSource: w });
                }(n2, t2, e2) });
              }
              e.matMul = (t2, e2, n2) => (c(e2), t2.session.pack ? [t2.run((0, s.createPackedMatmulProgramInfoLoader)(t2, e2, n2), e2)] : [t2.run(u(e2, n2), e2)]), e.parseMatMulAttributes = (t2) => (0, a.parseInternalActivationAttributes)(t2.attributes), e.createMatmulProgramInfoLoader = u;
              const c = (t2) => {
                if (!t2 || 2 !== t2.length)
                  throw new Error("MatMul requires 2 inputs.");
                if (t2[0].dims[t2[0].dims.length - 1] !== t2[1].dims[t2[1].dims.length - 2])
                  throw new Error("shared dimension does not match.");
                if ("float32" !== t2[0].type && "float64" !== t2[0].type || "float32" !== t2[1].type && "float64" !== t2[1].type)
                  throw new Error("inputs should be float type");
                if (t2[0].type !== t2[1].type)
                  throw new Error("inputs types should match");
              };
              function l(t2, e2, n2, i2, o2) {
                let a2 = "";
                const s2 = n2.length, u2 = i2.length, c2 = u2 - s2;
                a2 = u2 < 2 && s2 > 0 ? "coords" : n2.map((t3, n3) => `coords.${e2[n3 + c2]}`).join(", ");
                const l2 = r.BroadcastUtil.getBroadcastDims(n2, i2).map((t3) => `coords.${e2[t3 + c2]} = 0;`).join("\n");
                let p = "vec4(outputValue.xx, outputValue.yy)";
                return 1 === r.ShapeUtil.size(n2) && (p = "vec4(outputValue.x)"), o2 ? `
vec4 getBiasForMatmul() {
  ${t2} coords = getOutputCoords();
  ${l2}
  vec4 outputValue = getBias(${a2});
  return ${p};
}` : `
float getBiasForMatmul() {
  ${t2} coords = getOutputCoords();
  ${l2}
  return getBias(coords.x);
}`;
              }
              e.getBiasForMatmul = l;
            }, 2403: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.createPackProgramInfoLoader = void 0;
              const r = n(5060), i = n(2039), o = n(9390), a = n(2827), s = { name: "pack", inputNames: ["A"], inputTypes: [i.TextureType.unpackedReversed] };
              e.createPackProgramInfoLoader = (t2, e2) => Object.assign(Object.assign({}, s), { get: () => ((t3, e3) => {
                const n2 = (0, r.getGlsl)(t3.session.backend.glContext.version), u = e3.dims, c = u.length, l = e3.dims.length, p = (0, o.getCoordsDataType)(l), f = (0, a.getChannels)("rc", l), d = (h = l, g = f, b = u[u.length - 2], m = u[u.length - 1], 0 === h || 1 === h ? "" : `
    int r = ${g[h - 2]};
    int c = ${g[h - 1]};
    int rp1 = ${g[h - 2]} + 1;
    int cp1 = ${g[h - 1]} + 1;
    bool rEdge = rp1 >= ${m};
    bool cEdge = cp1 >= ${b};
    `);
                var h, g, b, m;
                let y;
                y = 0 === c ? [1, 1] : 1 === c ? [u[0], 1] : [u[l - 1], u[l - 2]];
                const _ = function(t4, e4, n3) {
                  if (0 === t4)
                    return "false";
                  if (1 === t4)
                    return `rc > ${e4[0]}`;
                  let r2 = "";
                  for (let i2 = t4 - 2; i2 < t4; i2++)
                    r2 += `${n3[i2]} >= ${e4[i2 - t4 + 2]}`, i2 < t4 - 1 && (r2 += "||");
                  return r2;
                }(l, y, f), v = function(t4, e4) {
                  const n3 = t4.length;
                  if (0 === n3)
                    return "getA(), 0, 0, 0";
                  if (1 === n3)
                    return `getA(rc),
            rc + 1 >= ${t4[0]} ? 0. : getA(rc + 1),
            0, 0`;
                  let r2 = "";
                  if (n3 > 2)
                    for (let t5 = 0; t5 < n3 - 2; ++t5)
                      r2 += `${e4[t5]},`;
                  return `getA(${r2}r, c),
          rEdge ? 0. : getA(${r2}rp1, c),
          cEdge ? 0. : getA(${r2}r, cp1),
          rEdge || cEdge ? 0. : getA(${r2}rp1, cp1)`;
                }(u, f), w = `
        void main() {
          ${p} rc = getOutputCoords();

          if(${_}) {
            ${n2.output} = vec4(0);
          } else {
            ${d}

            ${n2.output} = vec4(${v});
          }
        }
      `;
                return Object.assign(Object.assign({}, s), { hasMain: true, output: { dims: e3.dims, type: e3.type, textureType: i.TextureType.packed }, shaderSource: w });
              })(t2, e2) });
            }, 2827: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.unpackFromChannel = e.getChannels = e.getVecChannels = void 0;
              const r = n(9390);
              function i(t2, e2) {
                return (0, r.getGlChannels)(e2).map((e3) => `${t2}.${e3}`);
              }
              e.getVecChannels = i, e.getChannels = function(t2, e2) {
                return 1 === e2 ? [t2] : i(t2, e2);
              }, e.unpackFromChannel = function() {
                return "\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  ";
              };
            }, 2870: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.parsePadAttributesV11 = e.padV11 = e.parsePadAttributesV2 = e.padV2 = void 0;
              const r = n(246), i = n(2517), o = n(5060), a = n(2039), s = { name: "Pad", inputNames: ["A"], inputTypes: [a.TextureType.unpacked] };
              e.padV2 = (t2, e2, n2) => (l(e2), [t2.run(Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey, get: () => c(t2, e2[0], n2) }), e2)]), e.parsePadAttributesV2 = (t2) => {
                const e2 = t2.attributes.getString("mode", "constant"), n2 = t2.attributes.getFloat("value", 0), i2 = t2.attributes.getInts("pads");
                return (0, r.createAttributeWithCacheKey)({ mode: e2, value: n2, pads: i2 });
              }, e.padV11 = (t2, n2, r2) => {
                p(n2);
                const i2 = u(t2, n2, r2);
                return (0, e.padV2)(t2, [n2[0]], i2);
              }, e.parsePadAttributesV11 = (t2) => t2.attributes.getString("mode", "constant");
              const u = (t2, e2, n2) => {
                if (!t2.session.isInitializer(e2[1].dataId) || e2.length >= 3 && !t2.session.isInitializer(e2[2].dataId))
                  throw new Error("dynamic pad attributes are not allowed");
                const i2 = Array.from(e2[1].integerData), o2 = e2.length >= 3 ? e2[2].floatData[0] : 0;
                return (0, r.createAttributeWithCacheKey)({ mode: n2, pads: i2, value: o2 });
              }, c = (t2, e2, n2) => {
                const r2 = i.ShapeUtil.padShape(e2.dims.slice(), n2.pads), o2 = r2.length, s2 = `
      ${f(t2, e2, n2)}
      float process(int[${o2}] indices) {
          return padA(indices);
      }`;
                return { name: "Pad", inputNames: ["A"], inputTypes: [a.TextureType.unpacked], output: { dims: r2, type: e2.type, textureType: a.TextureType.unpacked }, shaderSource: s2 };
              }, l = (t2) => {
                if (!t2 || 1 !== t2.length)
                  throw new Error("Pad requires 1 input");
                if ("float32" !== t2[0].type && "float64" !== t2[0].type)
                  throw new Error("Invalid input type.");
              }, p = (t2) => {
                if (!t2 || 2 !== t2.length && 3 !== t2.length)
                  throw new Error("Pad requires 2 or 3 inputs");
                if ("int32" !== t2[1].type)
                  throw new Error("Invalid input type.");
                if (t2.length >= 3 && "string" === t2[2].type)
                  throw new Error("Invalid input type.");
              }, f = (t2, e2, n2) => {
                const r2 = (0, o.getGlsl)(t2.session.backend.glContext.version), [s2, u2] = t2.calculateTextureWidthAndHeight(e2.dims, a.TextureType.unpacked), c2 = i.ShapeUtil.computeStrides(e2.dims);
                switch (n2.mode) {
                  case "constant":
                    return d(r2, e2.dims, c2, s2, u2, n2.pads, n2.value);
                  case "reflect":
                    return h(r2, e2.dims, c2, s2, u2, n2.pads);
                  case "edge":
                    return g(r2, e2.dims, c2, s2, u2, n2.pads);
                  default:
                    throw new Error("Invalid mode");
                }
              }, d = (t2, e2, n2, r2, i2, o2, a2) => {
                const s2 = e2.length;
                let u2 = "";
                for (let t3 = s2 - 1; t3 >= 0; --t3)
                  u2 += `
        k = m[${t3}] - ${o2[t3]};
        if (k < 0)  return constant;
        if (k >= ${e2[t3]}) return constant;
        offset += k * ${n2[t3]};
        `;
                return `
      float padA(int m[${s2}]) {
        const float constant = float(${a2});
        int offset = 0;
        int k = 0;
        ${u2}
        vec2 coords = offsetToCoords(offset, ${r2}, ${i2});
        float value = getColorAsFloat(${t2.texture2D}(A, coords));
        return value;
      }
      `;
              }, h = (t2, e2, n2, r2, i2, o2) => {
                const a2 = e2.length;
                let s2 = "";
                for (let t3 = a2 - 1; t3 >= 0; --t3)
                  s2 += `
        k = m[${t3}] - ${o2[t3]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2 * (e2[t3] - 1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${e2[t3]}) { k = _2n_1 - k; }
        }
        offset += k * ${n2[t3]};
        `;
                return `
      float padA(int m[${a2}]) {
        int offset = 0;
        int k = 0;
        ${s2}
        vec2 coords = offsetToCoords(offset, ${r2}, ${i2});
        float value = getColorAsFloat(${t2.texture2D}(A, coords));
        return value;
      }
      `;
              }, g = (t2, e2, n2, r2, i2, o2) => {
                const a2 = e2.length;
                let s2 = "";
                for (let t3 = a2 - 1; t3 >= 0; --t3)
                  s2 += `
        k = m[${t3}] - ${o2[t3]};
        if (k < 0)  k = 0;
        if (k >= ${e2[t3]}) k = ${e2[t3] - 1};
        offset += k * ${n2[t3]};
      `;
                return `
      float padA(int m[${a2}]) {
        int offset = 0;
        int k = 0;
        ${s2}
        vec2 coords = offsetToCoords(offset, ${r2}, ${i2});
        float value = getColorAsFloat(${t2.texture2D}(A, coords));
        return value;
      }
      `;
              };
            }, 2143: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.globalMaxPool = e.parseMaxPoolAttributes = e.maxPool = e.parseGlobalAveragePoolAttributes = e.globalAveragePool = e.parseAveragePoolAttributes = e.averagePool = void 0;
              const r = n(246), i = n(2517), o = n(2039);
              e.averagePool = (t2, e2, n2) => {
                p(e2);
                const r2 = { name: "AveragePool", inputNames: ["X"], inputTypes: [o.TextureType.unpacked], cacheHint: n2.cacheKey };
                return [t2.run(Object.assign(Object.assign({}, r2), { get: () => a(e2, r2, false, n2) }), e2)];
              }, e.parseAveragePoolAttributes = (t2) => {
                const e2 = t2.attributes.getString("auto_pad", "NOTSET"), n2 = t2.attributes.getInt("ceil_mode", 0), i2 = 0 !== t2.attributes.getInt("count_include_pad", 0), o2 = t2.attributes.getInts("kernel_shape"), a2 = t2.attributes.getInts("strides", []), s2 = t2.attributes.getInts("pads", []);
                if (0 !== n2)
                  throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
                return (0, r.createAttributeWithCacheKey)({ autoPad: e2, ceilMode: n2, countIncludePad: i2, kernelShape: o2, strides: a2, pads: s2 });
              };
              const a = (t2, e2, n2, r2) => {
                const [a2, s2] = u(t2, r2, n2), c2 = i.ShapeUtil.size(a2.kernelShape);
                let l2 = "";
                a2.countIncludePad ? l2 += `value /= float(${c2});` : l2 += `value /= float(${c2} - pad);`;
                const p2 = `
        ${f(t2[0].dims, a2, "value += _X(x);", l2, "0.0")}
      `;
                return Object.assign(Object.assign({}, e2), { output: { dims: s2, type: t2[0].type, textureType: o.TextureType.unpacked }, shaderSource: p2 });
              };
              e.globalAveragePool = (t2, e2, n2) => {
                p(e2);
                const r2 = { name: "GlobalAveragePool", inputNames: ["X"], inputTypes: [o.TextureType.unpacked], cacheHint: `${n2.countIncludePad}` };
                return [t2.run(Object.assign(Object.assign({}, r2), { get: () => a(e2, r2, true, n2) }), e2)];
              }, e.parseGlobalAveragePoolAttributes = (t2) => {
                const e2 = 0 !== t2.attributes.getInt("count_include_pad", 0);
                return (0, r.createAttributeWithCacheKey)({ autoPad: "", ceilMode: 0, countIncludePad: e2, kernelShape: [], strides: [], pads: [] });
              }, e.maxPool = (t2, e2, n2) => {
                p(e2);
                const r2 = { name: "MaxPool", inputNames: ["X"], inputTypes: [o.TextureType.unpacked], cacheHint: n2.cacheKey };
                return [t2.run(Object.assign(Object.assign({}, r2), { get: () => s(e2, r2, false, n2) }), e2)];
              }, e.parseMaxPoolAttributes = (t2) => {
                const e2 = t2.attributes.getString("auto_pad", "NOTSET"), n2 = t2.attributes.getInt("ceil_mode", 0), i2 = t2.attributes.getInts("kernel_shape"), o2 = t2.attributes.getInts("strides", []), a2 = t2.attributes.getInts("pads", []), s2 = t2.attributes.getInt("storage_order", 0), u2 = t2.attributes.getInts("dilations", []);
                if (0 !== s2)
                  throw new Error("column major storage order is not yet supported for MaxPool");
                if (0 !== n2)
                  throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
                return (0, r.createAttributeWithCacheKey)({ autoPad: e2, ceilMode: n2, countIncludePad: false, kernelShape: i2, strides: o2, pads: a2, storageOrder: s2, dilations: u2 });
              };
              const s = (t2, e2, n2, r2) => {
                const [i2, a2] = u(t2, r2, n2), s2 = `
      ${f(t2[0].dims, i2, "\n      value = max(_X(x), value);\n    ", "", "-1e5")}
    `;
                return Object.assign(Object.assign({}, e2), { output: { dims: a2, type: t2[0].type, textureType: o.TextureType.unpacked }, shaderSource: s2 });
              }, u = (t2, e2, n2) => {
                const r2 = t2[0].dims.slice(), o2 = Object.hasOwnProperty.call(e2, "dilations"), a2 = e2.kernelShape.slice(), s2 = e2.strides.slice(), u2 = o2 ? e2.dilations.slice() : [], c2 = e2.pads.slice();
                i.PoolConvUtil.adjustPoolAttributes(n2, r2, a2, s2, u2, c2);
                const l2 = i.PoolConvUtil.computePoolOutputShape(n2, r2, s2, u2, a2, c2, e2.autoPad), p2 = Object.assign({}, e2);
                return o2 ? Object.assign(p2, { kernelShape: a2, strides: s2, pads: c2, dilations: u2, cacheKey: e2.cacheKey }) : Object.assign(p2, { kernelShape: a2, strides: s2, pads: c2, cacheKey: e2.cacheKey }), [p2, l2];
              }, c = { autoPad: "", ceilMode: 0, countIncludePad: false, kernelShape: [], strides: [], pads: [], storageOrder: 0, dilations: [], cacheKey: "" }, l = { name: "GlobalMaxPool", inputNames: ["X"], inputTypes: [o.TextureType.unpacked] };
              e.globalMaxPool = (t2, e2) => (p(e2), [t2.run(Object.assign(Object.assign({}, l), { get: () => s(e2, l, true, c) }), e2)]);
              const p = (t2) => {
                if (!t2 || 1 !== t2.length)
                  throw new Error("Pool ops requires 1 input.");
                if ("float32" !== t2[0].type && "float64" !== t2[0].type)
                  throw new Error("Invalid input type.");
              }, f = (t2, e2, n2, r2, o2) => {
                const a2 = t2.length;
                if (e2.kernelShape.length <= 2) {
                  const i2 = e2.kernelShape[e2.kernelShape.length - 1], s2 = e2.strides[e2.strides.length - 1], u2 = e2.pads[e2.pads.length / 2 - 1], c2 = e2.pads[e2.pads.length - 1], l2 = t2[a2 - 1];
                  let p2 = "", f2 = "", d2 = "";
                  if (p2 = u2 + c2 !== 0 ? `
          for (int i = 0; i < ${i2}; i++) {
            x[${a2} - 1] = indices[${a2} - 1] * ${s2} - ${u2} + i;
            if (x[${a2} - 1] < 0 || x[${a2} - 1] >= ${l2}) {
              pad++;
              continue;
            }
            ${n2}
          }` : `
          for (int i = 0; i < ${i2}; i++) {
            x[${a2} - 1] = indices[${a2} - 1] * ${s2} - ${u2} + i;
            ${n2}
          }`, 2 === e2.kernelShape.length) {
                    const n3 = e2.kernelShape[e2.kernelShape.length - 2], r3 = e2.strides[e2.strides.length - 2], o3 = e2.pads[e2.pads.length / 2 - 2], s3 = e2.pads[e2.pads.length - 2], u3 = t2[a2 - 2];
                    f2 = o3 + s3 !== 0 ? `
            for (int j = 0; j < ${n3}; j++) {
              x[${a2} - 2] = indices[${a2} - 2] * ${r3} - ${o3} + j;
              if (x[${a2} - 2] < 0 || x[${a2} - 2] >= ${u3}) {
                pad+= ${i2};
                continue;
              }
          ` : `
            for (int j = 0; j < ${n3}; j++) {
              x[${a2} - 2] = indices[${a2} - 2] * ${r3} - ${o3} + j;
            `, d2 = "\n          }\n        ";
                  }
                  return `
        float process(int indices[${a2}]) {
          int x[${a2}];
          copyVec(indices, x);

          float value = ${o2};
          int pad = 0;
          ${f2}
          ${p2}
          ${d2}
          ${r2}
          return value;
        }
      `;
                }
                {
                  const s2 = i.ShapeUtil.size(e2.kernelShape), u2 = i.ShapeUtil.computeStrides(e2.kernelShape), c2 = u2.length, l2 = e2.pads.length, p2 = h(c2), f2 = d(t2, "inputDims"), g = d(e2.pads, "pads"), b = d(u2, "kernelStrides"), m = d(e2.strides, "strides");
                  let y = "";
                  return y = e2.pads.reduce((t3, e3) => t3 + e3) ? `
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${n2}
          }` : `
          }
          ${n2}
        `, `
        ${p2}
        float process(int indices[${a2}]) {
          int x[${a2}];
          copyVec(indices, x);
          int offset[${c2}];
          int pads[${l2}];
          int inputDims[${a2}];
          int kernelStrides[${c2}];
          int strides[${c2}];
          ${g}
          ${f2}
          ${m}
          ${b}

          float value = ${o2};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${s2}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${a2} - ${c2}; j < ${a2}; j++) {
              x[j] = indices[j] * strides[j - ${a2} + ${c2}]
                + offset[j - ${a2} + ${c2}] - pads[j - 2];
              ${y}
          }
          ${r2}

          return value;
        }
      `;
                }
              }, d = (t2, e2) => {
                let n2 = "";
                for (let r2 = 0; r2 < t2.length; r2++)
                  n2 += `
      ${e2}[${r2}] = ${t2[r2]};
    `;
                return n2;
              }, h = (t2) => `
  void offsetToIndices(int offset, int[${t2}] strides, out int[${t2}] indices) {
    if (${t2} == 0) {
      return;
    }
    for (int i = 0; i < ${t2} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${t2} - 1] = offset;
  }`;
            }, 4939: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.reduceLogSumSquare = e.reduceLogSum = e.reduceProd = e.reduceMin = e.reduceMax = e.reduceMean = e.reduceSum = e.parseReduceAttributes = void 0;
              const r = n(246), i = n(782), o = n(2517), a = n(2039), s = (t2, e2, n2, r2, i2) => {
                c(e2);
                const o2 = { name: r2, inputNames: ["A"], inputTypes: [a.TextureType.unpacked] };
                return [t2.run(Object.assign(Object.assign({}, o2), { cacheHint: n2.cacheKey, get: () => u(t2, e2, n2, r2, i2, o2) }), e2)];
              };
              e.parseReduceAttributes = (t2) => {
                const e2 = t2.attributes.getInts("axes", []), n2 = 1 === t2.attributes.getInt("keepdims", 1);
                return (0, r.createAttributeWithCacheKey)({ axes: e2, keepDims: n2 });
              };
              const u = (t2, e2, n2, r2, i2, s2) => {
                const u2 = [], c2 = e2[0].dims.length || 1, l = [], p = o.ShapeUtil.normalizeAxes(n2.axes, e2[0].dims.length), f = i2(e2, p);
                let d = f[1];
                for (let t3 = 0; t3 < e2[0].dims.length; t3++)
                  p.indexOf(t3) >= 0 || 0 === p.length ? (n2.keepDims && u2.push(1), d = `
          for(int j${t3} = 0; j${t3} < ${e2[0].dims[t3]}; j${t3}++) {
            inputIdx[${t3}] = j${t3};
            ${d}
          }`) : (l.push(`inputIdx[${t3}] = outputIdx[${u2.length}];`), u2.push(e2[0].dims[t3]));
                const h = `
      float process(int outputIdx[${u2.length || 1}]) {
        float value;                 // final result
        int inputIdx[${c2}];      // addressing input data
        ${l.join("\n")}
        ${f[0]}       // init ops for reduce max/min
        ${d}
        ${f[2]}       // final computation for reduce mean
        return value;
      }`;
                return Object.assign(Object.assign({}, s2), { output: { dims: u2, type: e2[0].type, textureType: a.TextureType.unpacked }, shaderSource: h });
              }, c = (t2) => {
                if (!t2 || 1 !== t2.length)
                  throw new Error("Reduce op requires 1 input.");
                if (-1 === i.NUMBER_TYPES.indexOf(t2[0].type))
                  throw new Error("Invalid input type.");
              };
              e.reduceSum = (t2, e2, n2) => s(t2, e2, n2, "ReduceSum", () => ["value = 0.0;", "value += _A(inputIdx);", ""]), e.reduceMean = (t2, e2, n2) => s(t2, e2, n2, "ReduceMean", (t3, e3) => {
                let n3 = 1;
                for (let r2 = 0; r2 < t3[0].dims.length; r2++)
                  (e3.indexOf(r2) >= 0 || 0 === e3.length) && (n3 *= t3[0].dims[r2]);
                return ["value = 0.0;", "value += _A(inputIdx);", `value /= ${n3}.;`];
              }), e.reduceMax = (t2, e2, n2) => s(t2, e2, n2, "ReduceMax", (t3, e3) => {
                const n3 = [];
                for (let r2 = 0; r2 < t3[0].dims.length; r2++)
                  (e3.indexOf(r2) >= 0 || 0 === e3.length) && n3.push(`inputIdx[${r2}] = 0;`);
                return [`${n3.join("\n")}
value = _A(inputIdx);`, "value = max(value, _A(inputIdx));", ""];
              }), e.reduceMin = (t2, e2, n2) => s(t2, e2, n2, "ReduceMin", (t3, e3) => {
                const n3 = [];
                for (let r2 = 0; r2 < t3[0].dims.length; r2++)
                  (e3.indexOf(r2) >= 0 || 0 === e3.length) && n3.push(`inputIdx[${r2}] = 0;`);
                return [`${n3.join("\n")}
value = _A(inputIdx);`, "value = min(value, _A(inputIdx));", ""];
              }), e.reduceProd = (t2, e2, n2) => s(t2, e2, n2, "ReduceProd", () => ["value = 1.0;", "value *= _A(inputIdx);", ""]), e.reduceLogSum = (t2, e2, n2) => s(t2, e2, n2, "ReduceLogSum", () => ["value = 0.0;", "value += _A(inputIdx);", "value = log(value);"]), e.reduceLogSumSquare = (t2, e2, n2) => s(t2, e2, n2, "ReduceLogSumSquare", () => ["float t; value = 0.0;", "t = _A(inputIdx); value += t * t;", ""]);
            }, 7019: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.isReshapeCheap = e.processDims3D = e.createPackedReshape3DProgramInfoLoader = void 0;
              const r = n(2517), i = n(5060), o = n(2039), a = n(2827);
              e.createPackedReshape3DProgramInfoLoader = (t2, e2, n2) => {
                const s = ((t3) => ({ name: "Reshape (packed)", inputTypes: [o.TextureType.packed], inputNames: ["A"], cacheHint: `${t3}` }))(n2);
                return Object.assign(Object.assign({}, s), { get: () => ((t3, e3, n3, s2) => {
                  const u = e3.dims, c = s2;
                  let l = "";
                  for (let t4 = 0; t4 < 4; t4++) {
                    let e4 = "";
                    switch (t4) {
                      case 0:
                        e4 = "outputCoords = rc;";
                        break;
                      case 1:
                        e4 = "outputCoords = ivec3(rc.x, rc.y+1, rc.z);";
                        break;
                      case 2:
                        e4 = "outputCoords = ivec3(rc.x, rc.y, rc.z+1);";
                        break;
                      case 3:
                        e4 = "outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";
                        break;
                      default:
                        throw new Error();
                    }
                    l += `
        ${e4}
        ${t4 > 0 ? "if(outputCoords.y < rows && outputCoords.z < cols){" : ""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${t4}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${t4 > 0 ? "}" : ""}
      `;
                  }
                  const p = (0, i.getGlsl)(t3.session.backend.glContext.version), f = `
      ${function(t4) {
                    const e4 = r.ShapeUtil.computeStrides(t4), n4 = ["b", "r", "c"], i2 = "index";
                    return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e4.map((t5, r2) => `int ${n4[r2]} = ${i2} / ${t5}; ${r2 === e4.length - 1 ? `int ${n4[r2 + 1]} = ${i2} - ${n4[r2]} * ${t5}` : `index -= ${n4[r2]} * ${t5}`};`).join("")}
      return ivec3(b, r, c);
    }
  `;
                  }(u)}
      ${function(t4) {
                    const e4 = r.ShapeUtil.computeStrides(t4);
                    return `
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${e4[0]} + coords.z * ${e4[1]} + coords.y;
  }
`;
                  }(c)}
      ${(0, a.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${c[2]};
        int cols = ${c[1]};

        ${l}
        ${p.output} = result;
      }
    `;
                  return Object.assign(Object.assign({}, n3), { output: { dims: c, type: e3.type, textureType: o.TextureType.packed }, shaderSource: f, hasMain: true });
                })(t2, e2, s, n2) });
              }, e.processDims3D = function(t2) {
                if (0 === t2.length)
                  return [1, 1, 1];
                let e2 = 1;
                for (let n2 = 0; n2 < t2.length - 2; ++n2)
                  e2 *= t2[n2];
                return [e2, t2.length > 1 ? t2[t2.length - 2] : 1, t2[t2.length - 1]];
              }, e.isReshapeCheap = function(t2, e2) {
                let n2 = false;
                return n2 = 0 === t2.length || 0 === e2.length || (t2.length < 2 || e2.length < 2 ? t2[t2.length - 1] === e2[e2.length - 1] : t2[t2.length - 1] === e2[e2.length - 1] && t2[t2.length - 2] === e2[e2.length - 2]), n2;
              };
            }, 718: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.reshape = void 0;
              const r = n(2517);
              e.reshape = (t2, e2) => {
                const n2 = r.ShapeUtil.calculateReshapedDims(e2[0].dims, e2[1].integerData);
                return t2.session.pack ? [t2.reshapePacked(e2[0], n2)] : [t2.reshapeUnpacked(e2[0], n2)];
              };
            }, 2268: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.parseResizeAttributesV11 = e.parseResizeAttributesV10 = e.resize = void 0;
              const r = n(5060), i = n(2039), o = n(9390), a = n(2827), s = n(9793), u = { name: "Resize", inputNames: ["A"], inputTypes: [i.TextureType.packed] };
              e.resize = (t2, e2, n2) => ((0, s.validateInputs)(e2, n2), [t2.run(Object.assign(Object.assign({}, u), { cacheHint: n2.cacheKey, get: () => c(t2, e2, n2) }), e2)]), e.parseResizeAttributesV10 = (t2) => (0, s.parseUpsampleAttributes)(t2, 10), e.parseResizeAttributesV11 = (t2) => (0, s.parseUpsampleAttributes)(t2, 11);
              const c = (t2, e2, n2) => {
                const s2 = (0, r.getGlsl)(t2.session.backend.glContext.version), [c2, p2] = l(e2, n2);
                if (c2.every((t3) => 1 === t3) && "tf_crop_and_resize" !== n2.coordinateTransformMode)
                  return Object.assign(Object.assign({}, u), { output: { dims: p2, type: e2[0].type, textureType: i.TextureType.packed }, hasMain: true, shaderSource: `void main() {
                    vec4 v = ${s2.texture2D}(X, TexCoords);
                    ${s2.output} = v;
                }` });
                const f2 = p2.length;
                if (f2 < 2)
                  throw new Error(`output dimension should be at least 2, but got ${f2}`);
                const d = p2[f2 - 2], h = p2[f2 - 1], g = e2[0].dims;
                if (f2 !== g.length)
                  throw new Error(`output dimension should match input ${g.length}, but got ${f2}`);
                const b = g[f2 - 2], m = g[f2 - 1], y = c2[f2 - 2], _ = c2[f2 - 1];
                let v = "";
                if ("linear" !== n2.mode)
                  throw new Error(`resize (packed) does not support mode: '${n2.mode}'`);
                switch (n2.coordinateTransformMode) {
                  case "asymmetric":
                    v = "\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";
                    break;
                  case "half_pixel":
                    v = "\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";
                    break;
                  case "pytorch_half_pixel":
                    v = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${h}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${d}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${h}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${d}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;
                    break;
                  case "align_corners":
                    v = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${h}.0 - 1.0, ${d}.0 - 1.0, ${h}.0 - 1.0,
                            ${d}.0 - 1.0);
                        vec4 original = vec4(${m}.0 - 1.0, ${b}.0 - 1.0, ${m}.0 - 1.0,
                            ${b}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;
                    break;
                  default:
                    throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n2.coordinateTransformMode}'`);
                }
                const w = (0, o.getCoordsDataType)(f2), x = `
            const vec2 inputWH = vec2(${b}.0, ${m}.0);
            const vec4 scaleWHWH = vec4(float(${y}), float(${_}), float(${y}), float(${_}));
            ${(0, a.unpackFromChannel)()}
            ${v}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${w} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${d - 1};
                bool hasNextCol = rc.z < ${h - 1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${s2.output} = vec4(newValue);
            }
        `;
                return Object.assign(Object.assign({}, u), { output: { dims: p2, type: e2[0].type, textureType: i.TextureType.packed }, hasMain: true, shaderSource: x });
              }, l = (t2, e2) => {
                const n2 = t2[0].dims;
                let r2, i2 = e2.scales;
                if (0 === i2.length) {
                  const o3 = t2[e2.scalesInputIdx];
                  if (o3 && 0 !== o3.size) {
                    if (t2[e2.sizesInputIdx])
                      throw new Error("Only one of scales or sizes must be provided as input.");
                    i2 = p(o3, e2.mode, e2.isResize);
                  } else {
                    const o4 = t2[e2.sizesInputIdx];
                    if (!o4 || 0 === o4.size)
                      throw new Error("Either scales or sizes MUST be provided as input.");
                    r2 = Array.from(o4.integerData), i2 = f(r2, n2, e2.mode, e2.isResize);
                  }
                } else if (t2[e2.sizesInputIdx])
                  throw new Error("Only one of scales or sizes must be provided as input.");
                const o2 = r2 || n2.map((t3, e3) => Math.floor(t3 * i2[e3]));
                return [i2, o2];
              }, p = (t2, e2, n2) => {
                const r2 = Array.from(t2.floatData);
                return (0, s.scalesValidation)(r2, e2, n2), r2;
              }, f = (t2, e2, n2, r2) => {
                const i2 = e2.length, o2 = new Array(i2);
                for (let n3 = 0, r3 = i2; n3 < r3; n3++)
                  if (0 === e2[n3]) {
                    if (0 !== t2[n3])
                      throw new Error("Input dim is zero but required output dim is non-zero.");
                    o2[n3] = 1;
                  } else
                    o2[n3] = t2[n3] / e2[n3];
                return (0, s.scalesValidation)(o2, n2, r2), o2;
              };
            }, 8117: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.shape = void 0;
              const r = n(9162);
              e.shape = (t2, e2) => (i(e2), [new r.Tensor([e2[0].dims.length], "int32", void 0, void 0, new Int32Array(e2[0].dims))]);
              const i = (t2) => {
                if (!t2 || 1 !== t2.length)
                  throw new Error("Shape requires 1 input.");
              };
            }, 2278: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.sliceV10 = e.parseSliceAttributes = e.slice = void 0;
              const r = n(246), i = n(782), o = n(2517), a = n(2039), s = { name: "Slice", inputNames: ["A"], inputTypes: [a.TextureType.unpacked] };
              e.slice = (t2, e2, n2) => (c(e2), [t2.run(Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey, get: () => u(t2, e2[0], n2) }), e2)]), e.parseSliceAttributes = (t2) => {
                const e2 = t2.attributes.getInts("starts"), n2 = t2.attributes.getInts("ends"), i2 = t2.attributes.getInts("axes", []);
                return (0, r.createAttributeWithCacheKey)({ starts: e2, ends: n2, axes: i2 });
              };
              const u = (t2, e2, n2) => {
                const r2 = 0 === n2.axes.length ? e2.dims.slice(0).map((t3, e3) => e3) : n2.axes, i2 = o.ShapeUtil.normalizeAxes(r2, e2.dims.length), u2 = n2.starts.map((t3, n3) => t3 > e2.dims[i2[n3]] - 1 ? e2.dims[i2[n3]] : o.ShapeUtil.normalizeAxis(t3, e2.dims[i2[n3]])), c2 = n2.ends.map((t3, n3) => t3 > e2.dims[i2[n3]] - 1 ? e2.dims[i2[n3]] : o.ShapeUtil.normalizeAxis(t3, e2.dims[i2[n3]])), l2 = e2.dims.slice(), p2 = [];
                for (let t3 = 0; t3 < i2.length; t3++)
                  l2[i2[t3]] = c2[t3] - u2[t3], u2[t3] > 0 && p2.push(`outputIdx[${i2[t3]}] += ${u2[t3]};`);
                const f = `
      float process(int outputIdx[${l2.length}]) {
        ${p2.join("\n      ")}
        return _A(outputIdx);
      }`;
                return Object.assign(Object.assign({}, s), { output: { dims: l2, type: e2.type, textureType: a.TextureType.unpacked }, shaderSource: f });
              }, c = (t2) => {
                if (!t2 || 1 !== t2.length)
                  throw new Error("Slice requires 1 input.");
                if (-1 === i.NUMBER_TYPES.indexOf(t2[0].type))
                  throw new Error("Invalid input type.");
              };
              e.sliceV10 = (t2, e2) => {
                p(e2);
                const n2 = l(t2, e2);
                return [t2.run(Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey, get: () => u(t2, e2[0], n2) }), [e2[0]])];
              };
              const l = (t2, e2) => {
                if (!t2.session.isInitializer(e2[1].dataId) || !t2.session.isInitializer(e2[2].dataId) || e2.length >= 4 && !t2.session.isInitializer(e2[3].dataId) || e2.length >= 5 && !t2.session.isInitializer(e2[4].dataId))
                  throw new Error("dynamic slice attributes are not allowed");
                if (e2.length >= 5 && e2[4].integerData.some((t3) => 1 !== t3))
                  throw new Error("currently non-1 steps is not supported for Slice");
                const n2 = Array.from(e2[1].integerData), r2 = Array.from(e2[2].integerData), i2 = e2.length >= 4 ? Array.from(e2[3].integerData) : [];
                return { starts: n2, ends: r2, axes: i2, cacheKey: `${i2};${n2};${r2}` };
              }, p = (t2) => {
                if (!t2 || t2.length < 3 || t2.length > 5)
                  throw new Error("Invalid input number.");
                if ("int32" !== t2[1].type || 1 !== t2[1].dims.length)
                  throw new Error("Invalid input type.");
                if ("int32" !== t2[2].type || 1 !== t2[2].dims.length)
                  throw new Error("Invalid input type.");
                if (t2.length >= 4 && ("int32" !== t2[3].type || 1 !== t2[3].dims.length))
                  throw new Error("Invalid input type.");
                if (t2.length >= 5 && ("int32" !== t2[4].type || 1 !== t2[4].dims.length))
                  throw new Error("Invalid input type.");
              };
            }, 5524: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.softmaxV13 = e.parseSoftmaxAttributesV13 = e.parseSoftmaxAttributes = e.softmax = void 0;
              const r = n(246), i = n(2517), o = n(5060), a = n(2039), s = n(3738), u = { name: "SoftmaxComputeMax", inputNames: ["A"], inputTypes: [a.TextureType.unpacked] }, c = { name: "SoftmaxComputeScale", inputNames: ["A", "Max"], inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked] }, l = { name: "SoftMax", inputNames: ["A", "Max", "Norm"], inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked, a.TextureType.unpacked] };
              e.softmax = (t2, e2, n2) => {
                g(e2);
                const r2 = e2[0].dims.slice(), o2 = i.ShapeUtil.normalizeAxis(n2.axis, r2.length), a2 = i.ShapeUtil.sizeToDimension(r2, o2), s2 = i.ShapeUtil.sizeFromDimension(r2, o2);
                return p(t2, e2, n2, a2, s2);
              }, e.parseSoftmaxAttributes = (t2) => (0, r.createAttributeWithCacheKey)({ axis: t2.attributes.getInt("axis", 1) }), e.parseSoftmaxAttributesV13 = (t2) => (0, r.createAttributeWithCacheKey)({ axis: t2.attributes.getInt("axis", -1) }), e.softmaxV13 = (t2, e2, n2) => {
                g(e2);
                const o2 = e2[0].dims.slice(), a2 = i.ShapeUtil.normalizeAxis(n2.axis, o2.length), u2 = o2.length, c2 = a2 !== u2 - 1, l2 = [];
                let f2, d2 = [], h2 = [];
                c2 && (d2 = Array.from({ length: u2 }).map((t3, e3) => e3), d2[a2] = u2 - 1, d2[u2 - 1] = a2, d2.map((t3) => l2.push(o2[t3])), f2 = (0, r.createAttributeWithCacheKey)({ perm: d2 }), h2 = (0, s.transpose)(t2, e2, f2));
                const b = c2 ? i.ShapeUtil.sizeToDimension(l2, u2 - 1) : i.ShapeUtil.sizeToDimension(o2, u2 - 1), m = c2 ? i.ShapeUtil.sizeFromDimension(l2, u2 - 1) : i.ShapeUtil.sizeFromDimension(o2, u2 - 1), y = p(t2, c2 ? h2 : e2, n2, b, m);
                return c2 ? (0, s.transpose)(t2, y, f2) : y;
              };
              const p = (t2, e2, n2, r2, i2) => {
                const o2 = f(t2, e2[0], r2, i2, [r2]), a2 = t2.run(Object.assign(Object.assign({}, u), { cacheHint: n2.cacheKey, get: () => o2 }), e2), s2 = d(t2, e2[0], r2, i2, o2.output.dims, [r2]), p2 = t2.run(Object.assign(Object.assign({}, c), { cacheHint: n2.cacheKey, get: () => s2 }), [e2[0], a2]), g2 = h(t2, e2[0], r2, i2, o2.output.dims, s2.output.dims);
                return [t2.run(Object.assign(Object.assign({}, l), { cacheHint: n2.cacheKey, get: () => g2 }), [e2[0], a2, p2])];
              }, f = (t2, e2, n2, r2, i2) => {
                const [s2, c2] = t2.calculateTextureWidthAndHeight(e2.dims, a.TextureType.unpacked), l2 = i2.length;
                if (n2 < 1 || r2 < 1)
                  throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
                if (1 !== i2.length)
                  throw new Error("Dimensionality of the output should be 1");
                if (i2[0] !== n2)
                  throw new Error("Shape of the output should be equal to logical row count");
                const p2 = (0, o.getGlsl)(t2.session.backend.glContext.version), f2 = `
      float process(int[${l2}] indices) {
        int logical_row_start_offset = indices[0] * ${r2};

        float max = getColorAsFloat(${p2.texture2D}(A, offsetToCoords(logical_row_start_offset, ${s2},
        ${c2} )));
        for(int i=1; i<${r2}; ++i)
        {
          float current = getColorAsFloat(${p2.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${s2}, ${c2})));
          if(current > max)
          max = current;
        }

        return max;
      }`;
                return Object.assign(Object.assign({}, u), { output: { dims: i2, type: e2.type, textureType: a.TextureType.unpacked }, shaderSource: f2 });
              }, d = (t2, e2, n2, r2, i2, s2) => {
                const [u2, l2] = t2.calculateTextureWidthAndHeight(e2.dims, a.TextureType.unpacked), p2 = s2.length;
                if (n2 < 1 || r2 < 1)
                  throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
                if (1 !== s2.length)
                  throw new Error("Dimensionality of the output should be 1");
                if (s2[0] !== n2)
                  throw new Error("Shape of the output should be equal to logical row count");
                if (1 !== i2.length)
                  throw new Error("Dimensionality of the intermediate results should be 1");
                if (i2[0] !== n2)
                  throw new Error("Shape of the intermediate results should be equal to logical row count");
                const f2 = `
      float process(int[${p2}] indices) {
        int logical_row_start_offset = indices[0] * ${r2};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${r2}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0, o.getGlsl)(t2.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${u2}, ${l2}))) - max);
        }

        return norm_factor;
      }`;
                return Object.assign(Object.assign({}, c), { output: { dims: s2, type: e2.type, textureType: a.TextureType.unpacked }, shaderSource: f2 });
              }, h = (t2, e2, n2, r2, i2, o2) => {
                const [s2, u2] = t2.calculateTextureWidthAndHeight(e2.dims, a.TextureType.unpacked), c2 = e2.dims.length;
                if (n2 < 1 || r2 < 1)
                  throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
                if (1 !== i2.length || 1 !== o2.length)
                  throw new Error("Dimensionality of the intermediate results should be 1");
                if (i2[0] !== n2 || o2[0] !== n2)
                  throw new Error("Shape of the intermediate results should be equal to logical row count");
                const p2 = `
      float process(int[${c2}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${s2}, ${u2});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${r2};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;
                return Object.assign(Object.assign({}, l), { output: { dims: e2.dims, type: e2.type, textureType: a.TextureType.unpacked }, shaderSource: p2 });
              }, g = (t2) => {
                if (!t2 || 1 !== t2.length)
                  throw new Error("Softmax requires 1 input.");
                if ("float32" !== t2[0].type && "float64" !== t2[0].type)
                  throw new Error("Invalid input type");
              };
            }, 5975: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.parseSplitAttributes = e.split = void 0;
              const r = n(246), i = n(2517), o = n(2039), a = { name: "Split", inputNames: ["A"], inputTypes: [o.TextureType.unpacked] };
              e.split = (t2, e2, n2) => {
                c(e2);
                const r2 = i.ShapeUtil.normalizeAxis(n2.axis, e2[0].dims.length), o2 = s(t2, e2, r2, n2), l = [];
                for (let i2 = 0; i2 < o2; ++i2)
                  l.push(t2.run(Object.assign(Object.assign({}, a), { cacheHint: `${n2.cacheKey};${i2}`, get: () => u(t2, e2[0], n2, r2, i2) }), e2));
                return l;
              }, e.parseSplitAttributes = (t2) => {
                const e2 = t2.attributes.getInt("axis", 0), n2 = t2.attributes.getInts("split", []), i2 = t2.outputs.length;
                return (0, r.createAttributeWithCacheKey)({ axis: e2, split: n2, numOutputs: i2 });
              };
              const s = (t2, e2, n2, r2) => {
                const [, o2] = i.SplitUtil.splitShape(e2[0].dims, n2, r2.split, r2.numOutputs);
                return o2.length;
              }, u = (t2, e2, n2, r2, s2) => {
                const [u2, c2] = i.SplitUtil.splitShape(e2.dims, r2, n2.split, n2.numOutputs), l = c2[s2], p = u2[s2], f = `
      float process(int indices[${p.length}]) {
        indices[${r2}] += ${l};
        return _A(indices);
      }
    `;
                return Object.assign(Object.assign({}, a), { cacheHint: `${n2.cacheKey}:${s2}`, output: { dims: p, type: e2.type, textureType: o.TextureType.unpacked }, shaderSource: f });
              }, c = (t2) => {
                if (!t2 || 1 !== t2.length)
                  throw new Error("Split requires one input.");
                if ("int8" !== t2[0].type && "uint8" !== t2[0].type && "int16" !== t2[0].type && "uint16" !== t2[0].type && "int32" !== t2[0].type && "uint32" !== t2[0].type && "float32" !== t2[0].type && "float64" !== t2[0].type && "bool" !== t2[0].type)
                  throw new Error("Invalid input type.");
              };
            }, 3933: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.parseSqueezeAttributes = e.squeezeV13 = e.squeeze = void 0;
              const r = n(2517);
              e.squeeze = (t2, e2, n2) => {
                i(e2);
                const o2 = r.ShapeUtil.squeezeShape(e2[0].dims, n2);
                return [t2.reshapeUnpacked(e2[0], o2)];
              }, e.squeezeV13 = (t2, n2) => (o(n2), (0, e.squeeze)(t2, [n2[0]], Array.from(n2[1].integerData))), e.parseSqueezeAttributes = (t2) => t2.attributes.getInts("axes");
              const i = (t2) => {
                if (!t2 || 1 !== t2.length)
                  throw new Error("Squeeze requires 1 input.");
                if ("string" === t2[0].type)
                  throw new Error("invalid input tensor types.");
              }, o = (t2) => {
                if (!t2 || 2 !== t2.length)
                  throw new Error("Squeeze requires 2 inputs.");
                if ("int32" !== t2[1].type)
                  throw new Error("Invalid input type.");
              };
            }, 6558: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.sum = void 0;
              const r = n(5060), i = n(2039);
              e.sum = (t2, e2) => {
                a(e2);
                const n2 = { name: "Sum", inputNames: e2.map((t3, e3) => `X${e3}`), inputTypes: new Array(e2.length).fill(i.TextureType.unpacked) };
                return [t2.run(Object.assign(Object.assign({}, n2), { get: () => o(t2, e2, n2) }), e2)];
              };
              const o = (t2, e2, n2) => {
                const o2 = (0, r.getGlsl)(t2.session.backend.glContext.version), a2 = e2[0].dims.slice(), s = `
      void main() {
        vec4 result = ${e2.map((t3, e3) => `${o2.texture2D}(X${e3},TexCoords)`).join(" + ")};
        ${o2.output} = result;
      }
    `;
                return Object.assign(Object.assign({}, n2), { output: { dims: a2, type: e2[0].type, textureType: i.TextureType.unpacked }, hasMain: true, shaderSource: s });
              }, a = (t2) => {
                if (!t2 || 0 === t2.length)
                  throw new Error("Sum requires inputs.");
                const e2 = t2[0].dims.length;
                for (let n2 = 1; n2 < t2.length; n2++) {
                  if (e2 !== t2[n2].dims.length)
                    throw new Error("Input shapes are mismatched.");
                  for (let r2 = 0; r2 < e2; r2++)
                    if (t2[0].dims[r2] !== t2[n2].dims[r2])
                      throw new Error("Input shapes are not matched.");
                }
                if ("float32" !== t2[0].type && "float64" !== t2[0].type)
                  throw new Error("Invalid input type.");
                for (let e3 = 1; e3 < t2.length; e3++)
                  if (t2[0].type !== t2[e3].type)
                    throw new Error("Input types are not matched.");
              };
            }, 5723: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.tile = void 0;
              const r = n(782), i = n(2039);
              e.tile = (t2, e2) => {
                a(e2);
                const n2 = { name: "Tile", inputNames: ["A"], inputTypes: [i.TextureType.unpacked] };
                return [t2.run(Object.assign(Object.assign({}, n2), { get: () => o(t2, e2, n2) }), e2)];
              };
              const o = (t2, e2, n2) => {
                const r2 = e2[0].dims.slice(), o2 = new Array(r2.length), a2 = [];
                for (let t3 = 0; t3 < r2.length; t3++)
                  o2[t3] = r2[t3] * e2[1].numberData[t3], a2.push(`inputIdx[${t3}] = int(mod(float(outputIdx[${t3}]), ${r2[t3]}.));`);
                const s = o2.length, u = `
      float process(int outputIdx[${s}]) {
        int inputIdx[${s}];
        ${a2.join("\n")}
        return _A(inputIdx);
      }
    `;
                return Object.assign(Object.assign({}, n2), { output: { dims: o2, type: e2[0].type, textureType: i.TextureType.unpacked }, shaderSource: u });
              }, a = (t2) => {
                if (!t2 || 2 !== t2.length)
                  throw new Error("Tile requires 2 input.");
                if (1 !== t2[1].dims.length)
                  throw new Error("The second input shape must 1 dimension.");
                if (t2[1].dims[0] !== t2[0].dims.length)
                  throw new Error("Invalid input shape.");
                if (-1 === r.NUMBER_TYPES.indexOf(t2[0].type))
                  throw new Error("Invalid input type.");
                if ("int32" !== t2[1].type && "int16" !== t2[1].type)
                  throw new Error("Invalid repeat type.");
              };
            }, 3738: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.parseTransposeAttributes = e.transpose = void 0;
              const r = n(246), i = n(2517), o = n(2039), a = { name: "Transpose", inputNames: ["A"], inputTypes: [o.TextureType.unpacked] };
              e.transpose = (t2, e2, n2) => (p(e2), [t2.run(Object.assign(Object.assign({}, a), { cacheHint: n2.cacheKey, get: () => s(t2, e2[0], n2.perm) }), e2)]), e.parseTransposeAttributes = (t2) => (0, r.createAttributeWithCacheKey)({ perm: t2.attributes.getInts("perm", []) });
              const s = (t2, e2, n2) => {
                const r2 = e2.dims;
                n2 = u(r2, n2);
                const i2 = c(r2, n2), s2 = r2.length, p2 = `
      ${l("perm", n2, s2)}
      float process(int indices[${s2}]) {
        int a[${s2}];
        perm(a, indices);
        return _A(a);
      }`;
                return Object.assign(Object.assign({}, a), { output: { dims: i2, type: e2.type, textureType: o.TextureType.unpacked }, shaderSource: p2 });
              }, u = (t2, e2) => (e2 && e2.length !== t2.length && (e2 = [...t2.keys()].reverse()), e2), c = (t2, e2) => (e2 = u(t2, e2), i.ShapeUtil.sortBasedOnPerm(t2, e2)), l = (t2, e2, n2) => {
                const r2 = [];
                r2.push(`void ${t2}(out int a[${n2}], int src[${n2}]) {`);
                for (let t3 = 0; t3 < n2; ++t3)
                  r2.push(`	a[${e2[t3]}]=src[${t3}];`);
                return r2.push("	}"), r2.join("\n");
              }, p = (t2) => {
                if (!t2 || 1 !== t2.length)
                  throw new Error("Transpose requires 1 input.");
                if ("float32" !== t2[0].type && "float64" !== t2[0].type)
                  throw new Error("input should be float tensor");
              };
            }, 8710: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.encodeAsUint8 = void 0;
              const r = n(5060), i = n(2039);
              e.encodeAsUint8 = (t2, e2) => {
                const n2 = e2.shape, o = (0, r.getGlsl)(t2.session.backend.glContext.version), a = `
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${o.texture2D}(X,TexCoords).r;
      ${o.output} = encodeAsUint8(value);
    }`, s = { name: "Uint8Encode", inputTypes: [i.TextureType.unpacked], inputNames: ["X"], output: { dims: n2, type: e2.tensor.type, textureType: i.TextureType.downloadUint8AsFloat }, shaderSource: a, hasMain: true };
                return t2.executeProgram(s, [e2.tensor]);
              };
            }, 4909: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.tanh = e.tan = e.sqrt = e.sin = e.sigmoid = e.relu = e.not = e.neg = e.log = e.parseLeakyReluAttributes = e.leakyRelu = e.identity = e.floor = e.exp = e.parseEluAttributes = e.elu = e.cos = e.ceil = e.clipV11 = e.parseClipAttributes = e.clip = e.atan = e.asin = e.acos = e.abs = e.glslTanh = e.glslTan = e.glslSqrt = e.glslSigmoid = e.glslRelu = e.glslSin = e.glslNot = e.glslNeg = e.glslLog = e.glslLeakyRelu = e.glslIdentity = e.glslClip = e.glslFloor = e.glslExp = e.glslElu = e.glslCos = e.glslCeil = e.glslAtan = e.glslAsin = e.glslAcos = e.glslAbs = void 0;
              const r = n(246), i = n(2517), o = n(8520), a = n(5060), s = n(2039);
              function u() {
                return P("abs");
              }
              function c() {
                return P("acos");
              }
              function l() {
                return P("asin");
              }
              function p() {
                return P("atan");
              }
              function f() {
                return P("ceil");
              }
              function d() {
                return P("cos");
              }
              function h(t2) {
                const e2 = "elu";
                return { body: `
  const float alpha = float(${t2});

  float ${e2}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${e2}_(vec4 v) {
    return vec4(${e2}_(v.x), ${e2}_(v.y), ${e2}_(v.z), ${e2}_(v.w));
  }
  `, name: e2, type: o.FunctionType.ValueBased };
              }
              function g() {
                return P("exp");
              }
              function b() {
                return P("floor");
              }
              function m(t2, e2) {
                const n2 = "clip";
                return { body: `
  const float min = float(${t2});
  const float max = float(${e2});

  float ${n2}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${n2}_(vec4 v) {
    return clamp(v, min, max);
  }
  `, name: n2, type: o.FunctionType.ValueBased };
              }
              function y() {
                const t2 = "indentity";
                return { body: `
  float ${t2}_(float a) {
    return a;
  }
  vec4 ${t2}_(vec4 v) {
    return v;
  }
  `, name: t2, type: o.FunctionType.ValueBased };
              }
              function _(t2) {
                const e2 = "leakyRelu";
                return { body: `
  const float alpha = float(${t2});

  float ${e2}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${e2}_(vec4 v) {
    return vec4(${e2}_(v.x), ${e2}_(v.y), ${e2}_(v.z), ${e2}_(v.w));
  }
  `, name: e2, type: o.FunctionType.ValueBased };
              }
              function v() {
                return P("log");
              }
              function w() {
                const t2 = "neg";
                return { body: `
  float ${t2}_(float a) {
    return -a;
  }
  vec4 ${t2}_(vec4 v) {
    return -v;
  }
  `, name: t2, type: o.FunctionType.ValueBased };
              }
              function x() {
                const t2 = "not";
                return { body: `
  float ${t2}_(float a) {
    return float( ! bool(a) );
  }
  bool ${t2}_(bool a) {
    return !a;
  }
  vec4 ${t2}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${t2}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `, name: t2, type: o.FunctionType.ValueBased };
              }
              function T() {
                return P("sin");
              }
              function S() {
                const t2 = "relu";
                return { body: `
  float ${t2}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${t2}_(vec4 v) {
    return max( v, 0.0 );
  }
  `, name: t2, type: o.FunctionType.ValueBased };
              }
              function O() {
                const t2 = "sigmoid";
                return { body: `
  float ${t2}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${t2}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `, name: t2, type: o.FunctionType.ValueBased };
              }
              function A() {
                return P("sqrt");
              }
              function E() {
                return P("tan");
              }
              function I() {
                const t2 = "tanh";
                return { body: `
  float ${t2}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${t2}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `, name: t2, type: o.FunctionType.ValueBased };
              }
              function P(t2) {
                return { body: `
  float ${t2}_(float a) {
    return ${t2}(a);
  }
  vec4 ${t2}_(vec4 v) {
    return ${t2}(v);
  }
  `, name: t2, type: o.FunctionType.ValueBased };
              }
              e.glslAbs = u, e.glslAcos = c, e.glslAsin = l, e.glslAtan = p, e.glslCeil = f, e.glslCos = d, e.glslElu = h, e.glslExp = g, e.glslFloor = b, e.glslClip = m, e.glslIdentity = y, e.glslLeakyRelu = _, e.glslLog = v, e.glslNeg = w, e.glslNot = x, e.glslSin = T, e.glslRelu = S, e.glslSigmoid = O, e.glslSqrt = A, e.glslTan = E, e.glslTanh = I;
              const D = (t2, e2, n2, r2) => {
                const i2 = t2.session.pack ? s.TextureType.packed : s.TextureType.unpacked, o2 = { name: n2.name, inputTypes: [i2], inputNames: ["A"], cacheHint: r2 };
                return Object.assign(Object.assign({}, o2), { get: () => ((t3, e3, n3, r3) => {
                  const i3 = t3.session.pack ? s.TextureType.packed : s.TextureType.unpacked, o3 = (0, a.getGlsl)(t3.session.backend.glContext.version);
                  return Object.assign(Object.assign({}, e3), { output: { dims: n3.dims, type: n3.type, textureType: i3 }, shaderSource: `
     ${r3.body}
     void main() {
       vec4 v = ${o3.texture2D}(A, TexCoords);
       v = ${r3.name}_(v);
       ${o3.output} = v;
     }
     `, hasMain: true });
                })(t2, o2, e2, n2) });
              };
              e.abs = (t2, e2) => [t2.run(D(t2, e2[0], u()), e2)], e.acos = (t2, e2) => [t2.run(D(t2, e2[0], c()), e2)], e.asin = (t2, e2) => [t2.run(D(t2, e2[0], l()), e2)], e.atan = (t2, e2) => [t2.run(D(t2, e2[0], p()), e2)], e.clip = (t2, e2, n2) => [t2.run(D(t2, e2[0], m(n2.min, n2.max), n2.cacheKey), e2)], e.parseClipAttributes = (t2) => (0, r.createAttributeWithCacheKey)({ min: t2.attributes.getFloat("min", i.MIN_CLIP), max: t2.attributes.getFloat("max", i.MAX_CLIP) }), e.clipV11 = (t2, n2) => {
                const r2 = $(t2, n2);
                return (0, e.clip)(t2, [n2[0]], r2);
              };
              const $ = (t2, e2) => {
                if (e2.length >= 3 && (!t2.session.isInitializer(e2[1].dataId) || !t2.session.isInitializer(e2[2].dataId)))
                  throw new Error("dynamic clip attributes are not allowed");
                const n2 = e2.length >= 3 ? e2[1].numberData[0] : i.MIN_CLIP, o2 = e2.length >= 3 ? e2[2].numberData[0] : i.MAX_CLIP;
                return (0, r.createAttributeWithCacheKey)({ min: n2, max: o2 });
              };
              e.ceil = (t2, e2) => [t2.run(D(t2, e2[0], f()), e2)], e.cos = (t2, e2) => [t2.run(D(t2, e2[0], d()), e2)], e.elu = (t2, e2, n2) => [t2.run(D(t2, e2[0], h(n2.alpha), n2.cacheKey), e2)], e.parseEluAttributes = (t2) => (0, r.createAttributeWithCacheKey)({ alpha: t2.attributes.getFloat("alpha", 1) }), e.exp = (t2, e2) => [t2.run(D(t2, e2[0], g()), e2)], e.floor = (t2, e2) => [t2.run(D(t2, e2[0], b()), e2)], e.identity = (t2, e2) => [t2.run(D(t2, e2[0], y()), e2)], e.leakyRelu = (t2, e2, n2) => [t2.run(D(t2, e2[0], _(n2.alpha), n2.cacheKey), e2)], e.parseLeakyReluAttributes = (t2) => (0, r.createAttributeWithCacheKey)({ alpha: t2.attributes.getFloat("alpha", 0.01) }), e.log = (t2, e2) => [t2.run(D(t2, e2[0], v()), e2)], e.neg = (t2, e2) => [t2.run(D(t2, e2[0], w()), e2)], e.not = (t2, e2) => [t2.run(D(t2, e2[0], x()), e2)], e.relu = (t2, e2) => [t2.run(D(t2, e2[0], S()), e2)], e.sigmoid = (t2, e2) => [t2.run(D(t2, e2[0], O()), e2)], e.sin = (t2, e2) => [t2.run(D(t2, e2[0], T()), e2)], e.sqrt = (t2, e2) => [t2.run(D(t2, e2[0], A()), e2)], e.tan = (t2, e2) => [t2.run(D(t2, e2[0], E()), e2)], e.tanh = (t2, e2) => [t2.run(D(t2, e2[0], I()), e2)];
            }, 5611: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.createUnpackProgramInfoLoader = e.createUnpackProgramInfo = void 0;
              const r = n(5060), i = n(2039), o = n(9390), a = n(2827), s = { name: "unpack", inputNames: ["A"], inputTypes: [i.TextureType.packed] };
              e.createUnpackProgramInfo = (t2, e2) => {
                const n2 = e2.dims.length, u = (0, a.getChannels)("rc", n2), c = u.slice(-2), l = (0, o.getCoordsDataType)(n2), p = (0, a.unpackFromChannel)(), f = 0 === e2.dims.length ? "" : function(t3, e3) {
                  if (1 === t3)
                    return "rc";
                  let n3 = "";
                  for (let r2 = 0; r2 < t3; r2++)
                    n3 += e3[r2], r2 < t3 - 1 && (n3 += ",");
                  return n3;
                }(n2, u), d = n2 <= 1 ? "rc" : `vec2(${c.join(",")})`, h = `
    ${p}
    void main() {
      ${l} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${f});

       ${(0, r.getGlsl)(t2.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${d}), 0, 0, 0);
     }
   `;
                return Object.assign(Object.assign({}, s), { hasMain: true, output: { dims: e2.dims, type: e2.type, textureType: i.TextureType.unpacked }, shaderSource: h });
              }, e.createUnpackProgramInfoLoader = (t2, n2) => Object.assign(Object.assign({}, s), { get: () => (0, e.createUnpackProgramInfo)(t2, n2) });
            }, 8428: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.parseUnsqueezeAttributes = e.unsqueezeV13 = e.unsqueeze = void 0;
              const r = n(2517);
              e.unsqueeze = (t2, e2, n2) => {
                i(e2);
                const o2 = r.ShapeUtil.unsqueezeShape(e2[0].dims, n2);
                return [t2.reshapeUnpacked(e2[0], o2)];
              }, e.unsqueezeV13 = (t2, n2) => (o(n2), (0, e.unsqueeze)(t2, [n2[0]], Array.from(n2[1].integerData))), e.parseUnsqueezeAttributes = (t2) => t2.attributes.getInts("axes");
              const i = (t2) => {
                if (!t2 || 1 !== t2.length)
                  throw new Error("Unsqueeze requires 1 input.");
                if ("string" === t2[0].type)
                  throw new Error("invalid input tensor types.");
              }, o = (t2) => {
                if (!t2 || 2 !== t2.length)
                  throw new Error("Unsqueeze requires 2 inputs.");
                if ("int32" !== t2[1].type)
                  throw new Error("Invalid input type.");
              };
            }, 9793: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.scalesValidation = e.validateInputs = e.parseUpsampleAttributes = e.parseUpsampleAttributesV9 = e.parseUpsampleAttributesV7 = e.upsample = void 0;
              const r = n(246), i = n(5060), o = n(2039), a = { name: "Upsample", inputNames: ["X"], inputTypes: [o.TextureType.unpacked] };
              e.upsample = (t2, n2, r2) => ((0, e.validateInputs)(n2, r2), [t2.run(Object.assign(Object.assign({}, a), { cacheHint: r2.cacheKey, get: () => s(t2, n2, r2) }), n2)]), e.parseUpsampleAttributesV7 = (t2) => (0, e.parseUpsampleAttributes)(t2, 7), e.parseUpsampleAttributesV9 = (t2) => (0, e.parseUpsampleAttributes)(t2, 9), e.parseUpsampleAttributes = (t2, n2) => {
                const i2 = n2 >= 10, o2 = t2.attributes.getString("mode", "nearest");
                if ("nearest" !== o2 && "linear" !== o2 && (n2 < 11 || "cubic" !== o2))
                  throw new Error(`unrecognized mode: ${o2}`);
                let a2 = [];
                n2 < 9 && (a2 = t2.attributes.getFloats("scales"), (0, e.scalesValidation)(a2, o2, i2));
                const s2 = t2.attributes.getFloat("extrapolation_value", 0), u = n2 > 10 ? t2.attributes.getString("coordinate_transformation_mode", "half_pixel") : "asymmetric";
                if (-1 === ["asymmetric", "pytorch_half_pixel", "tf_half_pixel_for_nn", "align_corners", "tf_crop_and_resize", "half_pixel"].indexOf(u))
                  throw new Error(`coordinate_transform_mode '${u}' is not supported`);
                const c = "tf_crop_and_resize" === u, l = c, p = "nearest" === o2 && n2 >= 11 ? t2.attributes.getString("nearest_mode", "round_prefer_floor") : "";
                if (-1 === ["round_prefer_floor", "round_prefer_ceil", "floor", "ceil", ""].indexOf(p))
                  throw new Error(`nearest_mode '${p}' is not supported`);
                const f = t2.attributes.getFloat("cubic_coeff_a", -0.75), d = 0 !== t2.attributes.getInt("exclude_outside", 0);
                if (d && "cubic" !== o2)
                  throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");
                const h = n2 < 11 || "nearest" === o2 && "asymmetric" === u && "floor" === p;
                let g = 0, b = 0, m = 0;
                return n2 > 10 ? t2.inputs.length > 2 ? (g = 1, b = 2, m = 3) : (b = 1, m = 2) : 9 === n2 && (b = 1), (0, r.createAttributeWithCacheKey)({ opset: n2, isResize: i2, mode: o2, scales: a2, extrapolationValue: s2, coordinateTransformMode: u, useExtrapolation: l, needRoiInput: c, nearestMode: p, cubicCoefficientA: f, excludeOutside: d, useNearest2xOptimization: h, roiInputIdx: g, scalesInputIdx: b, sizesInputIdx: m });
              };
              const s = (t2, e2, n2) => {
                const r2 = (0, i.getGlsl)(t2.session.backend.glContext.version), [s2, u] = t2.calculateTextureWidthAndHeight(e2[0].dims, o.TextureType.unpacked), c = e2[0].dims.map((t3, e3) => Math.floor(t3 * n2.scales[e3])), [l, p] = t2.calculateTextureWidthAndHeight(c, o.TextureType.unpacked), f = c.length, d = new Array(f), h = new Array(f);
                let g = `
      int output_pitches[${f}];
      int input_pitches[${f}];
      `;
                for (let t3 = f - 1; t3 >= 0; t3--)
                  d[t3] = t3 === f - 1 ? 1 : d[t3 + 1] * c[t3 + 1], h[t3] = t3 === f - 1 ? 1 : h[t3 + 1] * e2[0].dims[t3 + 1], g += `
        output_pitches[${t3}] = ${d[t3]};
        input_pitches[${t3}] = ${h[t3]};
        `;
                const b = `
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${s2}, ${u});
        float value = getColorAsFloat(${r2.texture2D}(X, coords));
        return value;
      }
      `, m = "nearest" === n2.mode ? `
    ${b}
    float process(int indices[${f}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${l}, ${p});

      ${g}

      int d, m;
      for (int dim = 0; dim < ${f}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }` : 4 === f ? `
    ${b}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${l}, ${p});

      ${g}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${e2[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }` : `
    ${b}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${l}, ${p});

      ${g}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${e2[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;
                return Object.assign(Object.assign({}, a), { output: { dims: c, type: e2[0].type, textureType: o.TextureType.unpacked }, shaderSource: m, variables: [{ name: "scales", type: "int", arrayLength: n2.scales.length, data: n2.scales.map((t3) => Math.ceil(t3)) }] });
              };
              e.validateInputs = (t2, e2) => {
                if (!t2 || e2.opset < 9 && 1 !== t2.length || e2.opset >= 9 && e2.opset < 11 && 2 !== t2.length || e2.opset >= 11 && t2.length < 2)
                  throw new Error("invalid inputs.");
                if (e2.scales.length > 0 && t2[0].dims.length !== e2.scales.length)
                  throw new Error("Invalid input shape.");
                if ("string" === t2[0].type)
                  throw new Error("Invalid input tensor types.");
              }, e.scalesValidation = (t2, e2, n2) => {
                if (n2) {
                  for (const e3 of t2)
                    if (e3 <= 0)
                      throw new Error("Scale value should be greater than 0.");
                } else
                  for (const e3 of t2)
                    if (e3 < 1)
                      throw new Error("Scale value should be greater than or equal to 1.");
                if (!("linear" !== e2 && "cubic" !== e2 || 2 === t2.length || 4 === t2.length && 1 === t2[0] && 1 === t2[1]))
                  throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n2 ? "Resize" : "Upsample"} opeartor.`);
              };
            }, 1958: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.ProgramManager = void 0;
              const r = n(1670), i = n(6231), o = n(8879), a = n(5060);
              e.ProgramManager = class {
                constructor(t2, e2, n2) {
                  this.profiler = t2, this.glContext = e2, this.textureLayoutStrategy = n2, this.repo = /* @__PURE__ */ new Map(), this.attributesBound = false;
                }
                getArtifact(t2) {
                  return this.repo.get(t2);
                }
                setArtifact(t2, e2) {
                  this.repo.set(t2, e2);
                }
                run(t2, e2, n2) {
                  var r2;
                  this.profiler.event("op", `ProgramManager.run ${null !== (r2 = t2.programInfo.name) && void 0 !== r2 ? r2 : "unknown kernel"}`, () => {
                    var r3;
                    const o2 = this.glContext.gl, a2 = t2.program;
                    o2.useProgram(a2);
                    try {
                      this.bindOutput(n2), this.attributesBound || this.bindAttributes(t2.attribLocations), this.bindUniforms(t2.uniformLocations, null !== (r3 = t2.programInfo.variables) && void 0 !== r3 ? r3 : [], e2);
                    } catch (e3) {
                      throw i.Logger.error("ProgramManager", t2.programInfo.shaderSource), e3;
                    }
                    this.profiler.event("backend", "GlContext.draw()", () => {
                      this.glContext.draw();
                    });
                  }, this.glContext);
                }
                dispose() {
                  this.vertexShader && this.glContext.deleteShader(this.vertexShader), this.repo.forEach((t2) => this.glContext.deleteProgram(t2.program));
                }
                build(t2, e2, n2) {
                  return this.profiler.event("backend", "ProgramManager.build", () => {
                    const r2 = new o.GlslPreprocessor(this.glContext, t2, e2, n2), i2 = r2.preprocess(), a2 = this.compile(i2);
                    return { programInfo: t2, program: a2, uniformLocations: this.getUniformLocations(a2, r2.context.programInfo.inputNames, r2.context.programInfo.variables), attribLocations: this.getAttribLocations(a2) };
                  });
                }
                compile(t2) {
                  if (!this.vertexShader) {
                    i.Logger.verbose("ProrgramManager", "Compiling and caching Vertex shader for the first time");
                    const t3 = (0, a.getVertexShaderSource)(this.glContext.version);
                    this.vertexShader = this.glContext.compileShader(t3, this.glContext.gl.VERTEX_SHADER);
                  }
                  r.env.debug && i.Logger.verbose("ProrgramManager", `FragShader:
${t2}
`);
                  const e2 = this.glContext.compileShader(t2, this.glContext.gl.FRAGMENT_SHADER), n2 = this.glContext.createProgram(this.vertexShader, e2);
                  return this.glContext.deleteShader(e2), n2;
                }
                bindOutput(t2) {
                  const e2 = t2.width, n2 = t2.height;
                  i.Logger.verbose("ProrgramManager", `Binding output texture to Framebuffer: w/h=${e2}/${n2}, shape=${t2.shape}, type=${t2.tensor.type}`), this.glContext.attachFramebuffer(t2.texture, e2, n2);
                }
                bindAttributes(t2) {
                  const e2 = t2.position, n2 = t2.textureCoord;
                  this.glContext.setVertexAttributes(e2, n2), this.attributesBound = true;
                }
                bindUniforms(t2, e2, n2) {
                  var r2;
                  const i2 = this.glContext.gl;
                  let o2 = 0;
                  for (const { name: a2, type: s, location: u, arrayLength: c } of t2) {
                    const t3 = null === (r2 = e2.find((t4) => t4.name === a2)) || void 0 === r2 ? void 0 : r2.data;
                    if ("sampler2D" !== s && !t3)
                      throw new Error(`variable '${a2}' does not have data defined in program info`);
                    switch (s) {
                      case "sampler2D":
                        this.bindTexture(n2[o2], u, o2), o2++;
                        break;
                      case "float":
                        c ? i2.uniform1fv(u, t3) : i2.uniform1f(u, t3);
                        break;
                      case "int":
                        c ? i2.uniform1iv(u, t3) : i2.uniform1i(u, t3);
                        break;
                      default:
                        throw new Error(`Uniform not implemented: ${s}`);
                    }
                  }
                }
                bindTexture(t2, e2, n2) {
                  this.glContext.bindTextureToUniform(t2.texture, n2, e2);
                }
                getAttribLocations(t2) {
                  return { position: this.getAttribLocation(t2, "position"), textureCoord: this.getAttribLocation(t2, "textureCoord") };
                }
                getUniformLocations(t2, e2, n2) {
                  const r2 = [];
                  if (e2)
                    for (const n3 of e2)
                      r2.push({ name: n3, type: "sampler2D", location: this.getUniformLocation(t2, n3) });
                  if (n2)
                    for (const e3 of n2)
                      r2.push(Object.assign(Object.assign({}, e3), { location: this.getUniformLocation(t2, e3.name) }));
                  return r2;
                }
                getUniformLocation(t2, e2) {
                  const n2 = this.glContext.gl.getUniformLocation(t2, e2);
                  if (null === n2)
                    throw new Error(`Uniform ${e2} not found.`);
                  return n2;
                }
                getAttribLocation(t2, e2) {
                  return this.glContext.gl.getAttribLocation(t2, e2);
                }
              };
            }, 6416: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.WebGLSessionHandler = void 0;
              const r = n(6231), i = n(1047), o = n(8316), a = n(1640), s = n(1958), u = n(7859), c = n(5702);
              e.WebGLSessionHandler = class {
                constructor(t2, e2) {
                  this.backend = t2, this.context = e2, this.layoutStrategy = new u.PreferLogicalStrategy(t2.glContext.maxTextureSize), this.programManager = new s.ProgramManager(this.context.profiler, t2.glContext, this.layoutStrategy), this.textureManager = new c.TextureManager(t2.glContext, this.layoutStrategy, this.context.profiler, { reuseTextures: "full" === t2.textureCacheMode }), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache = /* @__PURE__ */ new Map(), this.pack = t2.pack, this.pack2unpackMap = /* @__PURE__ */ new Map(), this.unpack2packMap = /* @__PURE__ */ new Map();
                }
                createInferenceHandler() {
                  return new o.WebGLInferenceHandler(this);
                }
                onGraphInitialized(t2) {
                  const e2 = t2.getValues().filter((t3) => -1 === t3.from && t3.tensor).map((t3) => t3.tensor.dataId);
                  this.initializers = new Set(e2);
                }
                isInitializer(t2) {
                  return !!this.initializers && this.initializers.has(t2);
                }
                addInitializer(t2) {
                  this.initializers.add(t2);
                }
                getTextureData(t2, e2) {
                  return e2 ? this.packedTextureDataCache.get(t2) : this.unpackedTextureDataCache.get(t2);
                }
                setTextureData(t2, e2, n2 = false) {
                  r.Logger.verbose("WebGLSessionHandler", "Storing Texture data in cache"), n2 ? this.packedTextureDataCache.set(t2, e2) : this.unpackedTextureDataCache.set(t2, e2);
                }
                dispose() {
                  this.programManager.dispose(), this.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((t2) => this.textureManager.releaseTexture(t2, true)), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache.forEach((t2) => this.textureManager.releaseTexture(t2, true)), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
                }
                resolve(t2, e2, n2) {
                  const r2 = (0, i.resolveOperator)(t2, e2, a.WEBGL_OP_RESOLVE_RULES);
                  return { impl: r2.opImpl, context: r2.opInit ? r2.opInit(t2, n2) : t2 };
                }
              };
            }, 7769: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.Uint8DataEncoder = e.RGBAFloatDataEncoder = e.RedFloat32DataEncoder = void 0;
              const r = n(6231);
              e.RedFloat32DataEncoder = class {
                constructor(t2, e2 = 1) {
                  if (1 === e2)
                    this.internalFormat = t2.R32F, this.format = t2.RED, this.textureType = t2.FLOAT, this.channelSize = e2;
                  else {
                    if (4 !== e2)
                      throw new Error(`Invalid number of channels: ${e2}`);
                    this.internalFormat = t2.RGBA32F, this.format = t2.RGBA, this.textureType = t2.FLOAT, this.channelSize = e2;
                  }
                }
                encode(t2, e2) {
                  let n2, i;
                  return t2.constructor !== Float32Array && (r.Logger.warning("Encoder", "data was not of type Float32; creating new Float32Array"), i = new Float32Array(t2)), e2 * this.channelSize > t2.length ? (r.Logger.warning("Encoder", "Source data too small. Allocating larger array"), i = t2, n2 = this.allocate(e2 * this.channelSize), i.forEach((t3, e3) => n2[e3] = t3)) : (i = t2, n2 = i), n2;
                }
                allocate(t2) {
                  return new Float32Array(4 * t2);
                }
                decode(t2, e2) {
                  return 1 === this.channelSize ? t2.filter((t3, e3) => e3 % 4 == 0).subarray(0, e2) : t2.subarray(0, e2);
                }
              }, e.RGBAFloatDataEncoder = class {
                constructor(t2, e2 = 1, n2) {
                  if (1 !== e2 && 4 !== e2)
                    throw new Error(`Invalid number of channels: ${e2}`);
                  this.internalFormat = t2.RGBA, this.format = t2.RGBA, this.channelSize = e2, this.textureType = n2 || t2.FLOAT;
                }
                encode(t2, e2) {
                  let n2 = t2;
                  return 1 === this.channelSize && (r.Logger.verbose("Encoder", "Exploding into a larger array"), n2 = this.allocate(e2), t2.forEach((t3, e3) => n2[4 * e3] = t3)), n2;
                }
                allocate(t2) {
                  return new Float32Array(4 * t2);
                }
                decode(t2, e2) {
                  return 1 === this.channelSize ? t2.filter((t3, e3) => e3 % 4 == 0).subarray(0, e2) : t2.subarray(0, e2);
                }
              }, e.Uint8DataEncoder = class {
                constructor(t2, e2 = 1) {
                  if (this.channelSize = 4, 1 === e2)
                    this.internalFormat = t2.ALPHA, this.format = t2.ALPHA, this.textureType = t2.UNSIGNED_BYTE, this.channelSize = e2;
                  else {
                    if (4 !== e2)
                      throw new Error(`Invalid number of channels: ${e2}`);
                    this.internalFormat = t2.RGBA, this.format = t2.RGBA, this.textureType = t2.UNSIGNED_BYTE, this.channelSize = e2;
                  }
                }
                encode(t2, e2) {
                  return new Uint8Array(t2.buffer, t2.byteOffset, t2.byteLength);
                }
                allocate(t2) {
                  return new Uint8Array(t2 * this.channelSize);
                }
                decode(t2, e2) {
                  if (t2 instanceof Uint8Array)
                    return t2.subarray(0, e2);
                  throw new Error(`Invalid array type: ${t2.constructor}`);
                }
              };
            }, 7859: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.getBatchDim = e.sizeToSquarishShape = e.getRowsCols = e.sizeFromShape = e.isInt = e.parseAxisParam = e.squeezeShape = e.PreferLogicalStrategy = e.AlwaysKeepOriginalSizeStrategy = void 0;
              const r = n(6231), i = n(2517);
              function o(t2, e2) {
                const n2 = [], r2 = [], i2 = null != e2 && Array.isArray(e2) && 0 === e2.length, o2 = null == e2 || i2 ? null : a(e2, t2).sort();
                let s2 = 0;
                for (let e3 = 0; e3 < t2.length; ++e3) {
                  if (null != o2) {
                    if (o2[s2] === e3 && 1 !== t2[e3])
                      throw new Error(`Can't squeeze axis ${e3} since its dim '${t2[e3]}' is not 1`);
                    (null == o2[s2] || o2[s2] > e3) && 1 === t2[e3] && (n2.push(t2[e3]), r2.push(e3)), o2[s2] <= e3 && s2++;
                  }
                  1 !== t2[e3] && (n2.push(t2[e3]), r2.push(e3));
                }
                return { newShape: n2, keptDims: r2 };
              }
              function a(t2, e2) {
                const n2 = e2.length;
                return t2 = null == t2 ? e2.map((t3, e3) => e3) : [].concat(t2), (0, i.assert)(t2.every((t3) => t3 >= -n2 && t3 < n2), () => `All values in axis param must be in range [-${n2}, ${n2}) but got axis ${t2}`), (0, i.assert)(t2.every(s), () => `All values in axis param must be integers but got axis ${t2}`), t2.map((t3) => t3 < 0 ? n2 + t3 : t3);
              }
              function s(t2) {
                return t2 % 1 == 0;
              }
              function u(t2) {
                if (0 === t2.length)
                  return 1;
                let e2 = t2[0];
                for (let n2 = 1; n2 < t2.length; n2++)
                  e2 *= t2[n2];
                return e2;
              }
              function c(t2) {
                const e2 = Math.ceil(Math.sqrt(t2));
                return [e2, Math.ceil(t2 / e2)];
              }
              e.AlwaysKeepOriginalSizeStrategy = class {
                constructor(t2) {
                  this.maxTextureSize = t2;
                }
                computeTextureWH(t2, e2) {
                  if (0 === t2.length)
                    return [1, 1];
                  const n2 = this.maxTextureSize;
                  if (e2 && void 0 !== e2.breakAxis) {
                    const i3 = e2.breakAxis >= t2.length ? 1 : t2.slice(e2.breakAxis).reduce((t3, e3) => t3 * e3), o3 = e2.breakAxis <= 0 ? 1 : t2.slice(0, e2.breakAxis).reduce((t3, e3) => t3 * e3);
                    if (!(i3 > n2 || o3 > n2))
                      return [i3, o3];
                    r.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${t2}, breakAxis:${e2.breakAxis}`);
                  }
                  const i2 = t2.reduce((t3, e3) => t3 * e3);
                  let o2 = Math.floor(Math.sqrt(i2));
                  for (; o2 < n2 && o2 < i2 && i2 % o2 != 0; o2++)
                    ;
                  if (o2 >= n2 || i2 % o2 != 0)
                    throw new Error(`The given dimensions are outside this GPU's boundaries: ${t2}`);
                  return [o2, i2 / o2];
                }
              }, e.PreferLogicalStrategy = class {
                constructor(t2) {
                  this.maxTextureSize = t2;
                }
                computeTextureWH(t2, e2) {
                  const n2 = this.computeTexture(t2, e2);
                  return e2 && e2.isPacked && (n2[0] /= 2, n2[1] /= 2), e2 && e2.reverseWH ? [n2[1], n2[0]] : n2;
                }
                computeTexture(t2, e2) {
                  const n2 = e2 && e2.isPacked;
                  if (0 === t2.length)
                    return n2 ? [2, 2] : [1, 1];
                  let i2 = this.maxTextureSize;
                  if (e2 && void 0 !== e2.breakAxis) {
                    const n3 = e2.breakAxis >= t2.length ? 1 : t2.slice(e2.breakAxis).reduce((t3, e3) => t3 * e3), o2 = e2.breakAxis <= 0 ? 1 : t2.slice(0, e2.breakAxis).reduce((t3, e3) => t3 * e3);
                    if (!(n3 > i2 || o2 > i2))
                      return [n3, o2];
                    r.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${t2}, breakAxis:${e2.breakAxis}`);
                  }
                  let a2 = t2.slice(0);
                  if (n2 && (i2 *= 2, a2 = a2.map((t3, e3) => e3 >= a2.length - 2 ? a2[e3] % 2 == 0 ? a2[e3] : a2[e3] + 1 : a2[e3]), 1 === a2.length && (a2 = [2, a2[0]])), 2 !== a2.length) {
                    const t3 = o(a2);
                    a2 = t3.newShape;
                  }
                  const s2 = u(a2);
                  return a2.length <= 1 && s2 <= i2 ? [1, s2] : 2 === a2.length && a2[0] <= i2 && a2[1] <= i2 ? a2 : 3 === a2.length && a2[0] * a2[1] <= i2 && a2[2] <= i2 ? [a2[0] * a2[1], a2[2]] : 3 === a2.length && a2[0] <= i2 && a2[1] * a2[2] <= i2 ? [a2[0], a2[1] * a2[2]] : 4 === a2.length && a2[0] * a2[1] * a2[2] <= i2 && a2[3] <= i2 ? [a2[0] * a2[1] * a2[2], a2[3]] : 4 === a2.length && a2[0] <= i2 && a2[1] * a2[2] * a2[3] <= i2 ? [a2[0], a2[1] * a2[2] * a2[3]] : n2 ? c(s2 / 4).map((t3) => 2 * t3) : c(s2);
                }
              }, e.squeezeShape = o, e.parseAxisParam = a, e.isInt = s, e.sizeFromShape = u, e.getRowsCols = function(t2) {
                if (0 === t2.length)
                  throw Error("Cannot get rows and columns of an empty shape array.");
                return [t2.length > 1 ? t2[t2.length - 2] : 1, t2[t2.length - 1]];
              }, e.sizeToSquarishShape = c, e.getBatchDim = function(t2, e2 = 2) {
                return u(t2.slice(0, t2.length - e2));
              };
            }, 4057: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.createTextureLayoutFromShape = e.calculateTextureWidthAndHeight = e.createTextureLayoutFromTextureType = void 0;
              const r = n(2517), i = n(2039);
              e.createTextureLayoutFromTextureType = (t2, n2, r2) => {
                const o = r2 === i.TextureType.unpacked || r2 === i.TextureType.unpackedReversed ? 1 : 4, a = r2 === i.TextureType.packed, s = r2 === i.TextureType.unpackedReversed || r2 === i.TextureType.packed, u = r2 === i.TextureType.packedLastDimension ? n2.length - 1 : void 0, c = r2 === i.TextureType.packedLastDimension ? n2.map((t3, e2) => e2 === n2.length - 1 ? 4 * t3 : t3) : void 0;
                return (0, e.createTextureLayoutFromShape)(t2, n2, o, c, { isPacked: a, reverseWH: s, breakAxis: u });
              }, e.calculateTextureWidthAndHeight = (t2, n2, r2) => {
                const i2 = (0, e.createTextureLayoutFromTextureType)(t2, n2, r2);
                return [i2.width, i2.height];
              }, e.createTextureLayoutFromShape = (t2, e2, n2 = 1, i2, o) => {
                const a = !(!o || !o.isPacked), [s, u] = t2.computeTextureWH(a && i2 || e2, o), c = e2.length;
                let l = e2.slice(0);
                if (0 === c && (l = [1]), 1 === n2)
                  i2 = e2;
                else if (a) {
                  if (4 !== n2)
                    throw new Error("a packed texture must be 4-channel");
                  i2 = e2, c > 0 && (l[c - 1] = Math.ceil(l[c - 1] / 2)), c > 1 && (l[c - 2] = Math.ceil(l[c - 2] / 2));
                } else if (!i2)
                  throw new Error("Unpacked shape is needed when using channels > 1");
                return { width: s, height: u, channels: n2, isPacked: a, shape: l, strides: r.ShapeUtil.computeStrides(l), unpackedShape: i2, reversedWH: o && o.reverseWH };
              };
            }, 5702: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.TextureManager = void 0;
              const r = n(6231);
              e.TextureManager = class {
                constructor(t2, e2, n2, r2) {
                  this.glContext = t2, this.layoutStrategy = e2, this.profiler = n2, this.config = r2, this.pendingRead = /* @__PURE__ */ new Map(), r2.reuseTextures && (this.inUseTextures = /* @__PURE__ */ new Map(), this.idleTextures = /* @__PURE__ */ new Map(), this.textureLookup = /* @__PURE__ */ new Map());
                }
                createTextureFromLayout(t2, e2, n2, i) {
                  const o = this.toEncoderType(t2), a = this.glContext.getEncoder(o, e2.channels || 1, i);
                  if (e2.isPacked && 1 === i)
                    throw new Error("not implemented");
                  const s = e2.width, u = e2.height;
                  let c, l;
                  if (this.config.reuseTextures) {
                    c = `${s}x${u}_${a.format}_${a.internalFormat}_${a.textureType}`, l = this.inUseTextures.get(c), l || (l = [], this.inUseTextures.set(c, l));
                    const e3 = this.idleTextures.get(c);
                    if (e3 && e3.length > 0) {
                      const r2 = e3.pop();
                      return l.push(r2), 1 === i && this.glContext.updateTexture(r2, s, u, a, this.toTextureData(t2, n2)), r2;
                    }
                  }
                  r.Logger.verbose("TextureManager", `Creating new texture of size ${e2.width}x${e2.height}`);
                  const p = this.glContext.allocateTexture(s, u, a, this.toTextureData(t2, n2));
                  return this.config.reuseTextures && (l.push(p), this.textureLookup.set(p, c)), p;
                }
                readTexture(t2, e2, n2) {
                  return n2 || (n2 = 1), this.profiler.event("backend", "TextureManager.readTexture", () => {
                    const r2 = t2.shape.reduce((t3, e3) => t3 * e3) * n2, i = this.glContext.readTexture(t2.texture, t2.width, t2.height, r2, this.toEncoderType(e2), n2);
                    return this.toTensorData(e2, i);
                  });
                }
                async readTextureAsync(t2, e2, n2) {
                  const r2 = t2.tensor.dataId;
                  if (n2 || (n2 = 1), this.pendingRead.has(r2)) {
                    const t3 = this.pendingRead.get(r2);
                    return new Promise((e3) => null == t3 ? void 0 : t3.push(e3));
                  }
                  return this.profiler.event("backend", "TextureManager.readTextureAsync", async () => {
                    this.pendingRead.set(r2, []);
                    const i = t2.shape.reduce((t3, e3) => t3 * e3) * n2;
                    await this.glContext.createAndWaitForFence();
                    const o = this.glContext.readTexture(t2.texture, t2.width, t2.height, i, this.toEncoderType(e2), n2), a = this.toTensorData(e2, o), s = this.pendingRead.get(r2);
                    return this.pendingRead.delete(r2), null == s || s.forEach((t3) => t3(a)), a;
                  });
                }
                readUint8TextureAsFloat(t2) {
                  return this.profiler.event("backend", "TextureManager.readUint8TextureAsFloat", () => {
                    const e2 = t2.shape.reduce((t3, e3) => t3 * e3), n2 = this.glContext.readTexture(t2.texture, t2.width, t2.height, 4 * e2, "byte", 4);
                    return new Float32Array(n2.buffer, n2.byteOffset, e2);
                  });
                }
                releaseTexture(t2, e2) {
                  let n2;
                  if (this.config.reuseTextures && (n2 = this.textureLookup.get(t2.texture), n2)) {
                    e2 && this.textureLookup.delete(n2);
                    const r2 = this.inUseTextures.get(n2);
                    if (r2) {
                      const e3 = r2.indexOf(t2.texture);
                      if (-1 !== e3) {
                        r2.splice(e3, 1);
                        let i = this.idleTextures.get(n2);
                        i || (i = [], this.idleTextures.set(n2, i)), i.push(t2.texture);
                      }
                    }
                  }
                  n2 && !e2 || (r.Logger.verbose("TextureManager", `Deleting texture of size ${t2.width}x${t2.height}`), this.glContext.deleteTexture(t2.texture));
                }
                toTensorData(t2, e2) {
                  switch (t2) {
                    case "int16":
                      return e2 instanceof Int16Array ? e2 : Int16Array.from(e2);
                    case "int32":
                      return e2 instanceof Int32Array ? e2 : Int32Array.from(e2);
                    case "int8":
                      return e2 instanceof Int8Array ? e2 : Int8Array.from(e2);
                    case "uint16":
                      return e2 instanceof Uint16Array ? e2 : Uint16Array.from(e2);
                    case "uint32":
                      return e2 instanceof Uint32Array ? e2 : Uint32Array.from(e2);
                    case "uint8":
                    case "bool":
                      return e2 instanceof Uint8Array ? e2 : Uint8Array.from(e2);
                    case "float32":
                      return e2 instanceof Float32Array ? e2 : Float32Array.from(e2);
                    case "float64":
                      return e2 instanceof Float64Array ? e2 : Float64Array.from(e2);
                    default:
                      throw new Error(`TensorData type ${t2} is not supported`);
                  }
                }
                toTextureData(t2, e2) {
                  if (e2)
                    return e2 instanceof Float32Array ? e2 : new Float32Array(e2);
                }
                toEncoderType(t2) {
                  return "float";
                }
                clearActiveTextures() {
                  this.glContext.clearActiveTextures();
                }
              };
            }, 2039: (t, e) => {
              "use strict";
              var n;
              Object.defineProperty(e, "__esModule", { value: true }), e.TextureType = void 0, (n = e.TextureType || (e.TextureType = {}))[n.unpacked = 0] = "unpacked", n[n.unpackedReversed = 1] = "unpackedReversed", n[n.packed = 2] = "packed", n[n.downloadUint8AsFloat = 3] = "downloadUint8AsFloat", n[n.packedLastDimension = 4] = "packedLastDimension";
            }, 9390: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.getGlChannels = e.getCoordsDataType = e.getSqueezedParams = e.squeezeInputShape = e.generateShaderFuncNameFromInputSamplerNameAtOutCoords = e.generateShaderFuncNameFromInputSamplerName = e.repeatedTry = e.getPackedShape = void 0;
              const r = n(2517);
              e.getPackedShape = function(t2) {
                const e2 = t2.length;
                return t2.slice(0, e2 - 1).concat(t2[e2 - 1] / 4);
              }, e.repeatedTry = async function(t2, e2 = (t3) => 0, n2) {
                return new Promise((r2, i) => {
                  let o = 0;
                  const a = () => {
                    if (t2())
                      return void r2();
                    o++;
                    const s = e2(o);
                    null != n2 && o >= n2 ? i() : setTimeout(a, s);
                  };
                  a();
                });
              }, e.generateShaderFuncNameFromInputSamplerName = function(t2) {
                return (0, r.assert)(void 0 !== t2 && 0 !== t2.length, () => "empty string found for sampler name"), "get" + t2.charAt(0).toUpperCase() + t2.slice(1);
              }, e.generateShaderFuncNameFromInputSamplerNameAtOutCoords = function(t2) {
                return (0, r.assert)(void 0 !== t2 && 0 !== t2.length, () => "empty string found for sampler name"), "get" + t2.charAt(0).toUpperCase() + t2.slice(1) + "AtOutCoords";
              }, e.squeezeInputShape = function(t2, e2) {
                let n2 = JSON.parse(JSON.stringify(t2));
                return n2 = e2, n2;
              }, e.getSqueezedParams = function(t2, e2) {
                return e2.map((e3) => t2[e3]).join(", ");
              }, e.getCoordsDataType = function(t2) {
                if (t2 <= 1)
                  return "int";
                if (2 === t2)
                  return "ivec2";
                if (3 === t2)
                  return "ivec3";
                if (4 === t2)
                  return "ivec4";
                if (5 === t2)
                  return "ivec5";
                if (6 === t2)
                  return "ivec6";
                throw Error(`GPU for rank ${t2} is not yet supported`);
              }, e.getGlChannels = function(t2 = 6) {
                return ["x", "y", "z", "w", "u", "v"].slice(0, t2);
              };
            }, 7305: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.createNewWebGLContext = e.createWebGLContext = void 0;
              const r = n(6231), i = n(1713), o = {};
              function a(t2) {
                const e2 = function() {
                  if ("undefined" == typeof document) {
                    if ("undefined" == typeof OffscreenCanvas)
                      throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");
                    return new OffscreenCanvas(1, 1);
                  }
                  const t3 = document.createElement("canvas");
                  return t3.width = 1, t3.height = 1, t3;
                }();
                let n2;
                const o2 = { alpha: false, depth: false, antialias: false, stencil: false, preserveDrawingBuffer: false, premultipliedAlpha: false, failIfMajorPerformanceCaveat: false };
                if ((!t2 || "webgl2" === t2) && (n2 = e2.getContext("webgl2", o2), n2))
                  try {
                    return new i.WebGLContext(n2, 2);
                  } catch (t3) {
                    r.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl2'. Error: ${t3}`);
                  }
                if ((!t2 || "webgl" === t2) && (n2 = e2.getContext("webgl", o2) || e2.getContext("experimental-webgl", o2), n2))
                  try {
                    return new i.WebGLContext(n2, 1);
                  } catch (t3) {
                    r.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${t3}`);
                  }
                throw new Error("WebGL is not supported");
              }
              e.createWebGLContext = function t2(e2) {
                let n2;
                e2 && "webgl2" !== e2 || !("webgl2" in o) ? e2 && "webgl" !== e2 || !("webgl" in o) || (n2 = o.webgl) : n2 = o.webgl2, n2 = n2 || a(e2), e2 = e2 || 1 === n2.version ? "webgl" : "webgl2";
                const r2 = n2.gl;
                return o[e2] = n2, r2.isContextLost() ? (delete o[e2], t2(e2)) : (r2.disable(r2.DEPTH_TEST), r2.disable(r2.STENCIL_TEST), r2.disable(r2.BLEND), r2.disable(r2.DITHER), r2.disable(r2.POLYGON_OFFSET_FILL), r2.disable(r2.SAMPLE_COVERAGE), r2.enable(r2.SCISSOR_TEST), r2.enable(r2.CULL_FACE), r2.cullFace(r2.BACK), n2);
              }, e.createNewWebGLContext = a;
            }, 1713: function(t, e, n) {
              "use strict";
              var r = this && this.__createBinding || (Object.create ? function(t2, e2, n2, r2) {
                void 0 === r2 && (r2 = n2);
                var i2 = Object.getOwnPropertyDescriptor(e2, n2);
                i2 && !("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
                  return e2[n2];
                } }), Object.defineProperty(t2, r2, i2);
              } : function(t2, e2, n2, r2) {
                void 0 === r2 && (r2 = n2), t2[r2] = e2[n2];
              }), i = this && this.__setModuleDefault || (Object.create ? function(t2, e2) {
                Object.defineProperty(t2, "default", { enumerable: true, value: e2 });
              } : function(t2, e2) {
                t2.default = e2;
              }), o = this && this.__importStar || function(t2) {
                if (t2 && t2.__esModule)
                  return t2;
                var e2 = {};
                if (null != t2)
                  for (var n2 in t2)
                    "default" !== n2 && Object.prototype.hasOwnProperty.call(t2, n2) && r(e2, t2, n2);
                return i(e2, t2), e2;
              };
              Object.defineProperty(e, "__esModule", { value: true }), e.WebGLContext = e.linearSearchLastTrue = void 0;
              const a = n(1670), s = o(n(7769)), u = n(9390);
              function c(t2) {
                let e2 = 0;
                for (; e2 < t2.length && t2[e2](); ++e2)
                  ;
                return e2 - 1;
              }
              e.linearSearchLastTrue = c, e.WebGLContext = class {
                constructor(t2, e2) {
                  this.frameBufferBound = false, this.itemsToPoll = [], this.gl = t2, this.version = e2, this.getExtensions(), this.vertexbuffer = this.createVertexbuffer(), this.framebuffer = this.createFramebuffer(), this.queryVitalParameters();
                }
                allocateTexture(t2, e2, n2, r2) {
                  const i2 = this.gl, o2 = i2.createTexture();
                  i2.bindTexture(i2.TEXTURE_2D, o2), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MIN_FILTER, i2.NEAREST), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MAG_FILTER, i2.NEAREST), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_S, i2.CLAMP_TO_EDGE), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_T, i2.CLAMP_TO_EDGE);
                  const a2 = r2 ? n2.encode(r2, t2 * e2) : null;
                  return i2.texImage2D(i2.TEXTURE_2D, 0, n2.internalFormat, t2, e2, 0, n2.format, n2.textureType, a2), this.checkError(), o2;
                }
                updateTexture(t2, e2, n2, r2, i2) {
                  const o2 = this.gl;
                  o2.bindTexture(o2.TEXTURE_2D, t2);
                  const a2 = r2.encode(i2, e2 * n2);
                  o2.texSubImage2D(o2.TEXTURE_2D, 0, 0, 0, e2, n2, r2.format, r2.textureType, a2), this.checkError();
                }
                attachFramebuffer(t2, e2, n2) {
                  const r2 = this.gl;
                  r2.bindTexture(r2.TEXTURE_2D, t2), r2.bindFramebuffer(r2.FRAMEBUFFER, this.framebuffer), r2.framebufferTexture2D(r2.FRAMEBUFFER, r2.COLOR_ATTACHMENT0, r2.TEXTURE_2D, t2, 0), this.checkError(), r2.viewport(0, 0, e2, n2), r2.scissor(0, 0, e2, n2);
                }
                readTexture(t2, e2, n2, r2, i2, o2) {
                  const a2 = this.gl;
                  o2 || (o2 = 1), this.frameBufferBound || this.attachFramebuffer(t2, e2, n2);
                  const s2 = this.getEncoder(i2, o2), u2 = s2.allocate(e2 * n2);
                  return a2.bindTexture(a2.TEXTURE_2D, t2), a2.framebufferTexture2D(a2.FRAMEBUFFER, a2.COLOR_ATTACHMENT0, a2.TEXTURE_2D, t2, 0), a2.readPixels(0, 0, e2, n2, a2.RGBA, s2.textureType, u2), this.checkError(), s2.decode(u2, r2);
                }
                isFramebufferReady() {
                  return true;
                }
                getActiveTexture() {
                  const t2 = this.gl;
                  return "TEXTURE" + (t2.getParameter(this.gl.ACTIVE_TEXTURE) - t2.TEXTURE0);
                }
                getTextureBinding() {
                  return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
                }
                getFramebufferBinding() {
                  return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
                }
                setVertexAttributes(t2, e2) {
                  const n2 = this.gl;
                  n2.vertexAttribPointer(t2, 3, n2.FLOAT, false, 20, 0), n2.enableVertexAttribArray(t2), -1 !== e2 && (n2.vertexAttribPointer(e2, 2, n2.FLOAT, false, 20, 12), n2.enableVertexAttribArray(e2)), this.checkError();
                }
                createProgram(t2, e2) {
                  const n2 = this.gl, r2 = n2.createProgram();
                  return n2.attachShader(r2, t2), n2.attachShader(r2, e2), n2.linkProgram(r2), r2;
                }
                compileShader(t2, e2) {
                  const n2 = this.gl, r2 = n2.createShader(e2);
                  if (!r2)
                    throw new Error(`createShader() returned null with type ${e2}`);
                  if (n2.shaderSource(r2, t2), n2.compileShader(r2), false === n2.getShaderParameter(r2, n2.COMPILE_STATUS))
                    throw new Error(`Failed to compile shader: ${n2.getShaderInfoLog(r2)}
Shader source:
${t2}`);
                  return r2;
                }
                deleteShader(t2) {
                  this.gl.deleteShader(t2);
                }
                bindTextureToUniform(t2, e2, n2) {
                  const r2 = this.gl;
                  r2.activeTexture(r2.TEXTURE0 + e2), this.checkError(), r2.bindTexture(r2.TEXTURE_2D, t2), this.checkError(), r2.uniform1i(n2, e2), this.checkError();
                }
                draw() {
                  this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.checkError();
                }
                checkError() {
                  if (a.env.debug) {
                    const t2 = this.gl, e2 = t2.getError();
                    let n2 = "";
                    switch (e2) {
                      case t2.NO_ERROR:
                        return;
                      case t2.INVALID_ENUM:
                        n2 = "INVALID_ENUM";
                        break;
                      case t2.INVALID_VALUE:
                        n2 = "INVALID_VALUE";
                        break;
                      case t2.INVALID_OPERATION:
                        n2 = "INVALID_OPERATION";
                        break;
                      case t2.INVALID_FRAMEBUFFER_OPERATION:
                        n2 = "INVALID_FRAMEBUFFER_OPERATION";
                        break;
                      case t2.OUT_OF_MEMORY:
                        n2 = "OUT_OF_MEMORY";
                        break;
                      case t2.CONTEXT_LOST_WEBGL:
                        n2 = "CONTEXT_LOST_WEBGL";
                        break;
                      default:
                        n2 = `Unknown WebGL Error: ${e2.toString(16)}`;
                    }
                    throw new Error(n2);
                  }
                }
                deleteTexture(t2) {
                  this.gl.deleteTexture(t2);
                }
                deleteProgram(t2) {
                  this.gl.deleteProgram(t2);
                }
                getEncoder(t2, e2, n2 = 0) {
                  if (2 === this.version)
                    return new s.RedFloat32DataEncoder(this.gl, e2);
                  switch (t2) {
                    case "float":
                      return 1 === n2 || this.isRenderFloat32Supported ? new s.RGBAFloatDataEncoder(this.gl, e2) : new s.RGBAFloatDataEncoder(this.gl, e2, this.textureHalfFloatExtension.HALF_FLOAT_OES);
                    case "int":
                      throw new Error("not implemented");
                    case "byte":
                      return new s.Uint8DataEncoder(this.gl, e2);
                    default:
                      throw new Error(`Invalid dataType: ${t2}`);
                  }
                }
                clearActiveTextures() {
                  const t2 = this.gl;
                  for (let e2 = 0; e2 < this.maxTextureImageUnits; ++e2)
                    t2.activeTexture(t2.TEXTURE0 + e2), t2.bindTexture(t2.TEXTURE_2D, null);
                }
                dispose() {
                  if (this.disposed)
                    return;
                  const t2 = this.gl;
                  t2.bindFramebuffer(t2.FRAMEBUFFER, null), t2.deleteFramebuffer(this.framebuffer), t2.bindBuffer(t2.ARRAY_BUFFER, null), t2.deleteBuffer(this.vertexbuffer), t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, null), t2.finish(), this.disposed = true;
                }
                createDefaultGeometry() {
                  return new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
                }
                createVertexbuffer() {
                  const t2 = this.gl, e2 = t2.createBuffer();
                  if (!e2)
                    throw new Error("createBuffer() returned null");
                  const n2 = this.createDefaultGeometry();
                  return t2.bindBuffer(t2.ARRAY_BUFFER, e2), t2.bufferData(t2.ARRAY_BUFFER, n2, t2.STATIC_DRAW), this.checkError(), e2;
                }
                createFramebuffer() {
                  const t2 = this.gl.createFramebuffer();
                  if (!t2)
                    throw new Error("createFramebuffer returned null");
                  return t2;
                }
                queryVitalParameters() {
                  const t2 = this.gl;
                  if (this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer(), this.isRenderFloat32Supported = this.checkRenderFloat32(), this.isFloat32DownloadSupported = this.checkFloat32Download(), 1 === this.version && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported)
                    throw new Error("both float32 and float16 TextureType are not supported");
                  this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend(), this.maxTextureSize = t2.getParameter(t2.MAX_TEXTURE_SIZE), this.maxTextureImageUnits = t2.getParameter(t2.MAX_TEXTURE_IMAGE_UNITS), this.version;
                }
                getExtensions() {
                  2 === this.version ? (this.colorBufferFloatExtension = this.gl.getExtension("EXT_color_buffer_float"), this.disjointTimerQueryWebgl2Extension = this.gl.getExtension("EXT_disjoint_timer_query_webgl2")) : (this.textureFloatExtension = this.gl.getExtension("OES_texture_float"), this.textureHalfFloatExtension = this.gl.getExtension("OES_texture_half_float"));
                }
                checkFloatTextureAttachableToFrameBuffer() {
                  const t2 = this.gl, e2 = t2.createTexture();
                  t2.bindTexture(t2.TEXTURE_2D, e2);
                  const n2 = 2 === this.version ? t2.RGBA32F : t2.RGBA;
                  t2.texImage2D(t2.TEXTURE_2D, 0, n2, 1, 1, 0, t2.RGBA, t2.FLOAT, null);
                  const r2 = t2.createFramebuffer();
                  t2.bindFramebuffer(t2.FRAMEBUFFER, r2), t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, e2, 0);
                  const i2 = t2.checkFramebufferStatus(t2.FRAMEBUFFER) === t2.FRAMEBUFFER_COMPLETE;
                  return t2.bindTexture(t2.TEXTURE_2D, null), t2.bindFramebuffer(t2.FRAMEBUFFER, null), t2.deleteTexture(e2), t2.deleteFramebuffer(r2), i2;
                }
                checkRenderFloat32() {
                  if (2 === this.version) {
                    if (!this.colorBufferFloatExtension)
                      return false;
                  } else if (!this.textureFloatExtension)
                    return false;
                  return this.isFloatTextureAttachableToFrameBuffer;
                }
                checkFloat32Download() {
                  if (2 === this.version) {
                    if (!this.colorBufferFloatExtension)
                      return false;
                  } else {
                    if (!this.textureFloatExtension)
                      return false;
                    if (!this.gl.getExtension("WEBGL_color_buffer_float"))
                      return false;
                  }
                  return this.isFloatTextureAttachableToFrameBuffer;
                }
                checkFloat32Blend() {
                  const t2 = this.gl;
                  let e2, n2, r2, i2, o2;
                  try {
                    e2 = t2.createTexture(), n2 = t2.createFramebuffer(), t2.bindTexture(t2.TEXTURE_2D, e2);
                    const a2 = 2 === this.version ? t2.RGBA32F : t2.RGBA;
                    return t2.texImage2D(t2.TEXTURE_2D, 0, a2, 1, 1, 0, t2.RGBA, t2.FLOAT, null), t2.bindFramebuffer(t2.FRAMEBUFFER, n2), t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, e2, 0), t2.enable(t2.BLEND), r2 = t2.createShader(t2.VERTEX_SHADER), !!r2 && (t2.shaderSource(r2, "void main(){}"), t2.compileShader(r2), i2 = t2.createShader(t2.FRAGMENT_SHADER), !!i2 && (t2.shaderSource(i2, "precision highp float;void main(){gl_FragColor=vec4(0.5);}"), t2.compileShader(i2), o2 = t2.createProgram(), !!o2 && (t2.attachShader(o2, r2), t2.attachShader(o2, i2), t2.linkProgram(o2), t2.useProgram(o2), t2.drawArrays(t2.POINTS, 0, 1), t2.getError() === t2.NO_ERROR)));
                  } finally {
                    t2.disable(t2.BLEND), o2 && t2.deleteProgram(o2), r2 && t2.deleteShader(r2), i2 && t2.deleteShader(i2), n2 && (t2.bindFramebuffer(t2.FRAMEBUFFER, null), t2.deleteFramebuffer(n2)), e2 && (t2.bindTexture(t2.TEXTURE_2D, null), t2.deleteTexture(e2));
                  }
                }
                beginTimer() {
                  if (2 === this.version && this.disjointTimerQueryWebgl2Extension) {
                    const t2 = this.gl, e2 = this.disjointTimerQueryWebgl2Extension, n2 = t2.createQuery();
                    return t2.beginQuery(e2.TIME_ELAPSED_EXT, n2), n2;
                  }
                  throw new Error("WebGL1 profiling currently not supported.");
                }
                endTimer() {
                  if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension)
                    throw new Error("WebGL1 profiling currently not supported");
                  {
                    const t2 = this.gl, e2 = this.disjointTimerQueryWebgl2Extension;
                    t2.endQuery(e2.TIME_ELAPSED_EXT);
                  }
                }
                isTimerResultAvailable(t2) {
                  let e2 = false, n2 = false;
                  if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension)
                    throw new Error("WebGL1 profiling currently not supported");
                  {
                    const r2 = this.gl, i2 = this.disjointTimerQueryWebgl2Extension;
                    e2 = r2.getQueryParameter(t2, r2.QUERY_RESULT_AVAILABLE), n2 = r2.getParameter(i2.GPU_DISJOINT_EXT);
                  }
                  return e2 && !n2;
                }
                getTimerResult(t2) {
                  let e2 = 0;
                  if (2 !== this.version)
                    throw new Error("WebGL1 profiling currently not supported");
                  {
                    const n2 = this.gl;
                    e2 = n2.getQueryParameter(t2, n2.QUERY_RESULT), n2.deleteQuery(t2);
                  }
                  return e2 / 1e6;
                }
                async waitForQueryAndGetTime(t2) {
                  return await (0, u.repeatedTry)(() => this.isTimerResultAvailable(t2)), this.getTimerResult(t2);
                }
                async createAndWaitForFence() {
                  const t2 = this.createFence(this.gl);
                  return this.pollFence(t2);
                }
                createFence(t2) {
                  let e2;
                  const n2 = t2, r2 = n2.fenceSync(n2.SYNC_GPU_COMMANDS_COMPLETE, 0);
                  return t2.flush(), e2 = null === r2 ? () => true : () => {
                    const t3 = n2.clientWaitSync(r2, 0, 0);
                    return t3 === n2.ALREADY_SIGNALED || t3 === n2.CONDITION_SATISFIED;
                  }, { query: r2, isFencePassed: e2 };
                }
                async pollFence(t2) {
                  return new Promise((e2) => {
                    this.addItemToPoll(() => t2.isFencePassed(), () => e2());
                  });
                }
                pollItems() {
                  const t2 = c(this.itemsToPoll.map((t3) => t3.isDoneFn));
                  for (let e2 = 0; e2 <= t2; ++e2) {
                    const { resolveFn: t3 } = this.itemsToPoll[e2];
                    t3();
                  }
                  this.itemsToPoll = this.itemsToPoll.slice(t2 + 1);
                }
                async addItemToPoll(t2, e2) {
                  this.itemsToPoll.push({ isDoneFn: t2, resolveFn: e2 }), this.itemsToPoll.length > 1 || await (0, u.repeatedTry)(() => (this.pollItems(), 0 === this.itemsToPoll.length));
                }
              };
            }, 1036: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.ExecutionPlan = void 0;
              const r = n(6231);
              class i {
                constructor(t2, e2) {
                  this.op = t2, this.node = e2;
                }
              }
              e.ExecutionPlan = class {
                constructor(t2, e2, n2) {
                  this.graph = t2, this.profiler = n2, this.initialize(e2);
                }
                initialize(t2) {
                  this.profiler.event("session", "ExecutionPlan.initialize", () => {
                    const e2 = this.graph.getNodes();
                    if (e2.length !== t2.length)
                      throw new Error("The size of nodes and OPs do not match.");
                    this._ops = t2.map((t3, n2) => new i(t3, e2[n2])), this.reset(), this._starter = [], this._ops.forEach((t3, e3) => {
                      let n2 = true;
                      for (const e4 of t3.node.inputs)
                        if (!this._values[e4] && -1 === this.graph.getInputIndices().indexOf(e4)) {
                          n2 = false;
                          break;
                        }
                      n2 && this._starter.push(e3);
                    });
                  });
                }
                reset() {
                  this._values = this.graph.getValues().map((t2) => t2.tensor);
                }
                async execute(t2, e2) {
                  return this.profiler.event("session", "ExecutionPlan.execute", async () => {
                    this.reset();
                    const n2 = t2.createInferenceHandler(), i2 = this.graph.getInputIndices();
                    if (e2.length !== i2.length)
                      throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${e2.length} expected: ${i2.length}`);
                    e2.forEach((t3, e3) => {
                      const n3 = i2[e3];
                      this._values[n3] = t3;
                    });
                    const o = this._starter.slice(0), a = this.graph.getValues(), s = this.graph.getNodes();
                    let u = 0;
                    for (; u < o.length; ) {
                      const t3 = o[u++], e3 = this._ops[t3], i3 = e3.node.inputs.map((t4) => this._values[t4]);
                      if (-1 !== i3.indexOf(void 0))
                        throw new Error(`unresolved input detected: op: ${e3.node}`);
                      const c2 = i3;
                      r.Logger.verbose("ExecPlan", `Runing op:${e3.node.name} (${c2.map((t4, n3) => `'${e3.node.inputs[n3]}': ${t4.type}[${t4.dims.join(",")}]`).join(", ")})`);
                      const l = await this.profiler.event("node", e3.node.name, async () => e3.op.impl(n2, c2, e3.op.context));
                      if (l.length !== e3.node.outputs.length)
                        throw new Error("the size of output does not match model definition.");
                      l.forEach((t4, n3) => {
                        const r2 = e3.node.outputs[n3];
                        if (this._values[r2])
                          throw new Error(`output [${r2}] already has value: op:${e3.node.name}`);
                        this._values[r2] = t4;
                      });
                      const p = /* @__PURE__ */ new Set();
                      l.forEach((t4, n3) => {
                        const r2 = e3.node.outputs[n3];
                        for (const t5 of a[r2].to) {
                          const e4 = s[t5];
                          let n4 = true;
                          for (const t6 of e4.inputs)
                            if (!this._values[t6]) {
                              n4 = false;
                              break;
                            }
                          n4 && p.add(t5);
                        }
                      }), o.push(...p);
                    }
                    const c = [];
                    for (let t3 = 0; t3 < this.graph.getOutputIndices().length; t3++) {
                      const e3 = this.graph.getOutputIndices()[t3], n3 = this._values[e3];
                      if (void 0 === n3)
                        throw new Error(`required output [${e3}] does not have value`);
                      0 === e3 ? await n3.getData() : n3.data, c.push(n3);
                    }
                    return r.Logger.verbose("ExecPlan", "disposing of inferenceHandler"), n2.dispose(), c;
                  });
                }
              };
            }, 7070: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.Graph = void 0;
              const r = n(1446), i = n(7778), o = n(9395), a = n(9162), s = n(2517);
              var u = o.onnxruntime.experimental.fbs;
              e.Graph = { from: (t2, e2) => new p(t2, e2) };
              class c {
                constructor(t2) {
                  this._from = void 0, this._to = [], this.tensor = void 0, this.type = void 0, t2 && (this.type = s.ProtoUtil.tensorValueTypeFromProto(t2.type.tensorType));
                }
                get from() {
                  return this._from;
                }
                get to() {
                  return this._to;
                }
              }
              class l {
                constructor(t2, e2) {
                  t2 instanceof r.onnx.NodeProto ? (this.name = t2.name, this.opType = t2.opType, this.attributes = new i.Attribute(t2.attribute)) : t2 instanceof u.Node && (this.name = null != e2 ? e2 : t2.name(), this.opType = t2.opType(), this.attributes = new i.Attribute(s.ProtoUtil.tensorAttributesFromORTFormat(t2))), this.inputs = [], this.outputs = [], this.executeNode = true;
                }
              }
              class p {
                constructor(t2, e2) {
                  if (!t2)
                    throw new TypeError("graph is empty");
                  this.buildGraph(t2), this.transformGraph(e2), this.checkIsAcyclic();
                }
                getInputIndices() {
                  return this._allInputIndices;
                }
                getInputNames() {
                  return this._allInputNames;
                }
                getOutputIndices() {
                  return this._allOutputIndices;
                }
                getOutputNames() {
                  return this._allOutputNames;
                }
                getValues() {
                  return this._allData;
                }
                getNodes() {
                  return this._nodes;
                }
                buildGraph(t2) {
                  if (t2 instanceof r.onnx.GraphProto)
                    this.buildGraphFromOnnxFormat(t2);
                  else {
                    if (!(t2 instanceof u.Graph))
                      throw new TypeError("Graph type is not supported.");
                    this.buildGraphFromOrtFormat(t2);
                  }
                }
                buildGraphFromOnnxFormat(t2) {
                  const e2 = /* @__PURE__ */ new Map();
                  this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
                  const n2 = /* @__PURE__ */ new Map();
                  if (!t2.input)
                    throw new Error("missing information in graph: input");
                  const r2 = [];
                  for (const n3 of t2.input) {
                    if (e2.has(n3.name))
                      throw new Error(`duplicated input name: ${n3.name}`);
                    const t3 = this._allData.push(new c(n3)) - 1;
                    e2.set(n3.name, t3), r2.push(n3.name);
                  }
                  if (!t2.initializer)
                    throw new Error("missing information in graph: initializer");
                  for (const n3 of t2.initializer) {
                    let t3 = e2.get(n3.name);
                    if (void 0 === t3) {
                      const r3 = new c();
                      r3.type = { shape: { dims: s.ProtoUtil.tensorDimsFromProto(n3.dims) }, tensorType: s.ProtoUtil.tensorDataTypeFromProto(n3.dataType) }, t3 = this._allData.push(r3) - 1, e2.set(n3.name, t3);
                    }
                    this._allData[t3]._from = -1, this._allData[t3].tensor = a.Tensor.fromProto(n3);
                  }
                  for (let t3 = 0; t3 < this._allData.length; t3++)
                    this._allData[t3].tensor || (this._allInputIndices.push(t3), this._allInputNames.push(r2[t3]));
                  if (!t2.output)
                    throw new Error("missing information in graph: output");
                  for (const n3 of t2.output) {
                    if (e2.has(n3.name))
                      throw new Error(`duplicated output name: ${n3.name}`);
                    const t3 = this._allData.push(new c(n3)) - 1;
                    e2.set(n3.name, t3), this._allOutputIndices.push(t3), this._allOutputNames.push(n3.name);
                  }
                  if (!t2.node)
                    throw new Error("missing information in graph: node");
                  for (const e3 of t2.node) {
                    if (!e3.name)
                      for (let t4 = 0; ; t4++) {
                        const r3 = `unnamed_${e3.opType}_${t4}`;
                        if (!n2.has(r3)) {
                          e3.name = r3;
                          break;
                        }
                      }
                    if (n2.has(e3.name))
                      throw new Error(`duplicated node name: ${e3.name}`);
                    const t3 = this._nodes.push(new l(e3)) - 1;
                    n2.set(e3.name, t3);
                  }
                  for (let n3 = 0; n3 < this._nodes.length; n3++) {
                    const r3 = this._nodes[n3], i2 = t2.node[n3];
                    if (!i2.output)
                      throw new Error(`missing output for node: ${i2.name}`);
                    for (const t3 of i2.output) {
                      let o2 = e2.get(t3);
                      if (void 0 === o2 && (o2 = this._allData.push(new c()) - 1, e2.set(t3, o2)), r3.outputs.push(o2), void 0 !== this._allData[o2]._from)
                        throw new Error(`multiple nodes output to one data value: ${o2}`);
                      if (this._allData[o2]._from = n3, "Constant" === i2.opType) {
                        if (!i2.attribute || 1 !== i2.attribute.length || !i2.attribute[0].t)
                          throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                        if (!i2.output || 1 !== i2.output.length)
                          throw new Error("missing output or incorrect number of outputs for this Constant operator");
                        r3.outputs.pop(), r3.executeNode = false, this._allData[o2]._from = -1, this._allData[o2].tensor = a.Tensor.fromProto(i2.attribute[0].t);
                      }
                    }
                  }
                  for (let n3 = 0; n3 < this._nodes.length; n3++) {
                    const r3 = this._nodes[n3], i2 = t2.node[n3];
                    if (!i2.input)
                      throw new Error(`missing input for node: ${i2.name}`);
                    for (const t3 of i2.input) {
                      const o2 = e2.get(t3);
                      if (void 0 === o2) {
                        if ("" === t3 && 3 === i2.input.length && "Resize" === i2.opType)
                          continue;
                        throw new Error(`unrecognized input '${t3}' for node: ${i2.name}`);
                      }
                      r3.inputs.push(o2), this._allData[o2]._to.push(n3);
                    }
                  }
                  return true;
                }
                buildGraphFromOrtFormat(t2) {
                  var e2, n2, r2;
                  const i2 = /* @__PURE__ */ new Map();
                  this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
                  const o2 = /* @__PURE__ */ new Map(), p2 = [];
                  for (let o3 = 0; o3 < t2.inputsLength(); o3++) {
                    const a2 = t2.inputs(o3);
                    if (i2.has(a2))
                      throw new Error(`duplicated input name: ${a2}`);
                    for (let o4 = 0; o4 < t2.nodeArgsLength(); o4++)
                      if ((null === (e2 = t2.nodeArgs(o4)) || void 0 === e2 ? void 0 : e2.name()) === a2) {
                        const e3 = new c();
                        if ((null === (r2 = null === (n2 = t2.nodeArgs(o4)) || void 0 === n2 ? void 0 : n2.type()) || void 0 === r2 ? void 0 : r2.valueType()) !== u.TypeInfoValue.tensor_type)
                          throw new Error("Unexpected value type for the nodeArg.");
                        const l2 = t2.nodeArgs(o4).type().value(new u.TensorTypeAndShape()), f = s.ProtoUtil.tensorDataTypeFromProto(l2.elemType()), d = l2.shape(), h = [];
                        for (let t3 = 0; t3 < d.dimLength(); t3++)
                          h.push(s.LongUtil.longToNumber(d.dim(t3).value().dimValue()));
                        e3.type = { shape: { dims: h }, tensorType: f };
                        const g = this._allData.push(e3) - 1;
                        i2.set(a2, g), p2.push(a2);
                      }
                  }
                  for (let e3 = 0; e3 < t2.initializersLength(); e3++) {
                    const n3 = t2.initializers(e3);
                    let r3 = i2.get(n3.name());
                    if (void 0 === r3) {
                      const t3 = new c(), e4 = s.ProtoUtil.tensorDimsFromORTFormat(n3), o3 = s.ProtoUtil.tensorDataTypeFromProto(n3.dataType());
                      t3.type = { shape: { dims: e4 }, tensorType: o3 }, r3 = this._allData.push(t3) - 1, i2.set(n3.name(), r3);
                    }
                    this._allData[r3]._from = -1, this._allData[r3].tensor = a.Tensor.fromOrtTensor(n3);
                  }
                  for (let t3 = 0; t3 < this._allData.length; t3++)
                    this._allData[t3].tensor || (this._allInputIndices.push(t3), this._allInputNames.push(p2[t3]));
                  for (let e3 = 0; e3 < t2.outputsLength(); e3++) {
                    const n3 = t2.outputs(e3);
                    if (i2.has(n3))
                      throw new Error(`duplicated output name: ${n3}`);
                    const r3 = this._allData.push(new c()) - 1;
                    i2.set(n3, r3), this._allOutputIndices.push(r3), this._allOutputNames.push(n3);
                  }
                  if (!t2.nodes)
                    throw new Error("missing information in graph: node");
                  for (let e3 = 0; e3 < t2.nodesLength(); e3++) {
                    const n3 = t2.nodes(e3);
                    let r3 = n3.name();
                    if (!r3)
                      for (let t3 = 0; r3 = `unnamed_${n3.opType()}_${t3}`, o2.has(r3); t3++)
                        ;
                    if (o2.has(r3))
                      throw new Error(`duplicated node name: ${r3}`);
                    const i3 = this._nodes.push(new l(n3, r3)) - 1;
                    o2.set(r3, i3);
                  }
                  for (let e3 = 0; e3 < this._nodes.length; e3++) {
                    const n3 = this._nodes[e3], r3 = t2.nodes(e3);
                    if (null == r3)
                      throw new Error(`No node exists at index ${e3}`);
                    if (0 === (null == r3 ? void 0 : r3.outputsLength()))
                      throw new Error(`missing output for node: ${r3.name}`);
                    for (let t3 = 0; t3 < (null == r3 ? void 0 : r3.outputsLength()); t3++) {
                      const o3 = null == r3 ? void 0 : r3.outputs(t3);
                      let s2 = i2.get(o3);
                      if (void 0 === s2 && (s2 = this._allData.push(new c()) - 1, i2.set(o3, s2)), n3.outputs.push(s2), void 0 !== this._allData[s2]._from)
                        throw new Error(`multiple nodes output to one data value: ${s2}`);
                      if (this._allData[s2]._from = e3, "Constant" === r3.opType()) {
                        if (1 !== r3.attributesLength() || !r3.attributes(0).t())
                          throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                        if (1 !== r3.outputsLength())
                          throw new Error("missing output or incorrect number of outputs for this Constant operator");
                        n3.outputs.pop(), n3.executeNode = false, this._allData[s2]._from = -1, this._allData[s2].tensor = a.Tensor.fromOrtTensor(r3.attributes(0).t());
                      }
                    }
                  }
                  for (let e3 = 0; e3 < this._nodes.length; e3++) {
                    const n3 = this._nodes[e3], r3 = t2.nodes(e3);
                    if (0 === r3.inputsLength())
                      throw new Error(`missing input for node: ${r3.name}`);
                    for (let t3 = 0; t3 < r3.inputsLength(); t3++) {
                      const o3 = r3.inputs(t3), a2 = i2.get(o3);
                      if (void 0 === a2)
                        throw new Error(`unrecognized input '${o3}' for node: ${r3.name()}`);
                      n3.inputs.push(a2), this._allData[a2]._to.push(e3);
                    }
                  }
                }
                checkIsAcyclic() {
                  const t2 = /* @__PURE__ */ new Set();
                  this._allInputIndices.forEach((e3) => {
                    this._allData[e3]._to.forEach((e4) => {
                      t2.add(e4);
                    });
                  });
                  const e2 = Array.from(t2), n2 = new Array(this._nodes.length).fill("white");
                  for (; e2.length > 0; ) {
                    const t3 = e2.pop();
                    "gray" === n2[t3] ? n2[t3] = "black" : (e2.push(t3), n2[t3] = "gray", this._nodes[t3].outputs.forEach((r2) => {
                      const i2 = this._allData[r2];
                      if (void 0 !== i2.tensor)
                        throw new Error("node outputs should not be initialized");
                      if (i2._from !== t3)
                        throw new Error("from property of the Value object doesn't match index of Node being processed");
                      i2._to.forEach((t4) => {
                        if ("gray" === n2[t4])
                          throw new Error("model graph is cyclic");
                        "white" === n2[t4] && e2.push(t4);
                      });
                    }));
                  }
                }
                transformGraph(t2) {
                  this.removeAllIdentityNodes(), this.removeAllDropoutNodes(), this.fuseConvActivationNodes(), t2 && t2.transformGraph(this), this.finalizeGraph();
                }
                finalizeGraph() {
                  let t2 = 0;
                  for (let e2 = 0; e2 < this._nodes.length; e2++)
                    this._nodes[e2].executeNode ? t2 > 0 && (this._nodes[e2].inputs.forEach((n2) => {
                      const r2 = this._allData[n2]._to.indexOf(e2 + t2);
                      -1 !== r2 && (this._allData[n2]._to[r2] = e2);
                    }), this._nodes[e2].outputs.forEach((n2) => {
                      this._allData[n2]._from && this._allData[n2]._from === e2 + t2 && (this._allData[n2]._from = e2);
                    })) : (t2++, this._nodes[e2].outputs.forEach((t3) => {
                      this._allData[t3]._from = -2;
                    }), this._nodes.splice(e2, 1), e2--);
                  t2 = 0;
                  for (let e2 = 0; e2 < this._allData.length; e2++)
                    if (-2 !== this._allData[e2].from || -1 !== this._allOutputIndices.indexOf(e2 + t2)) {
                      if (t2 > 0) {
                        let n2 = -1;
                        void 0 !== this._allData[e2].from && -1 !== this._allData[e2].from ? (n2 = this._nodes[this._allData[e2].from].outputs.indexOf(e2 + t2), -1 !== n2 && (this._nodes[this._allData[e2].from].outputs[n2] = e2)) : (n2 = this._allInputIndices.indexOf(e2 + t2), -1 !== n2 && (this._allInputIndices[n2] = e2)), this._allData[e2].to.forEach((r2) => {
                          n2 = this._nodes[r2].inputs.indexOf(e2 + t2), -1 !== n2 && (this._nodes[r2].inputs[n2] = e2);
                        }), 0 === this._allData[e2].to.length && (n2 = this._allOutputIndices.indexOf(e2 + t2), -1 !== n2 && (this._allOutputIndices[n2] = e2));
                      }
                    } else
                      t2++, this._allData.splice(e2, 1), e2--;
                }
                deleteNode(t2) {
                  const e2 = this._nodes[t2];
                  if (e2.outputs.length > 1) {
                    for (let t3 = 1; t3 < e2.outputs.length; t3++)
                      if (this._allData[e2.outputs[t3]].to.length > 0)
                        throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");
                  }
                  e2.executeNode = false;
                  const n2 = e2.inputs[0], r2 = e2.outputs[0], i2 = this._allData[r2].to, o2 = this._allData[n2].to.indexOf(t2);
                  if (-1 === o2)
                    throw new Error("The Value object doesn't have the current Node in it's 'to' property ");
                  this._allData[n2].to.splice(o2, 1), this._allData[r2]._to = [];
                  const a2 = this._allOutputIndices.indexOf(r2);
                  if (-1 !== a2 && (this._allOutputIndices[a2] = n2), i2 && i2.length > 0)
                    for (const t3 of i2) {
                      const e3 = this._nodes[t3].inputs.indexOf(r2);
                      if (-1 === e3)
                        throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");
                      this._nodes[t3].inputs[e3] = n2, this._allData[n2].to.push(t3);
                    }
                }
                removeAllDropoutNodes() {
                  let t2 = 0;
                  for (const e2 of this._nodes) {
                    if ("Dropout" === e2.opType) {
                      if (1 !== e2.inputs.length)
                        throw new Error("Dropout nodes should only contain one input. ");
                      if (1 !== e2.outputs.length && 2 !== e2.outputs.length)
                        throw new Error("Dropout nodes should contain either 1 or 2 output(s)");
                      if (2 === e2.outputs.length && 0 !== this._allData[e2.outputs[1]]._to.length)
                        throw new Error("Dropout nodes's second output should not be referenced by other nodes");
                      this.deleteNode(t2);
                    }
                    t2++;
                  }
                }
                removeAllIdentityNodes() {
                  let t2 = 0;
                  for (const e2 of this._nodes)
                    "Identity" === e2.opType && this.deleteNode(t2), t2++;
                }
                isActivation(t2) {
                  switch (t2.opType) {
                    case "Relu":
                    case "Sigmoid":
                    case "Clip":
                      return true;
                    default:
                      return false;
                  }
                }
                fuseConvActivationNodes() {
                  for (const t2 of this._nodes)
                    if ("Conv" === t2.opType) {
                      const e2 = this._allData[t2.outputs[0]]._to;
                      if (1 === e2.length && this.isActivation(this._nodes[e2[0]])) {
                        const n2 = this._nodes[e2[0]];
                        if ("Clip" === n2.opType)
                          if (1 === n2.inputs.length)
                            try {
                              t2.attributes.set("activation_params", "floats", [n2.attributes.getFloat("min"), n2.attributes.getFloat("max")]);
                            } catch (e3) {
                              t2.attributes.set("activation_params", "floats", [s.MIN_CLIP, s.MAX_CLIP]);
                            }
                          else {
                            if (!(n2.inputs.length >= 3 && void 0 !== this._allData[n2.inputs[1]].tensor && void 0 !== this._allData[n2.inputs[2]].tensor))
                              continue;
                            t2.attributes.set("activation_params", "floats", [this._allData[n2.inputs[1]].tensor.floatData[0], this._allData[n2.inputs[2]].tensor.floatData[0]]);
                          }
                        t2.attributes.set("activation", "string", n2.opType), this.deleteNode(e2[0]);
                      }
                    }
                }
              }
            }, 6231: (t, e) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.now = e.Profiler = e.Logger = void 0;
              const n = { verbose: 1e3, info: 2e3, warning: 4e3, error: 5e3, fatal: 6e3 }, r = { none: new class {
                log(t2, e2, n2) {
                }
              }(), console: new class {
                log(t2, e2, n2) {
                  console.log(`${this.color(t2)} ${n2 ? "\x1B[35m" + n2 + "\x1B[0m " : ""}${e2}`);
                }
                color(t2) {
                  switch (t2) {
                    case "verbose":
                      return "\x1B[34;40mv\x1B[0m";
                    case "info":
                      return "\x1B[32mi\x1B[0m";
                    case "warning":
                      return "\x1B[30;43mw\x1B[0m";
                    case "error":
                      return "\x1B[31;40me\x1B[0m";
                    case "fatal":
                      return "\x1B[101mf\x1B[0m";
                    default:
                      throw new Error(`unsupported severity: ${t2}`);
                  }
                }
              }() }, i = { provider: "console", minimalSeverity: "warning", logDateTime: true, logSourceLocation: false };
              let o = { "": i };
              function a(t2, e2, n2, r2) {
                if (void 0 === e2)
                  return i2 = t2, { verbose: a.verbose.bind(null, i2), info: a.info.bind(null, i2), warning: a.warning.bind(null, i2), error: a.error.bind(null, i2), fatal: a.fatal.bind(null, i2) };
                if (void 0 === n2)
                  s(t2, e2);
                else if ("number" == typeof n2 && void 0 === r2)
                  s(t2, e2);
                else if ("string" == typeof n2 && void 0 === r2)
                  s(t2, n2, 0, e2);
                else {
                  if ("string" != typeof n2 || "number" != typeof r2)
                    throw new TypeError("input is valid");
                  s(t2, n2, 0, e2);
                }
                var i2;
              }
              function s(t2, e2, i2, a2) {
                const s2 = o[a2 || ""] || o[""];
                n[t2] < n[s2.minimalSeverity] || (s2.logDateTime && (e2 = `${new Date().toISOString()}|${e2}`), s2.logSourceLocation, r[s2.provider].log(t2, e2, a2));
              }
              !function(t2) {
                function e2(t3) {
                  o = {}, n2("", t3 || {});
                }
                function n2(t3, n3) {
                  if ("*" === t3)
                    e2(n3);
                  else {
                    const e3 = o[t3] || i;
                    o[t3] = { provider: n3.provider || e3.provider, minimalSeverity: n3.minimalSeverity || e3.minimalSeverity, logDateTime: void 0 === n3.logDateTime ? e3.logDateTime : n3.logDateTime, logSourceLocation: void 0 === n3.logSourceLocation ? e3.logSourceLocation : n3.logSourceLocation };
                  }
                }
                t2.verbose = function(e3, n3) {
                  t2("verbose", e3, n3);
                }, t2.info = function(e3, n3) {
                  t2("info", e3, n3);
                }, t2.warning = function(e3, n3) {
                  t2("warning", e3, n3);
                }, t2.error = function(e3, n3) {
                  t2("error", e3, n3);
                }, t2.fatal = function(e3, n3) {
                  t2("fatal", e3, n3);
                }, t2.reset = e2, t2.set = n2, t2.setWithEnv = function(t3) {
                  const e3 = {};
                  t3.logLevel && (e3.minimalSeverity = t3.logLevel), n2("", e3);
                };
              }(a || (a = {})), e.Logger = a;
              class u {
                constructor(t2, e2, n2, r2, i2, o2) {
                  this.category = t2, this.name = e2, this.startTime = n2, this.endCallback = r2, this.timer = i2, this.ctx = o2;
                }
                end() {
                  return this.endCallback(this);
                }
                async checkTimer() {
                  if (void 0 === this.ctx || void 0 === this.timer)
                    throw new Error("No webgl timer found");
                  return this.ctx.endTimer(), this.ctx.waitForQueryAndGetTime(this.timer);
                }
              }
              class c {
                constructor(t2, e2, n2, r2) {
                  this.category = t2, this.name = e2, this.startTime = n2, this.endTime = r2;
                }
              }
              e.Profiler = class {
                static create(t2) {
                  return void 0 === t2 ? new this() : new this(t2.maxNumberEvents, t2.flushBatchSize, t2.flushIntervalInMilliseconds);
                }
                constructor(t2, e2, n2) {
                  this._started = false, this._flushPointer = 0, this._started = false, this._maxNumberEvents = void 0 === t2 ? 1e4 : t2, this._flushBatchSize = void 0 === e2 ? 10 : e2, this._flushIntervalInMilliseconds = void 0 === n2 ? 5e3 : n2;
                }
                start() {
                  this._started = true, this._timingEvents = [], this._flushTime = (0, e.now)(), this._flushPointer = 0;
                }
                stop() {
                  for (this._started = false; this._flushPointer < this._timingEvents.length; this._flushPointer++)
                    this.logOneEvent(this._timingEvents[this._flushPointer]);
                }
                event(t2, e2, n2, r2) {
                  const i2 = this._started ? this.begin(t2, e2, r2) : void 0;
                  let o2 = false;
                  const a2 = n2();
                  if (a2 && "function" == typeof a2.then)
                    return o2 = true, new Promise((t3, e3) => {
                      a2.then(async (e4) => {
                        i2 && await i2.end(), t3(e4);
                      }, async (t4) => {
                        i2 && await i2.end(), e3(t4);
                      });
                    });
                  if (!o2 && i2) {
                    const t3 = i2.end();
                    if (t3 && "function" == typeof t3.then)
                      return new Promise((e3, n3) => {
                        t3.then(() => {
                          e3(a2);
                        }, (t4) => {
                          n3(t4);
                        });
                      });
                  }
                  return a2;
                }
                begin(t2, n2, r2) {
                  if (!this._started)
                    throw new Error("profiler is not started yet");
                  if (void 0 === r2) {
                    const r3 = (0, e.now)();
                    return this.flush(r3), new u(t2, n2, r3, (t3) => this.endSync(t3));
                  }
                  {
                    const e2 = r2.beginTimer();
                    return new u(t2, n2, 0, async (t3) => this.end(t3), e2, r2);
                  }
                }
                async end(t2) {
                  const e2 = await t2.checkTimer();
                  this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new c(t2.category, t2.name, t2.startTime, e2)), this.flush(e2));
                }
                endSync(t2) {
                  const n2 = (0, e.now)();
                  this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new c(t2.category, t2.name, t2.startTime, n2)), this.flush(n2));
                }
                logOneEvent(t2) {
                  e.Logger.verbose(`Profiler.${t2.category}`, `${(t2.endTime - t2.startTime).toFixed(2)}ms on event '${t2.name}' at ${t2.endTime.toFixed(2)}`);
                }
                flush(t2) {
                  if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || t2 - this._flushTime >= this._flushIntervalInMilliseconds) {
                    for (const t3 = this._flushPointer; this._flushPointer < t3 + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++)
                      this.logOneEvent(this._timingEvents[this._flushPointer]);
                    this._flushTime = (0, e.now)();
                  }
                }
                get started() {
                  return this._started;
                }
              }, e.now = "undefined" != typeof performance && performance.now ? () => performance.now() : Date.now;
            }, 2644: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.Model = void 0;
              const r = n(5686), i = n(1446), o = n(7070), a = n(9395), s = n(2517);
              var u = a.onnxruntime.experimental.fbs;
              e.Model = class {
                constructor() {
                }
                load(t2, e2, n2) {
                  if (!n2)
                    try {
                      return void this.loadFromOnnxFormat(t2, e2);
                    } catch (t3) {
                      if (void 0 !== n2)
                        throw t3;
                    }
                  this.loadFromOrtFormat(t2, e2);
                }
                loadFromOnnxFormat(t2, e2) {
                  const n2 = i.onnx.ModelProto.decode(t2);
                  if (s.LongUtil.longToNumber(n2.irVersion) < 3)
                    throw new Error("only support ONNX model with IR_VERSION>=3");
                  this._opsets = n2.opsetImport.map((t3) => ({ domain: t3.domain, version: s.LongUtil.longToNumber(t3.version) })), this._graph = o.Graph.from(n2.graph, e2);
                }
                loadFromOrtFormat(t2, e2) {
                  const n2 = new r.flatbuffers.ByteBuffer(t2), i2 = u.InferenceSession.getRootAsInferenceSession(n2).model();
                  if (s.LongUtil.longToNumber(i2.irVersion()) < 3)
                    throw new Error("only support ONNX model with IR_VERSION>=3");
                  this._opsets = [];
                  for (let t3 = 0; t3 < i2.opsetImportLength(); t3++) {
                    const e3 = i2.opsetImport(t3);
                    this._opsets.push({ domain: null == e3 ? void 0 : e3.domain(), version: s.LongUtil.longToNumber(e3.version()) });
                  }
                  this._graph = o.Graph.from(i2.graph(), e2);
                }
                get graph() {
                  return this._graph;
                }
                get opsets() {
                  return this._opsets;
                }
              };
            }, 782: (t, e) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.FLOAT_TYPES = e.INT_TYPES = e.NUMBER_TYPES = void 0, e.NUMBER_TYPES = ["float32", "float64", "int32", "int16", "int8", "uint16", "uint32", "uint8"], e.INT_TYPES = ["int32", "int16", "int8", "uint16", "uint32", "uint8"], e.FLOAT_TYPES = ["float32", "float64"];
            }, 1047: (t, e) => {
              "use strict";
              function n(t2, e2) {
                if (e2.endsWith("+")) {
                  const n2 = Number.parseInt(e2.substring(0, e2.length - 1), 10);
                  return !isNaN(n2) && n2 <= t2;
                }
                if (2 === e2.split("-").length) {
                  const n2 = e2.split("-"), r = Number.parseInt(n2[0], 10), i = Number.parseInt(n2[1], 10);
                  return !isNaN(r) && !isNaN(i) && r <= t2 && t2 <= i;
                }
                return Number.parseInt(e2, 10) === t2;
              }
              Object.defineProperty(e, "__esModule", { value: true }), e.resolveOperator = void 0, e.resolveOperator = function(t2, e2, r) {
                for (const i of r) {
                  const r2 = i[0], o = i[1], a = i[2], s = i[3], u = i[4];
                  if (t2.opType === r2) {
                    for (const t3 of e2)
                      if ((t3.domain === o || "ai.onnx" === t3.domain && "" === o) && n(t3.version, a))
                        return { opImpl: s, opInit: u };
                  }
                }
                throw new TypeError(`cannot resolve operator '${t2.opType}' with opsets: ${e2.map((t3) => `${t3.domain || "ai.onnx"} v${t3.version}`).join(", ")}`);
              };
            }, 9395: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.onnxruntime = void 0;
              const r = n(5686);
              var i, o;
              i = e.onnxruntime || (e.onnxruntime = {}), function(t2) {
                let e2;
                !function(t3) {
                  t3[t3.UNDEFINED = 0] = "UNDEFINED", t3[t3.FLOAT = 1] = "FLOAT", t3[t3.INT = 2] = "INT", t3[t3.STRING = 3] = "STRING", t3[t3.TENSOR = 4] = "TENSOR", t3[t3.GRAPH = 5] = "GRAPH", t3[t3.FLOATS = 6] = "FLOATS", t3[t3.INTS = 7] = "INTS", t3[t3.STRINGS = 8] = "STRINGS", t3[t3.TENSORS = 9] = "TENSORS", t3[t3.GRAPHS = 10] = "GRAPHS", t3[t3.SPARSE_TENSOR = 11] = "SPARSE_TENSOR", t3[t3.SPARSE_TENSORS = 12] = "SPARSE_TENSORS";
                }(e2 = t2.AttributeType || (t2.AttributeType = {}));
              }((o = i.experimental || (i.experimental = {})).fbs || (o.fbs = {})), function(t2) {
                !function(t3) {
                  !function(t4) {
                    let e2;
                    !function(t5) {
                      t5[t5.UNKNOWN = 0] = "UNKNOWN", t5[t5.VALUE = 1] = "VALUE", t5[t5.PARAM = 2] = "PARAM";
                    }(e2 = t4.DimensionValueType || (t4.DimensionValueType = {}));
                  }(t3.fbs || (t3.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(t3) {
                  !function(t4) {
                    let e2;
                    !function(t5) {
                      t5[t5.UNDEFINED = 0] = "UNDEFINED", t5[t5.FLOAT = 1] = "FLOAT", t5[t5.UINT8 = 2] = "UINT8", t5[t5.INT8 = 3] = "INT8", t5[t5.UINT16 = 4] = "UINT16", t5[t5.INT16 = 5] = "INT16", t5[t5.INT32 = 6] = "INT32", t5[t5.INT64 = 7] = "INT64", t5[t5.STRING = 8] = "STRING", t5[t5.BOOL = 9] = "BOOL", t5[t5.FLOAT16 = 10] = "FLOAT16", t5[t5.DOUBLE = 11] = "DOUBLE", t5[t5.UINT32 = 12] = "UINT32", t5[t5.UINT64 = 13] = "UINT64", t5[t5.COMPLEX64 = 14] = "COMPLEX64", t5[t5.COMPLEX128 = 15] = "COMPLEX128", t5[t5.BFLOAT16 = 16] = "BFLOAT16";
                    }(e2 = t4.TensorDataType || (t4.TensorDataType = {}));
                  }(t3.fbs || (t3.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(t3) {
                  !function(t4) {
                    let e2;
                    !function(t5) {
                      t5[t5.Primitive = 0] = "Primitive", t5[t5.Fused = 1] = "Fused";
                    }(e2 = t4.NodeType || (t4.NodeType = {}));
                  }(t3.fbs || (t3.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(t3) {
                  !function(t4) {
                    let e2;
                    !function(t5) {
                      t5[t5.NONE = 0] = "NONE", t5[t5.tensor_type = 1] = "tensor_type", t5[t5.sequence_type = 2] = "sequence_type", t5[t5.map_type = 3] = "map_type";
                    }(e2 = t4.TypeInfoValue || (t4.TypeInfoValue = {}));
                  }(t3.fbs || (t3.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(e2) {
                  !function(e3) {
                    class n2 {
                      constructor() {
                        this.bb = null, this.bb_pos = 0;
                      }
                      __init(t3, e4) {
                        return this.bb_pos = t3, this.bb = e4, this;
                      }
                      static getRootAsShape(t3, e4) {
                        return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      static getSizePrefixedRootAsShape(t3, e4) {
                        return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      dim(e4, n3) {
                        let r2 = this.bb.__offset(this.bb_pos, 4);
                        return r2 ? (n3 || new t2.experimental.fbs.Dimension()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                      }
                      dimLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 4);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      static startShape(t3) {
                        t3.startObject(1);
                      }
                      static addDim(t3, e4) {
                        t3.addFieldOffset(0, e4, 0);
                      }
                      static createDimVector(t3, e4) {
                        t3.startVector(4, e4.length, 4);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addOffset(e4[n3]);
                        return t3.endVector();
                      }
                      static startDimVector(t3, e4) {
                        t3.startVector(4, e4, 4);
                      }
                      static endShape(t3) {
                        return t3.endObject();
                      }
                      static createShape(t3, e4) {
                        return n2.startShape(t3), n2.addDim(t3, e4), n2.endShape(t3);
                      }
                    }
                    e3.Shape = n2;
                  }(e2.fbs || (e2.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(e2) {
                  !function(e3) {
                    class n2 {
                      constructor() {
                        this.bb = null, this.bb_pos = 0;
                      }
                      __init(t3, e4) {
                        return this.bb_pos = t3, this.bb = e4, this;
                      }
                      static getRootAsDimension(t3, e4) {
                        return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      static getSizePrefixedRootAsDimension(t3, e4) {
                        return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      value(e4) {
                        let n3 = this.bb.__offset(this.bb_pos, 4);
                        return n3 ? (e4 || new t2.experimental.fbs.DimensionValue()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                      }
                      denotation(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 6);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      static startDimension(t3) {
                        t3.startObject(2);
                      }
                      static addValue(t3, e4) {
                        t3.addFieldOffset(0, e4, 0);
                      }
                      static addDenotation(t3, e4) {
                        t3.addFieldOffset(1, e4, 0);
                      }
                      static endDimension(t3) {
                        return t3.endObject();
                      }
                      static createDimension(t3, e4, r2) {
                        return n2.startDimension(t3), n2.addValue(t3, e4), n2.addDenotation(t3, r2), n2.endDimension(t3);
                      }
                    }
                    e3.Dimension = n2;
                  }(e2.fbs || (e2.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(e2) {
                  !function(e3) {
                    class n2 {
                      constructor() {
                        this.bb = null, this.bb_pos = 0;
                      }
                      __init(t3, e4) {
                        return this.bb_pos = t3, this.bb = e4, this;
                      }
                      static getRootAsDimensionValue(t3, e4) {
                        return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      static getSizePrefixedRootAsDimensionValue(t3, e4) {
                        return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      dimType() {
                        let e4 = this.bb.__offset(this.bb_pos, 4);
                        return e4 ? this.bb.readInt8(this.bb_pos + e4) : t2.experimental.fbs.DimensionValueType.UNKNOWN;
                      }
                      dimValue() {
                        let t3 = this.bb.__offset(this.bb_pos, 6);
                        return t3 ? this.bb.readInt64(this.bb_pos + t3) : this.bb.createLong(0, 0);
                      }
                      dimParam(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 8);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      static startDimensionValue(t3) {
                        t3.startObject(3);
                      }
                      static addDimType(e4, n3) {
                        e4.addFieldInt8(0, n3, t2.experimental.fbs.DimensionValueType.UNKNOWN);
                      }
                      static addDimValue(t3, e4) {
                        t3.addFieldInt64(1, e4, t3.createLong(0, 0));
                      }
                      static addDimParam(t3, e4) {
                        t3.addFieldOffset(2, e4, 0);
                      }
                      static endDimensionValue(t3) {
                        return t3.endObject();
                      }
                      static createDimensionValue(t3, e4, r2, i2) {
                        return n2.startDimensionValue(t3), n2.addDimType(t3, e4), n2.addDimValue(t3, r2), n2.addDimParam(t3, i2), n2.endDimensionValue(t3);
                      }
                    }
                    e3.DimensionValue = n2;
                  }(e2.fbs || (e2.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(e2) {
                  !function(e3) {
                    class n2 {
                      constructor() {
                        this.bb = null, this.bb_pos = 0;
                      }
                      __init(t3, e4) {
                        return this.bb_pos = t3, this.bb = e4, this;
                      }
                      static getRootAsTensorTypeAndShape(t3, e4) {
                        return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      static getSizePrefixedRootAsTensorTypeAndShape(t3, e4) {
                        return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      elemType() {
                        let e4 = this.bb.__offset(this.bb_pos, 4);
                        return e4 ? this.bb.readInt32(this.bb_pos + e4) : t2.experimental.fbs.TensorDataType.UNDEFINED;
                      }
                      shape(e4) {
                        let n3 = this.bb.__offset(this.bb_pos, 6);
                        return n3 ? (e4 || new t2.experimental.fbs.Shape()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                      }
                      static startTensorTypeAndShape(t3) {
                        t3.startObject(2);
                      }
                      static addElemType(e4, n3) {
                        e4.addFieldInt32(0, n3, t2.experimental.fbs.TensorDataType.UNDEFINED);
                      }
                      static addShape(t3, e4) {
                        t3.addFieldOffset(1, e4, 0);
                      }
                      static endTensorTypeAndShape(t3) {
                        return t3.endObject();
                      }
                      static createTensorTypeAndShape(t3, e4, r2) {
                        return n2.startTensorTypeAndShape(t3), n2.addElemType(t3, e4), n2.addShape(t3, r2), n2.endTensorTypeAndShape(t3);
                      }
                    }
                    e3.TensorTypeAndShape = n2;
                  }(e2.fbs || (e2.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(e2) {
                  !function(e3) {
                    class n2 {
                      constructor() {
                        this.bb = null, this.bb_pos = 0;
                      }
                      __init(t3, e4) {
                        return this.bb_pos = t3, this.bb = e4, this;
                      }
                      static getRootAsMapType(t3, e4) {
                        return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      static getSizePrefixedRootAsMapType(t3, e4) {
                        return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      keyType() {
                        let e4 = this.bb.__offset(this.bb_pos, 4);
                        return e4 ? this.bb.readInt32(this.bb_pos + e4) : t2.experimental.fbs.TensorDataType.UNDEFINED;
                      }
                      valueType(e4) {
                        let n3 = this.bb.__offset(this.bb_pos, 6);
                        return n3 ? (e4 || new t2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                      }
                      static startMapType(t3) {
                        t3.startObject(2);
                      }
                      static addKeyType(e4, n3) {
                        e4.addFieldInt32(0, n3, t2.experimental.fbs.TensorDataType.UNDEFINED);
                      }
                      static addValueType(t3, e4) {
                        t3.addFieldOffset(1, e4, 0);
                      }
                      static endMapType(t3) {
                        return t3.endObject();
                      }
                      static createMapType(t3, e4, r2) {
                        return n2.startMapType(t3), n2.addKeyType(t3, e4), n2.addValueType(t3, r2), n2.endMapType(t3);
                      }
                    }
                    e3.MapType = n2;
                  }(e2.fbs || (e2.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(e2) {
                  !function(e3) {
                    class n2 {
                      constructor() {
                        this.bb = null, this.bb_pos = 0;
                      }
                      __init(t3, e4) {
                        return this.bb_pos = t3, this.bb = e4, this;
                      }
                      static getRootAsSequenceType(t3, e4) {
                        return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      static getSizePrefixedRootAsSequenceType(t3, e4) {
                        return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      elemType(e4) {
                        let n3 = this.bb.__offset(this.bb_pos, 4);
                        return n3 ? (e4 || new t2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                      }
                      static startSequenceType(t3) {
                        t3.startObject(1);
                      }
                      static addElemType(t3, e4) {
                        t3.addFieldOffset(0, e4, 0);
                      }
                      static endSequenceType(t3) {
                        return t3.endObject();
                      }
                      static createSequenceType(t3, e4) {
                        return n2.startSequenceType(t3), n2.addElemType(t3, e4), n2.endSequenceType(t3);
                      }
                    }
                    e3.SequenceType = n2;
                  }(e2.fbs || (e2.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(t3) {
                  (t3.fbs || (t3.fbs = {})).EdgeEnd = class {
                    constructor() {
                      this.bb = null, this.bb_pos = 0;
                    }
                    __init(t4, e2) {
                      return this.bb_pos = t4, this.bb = e2, this;
                    }
                    nodeIndex() {
                      return this.bb.readUint32(this.bb_pos);
                    }
                    srcArgIndex() {
                      return this.bb.readInt32(this.bb_pos + 4);
                    }
                    dstArgIndex() {
                      return this.bb.readInt32(this.bb_pos + 8);
                    }
                    static createEdgeEnd(t4, e2, n2, r2) {
                      return t4.prep(4, 12), t4.writeInt32(r2), t4.writeInt32(n2), t4.writeInt32(e2), t4.offset();
                    }
                  };
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(e2) {
                  !function(e3) {
                    class n2 {
                      constructor() {
                        this.bb = null, this.bb_pos = 0;
                      }
                      __init(t3, e4) {
                        return this.bb_pos = t3, this.bb = e4, this;
                      }
                      static getRootAsNodeEdge(t3, e4) {
                        return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      static getSizePrefixedRootAsNodeEdge(t3, e4) {
                        return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      nodeIndex() {
                        let t3 = this.bb.__offset(this.bb_pos, 4);
                        return t3 ? this.bb.readUint32(this.bb_pos + t3) : 0;
                      }
                      inputEdges(e4, n3) {
                        let r2 = this.bb.__offset(this.bb_pos, 6);
                        return r2 ? (n3 || new t2.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r2) + 12 * e4, this.bb) : null;
                      }
                      inputEdgesLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 6);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      outputEdges(e4, n3) {
                        let r2 = this.bb.__offset(this.bb_pos, 8);
                        return r2 ? (n3 || new t2.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r2) + 12 * e4, this.bb) : null;
                      }
                      outputEdgesLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 8);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      static startNodeEdge(t3) {
                        t3.startObject(3);
                      }
                      static addNodeIndex(t3, e4) {
                        t3.addFieldInt32(0, e4, 0);
                      }
                      static addInputEdges(t3, e4) {
                        t3.addFieldOffset(1, e4, 0);
                      }
                      static startInputEdgesVector(t3, e4) {
                        t3.startVector(12, e4, 4);
                      }
                      static addOutputEdges(t3, e4) {
                        t3.addFieldOffset(2, e4, 0);
                      }
                      static startOutputEdgesVector(t3, e4) {
                        t3.startVector(12, e4, 4);
                      }
                      static endNodeEdge(t3) {
                        return t3.endObject();
                      }
                      static createNodeEdge(t3, e4, r2, i2) {
                        return n2.startNodeEdge(t3), n2.addNodeIndex(t3, e4), n2.addInputEdges(t3, r2), n2.addOutputEdges(t3, i2), n2.endNodeEdge(t3);
                      }
                    }
                    e3.NodeEdge = n2;
                  }(e2.fbs || (e2.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(e2) {
                  !function(e3) {
                    class n2 {
                      constructor() {
                        this.bb = null, this.bb_pos = 0;
                      }
                      __init(t3, e4) {
                        return this.bb_pos = t3, this.bb = e4, this;
                      }
                      static getRootAsNode(t3, e4) {
                        return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      static getSizePrefixedRootAsNode(t3, e4) {
                        return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      name(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 4);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      docString(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 6);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      domain(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 8);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      sinceVersion() {
                        let t3 = this.bb.__offset(this.bb_pos, 10);
                        return t3 ? this.bb.readInt32(this.bb_pos + t3) : 0;
                      }
                      index() {
                        let t3 = this.bb.__offset(this.bb_pos, 12);
                        return t3 ? this.bb.readUint32(this.bb_pos + t3) : 0;
                      }
                      opType(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 14);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      type() {
                        let e4 = this.bb.__offset(this.bb_pos, 16);
                        return e4 ? this.bb.readInt32(this.bb_pos + e4) : t2.experimental.fbs.NodeType.Primitive;
                      }
                      executionProviderType(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 18);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      inputs(t3, e4) {
                        let n3 = this.bb.__offset(this.bb_pos, 20);
                        return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * t3, e4) : null;
                      }
                      inputsLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 20);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      outputs(t3, e4) {
                        let n3 = this.bb.__offset(this.bb_pos, 22);
                        return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * t3, e4) : null;
                      }
                      outputsLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 22);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      attributes(e4, n3) {
                        let r2 = this.bb.__offset(this.bb_pos, 24);
                        return r2 ? (n3 || new t2.experimental.fbs.Attribute()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                      }
                      attributesLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 24);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      inputArgCounts(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 26);
                        return e4 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + e4) + 4 * t3) : 0;
                      }
                      inputArgCountsLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 26);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      inputArgCountsArray() {
                        let t3 = this.bb.__offset(this.bb_pos, 26);
                        return t3 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t3), this.bb.__vector_len(this.bb_pos + t3)) : null;
                      }
                      implicitInputs(t3, e4) {
                        let n3 = this.bb.__offset(this.bb_pos, 28);
                        return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * t3, e4) : null;
                      }
                      implicitInputsLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 28);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      static startNode(t3) {
                        t3.startObject(13);
                      }
                      static addName(t3, e4) {
                        t3.addFieldOffset(0, e4, 0);
                      }
                      static addDocString(t3, e4) {
                        t3.addFieldOffset(1, e4, 0);
                      }
                      static addDomain(t3, e4) {
                        t3.addFieldOffset(2, e4, 0);
                      }
                      static addSinceVersion(t3, e4) {
                        t3.addFieldInt32(3, e4, 0);
                      }
                      static addIndex(t3, e4) {
                        t3.addFieldInt32(4, e4, 0);
                      }
                      static addOpType(t3, e4) {
                        t3.addFieldOffset(5, e4, 0);
                      }
                      static addType(e4, n3) {
                        e4.addFieldInt32(6, n3, t2.experimental.fbs.NodeType.Primitive);
                      }
                      static addExecutionProviderType(t3, e4) {
                        t3.addFieldOffset(7, e4, 0);
                      }
                      static addInputs(t3, e4) {
                        t3.addFieldOffset(8, e4, 0);
                      }
                      static createInputsVector(t3, e4) {
                        t3.startVector(4, e4.length, 4);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addOffset(e4[n3]);
                        return t3.endVector();
                      }
                      static startInputsVector(t3, e4) {
                        t3.startVector(4, e4, 4);
                      }
                      static addOutputs(t3, e4) {
                        t3.addFieldOffset(9, e4, 0);
                      }
                      static createOutputsVector(t3, e4) {
                        t3.startVector(4, e4.length, 4);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addOffset(e4[n3]);
                        return t3.endVector();
                      }
                      static startOutputsVector(t3, e4) {
                        t3.startVector(4, e4, 4);
                      }
                      static addAttributes(t3, e4) {
                        t3.addFieldOffset(10, e4, 0);
                      }
                      static createAttributesVector(t3, e4) {
                        t3.startVector(4, e4.length, 4);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addOffset(e4[n3]);
                        return t3.endVector();
                      }
                      static startAttributesVector(t3, e4) {
                        t3.startVector(4, e4, 4);
                      }
                      static addInputArgCounts(t3, e4) {
                        t3.addFieldOffset(11, e4, 0);
                      }
                      static createInputArgCountsVector(t3, e4) {
                        t3.startVector(4, e4.length, 4);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addInt32(e4[n3]);
                        return t3.endVector();
                      }
                      static startInputArgCountsVector(t3, e4) {
                        t3.startVector(4, e4, 4);
                      }
                      static addImplicitInputs(t3, e4) {
                        t3.addFieldOffset(12, e4, 0);
                      }
                      static createImplicitInputsVector(t3, e4) {
                        t3.startVector(4, e4.length, 4);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addOffset(e4[n3]);
                        return t3.endVector();
                      }
                      static startImplicitInputsVector(t3, e4) {
                        t3.startVector(4, e4, 4);
                      }
                      static endNode(t3) {
                        return t3.endObject();
                      }
                      static createNode(t3, e4, r2, i2, o2, a, s, u, c, l, p, f, d, h) {
                        return n2.startNode(t3), n2.addName(t3, e4), n2.addDocString(t3, r2), n2.addDomain(t3, i2), n2.addSinceVersion(t3, o2), n2.addIndex(t3, a), n2.addOpType(t3, s), n2.addType(t3, u), n2.addExecutionProviderType(t3, c), n2.addInputs(t3, l), n2.addOutputs(t3, p), n2.addAttributes(t3, f), n2.addInputArgCounts(t3, d), n2.addImplicitInputs(t3, h), n2.endNode(t3);
                      }
                    }
                    e3.Node = n2;
                  }(e2.fbs || (e2.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(e2) {
                  !function(e3) {
                    class n2 {
                      constructor() {
                        this.bb = null, this.bb_pos = 0;
                      }
                      __init(t3, e4) {
                        return this.bb_pos = t3, this.bb = e4, this;
                      }
                      static getRootAsValueInfo(t3, e4) {
                        return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      static getSizePrefixedRootAsValueInfo(t3, e4) {
                        return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      name(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 4);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      docString(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 6);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      type(e4) {
                        let n3 = this.bb.__offset(this.bb_pos, 8);
                        return n3 ? (e4 || new t2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                      }
                      static startValueInfo(t3) {
                        t3.startObject(3);
                      }
                      static addName(t3, e4) {
                        t3.addFieldOffset(0, e4, 0);
                      }
                      static addDocString(t3, e4) {
                        t3.addFieldOffset(1, e4, 0);
                      }
                      static addType(t3, e4) {
                        t3.addFieldOffset(2, e4, 0);
                      }
                      static endValueInfo(t3) {
                        return t3.endObject();
                      }
                      static createValueInfo(t3, e4, r2, i2) {
                        return n2.startValueInfo(t3), n2.addName(t3, e4), n2.addDocString(t3, r2), n2.addType(t3, i2), n2.endValueInfo(t3);
                      }
                    }
                    e3.ValueInfo = n2;
                  }(e2.fbs || (e2.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(e2) {
                  !function(e3) {
                    class n2 {
                      constructor() {
                        this.bb = null, this.bb_pos = 0;
                      }
                      __init(t3, e4) {
                        return this.bb_pos = t3, this.bb = e4, this;
                      }
                      static getRootAsTypeInfo(t3, e4) {
                        return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      static getSizePrefixedRootAsTypeInfo(t3, e4) {
                        return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      denotation(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 4);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      valueType() {
                        let e4 = this.bb.__offset(this.bb_pos, 6);
                        return e4 ? this.bb.readUint8(this.bb_pos + e4) : t2.experimental.fbs.TypeInfoValue.NONE;
                      }
                      value(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 8);
                        return e4 ? this.bb.__union(t3, this.bb_pos + e4) : null;
                      }
                      static startTypeInfo(t3) {
                        t3.startObject(3);
                      }
                      static addDenotation(t3, e4) {
                        t3.addFieldOffset(0, e4, 0);
                      }
                      static addValueType(e4, n3) {
                        e4.addFieldInt8(1, n3, t2.experimental.fbs.TypeInfoValue.NONE);
                      }
                      static addValue(t3, e4) {
                        t3.addFieldOffset(2, e4, 0);
                      }
                      static endTypeInfo(t3) {
                        return t3.endObject();
                      }
                      static createTypeInfo(t3, e4, r2, i2) {
                        return n2.startTypeInfo(t3), n2.addDenotation(t3, e4), n2.addValueType(t3, r2), n2.addValue(t3, i2), n2.endTypeInfo(t3);
                      }
                    }
                    e3.TypeInfo = n2;
                  }(e2.fbs || (e2.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(t3) {
                  !function(t4) {
                    class e2 {
                      constructor() {
                        this.bb = null, this.bb_pos = 0;
                      }
                      __init(t5, e3) {
                        return this.bb_pos = t5, this.bb = e3, this;
                      }
                      static getRootAsOperatorSetId(t5, n2) {
                        return (n2 || new e2()).__init(t5.readInt32(t5.position()) + t5.position(), t5);
                      }
                      static getSizePrefixedRootAsOperatorSetId(t5, n2) {
                        return t5.setPosition(t5.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (n2 || new e2()).__init(t5.readInt32(t5.position()) + t5.position(), t5);
                      }
                      domain(t5) {
                        let e3 = this.bb.__offset(this.bb_pos, 4);
                        return e3 ? this.bb.__string(this.bb_pos + e3, t5) : null;
                      }
                      version() {
                        let t5 = this.bb.__offset(this.bb_pos, 6);
                        return t5 ? this.bb.readInt64(this.bb_pos + t5) : this.bb.createLong(0, 0);
                      }
                      static startOperatorSetId(t5) {
                        t5.startObject(2);
                      }
                      static addDomain(t5, e3) {
                        t5.addFieldOffset(0, e3, 0);
                      }
                      static addVersion(t5, e3) {
                        t5.addFieldInt64(1, e3, t5.createLong(0, 0));
                      }
                      static endOperatorSetId(t5) {
                        return t5.endObject();
                      }
                      static createOperatorSetId(t5, n2, r2) {
                        return e2.startOperatorSetId(t5), e2.addDomain(t5, n2), e2.addVersion(t5, r2), e2.endOperatorSetId(t5);
                      }
                    }
                    t4.OperatorSetId = e2;
                  }(t3.fbs || (t3.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(e2) {
                  !function(e3) {
                    class n2 {
                      constructor() {
                        this.bb = null, this.bb_pos = 0;
                      }
                      __init(t3, e4) {
                        return this.bb_pos = t3, this.bb = e4, this;
                      }
                      static getRootAsTensor(t3, e4) {
                        return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      static getSizePrefixedRootAsTensor(t3, e4) {
                        return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      name(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 4);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      docString(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 6);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      dims(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 8);
                        return e4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + e4) + 8 * t3) : this.bb.createLong(0, 0);
                      }
                      dimsLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 8);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      dataType() {
                        let e4 = this.bb.__offset(this.bb_pos, 10);
                        return e4 ? this.bb.readInt32(this.bb_pos + e4) : t2.experimental.fbs.TensorDataType.UNDEFINED;
                      }
                      rawData(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 12);
                        return e4 ? this.bb.readUint8(this.bb.__vector(this.bb_pos + e4) + t3) : 0;
                      }
                      rawDataLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 12);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      rawDataArray() {
                        let t3 = this.bb.__offset(this.bb_pos, 12);
                        return t3 ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t3), this.bb.__vector_len(this.bb_pos + t3)) : null;
                      }
                      stringData(t3, e4) {
                        let n3 = this.bb.__offset(this.bb_pos, 14);
                        return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * t3, e4) : null;
                      }
                      stringDataLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 14);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      static startTensor(t3) {
                        t3.startObject(6);
                      }
                      static addName(t3, e4) {
                        t3.addFieldOffset(0, e4, 0);
                      }
                      static addDocString(t3, e4) {
                        t3.addFieldOffset(1, e4, 0);
                      }
                      static addDims(t3, e4) {
                        t3.addFieldOffset(2, e4, 0);
                      }
                      static createDimsVector(t3, e4) {
                        t3.startVector(8, e4.length, 8);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addInt64(e4[n3]);
                        return t3.endVector();
                      }
                      static startDimsVector(t3, e4) {
                        t3.startVector(8, e4, 8);
                      }
                      static addDataType(e4, n3) {
                        e4.addFieldInt32(3, n3, t2.experimental.fbs.TensorDataType.UNDEFINED);
                      }
                      static addRawData(t3, e4) {
                        t3.addFieldOffset(4, e4, 0);
                      }
                      static createRawDataVector(t3, e4) {
                        t3.startVector(1, e4.length, 1);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addInt8(e4[n3]);
                        return t3.endVector();
                      }
                      static startRawDataVector(t3, e4) {
                        t3.startVector(1, e4, 1);
                      }
                      static addStringData(t3, e4) {
                        t3.addFieldOffset(5, e4, 0);
                      }
                      static createStringDataVector(t3, e4) {
                        t3.startVector(4, e4.length, 4);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addOffset(e4[n3]);
                        return t3.endVector();
                      }
                      static startStringDataVector(t3, e4) {
                        t3.startVector(4, e4, 4);
                      }
                      static endTensor(t3) {
                        return t3.endObject();
                      }
                      static createTensor(t3, e4, r2, i2, o2, a, s) {
                        return n2.startTensor(t3), n2.addName(t3, e4), n2.addDocString(t3, r2), n2.addDims(t3, i2), n2.addDataType(t3, o2), n2.addRawData(t3, a), n2.addStringData(t3, s), n2.endTensor(t3);
                      }
                    }
                    e3.Tensor = n2;
                  }(e2.fbs || (e2.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(e2) {
                  !function(e3) {
                    class n2 {
                      constructor() {
                        this.bb = null, this.bb_pos = 0;
                      }
                      __init(t3, e4) {
                        return this.bb_pos = t3, this.bb = e4, this;
                      }
                      static getRootAsSparseTensor(t3, e4) {
                        return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      static getSizePrefixedRootAsSparseTensor(t3, e4) {
                        return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      values(e4) {
                        let n3 = this.bb.__offset(this.bb_pos, 4);
                        return n3 ? (e4 || new t2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                      }
                      indices(e4) {
                        let n3 = this.bb.__offset(this.bb_pos, 6);
                        return n3 ? (e4 || new t2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                      }
                      dims(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 8);
                        return e4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + e4) + 8 * t3) : this.bb.createLong(0, 0);
                      }
                      dimsLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 8);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      static startSparseTensor(t3) {
                        t3.startObject(3);
                      }
                      static addValues(t3, e4) {
                        t3.addFieldOffset(0, e4, 0);
                      }
                      static addIndices(t3, e4) {
                        t3.addFieldOffset(1, e4, 0);
                      }
                      static addDims(t3, e4) {
                        t3.addFieldOffset(2, e4, 0);
                      }
                      static createDimsVector(t3, e4) {
                        t3.startVector(8, e4.length, 8);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addInt64(e4[n3]);
                        return t3.endVector();
                      }
                      static startDimsVector(t3, e4) {
                        t3.startVector(8, e4, 8);
                      }
                      static endSparseTensor(t3) {
                        return t3.endObject();
                      }
                      static createSparseTensor(t3, e4, r2, i2) {
                        return n2.startSparseTensor(t3), n2.addValues(t3, e4), n2.addIndices(t3, r2), n2.addDims(t3, i2), n2.endSparseTensor(t3);
                      }
                    }
                    e3.SparseTensor = n2;
                  }(e2.fbs || (e2.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(e2) {
                  !function(e3) {
                    class n2 {
                      constructor() {
                        this.bb = null, this.bb_pos = 0;
                      }
                      __init(t3, e4) {
                        return this.bb_pos = t3, this.bb = e4, this;
                      }
                      static getRootAsAttribute(t3, e4) {
                        return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      static getSizePrefixedRootAsAttribute(t3, e4) {
                        return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      name(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 4);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      docString(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 6);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      type() {
                        let e4 = this.bb.__offset(this.bb_pos, 8);
                        return e4 ? this.bb.readInt32(this.bb_pos + e4) : t2.experimental.fbs.AttributeType.UNDEFINED;
                      }
                      f() {
                        let t3 = this.bb.__offset(this.bb_pos, 10);
                        return t3 ? this.bb.readFloat32(this.bb_pos + t3) : 0;
                      }
                      i() {
                        let t3 = this.bb.__offset(this.bb_pos, 12);
                        return t3 ? this.bb.readInt64(this.bb_pos + t3) : this.bb.createLong(0, 0);
                      }
                      s(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 14);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      t(e4) {
                        let n3 = this.bb.__offset(this.bb_pos, 16);
                        return n3 ? (e4 || new t2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                      }
                      g(e4) {
                        let n3 = this.bb.__offset(this.bb_pos, 18);
                        return n3 ? (e4 || new t2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                      }
                      floats(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 20);
                        return e4 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e4) + 4 * t3) : 0;
                      }
                      floatsLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 20);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      floatsArray() {
                        let t3 = this.bb.__offset(this.bb_pos, 20);
                        return t3 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t3), this.bb.__vector_len(this.bb_pos + t3)) : null;
                      }
                      ints(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 22);
                        return e4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + e4) + 8 * t3) : this.bb.createLong(0, 0);
                      }
                      intsLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 22);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      strings(t3, e4) {
                        let n3 = this.bb.__offset(this.bb_pos, 24);
                        return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * t3, e4) : null;
                      }
                      stringsLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 24);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      tensors(e4, n3) {
                        let r2 = this.bb.__offset(this.bb_pos, 26);
                        return r2 ? (n3 || new t2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                      }
                      tensorsLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 26);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      graphs(e4, n3) {
                        let r2 = this.bb.__offset(this.bb_pos, 28);
                        return r2 ? (n3 || new t2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                      }
                      graphsLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 28);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      static startAttribute(t3) {
                        t3.startObject(13);
                      }
                      static addName(t3, e4) {
                        t3.addFieldOffset(0, e4, 0);
                      }
                      static addDocString(t3, e4) {
                        t3.addFieldOffset(1, e4, 0);
                      }
                      static addType(e4, n3) {
                        e4.addFieldInt32(2, n3, t2.experimental.fbs.AttributeType.UNDEFINED);
                      }
                      static addF(t3, e4) {
                        t3.addFieldFloat32(3, e4, 0);
                      }
                      static addI(t3, e4) {
                        t3.addFieldInt64(4, e4, t3.createLong(0, 0));
                      }
                      static addS(t3, e4) {
                        t3.addFieldOffset(5, e4, 0);
                      }
                      static addT(t3, e4) {
                        t3.addFieldOffset(6, e4, 0);
                      }
                      static addG(t3, e4) {
                        t3.addFieldOffset(7, e4, 0);
                      }
                      static addFloats(t3, e4) {
                        t3.addFieldOffset(8, e4, 0);
                      }
                      static createFloatsVector(t3, e4) {
                        t3.startVector(4, e4.length, 4);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addFloat32(e4[n3]);
                        return t3.endVector();
                      }
                      static startFloatsVector(t3, e4) {
                        t3.startVector(4, e4, 4);
                      }
                      static addInts(t3, e4) {
                        t3.addFieldOffset(9, e4, 0);
                      }
                      static createIntsVector(t3, e4) {
                        t3.startVector(8, e4.length, 8);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addInt64(e4[n3]);
                        return t3.endVector();
                      }
                      static startIntsVector(t3, e4) {
                        t3.startVector(8, e4, 8);
                      }
                      static addStrings(t3, e4) {
                        t3.addFieldOffset(10, e4, 0);
                      }
                      static createStringsVector(t3, e4) {
                        t3.startVector(4, e4.length, 4);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addOffset(e4[n3]);
                        return t3.endVector();
                      }
                      static startStringsVector(t3, e4) {
                        t3.startVector(4, e4, 4);
                      }
                      static addTensors(t3, e4) {
                        t3.addFieldOffset(11, e4, 0);
                      }
                      static createTensorsVector(t3, e4) {
                        t3.startVector(4, e4.length, 4);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addOffset(e4[n3]);
                        return t3.endVector();
                      }
                      static startTensorsVector(t3, e4) {
                        t3.startVector(4, e4, 4);
                      }
                      static addGraphs(t3, e4) {
                        t3.addFieldOffset(12, e4, 0);
                      }
                      static createGraphsVector(t3, e4) {
                        t3.startVector(4, e4.length, 4);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addOffset(e4[n3]);
                        return t3.endVector();
                      }
                      static startGraphsVector(t3, e4) {
                        t3.startVector(4, e4, 4);
                      }
                      static endAttribute(t3) {
                        return t3.endObject();
                      }
                      static createAttribute(t3, e4, r2, i2, o2, a, s, u, c, l, p, f, d, h) {
                        return n2.startAttribute(t3), n2.addName(t3, e4), n2.addDocString(t3, r2), n2.addType(t3, i2), n2.addF(t3, o2), n2.addI(t3, a), n2.addS(t3, s), n2.addT(t3, u), n2.addG(t3, c), n2.addFloats(t3, l), n2.addInts(t3, p), n2.addStrings(t3, f), n2.addTensors(t3, d), n2.addGraphs(t3, h), n2.endAttribute(t3);
                      }
                    }
                    e3.Attribute = n2;
                  }(e2.fbs || (e2.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(e2) {
                  !function(e3) {
                    class n2 {
                      constructor() {
                        this.bb = null, this.bb_pos = 0;
                      }
                      __init(t3, e4) {
                        return this.bb_pos = t3, this.bb = e4, this;
                      }
                      static getRootAsGraph(t3, e4) {
                        return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      static getSizePrefixedRootAsGraph(t3, e4) {
                        return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      initializers(e4, n3) {
                        let r2 = this.bb.__offset(this.bb_pos, 4);
                        return r2 ? (n3 || new t2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                      }
                      initializersLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 4);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      nodeArgs(e4, n3) {
                        let r2 = this.bb.__offset(this.bb_pos, 6);
                        return r2 ? (n3 || new t2.experimental.fbs.ValueInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                      }
                      nodeArgsLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 6);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      nodes(e4, n3) {
                        let r2 = this.bb.__offset(this.bb_pos, 8);
                        return r2 ? (n3 || new t2.experimental.fbs.Node()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                      }
                      nodesLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 8);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      maxNodeIndex() {
                        let t3 = this.bb.__offset(this.bb_pos, 10);
                        return t3 ? this.bb.readUint32(this.bb_pos + t3) : 0;
                      }
                      nodeEdges(e4, n3) {
                        let r2 = this.bb.__offset(this.bb_pos, 12);
                        return r2 ? (n3 || new t2.experimental.fbs.NodeEdge()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                      }
                      nodeEdgesLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 12);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      inputs(t3, e4) {
                        let n3 = this.bb.__offset(this.bb_pos, 14);
                        return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * t3, e4) : null;
                      }
                      inputsLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 14);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      outputs(t3, e4) {
                        let n3 = this.bb.__offset(this.bb_pos, 16);
                        return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * t3, e4) : null;
                      }
                      outputsLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 16);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      sparseInitializers(e4, n3) {
                        let r2 = this.bb.__offset(this.bb_pos, 18);
                        return r2 ? (n3 || new t2.experimental.fbs.SparseTensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                      }
                      sparseInitializersLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 18);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      static startGraph(t3) {
                        t3.startObject(8);
                      }
                      static addInitializers(t3, e4) {
                        t3.addFieldOffset(0, e4, 0);
                      }
                      static createInitializersVector(t3, e4) {
                        t3.startVector(4, e4.length, 4);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addOffset(e4[n3]);
                        return t3.endVector();
                      }
                      static startInitializersVector(t3, e4) {
                        t3.startVector(4, e4, 4);
                      }
                      static addNodeArgs(t3, e4) {
                        t3.addFieldOffset(1, e4, 0);
                      }
                      static createNodeArgsVector(t3, e4) {
                        t3.startVector(4, e4.length, 4);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addOffset(e4[n3]);
                        return t3.endVector();
                      }
                      static startNodeArgsVector(t3, e4) {
                        t3.startVector(4, e4, 4);
                      }
                      static addNodes(t3, e4) {
                        t3.addFieldOffset(2, e4, 0);
                      }
                      static createNodesVector(t3, e4) {
                        t3.startVector(4, e4.length, 4);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addOffset(e4[n3]);
                        return t3.endVector();
                      }
                      static startNodesVector(t3, e4) {
                        t3.startVector(4, e4, 4);
                      }
                      static addMaxNodeIndex(t3, e4) {
                        t3.addFieldInt32(3, e4, 0);
                      }
                      static addNodeEdges(t3, e4) {
                        t3.addFieldOffset(4, e4, 0);
                      }
                      static createNodeEdgesVector(t3, e4) {
                        t3.startVector(4, e4.length, 4);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addOffset(e4[n3]);
                        return t3.endVector();
                      }
                      static startNodeEdgesVector(t3, e4) {
                        t3.startVector(4, e4, 4);
                      }
                      static addInputs(t3, e4) {
                        t3.addFieldOffset(5, e4, 0);
                      }
                      static createInputsVector(t3, e4) {
                        t3.startVector(4, e4.length, 4);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addOffset(e4[n3]);
                        return t3.endVector();
                      }
                      static startInputsVector(t3, e4) {
                        t3.startVector(4, e4, 4);
                      }
                      static addOutputs(t3, e4) {
                        t3.addFieldOffset(6, e4, 0);
                      }
                      static createOutputsVector(t3, e4) {
                        t3.startVector(4, e4.length, 4);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addOffset(e4[n3]);
                        return t3.endVector();
                      }
                      static startOutputsVector(t3, e4) {
                        t3.startVector(4, e4, 4);
                      }
                      static addSparseInitializers(t3, e4) {
                        t3.addFieldOffset(7, e4, 0);
                      }
                      static createSparseInitializersVector(t3, e4) {
                        t3.startVector(4, e4.length, 4);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addOffset(e4[n3]);
                        return t3.endVector();
                      }
                      static startSparseInitializersVector(t3, e4) {
                        t3.startVector(4, e4, 4);
                      }
                      static endGraph(t3) {
                        return t3.endObject();
                      }
                      static createGraph(t3, e4, r2, i2, o2, a, s, u, c) {
                        return n2.startGraph(t3), n2.addInitializers(t3, e4), n2.addNodeArgs(t3, r2), n2.addNodes(t3, i2), n2.addMaxNodeIndex(t3, o2), n2.addNodeEdges(t3, a), n2.addInputs(t3, s), n2.addOutputs(t3, u), n2.addSparseInitializers(t3, c), n2.endGraph(t3);
                      }
                    }
                    e3.Graph = n2;
                  }(e2.fbs || (e2.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(e2) {
                  !function(e3) {
                    class n2 {
                      constructor() {
                        this.bb = null, this.bb_pos = 0;
                      }
                      __init(t3, e4) {
                        return this.bb_pos = t3, this.bb = e4, this;
                      }
                      static getRootAsModel(t3, e4) {
                        return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      static getSizePrefixedRootAsModel(t3, e4) {
                        return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      irVersion() {
                        let t3 = this.bb.__offset(this.bb_pos, 4);
                        return t3 ? this.bb.readInt64(this.bb_pos + t3) : this.bb.createLong(0, 0);
                      }
                      opsetImport(e4, n3) {
                        let r2 = this.bb.__offset(this.bb_pos, 6);
                        return r2 ? (n3 || new t2.experimental.fbs.OperatorSetId()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                      }
                      opsetImportLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 6);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      producerName(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 8);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      producerVersion(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 10);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      domain(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 12);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      modelVersion() {
                        let t3 = this.bb.__offset(this.bb_pos, 14);
                        return t3 ? this.bb.readInt64(this.bb_pos + t3) : this.bb.createLong(0, 0);
                      }
                      docString(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 16);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      graph(e4) {
                        let n3 = this.bb.__offset(this.bb_pos, 18);
                        return n3 ? (e4 || new t2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                      }
                      graphDocString(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 20);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      static startModel(t3) {
                        t3.startObject(9);
                      }
                      static addIrVersion(t3, e4) {
                        t3.addFieldInt64(0, e4, t3.createLong(0, 0));
                      }
                      static addOpsetImport(t3, e4) {
                        t3.addFieldOffset(1, e4, 0);
                      }
                      static createOpsetImportVector(t3, e4) {
                        t3.startVector(4, e4.length, 4);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addOffset(e4[n3]);
                        return t3.endVector();
                      }
                      static startOpsetImportVector(t3, e4) {
                        t3.startVector(4, e4, 4);
                      }
                      static addProducerName(t3, e4) {
                        t3.addFieldOffset(2, e4, 0);
                      }
                      static addProducerVersion(t3, e4) {
                        t3.addFieldOffset(3, e4, 0);
                      }
                      static addDomain(t3, e4) {
                        t3.addFieldOffset(4, e4, 0);
                      }
                      static addModelVersion(t3, e4) {
                        t3.addFieldInt64(5, e4, t3.createLong(0, 0));
                      }
                      static addDocString(t3, e4) {
                        t3.addFieldOffset(6, e4, 0);
                      }
                      static addGraph(t3, e4) {
                        t3.addFieldOffset(7, e4, 0);
                      }
                      static addGraphDocString(t3, e4) {
                        t3.addFieldOffset(8, e4, 0);
                      }
                      static endModel(t3) {
                        return t3.endObject();
                      }
                      static createModel(t3, e4, r2, i2, o2, a, s, u, c, l) {
                        return n2.startModel(t3), n2.addIrVersion(t3, e4), n2.addOpsetImport(t3, r2), n2.addProducerName(t3, i2), n2.addProducerVersion(t3, o2), n2.addDomain(t3, a), n2.addModelVersion(t3, s), n2.addDocString(t3, u), n2.addGraph(t3, c), n2.addGraphDocString(t3, l), n2.endModel(t3);
                      }
                    }
                    e3.Model = n2;
                  }(e2.fbs || (e2.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(t3) {
                  !function(t4) {
                    class e2 {
                      constructor() {
                        this.bb = null, this.bb_pos = 0;
                      }
                      __init(t5, e3) {
                        return this.bb_pos = t5, this.bb = e3, this;
                      }
                      static getRootAsKernelCreateInfos(t5, n2) {
                        return (n2 || new e2()).__init(t5.readInt32(t5.position()) + t5.position(), t5);
                      }
                      static getSizePrefixedRootAsKernelCreateInfos(t5, n2) {
                        return t5.setPosition(t5.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (n2 || new e2()).__init(t5.readInt32(t5.position()) + t5.position(), t5);
                      }
                      nodeIndices(t5) {
                        let e3 = this.bb.__offset(this.bb_pos, 4);
                        return e3 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e3) + 4 * t5) : 0;
                      }
                      nodeIndicesLength() {
                        let t5 = this.bb.__offset(this.bb_pos, 4);
                        return t5 ? this.bb.__vector_len(this.bb_pos + t5) : 0;
                      }
                      nodeIndicesArray() {
                        let t5 = this.bb.__offset(this.bb_pos, 4);
                        return t5 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t5), this.bb.__vector_len(this.bb_pos + t5)) : null;
                      }
                      kernelDefHashes(t5) {
                        let e3 = this.bb.__offset(this.bb_pos, 6);
                        return e3 ? this.bb.readUint64(this.bb.__vector(this.bb_pos + e3) + 8 * t5) : this.bb.createLong(0, 0);
                      }
                      kernelDefHashesLength() {
                        let t5 = this.bb.__offset(this.bb_pos, 6);
                        return t5 ? this.bb.__vector_len(this.bb_pos + t5) : 0;
                      }
                      static startKernelCreateInfos(t5) {
                        t5.startObject(2);
                      }
                      static addNodeIndices(t5, e3) {
                        t5.addFieldOffset(0, e3, 0);
                      }
                      static createNodeIndicesVector(t5, e3) {
                        t5.startVector(4, e3.length, 4);
                        for (let n2 = e3.length - 1; n2 >= 0; n2--)
                          t5.addInt32(e3[n2]);
                        return t5.endVector();
                      }
                      static startNodeIndicesVector(t5, e3) {
                        t5.startVector(4, e3, 4);
                      }
                      static addKernelDefHashes(t5, e3) {
                        t5.addFieldOffset(1, e3, 0);
                      }
                      static createKernelDefHashesVector(t5, e3) {
                        t5.startVector(8, e3.length, 8);
                        for (let n2 = e3.length - 1; n2 >= 0; n2--)
                          t5.addInt64(e3[n2]);
                        return t5.endVector();
                      }
                      static startKernelDefHashesVector(t5, e3) {
                        t5.startVector(8, e3, 8);
                      }
                      static endKernelCreateInfos(t5) {
                        return t5.endObject();
                      }
                      static createKernelCreateInfos(t5, n2, r2) {
                        return e2.startKernelCreateInfos(t5), e2.addNodeIndices(t5, n2), e2.addKernelDefHashes(t5, r2), e2.endKernelCreateInfos(t5);
                      }
                    }
                    t4.KernelCreateInfos = e2;
                  }(t3.fbs || (t3.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(e2) {
                  !function(e3) {
                    class n2 {
                      constructor() {
                        this.bb = null, this.bb_pos = 0;
                      }
                      __init(t3, e4) {
                        return this.bb_pos = t3, this.bb = e4, this;
                      }
                      static getRootAsSubGraphSessionState(t3, e4) {
                        return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      static getSizePrefixedRootAsSubGraphSessionState(t3, e4) {
                        return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      graphId(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 4);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      sessionState(e4) {
                        let n3 = this.bb.__offset(this.bb_pos, 6);
                        return n3 ? (e4 || new t2.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                      }
                      static startSubGraphSessionState(t3) {
                        t3.startObject(2);
                      }
                      static addGraphId(t3, e4) {
                        t3.addFieldOffset(0, e4, 0);
                      }
                      static addSessionState(t3, e4) {
                        t3.addFieldOffset(1, e4, 0);
                      }
                      static endSubGraphSessionState(t3) {
                        let e4 = t3.endObject();
                        return t3.requiredField(e4, 4), e4;
                      }
                      static createSubGraphSessionState(t3, e4, r2) {
                        return n2.startSubGraphSessionState(t3), n2.addGraphId(t3, e4), n2.addSessionState(t3, r2), n2.endSubGraphSessionState(t3);
                      }
                    }
                    e3.SubGraphSessionState = n2;
                  }(e2.fbs || (e2.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(e2) {
                  !function(e3) {
                    class n2 {
                      constructor() {
                        this.bb = null, this.bb_pos = 0;
                      }
                      __init(t3, e4) {
                        return this.bb_pos = t3, this.bb = e4, this;
                      }
                      static getRootAsSessionState(t3, e4) {
                        return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      static getSizePrefixedRootAsSessionState(t3, e4) {
                        return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      kernels(e4) {
                        let n3 = this.bb.__offset(this.bb_pos, 4);
                        return n3 ? (e4 || new t2.experimental.fbs.KernelCreateInfos()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                      }
                      subGraphSessionStates(e4, n3) {
                        let r2 = this.bb.__offset(this.bb_pos, 6);
                        return r2 ? (n3 || new t2.experimental.fbs.SubGraphSessionState()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                      }
                      subGraphSessionStatesLength() {
                        let t3 = this.bb.__offset(this.bb_pos, 6);
                        return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                      }
                      static startSessionState(t3) {
                        t3.startObject(2);
                      }
                      static addKernels(t3, e4) {
                        t3.addFieldOffset(0, e4, 0);
                      }
                      static addSubGraphSessionStates(t3, e4) {
                        t3.addFieldOffset(1, e4, 0);
                      }
                      static createSubGraphSessionStatesVector(t3, e4) {
                        t3.startVector(4, e4.length, 4);
                        for (let n3 = e4.length - 1; n3 >= 0; n3--)
                          t3.addOffset(e4[n3]);
                        return t3.endVector();
                      }
                      static startSubGraphSessionStatesVector(t3, e4) {
                        t3.startVector(4, e4, 4);
                      }
                      static endSessionState(t3) {
                        return t3.endObject();
                      }
                      static createSessionState(t3, e4, r2) {
                        return n2.startSessionState(t3), n2.addKernels(t3, e4), n2.addSubGraphSessionStates(t3, r2), n2.endSessionState(t3);
                      }
                    }
                    e3.SessionState = n2;
                  }(e2.fbs || (e2.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
                !function(e2) {
                  !function(e3) {
                    class n2 {
                      constructor() {
                        this.bb = null, this.bb_pos = 0;
                      }
                      __init(t3, e4) {
                        return this.bb_pos = t3, this.bb = e4, this;
                      }
                      static getRootAsInferenceSession(t3, e4) {
                        return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      static getSizePrefixedRootAsInferenceSession(t3, e4) {
                        return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                      }
                      static bufferHasIdentifier(t3) {
                        return t3.__has_identifier("ORTM");
                      }
                      ortVersion(t3) {
                        let e4 = this.bb.__offset(this.bb_pos, 4);
                        return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                      }
                      model(e4) {
                        let n3 = this.bb.__offset(this.bb_pos, 6);
                        return n3 ? (e4 || new t2.experimental.fbs.Model()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                      }
                      sessionState(e4) {
                        let n3 = this.bb.__offset(this.bb_pos, 8);
                        return n3 ? (e4 || new t2.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                      }
                      static startInferenceSession(t3) {
                        t3.startObject(3);
                      }
                      static addOrtVersion(t3, e4) {
                        t3.addFieldOffset(0, e4, 0);
                      }
                      static addModel(t3, e4) {
                        t3.addFieldOffset(1, e4, 0);
                      }
                      static addSessionState(t3, e4) {
                        t3.addFieldOffset(2, e4, 0);
                      }
                      static endInferenceSession(t3) {
                        return t3.endObject();
                      }
                      static finishInferenceSessionBuffer(t3, e4) {
                        t3.finish(e4, "ORTM");
                      }
                      static finishSizePrefixedInferenceSessionBuffer(t3, e4) {
                        t3.finish(e4, "ORTM", true);
                      }
                      static createInferenceSession(t3, e4, r2, i2) {
                        return n2.startInferenceSession(t3), n2.addOrtVersion(t3, e4), n2.addModel(t3, r2), n2.addSessionState(t3, i2), n2.endInferenceSession(t3);
                      }
                    }
                    e3.InferenceSession = n2;
                  }(e2.fbs || (e2.fbs = {}));
                }(t2.experimental || (t2.experimental = {}));
              }(e.onnxruntime || (e.onnxruntime = {}));
            }, 7448: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.OnnxjsSessionHandler = void 0;
              const r = n(1670), i = n(9162);
              e.OnnxjsSessionHandler = class {
                constructor(t2) {
                  this.session = t2, this.inputNames = this.session.inputNames, this.outputNames = this.session.outputNames;
                }
                async dispose() {
                }
                async run(t2, e2, n2) {
                  const o = /* @__PURE__ */ new Map();
                  for (const e3 in t2)
                    if (Object.hasOwnProperty.call(t2, e3)) {
                      const n3 = t2[e3];
                      o.set(e3, new i.Tensor(n3.dims, n3.type, void 0, void 0, n3.data));
                    }
                  const a = await this.session.run(o), s = {};
                  return a.forEach((t3, e3) => {
                    s[e3] = new r.Tensor(t3.type, t3.data, t3.dims);
                  }), s;
                }
                startProfiling() {
                  this.session.startProfiling();
                }
                endProfiling() {
                  this.session.endProfiling();
                }
              };
            }, 6919: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.Session = void 0;
              const r = n(7067), i = n(1296), o = n(7091), a = n(1036), s = n(6231), u = n(2644);
              e.Session = class {
                constructor(t2 = {}) {
                  this._initialized = false, this.backendHint = t2.backendHint, this.profiler = s.Profiler.create(t2.profiler), this.context = { profiler: this.profiler, graphInputTypes: [], graphInputDims: [] };
                }
                get inputNames() {
                  return this._model.graph.getInputNames();
                }
                get outputNames() {
                  return this._model.graph.getOutputNames();
                }
                startProfiling() {
                  this.profiler.start();
                }
                endProfiling() {
                  this.profiler.stop();
                }
                async loadModel(t2, e2, n2) {
                  await this.profiler.event("session", "Session.loadModel", async () => {
                    const a2 = await (0, o.resolveBackend)(this.backendHint);
                    if (this.sessionHandler = a2.createSessionHandler(this.context), this._model = new u.Model(), "string" == typeof t2) {
                      const e3 = t2.endsWith(".ort");
                      if ("undefined" == typeof fetch) {
                        const n3 = await (0, i.promisify)(r.readFile)(t2);
                        this.initialize(n3, e3);
                      } else {
                        const n3 = await fetch(t2), r2 = await n3.arrayBuffer();
                        this.initialize(new Uint8Array(r2), e3);
                      }
                    } else if (ArrayBuffer.isView(t2))
                      this.initialize(t2);
                    else {
                      const r2 = new Uint8Array(t2, e2 || 0, n2 || t2.byteLength);
                      this.initialize(r2);
                    }
                  });
                }
                initialize(t2, e2) {
                  if (this._initialized)
                    throw new Error("already initialized");
                  this.profiler.event("session", "Session.initialize", () => {
                    const n2 = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;
                    this._model.load(t2, n2, e2), this.sessionHandler.onGraphInitialized && this.sessionHandler.onGraphInitialized(this._model.graph), this.initializeOps(this._model.graph), this._executionPlan = new a.ExecutionPlan(this._model.graph, this._ops, this.profiler);
                  }), this._initialized = true;
                }
                async run(t2) {
                  if (!this._initialized)
                    throw new Error("session not initialized yet");
                  return this.profiler.event("session", "Session.run", async () => {
                    const e2 = this.normalizeAndValidateInputs(t2), n2 = await this._executionPlan.execute(this.sessionHandler, e2);
                    return this.createOutput(n2);
                  });
                }
                normalizeAndValidateInputs(t2) {
                  const e2 = this._model.graph.getInputNames();
                  if (Array.isArray(t2)) {
                    if (t2.length !== e2.length)
                      throw new Error(`incorrect input array length: expected ${e2.length} but got ${t2.length}`);
                  } else {
                    if (t2.size !== e2.length)
                      throw new Error(`incorrect input map size: expected ${e2.length} but got ${t2.size}`);
                    const n2 = new Array(t2.size);
                    let r2 = 0;
                    for (let i2 = 0; i2 < e2.length; ++i2) {
                      const o2 = t2.get(e2[i2]);
                      if (!o2)
                        throw new Error(`missing input tensor for: '${name}'`);
                      n2[r2++] = o2;
                    }
                    t2 = n2;
                  }
                  if (this.context.graphInputTypes && 0 !== this.context.graphInputTypes.length && this.context.graphInputDims && 0 !== this.context.graphInputDims.length)
                    this.validateInputTensorDims(this.context.graphInputDims, t2, false);
                  else {
                    const e3 = this._model.graph.getInputIndices(), n2 = this._model.graph.getValues(), r2 = new Array(e3.length);
                    for (let i2 = 0; i2 < e3.length; ++i2) {
                      const o2 = n2[e3[i2]];
                      r2[i2] = o2.type.shape.dims, this.context.graphInputTypes.push(o2.type.tensorType), this.context.graphInputDims.push(t2[i2].dims);
                    }
                    this.validateInputTensorDims(r2, t2, true);
                  }
                  return this.validateInputTensorTypes(this.context.graphInputTypes, t2), t2;
                }
                validateInputTensorTypes(t2, e2) {
                  for (let n2 = 0; n2 < e2.length; n2++) {
                    const r2 = t2[n2], i2 = e2[n2].type;
                    if (r2 !== i2)
                      throw new Error(`input tensor[${n2}] check failed: expected type '${r2}' but got ${i2}`);
                  }
                }
                validateInputTensorDims(t2, e2, n2) {
                  for (let r2 = 0; r2 < e2.length; r2++) {
                    const i2 = t2[r2], o2 = e2[r2].dims;
                    if (!this.compareTensorDims(i2, o2, n2))
                      throw new Error(`input tensor[${r2}] check failed: expected shape '[${i2.join(",")}]' but got [${o2.join(",")}]`);
                  }
                }
                compareTensorDims(t2, e2, n2) {
                  if (t2.length !== e2.length)
                    return false;
                  for (let r2 = 0; r2 < t2.length; ++r2)
                    if (t2[r2] !== e2[r2] && (!n2 || 0 !== t2[r2]))
                      return false;
                  return true;
                }
                createOutput(t2) {
                  const e2 = this._model.graph.getOutputNames();
                  if (t2.length !== e2.length)
                    throw new Error("expected number of outputs do not match number of generated outputs");
                  const n2 = /* @__PURE__ */ new Map();
                  for (let r2 = 0; r2 < e2.length; ++r2)
                    n2.set(e2[r2], t2[r2]);
                  return n2;
                }
                initializeOps(t2) {
                  const e2 = t2.getNodes();
                  this._ops = new Array(e2.length);
                  for (let n2 = 0; n2 < e2.length; n2++)
                    this._ops[n2] = this.sessionHandler.resolve(e2[n2], this._model.opsets, t2);
                }
              };
            }, 9162: function(t, e, n) {
              "use strict";
              var r = this && this.__importDefault || function(t2) {
                return t2 && t2.__esModule ? t2 : { default: t2 };
              };
              Object.defineProperty(e, "__esModule", { value: true }), e.Tensor = void 0;
              const i = n(3442), o = r(n(3720)), a = n(1446), s = n(9395), u = n(2517);
              var c = s.onnxruntime.experimental.fbs;
              class l {
                get data() {
                  if (void 0 === this.cache) {
                    const t2 = this.dataProvider(this.dataId);
                    if (t2.length !== this.size)
                      throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");
                    this.cache = t2;
                  }
                  return this.cache;
                }
                get stringData() {
                  if ("string" !== this.type)
                    throw new TypeError("data type is not string");
                  return this.data;
                }
                get integerData() {
                  switch (this.type) {
                    case "uint8":
                    case "int8":
                    case "uint16":
                    case "int16":
                    case "int32":
                    case "uint32":
                    case "bool":
                      return this.data;
                    default:
                      throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)");
                  }
                }
                get floatData() {
                  switch (this.type) {
                    case "float32":
                    case "float64":
                      return this.data;
                    default:
                      throw new TypeError("data type is not float (float32, float64)");
                  }
                }
                get numberData() {
                  if ("string" !== this.type)
                    return this.data;
                  throw new TypeError("type cannot be non-number (string)");
                }
                get(t2) {
                  return this.data[u.ShapeUtil.indicesToOffset(t2, this.strides)];
                }
                set(t2, e2) {
                  this.data[u.ShapeUtil.indicesToOffset(t2, this.strides)] = e2;
                }
                async getData() {
                  return void 0 === this.cache && (this.cache = await this.asyncDataProvider(this.dataId)), this.cache;
                }
                get strides() {
                  return this._strides || (this._strides = u.ShapeUtil.computeStrides(this.dims)), this._strides;
                }
                constructor(t2, e2, n2, r2, o2, a2 = i.Guid.create()) {
                  this.dims = t2, this.type = e2, this.dataProvider = n2, this.asyncDataProvider = r2, this.cache = o2, this.dataId = a2, this.size = u.ShapeUtil.validateDimsAndCalcSize(t2);
                  const s2 = this.size, c2 = void 0 === n2 && void 0 === r2 && void 0 === o2;
                  if (void 0 !== o2 && o2.length !== s2)
                    throw new RangeError("Input dims doesn't match data length.");
                  if ("string" === e2) {
                    if (!(void 0 === o2 || Array.isArray(o2) && o2.every((t3) => "string" == typeof t3)))
                      throw new TypeError("cache should be a string array");
                    c2 && (this.cache = new Array(s2));
                  } else {
                    if (void 0 !== o2) {
                      const t3 = f(e2);
                      if (!(o2 instanceof t3))
                        throw new TypeError(`cache should be type ${t3.name}`);
                    }
                    if (c2) {
                      const t3 = new ArrayBuffer(s2 * function(t4) {
                        switch (t4) {
                          case "bool":
                          case "int8":
                          case "uint8":
                            return 1;
                          case "int16":
                          case "uint16":
                            return 2;
                          case "int32":
                          case "uint32":
                          case "float32":
                            return 4;
                          case "float64":
                            return 8;
                          default:
                            throw new Error(`cannot calculate sizeof() on type ${t4}`);
                        }
                      }(e2));
                      this.cache = function(t4, e3) {
                        return new (f(e3))(t4);
                      }(t3, e2);
                    }
                  }
                }
                static fromProto(t2) {
                  if (!t2)
                    throw new Error("cannot construct Value from an empty tensor");
                  const e2 = u.ProtoUtil.tensorDataTypeFromProto(t2.dataType), n2 = u.ProtoUtil.tensorDimsFromProto(t2.dims), r2 = new l(n2, e2);
                  if ("string" === e2)
                    t2.stringData.forEach((t3, e3) => {
                      r2.data[e3] = (0, u.decodeUtf8String)(t3);
                    });
                  else if (t2.rawData && "number" == typeof t2.rawData.byteLength && t2.rawData.byteLength > 0) {
                    const e3 = r2.data, n3 = new DataView(t2.rawData.buffer, t2.rawData.byteOffset, t2.rawData.byteLength), i2 = p(t2.dataType), o2 = t2.rawData.byteLength / i2;
                    if (t2.rawData.byteLength % i2 != 0)
                      throw new Error("invalid buffer length");
                    if (e3.length !== o2)
                      throw new Error("buffer length mismatch");
                    for (let r3 = 0; r3 < o2; r3++) {
                      const o3 = h(n3, t2.dataType, r3 * i2);
                      e3[r3] = o3;
                    }
                  } else {
                    let e3;
                    switch (t2.dataType) {
                      case a.onnx.TensorProto.DataType.FLOAT:
                        e3 = t2.floatData;
                        break;
                      case a.onnx.TensorProto.DataType.INT32:
                      case a.onnx.TensorProto.DataType.INT16:
                      case a.onnx.TensorProto.DataType.UINT16:
                      case a.onnx.TensorProto.DataType.INT8:
                      case a.onnx.TensorProto.DataType.UINT8:
                      case a.onnx.TensorProto.DataType.BOOL:
                        e3 = t2.int32Data;
                        break;
                      case a.onnx.TensorProto.DataType.INT64:
                        e3 = t2.int64Data;
                        break;
                      case a.onnx.TensorProto.DataType.DOUBLE:
                        e3 = t2.doubleData;
                        break;
                      case a.onnx.TensorProto.DataType.UINT32:
                      case a.onnx.TensorProto.DataType.UINT64:
                        e3 = t2.uint64Data;
                        break;
                      default:
                        throw new Error("unspecific error");
                    }
                    if (null == e3)
                      throw new Error("failed to populate data from a tensorproto value");
                    const n3 = r2.data;
                    if (n3.length !== e3.length)
                      throw new Error("array length mismatch");
                    for (let r3 = 0; r3 < e3.length; r3++) {
                      const i2 = e3[r3];
                      o.default.isLong(i2) ? n3[r3] = d(i2, t2.dataType) : n3[r3] = i2;
                    }
                  }
                  return r2;
                }
                static fromData(t2, e2, n2) {
                  return new l(e2, n2, void 0, void 0, t2);
                }
                static fromOrtTensor(t2) {
                  if (!t2)
                    throw new Error("cannot construct Value from an empty tensor");
                  const e2 = u.ProtoUtil.tensorDimsFromORTFormat(t2), n2 = u.ProtoUtil.tensorDataTypeFromProto(t2.dataType()), r2 = new l(e2, n2);
                  if ("string" === n2)
                    for (let e3 = 0; e3 < t2.stringDataLength(); e3++)
                      r2.data[e3] = t2.stringData(e3);
                  else if (t2.rawDataArray() && "number" == typeof t2.rawDataLength() && t2.rawDataLength() > 0) {
                    const e3 = r2.data, n3 = new DataView(t2.rawDataArray().buffer, t2.rawDataArray().byteOffset, t2.rawDataLength()), i2 = p(t2.dataType()), o2 = t2.rawDataLength() / i2;
                    if (t2.rawDataLength() % i2 != 0)
                      throw new Error("invalid buffer length");
                    if (e3.length !== o2)
                      throw new Error("buffer length mismatch");
                    for (let r3 = 0; r3 < o2; r3++) {
                      const o3 = h(n3, t2.dataType(), r3 * i2);
                      e3[r3] = o3;
                    }
                  }
                  return r2;
                }
              }
              function p(t2) {
                switch (t2) {
                  case a.onnx.TensorProto.DataType.UINT8:
                  case a.onnx.TensorProto.DataType.INT8:
                  case a.onnx.TensorProto.DataType.BOOL:
                    return 1;
                  case a.onnx.TensorProto.DataType.UINT16:
                  case a.onnx.TensorProto.DataType.INT16:
                    return 2;
                  case a.onnx.TensorProto.DataType.FLOAT:
                  case a.onnx.TensorProto.DataType.INT32:
                  case a.onnx.TensorProto.DataType.UINT32:
                    return 4;
                  case a.onnx.TensorProto.DataType.INT64:
                  case a.onnx.TensorProto.DataType.DOUBLE:
                  case a.onnx.TensorProto.DataType.UINT64:
                    return 8;
                  default:
                    throw new Error(`cannot calculate sizeof() on type ${a.onnx.TensorProto.DataType[t2]}`);
                }
              }
              function f(t2) {
                switch (t2) {
                  case "bool":
                  case "uint8":
                    return Uint8Array;
                  case "int8":
                    return Int8Array;
                  case "int16":
                    return Int16Array;
                  case "uint16":
                    return Uint16Array;
                  case "int32":
                    return Int32Array;
                  case "uint32":
                    return Uint32Array;
                  case "float32":
                    return Float32Array;
                  case "float64":
                    return Float64Array;
                  default:
                    throw new Error("unspecified error");
                }
              }
              function d(t2, e2) {
                if (e2 === a.onnx.TensorProto.DataType.INT64 || e2 === c.TensorDataType.INT64) {
                  if (t2.greaterThanOrEqual(2147483648) || t2.lessThan(-2147483648))
                    throw new TypeError("int64 is not supported");
                } else {
                  if (e2 !== a.onnx.TensorProto.DataType.UINT32 && e2 !== c.TensorDataType.UINT32 && e2 !== a.onnx.TensorProto.DataType.UINT64 && e2 !== c.TensorDataType.UINT64)
                    throw new TypeError(`not a LONG type: ${a.onnx.TensorProto.DataType[e2]}`);
                  if (t2.greaterThanOrEqual(4294967296) || t2.lessThan(0))
                    throw new TypeError("uint64 is not supported");
                }
                return t2.toNumber();
              }
              function h(t2, e2, n2) {
                switch (e2) {
                  case a.onnx.TensorProto.DataType.BOOL:
                  case a.onnx.TensorProto.DataType.UINT8:
                    return t2.getUint8(n2);
                  case a.onnx.TensorProto.DataType.INT8:
                    return t2.getInt8(n2);
                  case a.onnx.TensorProto.DataType.UINT16:
                    return t2.getUint16(n2, true);
                  case a.onnx.TensorProto.DataType.INT16:
                    return t2.getInt16(n2, true);
                  case a.onnx.TensorProto.DataType.FLOAT:
                    return t2.getFloat32(n2, true);
                  case a.onnx.TensorProto.DataType.INT32:
                    return t2.getInt32(n2, true);
                  case a.onnx.TensorProto.DataType.UINT32:
                    return t2.getUint32(n2, true);
                  case a.onnx.TensorProto.DataType.INT64:
                    return d(o.default.fromBits(t2.getUint32(n2, true), t2.getUint32(n2 + 4, true), false), e2);
                  case a.onnx.TensorProto.DataType.DOUBLE:
                    return t2.getFloat64(n2, true);
                  case a.onnx.TensorProto.DataType.UINT64:
                    return d(o.default.fromBits(t2.getUint32(n2, true), t2.getUint32(n2 + 4, true), true), e2);
                  default:
                    throw new Error(`cannot read from DataView for type ${a.onnx.TensorProto.DataType[e2]}`);
                }
              }
              e.Tensor = l;
            }, 2517: function(t, e, n) {
              "use strict";
              var r = this && this.__importDefault || function(t2) {
                return t2 && t2.__esModule ? t2 : { default: t2 };
              };
              Object.defineProperty(e, "__esModule", { value: true }), e.decodeUtf8String = e.MAX_CLIP = e.MIN_CLIP = e.PoolConvUtil = e.ReduceUtil = e.SplitUtil = e.MathUtil = e.ShapeUtil = e.LongUtil = e.ProtoUtil = e.GemmUtil = e.arrayCopyHelper = e.BroadcastUtil = e.MatMulUtil = e.ArrayUtil = e.assert = e.checkInputsShape = void 0;
              const i = n(5686), o = r(n(3720)), a = n(1446), s = n(9162);
              e.checkInputsShape = function(t2, ...e2) {
                if (!t2 || t2.length !== e2.length)
                  return false;
                for (let n2 = 0; n2 < t2.length; n2++)
                  if (!t2[n2].dims || t2[n2].dims.length !== e2[n2])
                    return false;
                return true;
              }, e.assert = function(t2, e2) {
                if (!t2)
                  throw new Error("string" == typeof e2 ? e2 : e2());
              }, e.ArrayUtil = class {
                static arraysEqual(t2, e2) {
                  if (t2.length !== e2.length)
                    return false;
                  for (let n2 = 0; n2 < t2.length; n2++)
                    if (t2[n2] !== e2[n2])
                      return false;
                  return true;
                }
              };
              class u {
                static preprocessInputShapes(t2, e2) {
                  return [1 === t2.length ? [1, t2[0]] : t2, 1 === e2.length ? [e2[0], 1] : e2];
                }
                static postprocessOutputShape(t2, e2, n2) {
                  1 === e2 && t2.splice(t2.length - 2, 1), 1 === n2 && t2.pop();
                }
                static calcMatMulShape(t2, e2) {
                  return t2[1] !== e2[0] ? void 0 : [t2[0], e2[1]];
                }
              }
              e.MatMulUtil = u;
              class c {
                static calcShape(t2, e2, n2 = false) {
                  const r2 = t2.length, i2 = e2.length;
                  if (0 === r2)
                    return e2;
                  if (0 === i2)
                    return t2;
                  const o2 = Math.max(t2.length, e2.length), a2 = new Array(o2);
                  if (n2) {
                    if (r2 < 2 || i2 < 2)
                      return;
                    const n3 = u.calcMatMulShape([t2[r2 - 2], t2[r2 - 1]], [e2[i2 - 2], e2[i2 - 1]]);
                    if (void 0 === n3)
                      return;
                    [a2[o2 - 2], a2[o2 - 1]] = n3;
                  }
                  for (let s2 = n2 ? 3 : 1; s2 <= o2; s2++) {
                    const n3 = r2 - s2 < 0 ? 1 : t2[r2 - s2], u2 = i2 - s2 < 0 ? 1 : e2[i2 - s2];
                    if (n3 !== u2 && n3 > 1 && u2 > 1)
                      return;
                    a2[o2 - s2] = Math.max(n3, u2);
                  }
                  return a2;
                }
                static index(t2, e2) {
                  const n2 = new Array(e2.length);
                  return c.fillIndex(t2, e2, n2), n2;
                }
                static fillIndex(t2, e2, n2) {
                  const r2 = t2.length - e2.length;
                  for (let i2 = 0; i2 < e2.length; i2++)
                    n2[i2] = t2[r2 + i2] % e2[i2];
                }
                static calc(t2, e2, n2, r2, i2) {
                  const o2 = c.calcShape(t2.dims, e2.dims);
                  if (o2) {
                    if (r2 && !f.areEqual(o2, t2.dims))
                      return;
                    const a2 = f.size(o2), u2 = r2 ? t2 : new s.Tensor(o2, i2 || t2.type);
                    if (0 === o2.length)
                      u2.set([], n2(t2.get([]), e2.get([])));
                    else {
                      const r3 = new Array(o2.length), i3 = new Array(t2.dims.length), s2 = new Array(e2.dims.length);
                      let l2, p2 = 0, f2 = 0, d2 = false, h2 = false;
                      0 === t2.dims.length && (p2 = t2.get([]), d2 = true), 0 === e2.dims.length && (f2 = e2.get([]), h2 = true);
                      for (let g2 = 0; g2 < a2; g2++) {
                        l2 = g2;
                        for (let t3 = o2.length - 1; t3 >= 0; t3--)
                          r3[t3] = l2 % o2[t3], l2 = Math.floor(l2 / o2[t3]);
                        d2 || (c.fillIndex(r3, t2.dims, i3), p2 = t2.get(i3)), h2 || (c.fillIndex(r3, e2.dims, s2), f2 = e2.get(s2)), u2.set(r3, n2(p2, f2));
                      }
                    }
                    return u2;
                  }
                }
                static isValidBroadcast(t2, e2) {
                  const n2 = t2.length, r2 = e2.length;
                  if (n2 > r2)
                    return false;
                  for (let i2 = 1; i2 <= n2; i2++)
                    if (1 !== t2[n2 - i2] && t2[n2 - i2] !== e2[r2 - i2])
                      return false;
                  return true;
                }
                static getBroadcastDims(t2, e2) {
                  const n2 = t2.length, r2 = [];
                  for (let i2 = 0; i2 < n2; i2++) {
                    const o2 = n2 - 1 - i2, a2 = t2[o2] || 1;
                    (e2[e2.length - 1 - i2] || 1) > 1 && 1 === a2 && r2.unshift(o2);
                  }
                  return r2;
                }
              }
              e.BroadcastUtil = c, e.arrayCopyHelper = function(t2, e2, n2, r2, i2) {
                if (r2 < 0 || r2 >= e2.length)
                  throw new Error("sourceIndex out of bounds");
                if (n2 < 0 || n2 >= t2.length)
                  throw new Error("targetIndex out of bounds");
                if (r2 + i2 > e2.length)
                  throw new Error("source indices to be copied are outside bounds");
                if (n2 + i2 > t2.length)
                  throw new Error("target array is too small to hold result");
                for (let o2 = 0; o2 < i2; o2++)
                  t2[n2 + o2] = e2[r2 + o2];
              }, e.GemmUtil = class {
                static getShapeOfGemmResult(t2, e2, n2, r2, i2) {
                  if (2 !== t2.length || 2 !== n2.length)
                    throw new Error("shape need to be of size 2");
                  let o2, a2, s2;
                  e2 ? (o2 = t2[1], a2 = t2[0]) : (o2 = t2[0], a2 = t2[1]);
                  let u2 = -1;
                  if (r2 ? (s2 = n2[0], u2 = 1) : (s2 = n2[1], u2 = 0), n2[u2] !== a2)
                    throw new Error("dimension mismatch");
                  if (o2 <= 0 || s2 <= 0 || a2 <= 0)
                    throw new Error("invalid shape specified");
                  if (i2 && !c.isValidBroadcast(i2, [o2, s2]))
                    throw new Error("gemm: invalid bias shape for broadcast");
                  return [o2, s2, a2];
                }
              };
              class l {
                static tensorDataTypeFromProto(t2) {
                  switch (t2) {
                    case a.onnx.TensorProto.DataType.INT8:
                      return "int8";
                    case a.onnx.TensorProto.DataType.UINT8:
                      return "uint8";
                    case a.onnx.TensorProto.DataType.BOOL:
                      return "bool";
                    case a.onnx.TensorProto.DataType.INT16:
                      return "int16";
                    case a.onnx.TensorProto.DataType.UINT16:
                      return "uint16";
                    case a.onnx.TensorProto.DataType.INT32:
                      return "int32";
                    case a.onnx.TensorProto.DataType.UINT32:
                      return "uint32";
                    case a.onnx.TensorProto.DataType.FLOAT:
                      return "float32";
                    case a.onnx.TensorProto.DataType.DOUBLE:
                      return "float64";
                    case a.onnx.TensorProto.DataType.STRING:
                      return "string";
                    case a.onnx.TensorProto.DataType.INT64:
                      return "int32";
                    case a.onnx.TensorProto.DataType.UINT64:
                      return "uint32";
                    default:
                      throw new Error(`unsupported data type: ${a.onnx.TensorProto.DataType[t2]}`);
                  }
                }
                static tensorDataTypeStringToEnum(t2) {
                  switch (t2) {
                    case "int8":
                      return a.onnx.TensorProto.DataType.INT8;
                    case "uint8":
                      return a.onnx.TensorProto.DataType.UINT8;
                    case "bool":
                      return a.onnx.TensorProto.DataType.BOOL;
                    case "int16":
                      return a.onnx.TensorProto.DataType.INT16;
                    case "uint16":
                      return a.onnx.TensorProto.DataType.UINT16;
                    case "int32":
                      return a.onnx.TensorProto.DataType.INT32;
                    case "uint32":
                      return a.onnx.TensorProto.DataType.UINT32;
                    case "float32":
                      return a.onnx.TensorProto.DataType.FLOAT;
                    case "float64":
                      return a.onnx.TensorProto.DataType.DOUBLE;
                    case "string":
                      return a.onnx.TensorProto.DataType.STRING;
                    case "int64":
                      return a.onnx.TensorProto.DataType.INT64;
                    case "uint64":
                      return a.onnx.TensorProto.DataType.UINT64;
                    default:
                      throw new Error(`unsupported data type: ${t2}`);
                  }
                }
                static tensorDimsFromProto(t2) {
                  return t2.map((t3) => o.default.isLong(t3) ? t3.toNumber() : t3);
                }
                static tensorValueTypeFromProto(t2) {
                  return { tensorType: l.tensorDataTypeFromProto(t2.elemType), shape: { dims: l.tensorDimsFromProto(t2.shape.dim.map((t3) => t3.dimValue)) } };
                }
                static tensorDimsFromORTFormat(t2) {
                  const e2 = [];
                  for (let n2 = 0; n2 < t2.dimsLength(); n2++)
                    e2.push(p.longToNumber(t2.dims(n2)));
                  return e2;
                }
                static tensorAttributesFromORTFormat(t2) {
                  const e2 = [];
                  for (let n2 = 0; n2 < t2.attributesLength(); n2++)
                    e2.push(t2.attributes(n2));
                  return e2;
                }
              }
              e.ProtoUtil = l;
              class p {
                static longToNumber(t2, e2) {
                  return o.default.isLong(t2) ? t2.toNumber() : t2 instanceof i.flatbuffers.Long ? o.default.fromValue({ low: t2.low, high: t2.high, unsigned: null != e2 && e2 }).toNumber() : t2;
                }
                static isLong(t2) {
                  return o.default.isLong(t2) || t2 instanceof i.flatbuffers.Long;
                }
              }
              e.LongUtil = p;
              class f {
                static size(t2) {
                  return f.getSizeFromDimensionRange(t2, 0, t2.length);
                }
                static sizeFromDimension(t2, e2) {
                  if (e2 < 0 || e2 > t2.length)
                    throw new Error(`invalid dimension of ${e2} for sizeFromDimension as Tensor has ${t2.length} dimensions.`);
                  return f.getSizeFromDimensionRange(t2, e2, t2.length);
                }
                static sizeToDimension(t2, e2) {
                  if (e2 < 0 || e2 > t2.length)
                    throw new Error(`invalid dimension of ${e2} for sizeToDimension as Tensor has ${t2.length} dimensions.`);
                  return f.getSizeFromDimensionRange(t2, 0, e2);
                }
                static getSizeFromDimensionRange(t2, e2, n2) {
                  let r2 = 1;
                  for (let i2 = e2; i2 < n2; i2++) {
                    if (t2[i2] <= 0)
                      throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");
                    r2 *= t2[i2];
                  }
                  return r2;
                }
                static computeStrides(t2) {
                  const e2 = t2.length;
                  if (0 === e2)
                    return [];
                  if (1 === e2)
                    return [1];
                  const n2 = new Array(e2);
                  n2[e2 - 1] = 1, n2[e2 - 2] = t2[e2 - 1];
                  for (let r2 = e2 - 3; r2 >= 0; --r2)
                    n2[r2] = n2[r2 + 1] * t2[r2 + 1];
                  return n2;
                }
                static transpose(t2) {
                  return t2.slice().reverse();
                }
                static indicesToOffset(t2, e2, n2) {
                  void 0 === n2 && (n2 = t2.length);
                  let r2 = 0;
                  for (let i2 = 0; i2 < n2; ++i2)
                    r2 += e2[i2] * t2[i2];
                  return r2;
                }
                static offsetToIndices(t2, e2) {
                  const n2 = e2.length;
                  if (0 === n2)
                    return [];
                  if (1 === n2)
                    return [t2 * e2[0]];
                  const r2 = new Array(e2.length);
                  for (let n3 = 0; n3 < r2.length - 1; ++n3)
                    r2[n3] = Math.floor(t2 / e2[n3]), t2 -= r2[n3] * e2[n3];
                  return r2[r2.length - 1] = t2, r2;
                }
                static normalizeAxis(t2, e2) {
                  if (t2 < -e2 && t2 >= e2)
                    throw new Error("unsupported axis for this operation.");
                  return t2 < 0 ? t2 + e2 : t2;
                }
                static normalizeAxes(t2, e2) {
                  return t2.map((t3) => this.normalizeAxis(t3, e2));
                }
                static incrementIndex(t2, e2, n2) {
                  if (0 === e2.length || 0 === t2.length)
                    throw new Error("Index incrementing unsupported for scalar Tensor");
                  if (void 0 === n2)
                    n2 = e2.length;
                  else if (n2 <= 0 || n2 > e2.length)
                    throw new Error("Incorrect axis to increment on");
                  for (let r2 = n2 - 1; r2 >= 0 && (t2[r2]++, !(t2[r2] < e2[r2])); --r2)
                    t2[r2] = 0;
                }
                static calculateReshapedDims(t2, e2) {
                  if (0 === e2.length) {
                    if (0 === t2.length || 1 === f.size(t2))
                      return [];
                    throw new Error("cannot reshape to a scalar Tensor");
                  }
                  const n2 = e2.length, r2 = new Array(n2);
                  let i2 = -1, o2 = 1;
                  for (let a3 = 0; a3 < n2; a3++) {
                    if (e2[a3] < -1)
                      throw new Error("a dimension in shape hints cannot be less than -1");
                    if (-1 === e2[a3]) {
                      if (-1 !== i2)
                        throw new Error("at most one dimension in shape hints can be -1");
                      i2 = a3;
                    } else {
                      if (0 === e2[a3]) {
                        if (a3 >= t2.length)
                          throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");
                        r2[a3] = t2[a3];
                      } else
                        r2[a3] = e2[a3];
                      o2 *= r2[a3];
                    }
                  }
                  const a2 = f.size(t2);
                  if (-1 !== i2) {
                    if (a2 % o2 != 0)
                      throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${t2}] Output shape: [${e2}]`);
                    r2[i2] = a2 / o2;
                  } else if (o2 !== a2)
                    throw new Error("reshapedDims and originalDims don't have matching sizes");
                  return r2;
                }
                static sortBasedOnPerm(t2, e2) {
                  return e2 ? e2.map((e3) => t2[e3]) : t2.slice().reverse();
                }
                static padShape(t2, e2) {
                  const n2 = t2.length;
                  return t2.map((t3, r2) => t3 + e2[r2] + e2[r2 + n2]);
                }
                static areEqual(t2, e2) {
                  return t2.length === e2.length && t2.every((t3, n2) => t3 === e2[n2]);
                }
                static validateDimsAndCalcSize(t2) {
                  if (t2.length > 6)
                    throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");
                  let e2 = 1;
                  for (const n2 of t2) {
                    if (!Number.isInteger(n2))
                      throw new TypeError(`Invalid shape: ${n2} is not an integer`);
                    if (n2 < 0 || n2 > 2147483647)
                      throw new TypeError(`Invalid shape: length ${n2} is not allowed`);
                    e2 *= n2;
                  }
                  return e2;
                }
                static flattenShape(t2, e2) {
                  e2 < 0 && (e2 += t2.length);
                  const n2 = t2.reduce((t3, e3) => t3 * e3, 1), r2 = t2.slice(e2).reduce((t3, e3) => t3 * e3, 1);
                  return [n2 / r2, r2];
                }
                static squeezeShape(t2, e2) {
                  const n2 = new Array();
                  e2 = f.normalizeAxes(e2, t2.length);
                  for (let r2 = 0; r2 < t2.length; r2++) {
                    const i2 = e2.indexOf(r2) >= 0;
                    if (i2 && 1 !== t2[r2])
                      throw new Error("squeeze an axis of size different than 1");
                    (0 === e2.length && t2[r2] > 1 || e2.length > 0 && !i2) && n2.push(t2[r2]);
                  }
                  return n2;
                }
                static unsqueezeShape(t2, e2) {
                  const n2 = new Array(t2.length + e2.length);
                  n2.fill(0);
                  for (let t3 = 0; t3 < e2.length; t3++) {
                    const r3 = f.normalizeAxis(e2[t3], n2.length);
                    if (r3 >= n2.length)
                      throw new Error("'axes' has an out of range axis");
                    if (0 !== n2[r3])
                      throw new Error("'axes' has a duplicate axis");
                    n2[r3] = 1;
                  }
                  let r2 = 0;
                  for (let e3 = 0; e3 < n2.length; e3++)
                    0 === n2[e3] && (n2[e3] = t2[r2++]);
                  if (r2 !== t2.length)
                    throw new Error("the unsqueezed dimension could not be established");
                  return n2;
                }
              }
              e.ShapeUtil = f, e.MathUtil = class {
                static sqr(t2, e2, n2, r2, i2) {
                  if (r2 < 0 || r2 >= e2.length)
                    throw new Error("sourceIndex out of bounds");
                  if (n2 < 0 || n2 >= t2.length)
                    throw new Error("targetIndex out of bounds");
                  if (r2 + i2 > e2.length)
                    throw new Error("source indices to be copied are outside bounds");
                  if (n2 + i2 > t2.length)
                    throw new Error("target array is too small to hold result");
                  for (let o2 = 0; o2 < i2; o2++)
                    t2[n2 + o2] += Math.pow(e2[r2 + o2], 2);
                }
                static axpy(t2, e2, n2, r2, i2, o2) {
                  if (r2 < 0 || r2 >= e2.length)
                    throw new Error("sourceIndex out of bounds");
                  if (n2 < 0 || n2 >= t2.length)
                    throw new Error("targetIndex out of bounds");
                  if (r2 + i2 > e2.length)
                    throw new Error("source indices to be copied are outside bounds");
                  if (n2 + i2 > t2.length)
                    throw new Error("target array is too small to hold result");
                  for (let a2 = 0; a2 < i2; a2++)
                    t2[n2 + a2] += o2 * e2[r2 + a2];
                }
                static powx(t2, e2, n2, r2, i2, o2) {
                  if (r2 < 0 || r2 >= e2.length)
                    throw new Error("sourceIndex out of bounds");
                  if (n2 < 0 || n2 >= t2.length)
                    throw new Error("targetIndex out of bounds");
                  if (r2 + i2 > e2.length)
                    throw new Error("source indices to be copied are outside bounds");
                  if (n2 + i2 > t2.length)
                    throw new Error("target array is too small to hold result");
                  for (let a2 = 0; a2 < i2; a2++)
                    t2[n2 + a2] = Math.pow(e2[r2 + a2], o2);
                }
                static mul(t2, e2, n2, r2, i2) {
                  if (r2 < 0 || r2 >= e2.length)
                    throw new Error("sourceIndex out of bounds");
                  if (n2 < 0 || n2 >= t2.length)
                    throw new Error("targetIndex out of bounds");
                  if (r2 + i2 > e2.length)
                    throw new Error("source indices to be copied are outside bounds");
                  if (n2 + i2 > t2.length)
                    throw new Error("target array is too small to hold result");
                  for (let o2 = 0; o2 < i2; o2++)
                    t2[n2 + o2] = e2[r2 + o2] * t2[n2 + o2];
                }
              };
              class d {
                static splitShape(t2, e2, n2, r2) {
                  if (0 === n2.length) {
                    if (!r2)
                      throw new Error("need to know number of outputs when the 'split' attribute is not specified");
                    d.determineSplit(t2[e2], r2, n2);
                  }
                  const i2 = [], o2 = [0];
                  for (let r3 = 0; r3 < n2.length; ++r3) {
                    0 !== r3 && o2.push(o2[r3 - 1] + n2[r3 - 1]);
                    const a2 = t2.slice();
                    a2[e2] = n2[r3], i2.push(a2);
                  }
                  return [i2, o2];
                }
                static determineSplit(t2, e2, n2) {
                  if (t2 % e2 != 0)
                    throw new Error("cannot split tensor to equal sized parts");
                  for (let r2 = 0; r2 < e2; ++r2)
                    n2.push(t2 / e2);
                }
              }
              e.SplitUtil = d;
              class h {
                static calcReduce(t2, e2, n2, r2, i2) {
                  const o2 = t2.dims.slice(0);
                  0 === e2.length && o2.forEach((t3, n3) => e2.push(n3));
                  const a2 = h.calcReduceShape(o2, e2, true), u2 = f.size(a2), l2 = new s.Tensor(a2, t2.type), p2 = f.computeStrides(a2), d2 = f.computeStrides(o2), g2 = new Array(o2.length);
                  for (let n3 = 0; n3 < u2; n3++) {
                    const a3 = f.offsetToIndices(n3, p2);
                    c.fillIndex(a3, o2, g2), l2.set(a3, h.calcReduceByAxis(t2.numberData, e2, o2, 0, f.indicesToOffset(g2, d2), r2, i2));
                  }
                  return n2 ? l2 : new s.Tensor(h.calcReduceShape(o2, e2, n2), l2.type, void 0, void 0, l2.data, l2.dataId);
                }
                static calcReduceByAxis(t2, e2, n2, r2, i2, o2, a2) {
                  let s2 = 0;
                  if (r2 >= e2.length)
                    return o2(t2[i2]);
                  const u2 = e2[r2], c2 = u2 >= n2.length ? 1 : f.size(n2.slice(u2 + 1));
                  for (let l2 = 0; l2 < n2[u2]; l2++)
                    s2 = 0 === l2 ? h.calcReduceByAxis(t2, e2, n2, r2 + 1, i2, o2, a2) : a2(s2, h.calcReduceByAxis(t2, e2, n2, r2 + 1, i2, o2, a2)), i2 += c2;
                  return s2;
                }
                static calcReduceShape(t2, e2, n2) {
                  const r2 = t2.slice();
                  for (let t3 = 0; t3 < e2.length; t3++)
                    r2[e2[t3]] = n2 ? 1 : 0;
                  return r2.filter((t3) => 0 !== t3);
                }
              }
              e.ReduceUtil = h;
              class g {
                static adjustPoolAttributes(t2, e2, n2, r2, i2, o2) {
                  if (!t2 && n2.length !== e2.length - 2)
                    throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
                  if (t2)
                    for (let t3 = 0; t3 < e2.length - 2; t3++)
                      t3 >= n2.length ? n2.push(e2[t3 + 2]) : n2[t3] = e2[t3 + 2];
                  for (let t3 = 0; t3 < n2.length; t3++)
                    if (t3 < r2.length) {
                      if (r2[t3] < 0)
                        throw new Error("strides should be greater than or equal to 1");
                    } else
                      r2.push(1);
                  for (let t3 = 0; t3 < n2.length; t3++)
                    if (t3 < i2.length) {
                      if (i2[t3] < 0)
                        throw new Error("dilations should be greater than or equal to 1");
                    } else
                      i2.push(1);
                  for (let t3 = 0; t3 < 2 * n2.length; t3++)
                    if (t3 < o2.length) {
                      if (o2[t3] < 0)
                        throw new Error("pad should be greater than or equal to 1");
                    } else
                      o2.push(0);
                  for (let t3 = 0; t3 < n2.length; t3++) {
                    if (n2[t3] <= 0)
                      throw new Error("kernel shapes need to be greater than 0");
                    if (o2[t3] >= n2[t3] || o2[t3 + n2.length] >= n2[t3])
                      throw new Error("pads should be smaller than kernel");
                  }
                }
                static adjustPadsBasedOnAutoPad(t2, e2, n2, r2, i2, o2) {
                  if (o2) {
                    if (i2.length !== 2 * (t2.length - 2))
                      throw new Error("length of pads should be twice the length of data dimensions");
                    if (e2.length !== t2.length - 2)
                      throw new Error("length of strides should be the length of data dimensions");
                    if (r2.length !== t2.length - 2)
                      throw new Error("length of kernel shapes should be the length of data dimensions");
                    for (let a2 = 0; a2 < t2.length - 2; a2++)
                      g.adjustPadAndReturnShape(t2[a2 + 2], e2[a2], n2[a2], r2[a2], i2, a2, a2 + t2.length - 2, o2);
                  }
                }
                static computePoolOutputShape(t2, e2, n2, r2, i2, o2, a2) {
                  if (e2.length <= 0)
                    throw new Error("input shape must be of size greater than 0");
                  const s2 = [e2[0], e2[1]];
                  return g.computeShapeHelper(t2, e2, s2, n2, r2, i2, o2, a2), s2;
                }
                static computeConvOutputShape(t2, e2, n2, r2, i2, o2, a2) {
                  if (t2.length <= 0 || e2.length <= 0)
                    throw new Error("invalid input tensor dims or invalid filter tensor dims");
                  const s2 = [t2[0], e2[0]];
                  return g.computeShapeHelper(false, t2, s2, n2, r2, i2, o2, a2), s2;
                }
                static computeShapeHelper(t2, e2, n2, r2, i2, o2, a2, s2) {
                  if (t2)
                    for (let t3 = 0; t3 < e2.length - 2; t3++)
                      n2.push(1);
                  else
                    for (let t3 = 0; t3 < e2.length - 2; t3++)
                      n2.push(g.adjustPadAndReturnShape(e2[t3 + 2], r2[t3], i2[t3], o2[t3], a2, t3, t3 + e2.length - 2, s2));
                }
                static adjustPadAndReturnShape(t2, e2, n2, r2, i2, o2, a2, s2) {
                  const u2 = n2 * (r2 - 1) + 1;
                  if (!s2 || "NOTSET" === s2)
                    return Math.floor((t2 + i2[o2] + i2[a2] - u2) / e2 + 1);
                  switch (s2) {
                    case "VALID":
                      return i2[o2] = 0, i2[a2] = 0, Math.floor((t2 - u2) / e2 + 1);
                    case "SAME_LOWER":
                    case "SAME_UPPER":
                      if (1 !== n2)
                        throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
                      {
                        const n3 = ((t2 + e2 - 1) / e2 - 1) * e2 + r2 - t2;
                        return i2[o2] = "SAME_LOWER" === s2 ? Math.floor((n3 + 1) / 2) : Math.floor(n3 / 2), i2[a2] = n3 - i2[o2], Math.floor((t2 + n3 - r2) / e2 + 1);
                      }
                    default:
                      throw new Error("Unsupported AutoPad type");
                  }
                }
              }
              e.PoolConvUtil = g, e.MIN_CLIP = -34028234663852886e22, e.MAX_CLIP = 34028234663852886e22, e.decodeUtf8String = function(t2) {
                return new TextDecoder().decode(t2);
              };
            }, 7967: (t, e) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.iterateExtraOptions = void 0, e.iterateExtraOptions = (t2, n, r, i) => {
                if ("object" == typeof t2 && null !== t2) {
                  if (r.has(t2))
                    throw new Error("Circular reference in options");
                  r.add(t2);
                }
                Object.entries(t2).forEach(([t3, o]) => {
                  const a = n ? n + t3 : t3;
                  if ("object" == typeof o)
                    (0, e.iterateExtraOptions)(o, a + ".", r, i);
                  else if ("string" == typeof o || "number" == typeof o)
                    i(a, o.toString());
                  else {
                    if ("boolean" != typeof o)
                      throw new Error("Can't handle extra config type: " + typeof o);
                    i(a, o ? "1" : "0");
                  }
                });
              };
            }, 2157: function(t, e, n) {
              "use strict";
              var r, i = this && this.__createBinding || (Object.create ? function(t2, e2, n2, r2) {
                void 0 === r2 && (r2 = n2);
                var i2 = Object.getOwnPropertyDescriptor(e2, n2);
                i2 && !("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
                  return e2[n2];
                } }), Object.defineProperty(t2, r2, i2);
              } : function(t2, e2, n2, r2) {
                void 0 === r2 && (r2 = n2), t2[r2] = e2[n2];
              }), o = this && this.__setModuleDefault || (Object.create ? function(t2, e2) {
                Object.defineProperty(t2, "default", { enumerable: true, value: e2 });
              } : function(t2, e2) {
                t2.default = e2;
              }), a = this && this.__importStar || function(t2) {
                if (t2 && t2.__esModule)
                  return t2;
                var e2 = {};
                if (null != t2)
                  for (var n2 in t2)
                    "default" !== n2 && Object.prototype.hasOwnProperty.call(t2, n2) && i(e2, t2, n2);
                return o(e2, t2), e2;
              };
              Object.defineProperty(e, "__esModule", { value: true }), e.endProfiling = e.run = e.releaseSession = e.createSession = e.createSessionFinalize = e.createSessionAllocate = e.initOrt = e.initWasm = void 0;
              const s = n(1670), u = a(n(349)), c = n(6361), l = () => !!s.env.wasm.proxy && "undefined" != typeof document;
              let p, f, d, h = false, g = false, b = false;
              const m = [], y = [], _ = [], v = [], w = [], x = [], T = () => {
                if (h || !g || b || !p)
                  throw new Error("worker not ready");
              }, S = (t2) => {
                switch (t2.data.type) {
                  case "init-wasm":
                    h = false, t2.data.err ? (b = true, f[1](t2.data.err)) : (g = true, f[0]());
                    break;
                  case "init-ort":
                    t2.data.err ? d[1](t2.data.err) : d[0]();
                    break;
                  case "create_allocate":
                    t2.data.err ? m.shift()[1](t2.data.err) : m.shift()[0](t2.data.out);
                    break;
                  case "create_finalize":
                    t2.data.err ? y.shift()[1](t2.data.err) : y.shift()[0](t2.data.out);
                    break;
                  case "create":
                    t2.data.err ? _.shift()[1](t2.data.err) : _.shift()[0](t2.data.out);
                    break;
                  case "release":
                    t2.data.err ? v.shift()[1](t2.data.err) : v.shift()[0]();
                    break;
                  case "run":
                    t2.data.err ? w.shift()[1](t2.data.err) : w.shift()[0](t2.data.out);
                    break;
                  case "end-profiling":
                    t2.data.err ? x.shift()[1](t2.data.err) : x.shift()[0]();
                }
              }, O = "undefined" != typeof document ? null === (r = null === document || void 0 === document ? void 0 : document.currentScript) || void 0 === r ? void 0 : r.src : void 0;
              e.initWasm = async () => {
                if (l()) {
                  if (g)
                    return;
                  if (h)
                    throw new Error("multiple calls to 'initWasm()' detected.");
                  if (b)
                    throw new Error("previous call to 'initWasm()' failed.");
                  return h = true, void 0 === s.env.wasm.wasmPaths && O && 0 !== O.indexOf("blob:") && (s.env.wasm.wasmPaths = O.substr(0, +O.lastIndexOf("/") + 1)), new Promise((t2, e2) => {
                    null == p || p.terminate(), p = n(9710).Z(), p.onmessage = S, f = [t2, e2];
                    const r2 = { type: "init-wasm", in: s.env.wasm };
                    p.postMessage(r2);
                  });
                }
                return (0, c.initializeWebAssembly)(s.env.wasm);
              }, e.initOrt = async (t2, e2) => {
                if (l())
                  return T(), new Promise((n2, r2) => {
                    d = [n2, r2];
                    const i2 = { type: "init-ort", in: { numThreads: t2, loggingLevel: e2 } };
                    p.postMessage(i2);
                  });
                u.initOrt(t2, e2);
              }, e.createSessionAllocate = async (t2) => l() ? (T(), new Promise((e2, n2) => {
                m.push([e2, n2]);
                const r2 = { type: "create_allocate", in: { model: t2 } };
                p.postMessage(r2, [t2.buffer]);
              })) : u.createSessionAllocate(t2), e.createSessionFinalize = async (t2, e2) => l() ? (T(), new Promise((n2, r2) => {
                y.push([n2, r2]);
                const i2 = { type: "create_finalize", in: { modeldata: t2, options: e2 } };
                p.postMessage(i2);
              })) : u.createSessionFinalize(t2, e2), e.createSession = async (t2, e2) => l() ? (T(), new Promise((n2, r2) => {
                _.push([n2, r2]);
                const i2 = { type: "create", in: { model: t2, options: e2 } };
                p.postMessage(i2, [t2.buffer]);
              })) : u.createSession(t2, e2), e.releaseSession = async (t2) => {
                if (l())
                  return T(), new Promise((e2, n2) => {
                    v.push([e2, n2]);
                    const r2 = { type: "release", in: t2 };
                    p.postMessage(r2);
                  });
                u.releaseSession(t2);
              }, e.run = async (t2, e2, n2, r2, i2) => l() ? (T(), new Promise((o2, a2) => {
                w.push([o2, a2]);
                const s2 = { type: "run", in: { sessionId: t2, inputIndices: e2, inputs: n2, outputIndices: r2, options: i2 } };
                p.postMessage(s2, u.extractTransferableBuffers(n2));
              })) : u.run(t2, e2, n2, r2, i2), e.endProfiling = async (t2) => {
                if (l())
                  return T(), new Promise((e2, n2) => {
                    x.push([e2, n2]);
                    const r2 = { type: "end-profiling", in: t2 };
                    p.postMessage(r2);
                  });
                u.endProfiling(t2);
              };
            }, 586: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.setRunOptions = void 0;
              const r = n(7967), i = n(4983), o = n(6361);
              e.setRunOptions = (t2) => {
                const e2 = (0, o.getInstance)();
                let n2 = 0;
                const a = [], s = t2 || {};
                try {
                  if (void 0 === (null == t2 ? void 0 : t2.logSeverityLevel))
                    s.logSeverityLevel = 2;
                  else if ("number" != typeof t2.logSeverityLevel || !Number.isInteger(t2.logSeverityLevel) || t2.logSeverityLevel < 0 || t2.logSeverityLevel > 4)
                    throw new Error(`log serverity level is not valid: ${t2.logSeverityLevel}`);
                  if (void 0 === (null == t2 ? void 0 : t2.logVerbosityLevel))
                    s.logVerbosityLevel = 0;
                  else if ("number" != typeof t2.logVerbosityLevel || !Number.isInteger(t2.logVerbosityLevel))
                    throw new Error(`log verbosity level is not valid: ${t2.logVerbosityLevel}`);
                  void 0 === (null == t2 ? void 0 : t2.terminate) && (s.terminate = false);
                  let o2 = 0;
                  if (void 0 !== (null == t2 ? void 0 : t2.tag) && (o2 = (0, i.allocWasmString)(t2.tag, a)), n2 = e2._OrtCreateRunOptions(s.logSeverityLevel, s.logVerbosityLevel, !!s.terminate, o2), 0 === n2)
                    throw new Error("Can't create run options");
                  return void 0 !== (null == t2 ? void 0 : t2.extra) && (0, r.iterateExtraOptions)(t2.extra, "", /* @__PURE__ */ new WeakSet(), (t3, r2) => {
                    const o3 = (0, i.allocWasmString)(t3, a), s2 = (0, i.allocWasmString)(r2, a);
                    if (0 !== e2._OrtAddRunConfigEntry(n2, o3, s2))
                      throw new Error(`Can't set a run config entry: ${t3} - ${r2}`);
                  }), [n2, a];
                } catch (t3) {
                  throw 0 !== n2 && e2._OrtReleaseRunOptions(n2), a.forEach(e2._free), t3;
                }
              };
            }, 2306: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.OnnxruntimeWebAssemblySessionHandler = void 0;
              const r = n(2806), i = n(1670), o = n(2850), a = n(2157);
              let s;
              e.OnnxruntimeWebAssemblySessionHandler = class {
                async createSessionAllocate(t2) {
                  const e2 = await fetch(t2), n2 = await e2.arrayBuffer();
                  return (0, a.createSessionAllocate)(new Uint8Array(n2));
                }
                async loadModel(t2, e2) {
                  if (s || (await (0, a.initOrt)(i.env.wasm.numThreads, ((t3) => {
                    switch (t3) {
                      case "verbose":
                        return 0;
                      case "info":
                        return 1;
                      case "warning":
                        return 2;
                      case "error":
                        return 3;
                      case "fatal":
                        return 4;
                      default:
                        throw new Error(`unsupported logging level: ${t3}`);
                    }
                  })(i.env.logLevel)), s = true), "string" == typeof t2)
                    if ("undefined" == typeof fetch) {
                      const n2 = await (0, o.promisify)(r.readFile)(t2);
                      [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSession)(n2, e2);
                    } else {
                      const n2 = await this.createSessionAllocate(t2);
                      [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSessionFinalize)(n2, e2);
                    }
                  else
                    [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSession)(t2, e2);
                }
                async dispose() {
                  return (0, a.releaseSession)(this.sessionId);
                }
                async run(t2, e2, n2) {
                  const r2 = [], o2 = [];
                  Object.entries(t2).forEach((t3) => {
                    const e3 = t3[0], n3 = t3[1], i2 = this.inputNames.indexOf(e3);
                    if (-1 === i2)
                      throw new Error(`invalid input '${e3}'`);
                    r2.push(n3), o2.push(i2);
                  });
                  const s2 = [];
                  Object.entries(e2).forEach((t3) => {
                    const e3 = t3[0], n3 = this.outputNames.indexOf(e3);
                    if (-1 === n3)
                      throw new Error(`invalid output '${e3}'`);
                    s2.push(n3);
                  });
                  const u = await (0, a.run)(this.sessionId, o2, r2.map((t3) => [t3.type, t3.dims, t3.data]), s2, n2), c = {};
                  for (let t3 = 0; t3 < u.length; t3++)
                    c[this.outputNames[s2[t3]]] = new i.Tensor(u[t3][0], u[t3][2], u[t3][1]);
                  return c;
                }
                startProfiling() {
                }
                endProfiling() {
                  (0, a.endProfiling)(this.sessionId);
                }
              };
            }, 4919: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.setSessionOptions = void 0;
              const r = n(7967), i = n(4983), o = n(6361);
              e.setSessionOptions = (t2) => {
                const e2 = (0, o.getInstance)();
                let n2 = 0;
                const a = [], s = t2 || {};
                ((t3) => {
                  t3.extra || (t3.extra = {}), t3.extra.session || (t3.extra.session = {});
                  const e3 = t3.extra.session;
                  e3.use_ort_model_bytes_directly || (e3.use_ort_model_bytes_directly = "1");
                })(s);
                try {
                  void 0 === (null == t2 ? void 0 : t2.graphOptimizationLevel) && (s.graphOptimizationLevel = "all");
                  const u = ((t3) => {
                    switch (t3) {
                      case "disabled":
                        return 0;
                      case "basic":
                        return 1;
                      case "extended":
                        return 2;
                      case "all":
                        return 99;
                      default:
                        throw new Error(`unsupported graph optimization level: ${t3}`);
                    }
                  })(s.graphOptimizationLevel);
                  void 0 === (null == t2 ? void 0 : t2.enableCpuMemArena) && (s.enableCpuMemArena = true), void 0 === (null == t2 ? void 0 : t2.enableMemPattern) && (s.enableMemPattern = true), void 0 === (null == t2 ? void 0 : t2.executionMode) && (s.executionMode = "sequential");
                  const c = ((t3) => {
                    switch (t3) {
                      case "sequential":
                        return 0;
                      case "parallel":
                        return 1;
                      default:
                        throw new Error(`unsupported execution mode: ${t3}`);
                    }
                  })(s.executionMode);
                  let l = 0;
                  if (void 0 !== (null == t2 ? void 0 : t2.logId) && (l = (0, i.allocWasmString)(t2.logId, a)), void 0 === (null == t2 ? void 0 : t2.logSeverityLevel))
                    s.logSeverityLevel = 2;
                  else if ("number" != typeof t2.logSeverityLevel || !Number.isInteger(t2.logSeverityLevel) || t2.logSeverityLevel < 0 || t2.logSeverityLevel > 4)
                    throw new Error(`log serverity level is not valid: ${t2.logSeverityLevel}`);
                  if (void 0 === (null == t2 ? void 0 : t2.logVerbosityLevel))
                    s.logVerbosityLevel = 0;
                  else if ("number" != typeof t2.logVerbosityLevel || !Number.isInteger(t2.logVerbosityLevel))
                    throw new Error(`log verbosity level is not valid: ${t2.logVerbosityLevel}`);
                  if (void 0 === (null == t2 ? void 0 : t2.enableProfiling) && (s.enableProfiling = false), n2 = e2._OrtCreateSessionOptions(u, !!s.enableCpuMemArena, !!s.enableMemPattern, c, !!s.enableProfiling, 0, l, s.logSeverityLevel, s.logVerbosityLevel), 0 === n2)
                    throw new Error("Can't create session options");
                  return (null == t2 ? void 0 : t2.executionProviders) && ((t3, e3, n3) => {
                    for (const r2 of e3) {
                      let e4 = "string" == typeof r2 ? r2 : r2.name;
                      switch (e4) {
                        case "xnnpack":
                          e4 = "XNNPACK";
                          break;
                        case "wasm":
                        case "cpu":
                          continue;
                        default:
                          throw new Error(`not supported EP: ${e4}`);
                      }
                      const a2 = (0, i.allocWasmString)(e4, n3);
                      if (0 !== (0, o.getInstance)()._OrtAppendExecutionProvider(t3, a2))
                        throw new Error(`Can't append execution provider: ${e4}`);
                    }
                  })(n2, t2.executionProviders, a), void 0 !== (null == t2 ? void 0 : t2.extra) && (0, r.iterateExtraOptions)(t2.extra, "", /* @__PURE__ */ new WeakSet(), (t3, r2) => {
                    const o2 = (0, i.allocWasmString)(t3, a), s2 = (0, i.allocWasmString)(r2, a);
                    if (0 !== e2._OrtAddSessionConfigEntry(n2, o2, s2))
                      throw new Error(`Can't set a session config entry: ${t3} - ${r2}`);
                  }), [n2, a];
                } catch (t3) {
                  throw 0 !== n2 && e2._OrtReleaseSessionOptions(n2), a.forEach(e2._free), t3;
                }
              };
            }, 4983: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.allocWasmString = void 0;
              const r = n(6361);
              e.allocWasmString = (t2, e2) => {
                const n2 = (0, r.getInstance)(), i = n2.lengthBytesUTF8(t2) + 1, o = n2._malloc(i);
                return n2.stringToUTF8(t2, o, i), e2.push(o), o;
              };
            }, 349: (t, e, n) => {
              "use strict";
              Object.defineProperty(e, "__esModule", { value: true }), e.extractTransferableBuffers = e.endProfiling = e.run = e.releaseSession = e.createSession = e.createSessionFinalize = e.createSessionAllocate = e.initOrt = void 0;
              const r = n(586), i = n(4919), o = n(4983), a = n(6361);
              e.initOrt = (t2, e2) => {
                const n2 = (0, a.getInstance)()._OrtInit(t2, e2);
                if (0 !== n2)
                  throw new Error(`Can't initialize onnxruntime. error code = ${n2}`);
              };
              const s = /* @__PURE__ */ new Map();
              e.createSessionAllocate = (t2) => {
                const e2 = (0, a.getInstance)(), n2 = e2._malloc(t2.byteLength);
                return e2.HEAPU8.set(t2, n2), [n2, t2.byteLength];
              }, e.createSessionFinalize = (t2, e2) => {
                const n2 = (0, a.getInstance)();
                let r2 = 0, o2 = 0, u2 = [];
                try {
                  if ([o2, u2] = (0, i.setSessionOptions)(e2), r2 = n2._OrtCreateSession(t2[0], t2[1], o2), 0 === r2)
                    throw new Error("Can't create a session");
                } finally {
                  n2._free(t2[0]), n2._OrtReleaseSessionOptions(o2), u2.forEach(n2._free);
                }
                const c2 = n2._OrtGetInputCount(r2), l2 = n2._OrtGetOutputCount(r2), p = [], f = [], d = [], h = [];
                for (let t3 = 0; t3 < c2; t3++) {
                  const e3 = n2._OrtGetInputName(r2, t3);
                  if (0 === e3)
                    throw new Error("Can't get an input name");
                  f.push(e3), p.push(n2.UTF8ToString(e3));
                }
                for (let t3 = 0; t3 < l2; t3++) {
                  const e3 = n2._OrtGetOutputName(r2, t3);
                  if (0 === e3)
                    throw new Error("Can't get an output name");
                  h.push(e3), d.push(n2.UTF8ToString(e3));
                }
                return s.set(r2, [r2, f, h]), [r2, p, d];
              }, e.createSession = (t2, n2) => {
                const r2 = (0, e.createSessionAllocate)(t2);
                return (0, e.createSessionFinalize)(r2, n2);
              }, e.releaseSession = (t2) => {
                const e2 = (0, a.getInstance)(), n2 = s.get(t2);
                if (!n2)
                  throw new Error("invalid session id");
                const r2 = n2[0], i2 = n2[1], o2 = n2[2];
                i2.forEach(e2._OrtFree), o2.forEach(e2._OrtFree), e2._OrtReleaseSession(r2), s.delete(t2);
              };
              const u = (t2) => {
                switch (t2) {
                  case "int8":
                    return 3;
                  case "uint8":
                    return 2;
                  case "bool":
                    return 9;
                  case "int16":
                    return 5;
                  case "uint16":
                    return 4;
                  case "int32":
                    return 6;
                  case "uint32":
                    return 12;
                  case "float32":
                    return 1;
                  case "float64":
                    return 11;
                  case "string":
                    return 8;
                  case "int64":
                    return 7;
                  case "uint64":
                    return 13;
                  default:
                    throw new Error(`unsupported data type: ${t2}`);
                }
              }, c = (t2) => {
                switch (t2) {
                  case 3:
                    return "int8";
                  case 2:
                    return "uint8";
                  case 9:
                    return "bool";
                  case 5:
                    return "int16";
                  case 4:
                    return "uint16";
                  case 6:
                    return "int32";
                  case 12:
                    return "uint32";
                  case 1:
                    return "float32";
                  case 11:
                    return "float64";
                  case 8:
                    return "string";
                  case 7:
                    return "int64";
                  case 13:
                    return "uint64";
                  default:
                    throw new Error(`unsupported data type: ${t2}`);
                }
              }, l = (t2) => {
                switch (t2) {
                  case "float32":
                    return Float32Array;
                  case "uint8":
                  case "bool":
                    return Uint8Array;
                  case "int8":
                    return Int8Array;
                  case "uint16":
                    return Uint16Array;
                  case "int16":
                    return Int16Array;
                  case "int32":
                    return Int32Array;
                  case "float64":
                    return Float64Array;
                  case "uint32":
                    return Uint32Array;
                  case "int64":
                    return BigInt64Array;
                  case "uint64":
                    return BigUint64Array;
                  default:
                    throw new Error(`unsupported type: ${t2}`);
                }
              };
              e.run = (t2, e2, n2, i2, p) => {
                const f = (0, a.getInstance)(), d = s.get(t2);
                if (!d)
                  throw new Error("invalid session id");
                const h = d[0], g = d[1], b = d[2], m = e2.length, y = i2.length;
                let _ = 0, v = [];
                const w = [], x = [];
                try {
                  [_, v] = (0, r.setRunOptions)(p);
                  for (let t4 = 0; t4 < m; t4++) {
                    const e3 = n2[t4][0], r2 = n2[t4][1], i3 = n2[t4][2];
                    let a3, s3;
                    if (Array.isArray(i3)) {
                      s3 = 4 * i3.length, a3 = f._malloc(s3), x.push(a3);
                      let t5 = a3 / 4;
                      for (let e4 = 0; e4 < i3.length; e4++) {
                        if ("string" != typeof i3[e4])
                          throw new TypeError(`tensor data at index ${e4} is not a string`);
                        f.HEAPU32[t5++] = (0, o.allocWasmString)(i3[e4], x);
                      }
                    } else
                      s3 = i3.byteLength, a3 = f._malloc(s3), x.push(a3), f.HEAPU8.set(new Uint8Array(i3.buffer, i3.byteOffset, s3), a3);
                    const c2 = f.stackSave(), l2 = f.stackAlloc(4 * r2.length);
                    try {
                      let t5 = l2 / 4;
                      r2.forEach((e4) => f.HEAP32[t5++] = e4);
                      const n3 = f._OrtCreateTensor(u(e3), a3, s3, l2, r2.length);
                      if (0 === n3)
                        throw new Error("Can't create a tensor");
                      w.push(n3);
                    } finally {
                      f.stackRestore(c2);
                    }
                  }
                  const t3 = f.stackSave(), a2 = f.stackAlloc(4 * m), s2 = f.stackAlloc(4 * m), d2 = f.stackAlloc(4 * y), T = f.stackAlloc(4 * y);
                  try {
                    let n3 = a2 / 4, r2 = s2 / 4, o2 = d2 / 4, u2 = T / 4;
                    for (let t4 = 0; t4 < m; t4++)
                      f.HEAPU32[n3++] = w[t4], f.HEAPU32[r2++] = g[e2[t4]];
                    for (let t4 = 0; t4 < y; t4++)
                      f.HEAPU32[o2++] = 0, f.HEAPU32[u2++] = b[i2[t4]];
                    let p2 = f._OrtRun(h, s2, a2, m, T, y, d2, _);
                    const v2 = [];
                    if (0 === p2)
                      for (let t4 = 0; t4 < y; t4++) {
                        const e3 = f.HEAPU32[d2 / 4 + t4], n4 = f.stackSave(), r3 = f.stackAlloc(16);
                        let i3, o3 = 0;
                        try {
                          if (p2 = f._OrtGetTensorData(e3, r3, r3 + 4, r3 + 8, r3 + 12), 0 !== p2)
                            throw new Error(`Can't access output tensor data. error code = ${p2}`);
                          let t5 = r3 / 4;
                          const a3 = f.HEAPU32[t5++];
                          o3 = f.HEAPU32[t5++];
                          const s3 = f.HEAPU32[t5++], u3 = f.HEAPU32[t5++], d3 = [];
                          for (let t6 = 0; t6 < u3; t6++)
                            d3.push(f.HEAPU32[s3 / 4 + t6]);
                          f._OrtFree(s3);
                          const h2 = 0 === d3.length ? 1 : d3.reduce((t6, e4) => t6 * e4);
                          if (i3 = c(a3), "string" === i3) {
                            const t6 = [];
                            let e4 = o3 / 4;
                            for (let n5 = 0; n5 < h2; n5++) {
                              const r4 = f.HEAPU32[e4++], i4 = n5 === h2 - 1 ? void 0 : f.HEAPU32[e4] - r4;
                              t6.push(f.UTF8ToString(r4, i4));
                            }
                            v2.push([i3, d3, t6]);
                          } else {
                            const t6 = new (l(i3))(h2);
                            new Uint8Array(t6.buffer, t6.byteOffset, t6.byteLength).set(f.HEAPU8.subarray(o3, o3 + t6.byteLength)), v2.push([i3, d3, t6]);
                          }
                        } finally {
                          f.stackRestore(n4), "string" === i3 && o3 && f._free(o3), f._OrtReleaseTensor(e3);
                        }
                      }
                    if (0 === p2)
                      return v2;
                    throw new Error(`failed to call OrtRun(). error code = ${p2}.`);
                  } finally {
                    f.stackRestore(t3);
                  }
                } finally {
                  w.forEach(f._OrtReleaseTensor), x.forEach(f._free), f._OrtReleaseRunOptions(_), v.forEach(f._free);
                }
              }, e.endProfiling = (t2) => {
                const e2 = (0, a.getInstance)(), n2 = s.get(t2);
                if (!n2)
                  throw new Error("invalid session id");
                const r2 = n2[0], i2 = e2._OrtEndProfiling(r2);
                if (0 === i2)
                  throw new Error("Can't get an profile file name");
                e2._OrtFree(i2);
              }, e.extractTransferableBuffers = (t2) => {
                const e2 = [];
                for (const n2 of t2) {
                  const t3 = n2[2];
                  !Array.isArray(t3) && t3.buffer && e2.push(t3.buffer);
                }
                return e2;
              };
            }, 6361: function(t, e, n) {
              "use strict";
              var r = this && this.__createBinding || (Object.create ? function(t2, e2, n2, r2) {
                void 0 === r2 && (r2 = n2);
                var i2 = Object.getOwnPropertyDescriptor(e2, n2);
                i2 && !("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
                  return e2[n2];
                } }), Object.defineProperty(t2, r2, i2);
              } : function(t2, e2, n2, r2) {
                void 0 === r2 && (r2 = n2), t2[r2] = e2[n2];
              }), i = this && this.__setModuleDefault || (Object.create ? function(t2, e2) {
                Object.defineProperty(t2, "default", { enumerable: true, value: e2 });
              } : function(t2, e2) {
                t2.default = e2;
              }), o = this && this.__importStar || function(t2) {
                if (t2 && t2.__esModule)
                  return t2;
                var e2 = {};
                if (null != t2)
                  for (var n2 in t2)
                    "default" !== n2 && Object.prototype.hasOwnProperty.call(t2, n2) && r(e2, t2, n2);
                return i(e2, t2), e2;
              }, a = this && this.__importDefault || function(t2) {
                return t2 && t2.__esModule ? t2 : { default: t2 };
              };
              Object.defineProperty(e, "__esModule", { value: true }), e.dispose = e.getInstance = e.initializeWebAssembly = void 0;
              const s = o(n(6449)), u = a(n(932)), c = n(3474);
              let l, p = false, f = false, d = false;
              const h = (t2, e2) => e2 ? t2 ? "ort-wasm-simd-threaded.wasm" : "ort-wasm-threaded.wasm" : t2 ? "ort-wasm-simd.wasm" : "ort-wasm.wasm";
              e.initializeWebAssembly = async (t2) => {
                if (p)
                  return Promise.resolve();
                if (f)
                  throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
                if (d)
                  throw new Error("previous call to 'initializeWebAssembly()' failed.");
                f = true;
                const e2 = t2.initTimeout, r2 = t2.numThreads, i2 = t2.simd, o2 = r2 > 1 && (() => {
                  try {
                    return "undefined" != typeof SharedArrayBuffer && ("undefined" != typeof MessageChannel && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11])));
                  } catch (t3) {
                    return false;
                  }
                })(), a2 = i2 && (() => {
                  try {
                    return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1, 28, 0, 65, 0, 253, 15, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26, 11]));
                  } catch (t3) {
                    return false;
                  }
                })(), g = "string" == typeof t2.wasmPaths ? t2.wasmPaths : void 0, b = h(false, o2), m = h(a2, o2), y = "object" == typeof t2.wasmPaths ? t2.wasmPaths[m] : void 0;
                let _ = false;
                const v = [];
                if (e2 > 0 && v.push(new Promise((t3) => {
                  setTimeout(() => {
                    _ = true, t3();
                  }, e2);
                })), v.push(new Promise((t3, e3) => {
                  const r3 = o2 ? c : u.default, i3 = { locateFile: (t4, e4) => o2 && t4.endsWith(".worker.js") && "undefined" != typeof Blob ? URL.createObjectURL(new Blob([n(4154)], { type: "text/javascript" })) : t4 === b ? null != y ? y : (null != g ? g : e4) + m : e4 + t4 };
                  if (o2)
                    if ("undefined" == typeof Blob)
                      i3.mainScriptUrlOrBlob = s.join("/", "ort-wasm-threaded.js");
                    else {
                      const t4 = `var ortWasmThreaded=(function(){var _scriptDir;return ${r3.toString()}})();`;
                      i3.mainScriptUrlOrBlob = new Blob([t4], { type: "text/javascript" });
                    }
                  r3(i3).then((e4) => {
                    f = false, p = true, l = e4, t3();
                  }, (t4) => {
                    f = false, d = true, e3(t4);
                  });
                })), await Promise.race(v), _)
                  throw new Error(`WebAssembly backend initializing failed due to timeout: ${e2}ms`);
              }, e.getInstance = () => {
                if (p && l)
                  return l;
                throw new Error("WebAssembly is not initialized yet.");
              }, e.dispose = () => {
                var t2;
                !p || f || d || (f = true, null === (t2 = l.PThread) || void 0 === t2 || t2.terminateAllThreads(), l = void 0, f = false, p = false, d = true);
              };
            }, 9710: (t, e, n) => {
              "use strict";
              n.d(e, { Z: () => o });
              var r = n(477), i = n.n(r);
              function o() {
                return i()('/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){function e(){return j.buffer!=D&&N(j.buffer),P}function r(){return j.buffer!=D&&N(j.buffer),U}function a(){return j.buffer!=D&&N(j.buffer),F}function i(){return j.buffer!=D&&N(j.buffer),I}function o(){return j.buffer!=D&&N(j.buffer),W}var u,c,s;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){c=t,s=e}));var l,f,p,h,d,y,b=Object.assign({},u),m="./this.program",g=(t,e)=>{throw e},v="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A="";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(_){let e;A=w?n(908).dirname(A)+"/":"//",y=()=>{d||(h=n(384),d=n(908))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:"utf8")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof ct))throw t})),process.on("unhandledRejection",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof ct||x("exiting due to exception: "+e),process.exit(t)},u.inspect=function(){return"[Emscripten Module object]"};try{e=n(925)}catch(t){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),t}n.g.Worker=e.Worker}else(v||w)&&(w?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},w&&(p=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var T=console.log.bind(console),E=console.warn.bind(console);_&&(y(),T=t=>h.writeSync(1,t+"\\n"),E=t=>h.writeSync(2,t+"\\n"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;"object"!=typeof WebAssembly&&at("no native wasm support detected");var j,k,D,P,U,F,I,W,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function z(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&L)return L.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?z(r(),t,e):""}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)j=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");j&&(D=j.buffer),V=D.byteLength,N(D);var $,q=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();q.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:"onAbort",arg:t}):u.onAbort&&u.onAbort(t),x(t="Aborted("+t+")"),H=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),s(t),t}function it(){return tt.startsWith("data:application/octet-stream;base64,")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw"both async and sync fetching of the wasm failed"}catch(t){at(t)}}tt="ort-wasm-threaded.wasm",it()||(tt=S(tt));var ut={};function ct(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function st(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:"run",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return $t(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new ct(t))}function pt(t,e){if(!e&&O)throw bt(t),"unwind";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?zt(n.queue):"spawnThread"===r?lt(n):"cleanupThread"===r?st(n.thread):"killThread"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?ht.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):"print"===r?C("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?t.postMessage(n):"onAbort"===r?u.onAbort&&u.onAbort(n.arg):r&&x("worker sent an unknown command "+r);ht.Bc=void 0},t.onerror=t=>{throw x("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},_&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:j,wasmModule:k})},yc:function(){var t=S("ort-wasm-threaded.worker.js");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return $t(2,0,t);try{pt(t)}catch(t){t instanceof ct||"unwind"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=$.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,wt,_t=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?$t(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc="spawnThread",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?$t(4,1,t,e,n):0}function xt(t,e){if(O)return $t(5,1,t,e)}function Rt(t,e){if(O)return $t(6,1,t,e)}function jt(t,e,n){if(O)return $t(7,1,t,e,n)}function kt(t,e,n){return O?$t(8,1,t,e,n):0}function Dt(t,e){if(O)return $t(9,1,t,e)}function Pt(t,e,n){if(O)return $t(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return $t(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return $t(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return $t(13,1,t,e,n,r)}function Wt(t){if(O)return $t(14,1,t)}function Ht(t,e){if(O)return $t(15,1,t,e)}function Lt(t,e,n){if(O)return $t(16,1,t,e,n)}function zt(t){Atomics.store(a(),t>>2,1),he()&&_e(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?$t(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return $t(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}if(O)return $t(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),c=new Date(o,6,1);o=u.getTimezoneOffset();var s=c.getTimezoneOffset(),l=Math.max(o,s);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=s),t=r(u),e=r(c),t=Nt(t),e=Nt(e),s<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function $t(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var c=r[2+u];o()[i+u>>>0]=c}return we(t,n,a,e)}))}u.executeNotifiedProxyingQueue=zt,wt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var qt,Xt=[],Jt={};function Zt(){if(!qt){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+"="+e[t]);qt=n}return qt}function Qt(t,n){if(O)return $t(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return $t(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?$t(22,1,t):52}function ee(t,e,n,r){return O?$t(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?$t(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(z(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return $t(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var c=i()[e>>2>>>0],s=i()[e+4>>2>>>0];e+=8;for(var l=0;l<s;l++)ae(t,r()[c+l>>>0]);o+=s}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var ce=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,"0")}function c(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?ce:se)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=c(e,t)?0>=c(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):""},r=Y(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(t){return h[t.Tb].substring(0,3)},"%A":function(t){return h[t.Tb]},"%b":function(t){return d[t.ec].substring(0,3)},"%B":function(t){return d[t.ec]},"%C":function(t){return u((t.Xb+1900)/100|0,2)},"%d":function(t){return u(t.jc,2)},"%e":function(t){return o(t.jc,2," ")},"%g":function(t){return l(t).toString().substring(2)},"%G":function(t){return l(t)},"%H":function(t){return u(t.dc,2)},"%I":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?ce:se)[n++]);return u(t.jc+e,3)},"%m":function(t){return u(t.ec+1,2)},"%M":function(t){return u(t.Kc,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.dc&&12>t.dc?"AM":"PM"},"%S":function(t){return u(t.Lc,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Tb||7},"%U":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},"%V":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},"%w":function(t){return t.Tb},"%W":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},"%y":function(t){return(t.Xb+1900).toString().substring(2)},"%Y":function(t){return t.Xb+1900},"%z":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,jt,kt,Dt,Pt,Ut,Ft,It,Wt,Ht,Lt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),_t.push(t),t.sc(),t.vc()},ma:function(t){throw x("Unexpected exception thrown, this is not properly supported - aborting"),H=!0,t},x:function(){Se(0);var t=_t.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=_t.pop();t||at("no exception to throw");var e=t.Zb;throw t.kc()||(_t.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!w,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:"cleanupThread",thread:t}):st(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:jt,oa:kt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:Lt,Ta:function(){},X:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>zt(r)));else if(O)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),c=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&c==r):0<n!=(c==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?c:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at("")},U:function(){if(!_&&!w){var t="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";vt||(vt={}),vt[t]||(vt[t]=1,_&&(t="warning: "+t),x(t))}},ra:function(){return 4294901760},B:wt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{j.grow(i-D.byteLength+65535>>>16),N(j.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw"unwind"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(_)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>at("randomDevice")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var c=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return ke(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return Le(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return je(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var c=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,c){var s=Ee();try{gt(t)(e,n,r,a,i,o,u,c)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var c=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:j||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),$=u.asm.ub,X.unshift(u.asm.Va),k=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||w)){if("function"==typeof fetch&&!tt.startsWith("file://"))return fetch(tt,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+tt+"\'";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x("failed to asynchronously prepare wasm: "+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x("Module.instantiateWasm callback failed with error: "+t),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith("file://")||_||"function"!=typeof fetch?n(e):fetch(tt,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x("wasm streaming compile failed: "+t),x("falling back to ArrayBuffer instantiation"),n(e)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,we=u._emscripten_run_in_main_runtime_thread_js=function(){return(we=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},_e=u.__emscripten_proxy_execute_task_queue=function(){return(_e=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},je=u.dynCall_j=function(){return(je=u.dynCall_j=u.asm.Ib).apply(null,arguments)},ke=u.dynCall_iiiiij=function(){return(ke=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Le=u.dynCall_iiij=function(){return(Le=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function ze(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)c(u),O||dt(X),postMessage({cmd:"loaded"});else{if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt(q),0<et||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=j,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=ct,u.PThread=ht,rt=function t(){ve||ze(),ve||(rt=t)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return ze(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,c,s,l,f=Object.assign({},e),p="./this.program",h=(t,e)=>{throw e},d="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";b?(m=y?n(908).dirname(m)+"/":"//",l=()=>{s||(c=n(384),s=n(908))},i=function(t,e){return l(),t=s.normalize(t),c.readFileSync(t,e?void 0:"utf8")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=s.normalize(t),c.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof J))throw t})),process.on("unhandledRejection",(function(t){throw t})),h=(t,e)=>{if(_||0<L)throw process.exitCode=t,e;e instanceof J||w("exiting due to exception: "+e),process.exit(t)},e.inspect=function(){return"[Emscripten Module object]"}):(d||y)&&(y?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),w=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var _=e.noExitRuntime||!1;"object"!=typeof WebAssembly&&V("no native wasm support detected");var O,A,S,T,E,M,C=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function j(t,e){return(t>>>=0)?R(T,t,e):""}function k(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],L=0;function z(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),w(t="Aborted("+t+")"),C=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),a(t),t}function $(){return Y.startsWith("data:application/octet-stream;base64,")}if(Y="ort-wasm.wasm",!$()){var q=Y;Y=e.locateFile?e.locateFile(q,m):m+q}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw"both async and sync fetching of the wasm failed"}catch(t){V(t)}}function J(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&k(t,S,n,e),n}var ot={};function ut(){if(!ct){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+"="+e[t]);ct=n}return ct}var ct,st=[null,[],[]];function lt(t,e){var n=st[t];0===e||10===e?((1===t?v:w)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,"0")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var s=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:s?j(s):""},n=j(n),s={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),s[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in s={"%a":function(t){return f[t.Ab].substring(0,3)},"%A":function(t){return f[t.Ab]},"%b":function(t){return p[t.Hb].substring(0,3)},"%B":function(t){return p[t.Hb]},"%C":function(t){return i((t.Cb+1900)/100|0,2)},"%d":function(t){return i(t.Kb,2)},"%e":function(t){return a(t.Kb,2," ")},"%g":function(t){return c(t).toString().substring(2)},"%G":function(t){return c(t)},"%H":function(t){return i(t.Gb,2)},"%I":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},"%m":function(t){return i(t.Hb+1,2)},"%M":function(t){return i(t.Zb,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.Gb&&12>t.Gb?"AM":"PM"},"%S":function(t){return i(t.$b,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Ab||7},"%U":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},"%V":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},"%w":function(t){return t.Ab},"%W":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},"%y":function(t){return(t.Cb+1900).toString().substring(2)},"%Y":function(t){return t.Cb+1900},"%z":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),s)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),s[l](r)));return l=function(t){var e=Array(D(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\0\\0/g,"%")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw w("Unexpected exception thrown, this is not properly supported - aborting"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V("no exception to throw");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V("")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){_||0<L||(_t(),Z(W),wt(0),st[1].length&&lt(1,10),st[2].length&&lt(2,10)),_||0<L||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var c=0;c<u;c++)lt(t,T[o+c>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>V("randomDevice")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var c=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var c=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var c=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,c){var s=At();try{at(t)(e,n,r,a,i,o,u,c)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,c,s,l){var f=At();try{at(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=At();try{jt(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{kt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if("function"==typeof fetch&&!Y.startsWith("file://"))return fetch(Y,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+Y+"\'";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){w("failed to asynchronously prepare wasm: "+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return w("Module.instantiateWasm callback failed with error: "+t),!1}(g||"function"!=typeof WebAssembly.instantiateStreaming||$()||Y.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(Y,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return w("wasm streaming compile failed: "+t),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},wt=e._fflush=function(){return(wt=e._fflush=e.asm.gb).apply(null,arguments)},_t=e.___funcs_on_exit=function(){return(_t=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},jt=e.dynCall_viiiiij=function(){return(jt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)z();Z(F),0<B||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),t()}),1)):t())}}if(e.UTF8ToString=j,e.stringToUTF8=function(t,e,n){return k(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if("object"==typeof t&&null!==t){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if("object"==typeof i)(0,e.iterateExtraOptions)(i,o+".",r,a);else if("string"==typeof i||"number"==typeof i)a(o,i.toString());else{if("boolean"!=typeof i)throw new Error("Can\'t handle extra config type: "+typeof i);a(o,i?"1":"0")}}))}},586:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error("Can\'t create run options");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel="all");const c=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode="sequential");const s=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error("Can\'t create session options");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e="string"==typeof r?r:r.name;switch(e){case"xnnpack":e="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,c=[];try{if([i,c]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error("Can\'t create a session")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),c.forEach(n._free)}const s=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<s;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error("Can\'t get an input name");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error("Can\'t get an output name");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const c=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},s=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error("invalid session id");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,w=[];const _=[],O=[];try{[v,w]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if("string"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const s=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(c(e),o,u,l,r.length);if(0===n)throw new Error("Can\'t create a tensor");_.push(n)}finally{p.stackRestore(s)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,c=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=_[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[c++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const w=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],c=p.HEAPU32[t++],h=[];for(let t=0;t<c;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=s(o),"string"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}w.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),w.push([a,h,t])}}finally{p.stackRestore(n),"string"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return w;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{_.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),w.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!("get"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(449)),c=o(n(932)),s=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":t?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(h)throw new Error("previous call to \'initializeWebAssembly()\' failed.");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y="string"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g="object"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const w=[];if(e>0&&w.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),w.push(new Promise(((t,e)=>{const r=i?s:c.default,a={locateFile:(t,e)=>i&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=u.join("/","ort-wasm-threaded.js");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(w),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{"use strict";t.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),(()=>{"use strict";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(t=>postMessage({type:"init-wasm",err:t})));break;case"init-ort":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:"init-ort"})}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:"create_finalize",out:a})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:"create",out:a})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:"run",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}}}})()})();\n', "Worker", void 0, void 0);
              }
            }, 477: (t) => {
              "use strict";
              t.exports = function(t2, e, n, r) {
                var i = self || window;
                try {
                  try {
                    var o;
                    try {
                      o = new i.Blob([t2]);
                    } catch (e2) {
                      (o = new (i.BlobBuilder || i.WebKitBlobBuilder || i.MozBlobBuilder || i.MSBlobBuilder)()).append(t2), o = o.getBlob();
                    }
                    var a = i.URL || i.webkitURL, s = a.createObjectURL(o), u = new i[e](s, n);
                    return a.revokeObjectURL(s), u;
                  } catch (r2) {
                    return new i[e]("data:application/javascript,".concat(encodeURIComponent(t2)), n);
                  }
                } catch (t3) {
                  if (!r)
                    throw Error("Inline worker is not supported");
                  return new i[e](r, n);
                }
              };
            }, 4154: (t) => {
              "use strict";
              t.exports = '"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\n';
            }, 1670: (t) => {
              "use strict";
              t.exports = __WEBPACK_EXTERNAL_MODULE__1670__;
            }, 7067: () => {
            }, 1296: () => {
            }, 1384: () => {
            }, 3993: () => {
            }, 908: () => {
            }, 6953: () => {
            }, 9925: () => {
            }, 2806: () => {
            }, 6449: () => {
            }, 2850: () => {
            }, 5381: () => {
            }, 5686: (t, e, n) => {
              "use strict";
              n.r(e), n.d(e, { flatbuffers: () => r });
              var r = {};
              r.Offset, r.Table, r.SIZEOF_SHORT = 2, r.SIZEOF_INT = 4, r.FILE_IDENTIFIER_LENGTH = 4, r.SIZE_PREFIX_LENGTH = 4, r.Encoding = { UTF8_BYTES: 1, UTF16_STRING: 2 }, r.int32 = new Int32Array(2), r.float32 = new Float32Array(r.int32.buffer), r.float64 = new Float64Array(r.int32.buffer), r.isLittleEndian = 1 === new Uint16Array(new Uint8Array([1, 0]).buffer)[0], r.Long = function(t2, e2) {
                this.low = 0 | t2, this.high = 0 | e2;
              }, r.Long.create = function(t2, e2) {
                return 0 == t2 && 0 == e2 ? r.Long.ZERO : new r.Long(t2, e2);
              }, r.Long.prototype.toFloat64 = function() {
                return (this.low >>> 0) + 4294967296 * this.high;
              }, r.Long.prototype.equals = function(t2) {
                return this.low == t2.low && this.high == t2.high;
              }, r.Long.ZERO = new r.Long(0, 0), r.Builder = function(t2) {
                if (t2)
                  e2 = t2;
                else
                  var e2 = 1024;
                this.bb = r.ByteBuffer.allocate(e2), this.space = e2, this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false;
              }, r.Builder.prototype.clear = function() {
                this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false;
              }, r.Builder.prototype.forceDefaults = function(t2) {
                this.force_defaults = t2;
              }, r.Builder.prototype.dataBuffer = function() {
                return this.bb;
              }, r.Builder.prototype.asUint8Array = function() {
                return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
              }, r.Builder.prototype.prep = function(t2, e2) {
                t2 > this.minalign && (this.minalign = t2);
                for (var n2 = 1 + ~(this.bb.capacity() - this.space + e2) & t2 - 1; this.space < n2 + t2 + e2; ) {
                  var i = this.bb.capacity();
                  this.bb = r.Builder.growByteBuffer(this.bb), this.space += this.bb.capacity() - i;
                }
                this.pad(n2);
              }, r.Builder.prototype.pad = function(t2) {
                for (var e2 = 0; e2 < t2; e2++)
                  this.bb.writeInt8(--this.space, 0);
              }, r.Builder.prototype.writeInt8 = function(t2) {
                this.bb.writeInt8(this.space -= 1, t2);
              }, r.Builder.prototype.writeInt16 = function(t2) {
                this.bb.writeInt16(this.space -= 2, t2);
              }, r.Builder.prototype.writeInt32 = function(t2) {
                this.bb.writeInt32(this.space -= 4, t2);
              }, r.Builder.prototype.writeInt64 = function(t2) {
                this.bb.writeInt64(this.space -= 8, t2);
              }, r.Builder.prototype.writeFloat32 = function(t2) {
                this.bb.writeFloat32(this.space -= 4, t2);
              }, r.Builder.prototype.writeFloat64 = function(t2) {
                this.bb.writeFloat64(this.space -= 8, t2);
              }, r.Builder.prototype.addInt8 = function(t2) {
                this.prep(1, 0), this.writeInt8(t2);
              }, r.Builder.prototype.addInt16 = function(t2) {
                this.prep(2, 0), this.writeInt16(t2);
              }, r.Builder.prototype.addInt32 = function(t2) {
                this.prep(4, 0), this.writeInt32(t2);
              }, r.Builder.prototype.addInt64 = function(t2) {
                this.prep(8, 0), this.writeInt64(t2);
              }, r.Builder.prototype.addFloat32 = function(t2) {
                this.prep(4, 0), this.writeFloat32(t2);
              }, r.Builder.prototype.addFloat64 = function(t2) {
                this.prep(8, 0), this.writeFloat64(t2);
              }, r.Builder.prototype.addFieldInt8 = function(t2, e2, n2) {
                (this.force_defaults || e2 != n2) && (this.addInt8(e2), this.slot(t2));
              }, r.Builder.prototype.addFieldInt16 = function(t2, e2, n2) {
                (this.force_defaults || e2 != n2) && (this.addInt16(e2), this.slot(t2));
              }, r.Builder.prototype.addFieldInt32 = function(t2, e2, n2) {
                (this.force_defaults || e2 != n2) && (this.addInt32(e2), this.slot(t2));
              }, r.Builder.prototype.addFieldInt64 = function(t2, e2, n2) {
                !this.force_defaults && e2.equals(n2) || (this.addInt64(e2), this.slot(t2));
              }, r.Builder.prototype.addFieldFloat32 = function(t2, e2, n2) {
                (this.force_defaults || e2 != n2) && (this.addFloat32(e2), this.slot(t2));
              }, r.Builder.prototype.addFieldFloat64 = function(t2, e2, n2) {
                (this.force_defaults || e2 != n2) && (this.addFloat64(e2), this.slot(t2));
              }, r.Builder.prototype.addFieldOffset = function(t2, e2, n2) {
                (this.force_defaults || e2 != n2) && (this.addOffset(e2), this.slot(t2));
              }, r.Builder.prototype.addFieldStruct = function(t2, e2, n2) {
                e2 != n2 && (this.nested(e2), this.slot(t2));
              }, r.Builder.prototype.nested = function(t2) {
                if (t2 != this.offset())
                  throw new Error("FlatBuffers: struct must be serialized inline.");
              }, r.Builder.prototype.notNested = function() {
                if (this.isNested)
                  throw new Error("FlatBuffers: object serialization must not be nested.");
              }, r.Builder.prototype.slot = function(t2) {
                this.vtable[t2] = this.offset();
              }, r.Builder.prototype.offset = function() {
                return this.bb.capacity() - this.space;
              }, r.Builder.growByteBuffer = function(t2) {
                var e2 = t2.capacity();
                if (3221225472 & e2)
                  throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
                var n2 = e2 << 1, i = r.ByteBuffer.allocate(n2);
                return i.setPosition(n2 - e2), i.bytes().set(t2.bytes(), n2 - e2), i;
              }, r.Builder.prototype.addOffset = function(t2) {
                this.prep(r.SIZEOF_INT, 0), this.writeInt32(this.offset() - t2 + r.SIZEOF_INT);
              }, r.Builder.prototype.startObject = function(t2) {
                this.notNested(), null == this.vtable && (this.vtable = []), this.vtable_in_use = t2;
                for (var e2 = 0; e2 < t2; e2++)
                  this.vtable[e2] = 0;
                this.isNested = true, this.object_start = this.offset();
              }, r.Builder.prototype.endObject = function() {
                if (null == this.vtable || !this.isNested)
                  throw new Error("FlatBuffers: endObject called without startObject");
                this.addInt32(0);
                for (var t2 = this.offset(), e2 = this.vtable_in_use - 1; e2 >= 0 && 0 == this.vtable[e2]; e2--)
                  ;
                for (var n2 = e2 + 1; e2 >= 0; e2--)
                  this.addInt16(0 != this.vtable[e2] ? t2 - this.vtable[e2] : 0);
                this.addInt16(t2 - this.object_start);
                var i = (n2 + 2) * r.SIZEOF_SHORT;
                this.addInt16(i);
                var o = 0, a = this.space;
                t:
                  for (e2 = 0; e2 < this.vtables.length; e2++) {
                    var s = this.bb.capacity() - this.vtables[e2];
                    if (i == this.bb.readInt16(s)) {
                      for (var u = r.SIZEOF_SHORT; u < i; u += r.SIZEOF_SHORT)
                        if (this.bb.readInt16(a + u) != this.bb.readInt16(s + u))
                          continue t;
                      o = this.vtables[e2];
                      break;
                    }
                  }
                return o ? (this.space = this.bb.capacity() - t2, this.bb.writeInt32(this.space, o - t2)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - t2, this.offset() - t2)), this.isNested = false, t2;
              }, r.Builder.prototype.finish = function(t2, e2, n2) {
                var i = n2 ? r.SIZE_PREFIX_LENGTH : 0;
                if (e2) {
                  var o = e2;
                  if (this.prep(this.minalign, r.SIZEOF_INT + r.FILE_IDENTIFIER_LENGTH + i), o.length != r.FILE_IDENTIFIER_LENGTH)
                    throw new Error("FlatBuffers: file identifier must be length " + r.FILE_IDENTIFIER_LENGTH);
                  for (var a = r.FILE_IDENTIFIER_LENGTH - 1; a >= 0; a--)
                    this.writeInt8(o.charCodeAt(a));
                }
                this.prep(this.minalign, r.SIZEOF_INT + i), this.addOffset(t2), i && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);
              }, r.Builder.prototype.finishSizePrefixed = function(t2, e2) {
                this.finish(t2, e2, true);
              }, r.Builder.prototype.requiredField = function(t2, e2) {
                var n2 = this.bb.capacity() - t2, r2 = n2 - this.bb.readInt32(n2);
                if (0 == this.bb.readInt16(r2 + e2))
                  throw new Error("FlatBuffers: field " + e2 + " must be set");
              }, r.Builder.prototype.startVector = function(t2, e2, n2) {
                this.notNested(), this.vector_num_elems = e2, this.prep(r.SIZEOF_INT, t2 * e2), this.prep(n2, t2 * e2);
              }, r.Builder.prototype.endVector = function() {
                return this.writeInt32(this.vector_num_elems), this.offset();
              }, r.Builder.prototype.createString = function(t2) {
                if (t2 instanceof Uint8Array)
                  var e2 = t2;
                else {
                  e2 = [];
                  for (var n2 = 0; n2 < t2.length; ) {
                    var r2, i = t2.charCodeAt(n2++);
                    (r2 = i < 55296 || i >= 56320 ? i : (i << 10) + t2.charCodeAt(n2++) + -56613888) < 128 ? e2.push(r2) : (r2 < 2048 ? e2.push(r2 >> 6 & 31 | 192) : (r2 < 65536 ? e2.push(r2 >> 12 & 15 | 224) : e2.push(r2 >> 18 & 7 | 240, r2 >> 12 & 63 | 128), e2.push(r2 >> 6 & 63 | 128)), e2.push(63 & r2 | 128));
                  }
                }
                this.addInt8(0), this.startVector(1, e2.length, 1), this.bb.setPosition(this.space -= e2.length), n2 = 0;
                for (var o = this.space, a = this.bb.bytes(); n2 < e2.length; n2++)
                  a[o++] = e2[n2];
                return this.endVector();
              }, r.Builder.prototype.createLong = function(t2, e2) {
                return r.Long.create(t2, e2);
              }, r.ByteBuffer = function(t2) {
                this.bytes_ = t2, this.position_ = 0;
              }, r.ByteBuffer.allocate = function(t2) {
                return new r.ByteBuffer(new Uint8Array(t2));
              }, r.ByteBuffer.prototype.clear = function() {
                this.position_ = 0;
              }, r.ByteBuffer.prototype.bytes = function() {
                return this.bytes_;
              }, r.ByteBuffer.prototype.position = function() {
                return this.position_;
              }, r.ByteBuffer.prototype.setPosition = function(t2) {
                this.position_ = t2;
              }, r.ByteBuffer.prototype.capacity = function() {
                return this.bytes_.length;
              }, r.ByteBuffer.prototype.readInt8 = function(t2) {
                return this.readUint8(t2) << 24 >> 24;
              }, r.ByteBuffer.prototype.readUint8 = function(t2) {
                return this.bytes_[t2];
              }, r.ByteBuffer.prototype.readInt16 = function(t2) {
                return this.readUint16(t2) << 16 >> 16;
              }, r.ByteBuffer.prototype.readUint16 = function(t2) {
                return this.bytes_[t2] | this.bytes_[t2 + 1] << 8;
              }, r.ByteBuffer.prototype.readInt32 = function(t2) {
                return this.bytes_[t2] | this.bytes_[t2 + 1] << 8 | this.bytes_[t2 + 2] << 16 | this.bytes_[t2 + 3] << 24;
              }, r.ByteBuffer.prototype.readUint32 = function(t2) {
                return this.readInt32(t2) >>> 0;
              }, r.ByteBuffer.prototype.readInt64 = function(t2) {
                return new r.Long(this.readInt32(t2), this.readInt32(t2 + 4));
              }, r.ByteBuffer.prototype.readUint64 = function(t2) {
                return new r.Long(this.readUint32(t2), this.readUint32(t2 + 4));
              }, r.ByteBuffer.prototype.readFloat32 = function(t2) {
                return r.int32[0] = this.readInt32(t2), r.float32[0];
              }, r.ByteBuffer.prototype.readFloat64 = function(t2) {
                return r.int32[r.isLittleEndian ? 0 : 1] = this.readInt32(t2), r.int32[r.isLittleEndian ? 1 : 0] = this.readInt32(t2 + 4), r.float64[0];
              }, r.ByteBuffer.prototype.writeInt8 = function(t2, e2) {
                this.bytes_[t2] = e2;
              }, r.ByteBuffer.prototype.writeUint8 = function(t2, e2) {
                this.bytes_[t2] = e2;
              }, r.ByteBuffer.prototype.writeInt16 = function(t2, e2) {
                this.bytes_[t2] = e2, this.bytes_[t2 + 1] = e2 >> 8;
              }, r.ByteBuffer.prototype.writeUint16 = function(t2, e2) {
                this.bytes_[t2] = e2, this.bytes_[t2 + 1] = e2 >> 8;
              }, r.ByteBuffer.prototype.writeInt32 = function(t2, e2) {
                this.bytes_[t2] = e2, this.bytes_[t2 + 1] = e2 >> 8, this.bytes_[t2 + 2] = e2 >> 16, this.bytes_[t2 + 3] = e2 >> 24;
              }, r.ByteBuffer.prototype.writeUint32 = function(t2, e2) {
                this.bytes_[t2] = e2, this.bytes_[t2 + 1] = e2 >> 8, this.bytes_[t2 + 2] = e2 >> 16, this.bytes_[t2 + 3] = e2 >> 24;
              }, r.ByteBuffer.prototype.writeInt64 = function(t2, e2) {
                this.writeInt32(t2, e2.low), this.writeInt32(t2 + 4, e2.high);
              }, r.ByteBuffer.prototype.writeUint64 = function(t2, e2) {
                this.writeUint32(t2, e2.low), this.writeUint32(t2 + 4, e2.high);
              }, r.ByteBuffer.prototype.writeFloat32 = function(t2, e2) {
                r.float32[0] = e2, this.writeInt32(t2, r.int32[0]);
              }, r.ByteBuffer.prototype.writeFloat64 = function(t2, e2) {
                r.float64[0] = e2, this.writeInt32(t2, r.int32[r.isLittleEndian ? 0 : 1]), this.writeInt32(t2 + 4, r.int32[r.isLittleEndian ? 1 : 0]);
              }, r.ByteBuffer.prototype.getBufferIdentifier = function() {
                if (this.bytes_.length < this.position_ + r.SIZEOF_INT + r.FILE_IDENTIFIER_LENGTH)
                  throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
                for (var t2 = "", e2 = 0; e2 < r.FILE_IDENTIFIER_LENGTH; e2++)
                  t2 += String.fromCharCode(this.readInt8(this.position_ + r.SIZEOF_INT + e2));
                return t2;
              }, r.ByteBuffer.prototype.__offset = function(t2, e2) {
                var n2 = t2 - this.readInt32(t2);
                return e2 < this.readInt16(n2) ? this.readInt16(n2 + e2) : 0;
              }, r.ByteBuffer.prototype.__union = function(t2, e2) {
                return t2.bb_pos = e2 + this.readInt32(e2), t2.bb = this, t2;
              }, r.ByteBuffer.prototype.__string = function(t2, e2) {
                t2 += this.readInt32(t2);
                var n2 = this.readInt32(t2), i = "", o = 0;
                if (t2 += r.SIZEOF_INT, e2 === r.Encoding.UTF8_BYTES)
                  return this.bytes_.subarray(t2, t2 + n2);
                for (; o < n2; ) {
                  var a, s = this.readUint8(t2 + o++);
                  if (s < 192)
                    a = s;
                  else {
                    var u = this.readUint8(t2 + o++);
                    if (s < 224)
                      a = (31 & s) << 6 | 63 & u;
                    else {
                      var c = this.readUint8(t2 + o++);
                      a = s < 240 ? (15 & s) << 12 | (63 & u) << 6 | 63 & c : (7 & s) << 18 | (63 & u) << 12 | (63 & c) << 6 | 63 & this.readUint8(t2 + o++);
                    }
                  }
                  a < 65536 ? i += String.fromCharCode(a) : (a -= 65536, i += String.fromCharCode(55296 + (a >> 10), 56320 + (1023 & a)));
                }
                return i;
              }, r.ByteBuffer.prototype.__indirect = function(t2) {
                return t2 + this.readInt32(t2);
              }, r.ByteBuffer.prototype.__vector = function(t2) {
                return t2 + this.readInt32(t2) + r.SIZEOF_INT;
              }, r.ByteBuffer.prototype.__vector_len = function(t2) {
                return this.readInt32(t2 + this.readInt32(t2));
              }, r.ByteBuffer.prototype.__has_identifier = function(t2) {
                if (t2.length != r.FILE_IDENTIFIER_LENGTH)
                  throw new Error("FlatBuffers: file identifier must be length " + r.FILE_IDENTIFIER_LENGTH);
                for (var e2 = 0; e2 < r.FILE_IDENTIFIER_LENGTH; e2++)
                  if (t2.charCodeAt(e2) != this.readInt8(this.position_ + r.SIZEOF_INT + e2))
                    return false;
                return true;
              }, r.ByteBuffer.prototype.createLong = function(t2, e2) {
                return r.Long.create(t2, e2);
              };
            } }, __webpack_module_cache__ = {};
            function __nested_webpack_require_546802__(t) {
              var e = __webpack_module_cache__[t];
              if (void 0 !== e)
                return e.exports;
              var n = __webpack_module_cache__[t] = { exports: {} };
              return __webpack_modules__[t].call(n.exports, n, n.exports, __nested_webpack_require_546802__), n.exports;
            }
            __nested_webpack_require_546802__.n = (t) => {
              var e = t && t.__esModule ? () => t.default : () => t;
              return __nested_webpack_require_546802__.d(e, { a: e }), e;
            }, __nested_webpack_require_546802__.d = (t, e) => {
              for (var n in e)
                __nested_webpack_require_546802__.o(e, n) && !__nested_webpack_require_546802__.o(t, n) && Object.defineProperty(t, n, { enumerable: true, get: e[n] });
            }, __nested_webpack_require_546802__.g = function() {
              if ("object" == typeof globalThis)
                return globalThis;
              try {
                return this || new Function("return this")();
              } catch (t) {
                if ("object" == typeof window)
                  return window;
              }
            }(), __nested_webpack_require_546802__.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), __nested_webpack_require_546802__.r = (t) => {
              "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: true });
            };
            var __nested_webpack_exports__ = __nested_webpack_require_546802__(6018);
            return __nested_webpack_exports__;
          })());
        }
      ),
      /***/
      "?2ce3": (
        /*!**********************************!*\
          !*** onnxruntime-node (ignored) ***!
          \**********************************/
        /***/
        () => {
        }
      ),
      /***/
      "?7a2c": (
        /*!********************!*\
          !*** fs (ignored) ***!
          \********************/
        /***/
        () => {
        }
      ),
      /***/
      "?a42a": (
        /*!**********************!*\
          !*** path (ignored) ***!
          \**********************/
        /***/
        () => {
        }
      ),
      /***/
      "?2b25": (
        /*!***********************!*\
          !*** sharp (ignored) ***!
          \***********************/
        /***/
        () => {
        }
      ),
      /***/
      "?569f": (
        /*!********************!*\
          !*** fs (ignored) ***!
          \********************/
        /***/
        () => {
        }
      ),
      /***/
      "?3f59": (
        /*!**********************!*\
          !*** path (ignored) ***!
          \**********************/
        /***/
        () => {
        }
      ),
      /***/
      "?154a": (
        /*!*********************!*\
          !*** url (ignored) ***!
          \*********************/
        /***/
        () => {
        }
      ),
      /***/
      "./node_modules/@huggingface/jinja/dist/index.js": (
        /*!*******************************************************!*\
          !*** ./node_modules/@huggingface/jinja/dist/index.js ***!
          \*******************************************************/
        /***/
        (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "Environment": () => (
              /* binding */
              Environment
            ),
            /* harmony export */
            "Interpreter": () => (
              /* binding */
              Interpreter
            ),
            /* harmony export */
            "Template": () => (
              /* binding */
              Template
            ),
            /* harmony export */
            "parse": () => (
              /* binding */
              parse
            ),
            /* harmony export */
            "tokenize": () => (
              /* binding */
              tokenize4
            )
            /* harmony export */
          });
          var TOKEN_TYPES = Object.freeze({
            Text: "Text",
            // The text between Jinja statements or expressions
            NumericLiteral: "NumericLiteral",
            // e.g., 123
            BooleanLiteral: "BooleanLiteral",
            // true or false
            StringLiteral: "StringLiteral",
            // 'string'
            Identifier: "Identifier",
            // Variables, functions, etc.
            Equals: "Equals",
            // =
            OpenParen: "OpenParen",
            // (
            CloseParen: "CloseParen",
            // )
            OpenStatement: "OpenStatement",
            // {%
            CloseStatement: "CloseStatement",
            // %}
            OpenExpression: "OpenExpression",
            // {{
            CloseExpression: "CloseExpression",
            // }}
            OpenSquareBracket: "OpenSquareBracket",
            // [
            CloseSquareBracket: "CloseSquareBracket",
            // ]
            OpenCurlyBracket: "OpenCurlyBracket",
            // {
            CloseCurlyBracket: "CloseCurlyBracket",
            // }
            Comma: "Comma",
            // ,
            Dot: "Dot",
            // .
            Colon: "Colon",
            // :
            Pipe: "Pipe",
            // |
            CallOperator: "CallOperator",
            // ()
            AdditiveBinaryOperator: "AdditiveBinaryOperator",
            // + -
            MultiplicativeBinaryOperator: "MultiplicativeBinaryOperator",
            // * / %
            ComparisonBinaryOperator: "ComparisonBinaryOperator",
            // < > <= >= == !=
            UnaryOperator: "UnaryOperator",
            // ! - +
            // Keywords
            Set: "Set",
            If: "If",
            For: "For",
            In: "In",
            Is: "Is",
            NotIn: "NotIn",
            Else: "Else",
            EndIf: "EndIf",
            ElseIf: "ElseIf",
            EndFor: "EndFor",
            And: "And",
            Or: "Or",
            Not: "UnaryOperator"
          });
          var KEYWORDS = Object.freeze({
            set: TOKEN_TYPES.Set,
            for: TOKEN_TYPES.For,
            in: TOKEN_TYPES.In,
            is: TOKEN_TYPES.Is,
            if: TOKEN_TYPES.If,
            else: TOKEN_TYPES.Else,
            endif: TOKEN_TYPES.EndIf,
            elif: TOKEN_TYPES.ElseIf,
            endfor: TOKEN_TYPES.EndFor,
            and: TOKEN_TYPES.And,
            or: TOKEN_TYPES.Or,
            not: TOKEN_TYPES.Not,
            "not in": TOKEN_TYPES.NotIn,
            // Literals
            true: TOKEN_TYPES.BooleanLiteral,
            false: TOKEN_TYPES.BooleanLiteral
          });
          var Token2 = class {
            /**
             * Constructs a new Token.
             * @param {string} value The raw value as seen inside the source code.
             * @param {TokenType} type The type of token.
             */
            constructor(value, type) {
              this.value = value;
              this.type = type;
            }
          };
          function isWord(char) {
            return /\w/.test(char);
          }
          function isInteger(char) {
            return /[0-9]/.test(char);
          }
          var ORDERED_MAPPING_TABLE = [
            // Control sequences
            ["{%", TOKEN_TYPES.OpenStatement],
            ["%}", TOKEN_TYPES.CloseStatement],
            ["{{", TOKEN_TYPES.OpenExpression],
            ["}}", TOKEN_TYPES.CloseExpression],
            // Single character tokens
            ["(", TOKEN_TYPES.OpenParen],
            [")", TOKEN_TYPES.CloseParen],
            ["{", TOKEN_TYPES.OpenCurlyBracket],
            ["}", TOKEN_TYPES.CloseCurlyBracket],
            ["[", TOKEN_TYPES.OpenSquareBracket],
            ["]", TOKEN_TYPES.CloseSquareBracket],
            [",", TOKEN_TYPES.Comma],
            [".", TOKEN_TYPES.Dot],
            [":", TOKEN_TYPES.Colon],
            ["|", TOKEN_TYPES.Pipe],
            // Comparison operators
            ["<=", TOKEN_TYPES.ComparisonBinaryOperator],
            [">=", TOKEN_TYPES.ComparisonBinaryOperator],
            ["==", TOKEN_TYPES.ComparisonBinaryOperator],
            ["!=", TOKEN_TYPES.ComparisonBinaryOperator],
            ["<", TOKEN_TYPES.ComparisonBinaryOperator],
            [">", TOKEN_TYPES.ComparisonBinaryOperator],
            // Arithmetic operators
            ["+", TOKEN_TYPES.AdditiveBinaryOperator],
            ["-", TOKEN_TYPES.AdditiveBinaryOperator],
            ["*", TOKEN_TYPES.MultiplicativeBinaryOperator],
            ["/", TOKEN_TYPES.MultiplicativeBinaryOperator],
            ["%", TOKEN_TYPES.MultiplicativeBinaryOperator],
            // Assignment operator
            ["=", TOKEN_TYPES.Equals]
          ];
          var ESCAPE_CHARACTERS = /* @__PURE__ */ new Map([
            ["n", "\n"],
            // New line
            ["t", "	"],
            // Horizontal tab
            ["r", "\r"],
            // Carriage return
            ["b", "\b"],
            // Backspace
            ["f", "\f"],
            // Form feed
            ["v", "\v"],
            // Vertical tab
            ["'", "'"],
            // Single quote
            ['"', '"'],
            // Double quote
            ["\\", "\\"]
            // Backslash
          ]);
          function preprocess(template, options = {}) {
            if (template.endsWith("\n")) {
              template = template.slice(0, -1);
            }
            template = template.replace(/{#.*?#}/gs, "{##}");
            if (options.lstrip_blocks) {
              template = template.replace(/^[ \t]*({[#%])/gm, "$1");
            }
            if (options.trim_blocks) {
              template = template.replace(/([#%]})\n/g, "$1");
            }
            return template.replace(/{##}/g, "").replace(/-%}\s*/g, "%}").replace(/\s*{%-/g, "{%").replace(/-}}\s*/g, "}}").replace(/\s*{{-/g, "{{");
          }
          function tokenize4(source, options = {}) {
            const tokens = [];
            const src = preprocess(source, options);
            let cursorPosition = 0;
            const consumeWhile = (predicate) => {
              let str = "";
              while (predicate(src[cursorPosition])) {
                if (src[cursorPosition] === "\\") {
                  ++cursorPosition;
                  if (cursorPosition >= src.length)
                    throw new SyntaxError("Unexpected end of input");
                  const escaped = src[cursorPosition++];
                  const unescaped = ESCAPE_CHARACTERS.get(escaped);
                  if (unescaped === void 0) {
                    throw new SyntaxError(`Unexpected escaped character: ${escaped}`);
                  }
                  str += unescaped;
                  continue;
                }
                str += src[cursorPosition++];
                if (cursorPosition >= src.length)
                  throw new SyntaxError("Unexpected end of input");
              }
              return str;
            };
            main:
              while (cursorPosition < src.length) {
                const lastTokenType = tokens.at(-1)?.type;
                if (lastTokenType === void 0 || lastTokenType === TOKEN_TYPES.CloseStatement || lastTokenType === TOKEN_TYPES.CloseExpression) {
                  let text2 = "";
                  while (cursorPosition < src.length && // Keep going until we hit the next Jinja statement or expression
                  !(src[cursorPosition] === "{" && (src[cursorPosition + 1] === "%" || src[cursorPosition + 1] === "{"))) {
                    text2 += src[cursorPosition++];
                  }
                  if (text2.length > 0) {
                    tokens.push(new Token2(text2, TOKEN_TYPES.Text));
                    continue;
                  }
                }
                consumeWhile((char2) => /\s/.test(char2));
                const char = src[cursorPosition];
                if (char === "-" || char === "+") {
                  const lastTokenType2 = tokens.at(-1)?.type;
                  if (lastTokenType2 === TOKEN_TYPES.Text || lastTokenType2 === void 0) {
                    throw new SyntaxError(`Unexpected character: ${char}`);
                  }
                  switch (lastTokenType2) {
                    case TOKEN_TYPES.Identifier:
                    case TOKEN_TYPES.NumericLiteral:
                    case TOKEN_TYPES.BooleanLiteral:
                    case TOKEN_TYPES.StringLiteral:
                    case TOKEN_TYPES.CloseParen:
                    case TOKEN_TYPES.CloseSquareBracket:
                      break;
                    default: {
                      ++cursorPosition;
                      const num = consumeWhile(isInteger);
                      tokens.push(
                        new Token2(`${char}${num}`, num.length > 0 ? TOKEN_TYPES.NumericLiteral : TOKEN_TYPES.UnaryOperator)
                      );
                      continue;
                    }
                  }
                }
                for (const [char2, token] of ORDERED_MAPPING_TABLE) {
                  const slice2 = src.slice(cursorPosition, cursorPosition + char2.length);
                  if (slice2 === char2) {
                    tokens.push(new Token2(char2, token));
                    cursorPosition += char2.length;
                    continue main;
                  }
                }
                if (char === "'" || char === '"') {
                  ++cursorPosition;
                  const str = consumeWhile((c) => c !== char);
                  tokens.push(new Token2(str, TOKEN_TYPES.StringLiteral));
                  ++cursorPosition;
                  continue;
                }
                if (isInteger(char)) {
                  const num = consumeWhile(isInteger);
                  tokens.push(new Token2(num, TOKEN_TYPES.NumericLiteral));
                  continue;
                }
                if (isWord(char)) {
                  const word = consumeWhile(isWord);
                  const type = Object.hasOwn(KEYWORDS, word) ? KEYWORDS[word] : TOKEN_TYPES.Identifier;
                  if (type === TOKEN_TYPES.In && tokens.at(-1)?.type === TOKEN_TYPES.Not) {
                    tokens.pop();
                    tokens.push(new Token2("not in", TOKEN_TYPES.NotIn));
                  } else {
                    tokens.push(new Token2(word, type));
                  }
                  continue;
                }
                throw new SyntaxError(`Unexpected character: ${char}`);
              }
            return tokens;
          }
          var Statement = class {
            constructor() {
              __publicField(this, "type", "Statement");
            }
          };
          var Program = class extends Statement {
            constructor(body) {
              super();
              __publicField(this, "type", "Program");
              this.body = body;
            }
          };
          var If = class extends Statement {
            constructor(test2, body, alternate) {
              super();
              __publicField(this, "type", "If");
              this.test = test2;
              this.body = body;
              this.alternate = alternate;
            }
          };
          var For = class extends Statement {
            constructor(loopvar, iterable, body) {
              super();
              __publicField(this, "type", "For");
              this.loopvar = loopvar;
              this.iterable = iterable;
              this.body = body;
            }
          };
          var SetStatement = class extends Statement {
            constructor(assignee, value) {
              super();
              __publicField(this, "type", "Set");
              this.assignee = assignee;
              this.value = value;
            }
          };
          var Expression = class extends Statement {
            constructor() {
              super(...arguments);
              __publicField(this, "type", "Expression");
            }
          };
          var MemberExpression = class extends Expression {
            constructor(object, property, computed) {
              super();
              __publicField(this, "type", "MemberExpression");
              this.object = object;
              this.property = property;
              this.computed = computed;
            }
          };
          var CallExpression = class extends Expression {
            constructor(callee, args) {
              super();
              __publicField(this, "type", "CallExpression");
              this.callee = callee;
              this.args = args;
            }
          };
          var Identifier = class extends Expression {
            /**
             * @param {string} value The name of the identifier
             */
            constructor(value) {
              super();
              __publicField(this, "type", "Identifier");
              this.value = value;
            }
          };
          var Literal = class extends Expression {
            constructor(value) {
              super();
              __publicField(this, "type", "Literal");
              this.value = value;
            }
          };
          var NumericLiteral = class extends Literal {
            constructor() {
              super(...arguments);
              __publicField(this, "type", "NumericLiteral");
            }
          };
          var StringLiteral = class extends Literal {
            constructor() {
              super(...arguments);
              __publicField(this, "type", "StringLiteral");
            }
          };
          var BooleanLiteral = class extends Literal {
            constructor() {
              super(...arguments);
              __publicField(this, "type", "BooleanLiteral");
            }
          };
          var ArrayLiteral = class extends Literal {
            constructor() {
              super(...arguments);
              __publicField(this, "type", "ArrayLiteral");
            }
          };
          var TupleLiteral = class extends Literal {
            constructor() {
              super(...arguments);
              __publicField(this, "type", "TupleLiteral");
            }
          };
          var ObjectLiteral = class extends Literal {
            constructor() {
              super(...arguments);
              __publicField(this, "type", "ObjectLiteral");
            }
          };
          var BinaryExpression = class extends Expression {
            constructor(operator, left, right) {
              super();
              __publicField(this, "type", "BinaryExpression");
              this.operator = operator;
              this.left = left;
              this.right = right;
            }
          };
          var FilterExpression = class extends Expression {
            constructor(operand, filter) {
              super();
              __publicField(this, "type", "FilterExpression");
              this.operand = operand;
              this.filter = filter;
            }
          };
          var TestExpression = class extends Expression {
            constructor(operand, negate, test2) {
              super();
              __publicField(this, "type", "TestExpression");
              this.operand = operand;
              this.negate = negate;
              this.test = test2;
            }
          };
          var UnaryExpression = class extends Expression {
            constructor(operator, argument) {
              super();
              __publicField(this, "type", "UnaryExpression");
              this.operator = operator;
              this.argument = argument;
            }
          };
          var SliceExpression = class extends Expression {
            constructor(start = void 0, stop = void 0, step = void 0) {
              super();
              __publicField(this, "type", "SliceExpression");
              this.start = start;
              this.stop = stop;
              this.step = step;
            }
          };
          var KeywordArgumentExpression = class extends Expression {
            constructor(key, value) {
              super();
              __publicField(this, "type", "KeywordArgumentExpression");
              this.key = key;
              this.value = value;
            }
          };
          function parse(tokens) {
            const program = new Program([]);
            let current = 0;
            function expect(type, error2) {
              const prev = tokens[current++];
              if (!prev || prev.type !== type) {
                throw new Error(`Parser Error: ${error2}. ${prev.type} !== ${type}.`);
              }
              return prev;
            }
            function parseAny() {
              switch (tokens[current].type) {
                case TOKEN_TYPES.Text:
                  return parseText();
                case TOKEN_TYPES.OpenStatement:
                  return parseJinjaStatement();
                case TOKEN_TYPES.OpenExpression:
                  return parseJinjaExpression();
                default:
                  throw new SyntaxError(`Unexpected token type: ${tokens[current].type}`);
              }
            }
            function not(...types) {
              return current + types.length <= tokens.length && types.some((type, i) => type !== tokens[current + i].type);
            }
            function is(...types) {
              return current + types.length <= tokens.length && types.every((type, i) => type === tokens[current + i].type);
            }
            function parseText() {
              return new StringLiteral(expect(TOKEN_TYPES.Text, "Expected text token").value);
            }
            function parseJinjaStatement() {
              expect(TOKEN_TYPES.OpenStatement, "Expected opening statement token");
              let result;
              switch (tokens[current].type) {
                case TOKEN_TYPES.Set:
                  ++current;
                  result = parseSetStatement();
                  expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
                  break;
                case TOKEN_TYPES.If:
                  ++current;
                  result = parseIfStatement();
                  expect(TOKEN_TYPES.OpenStatement, "Expected {% token");
                  expect(TOKEN_TYPES.EndIf, "Expected endif token");
                  expect(TOKEN_TYPES.CloseStatement, "Expected %} token");
                  break;
                case TOKEN_TYPES.For:
                  ++current;
                  result = parseForStatement();
                  expect(TOKEN_TYPES.OpenStatement, "Expected {% token");
                  expect(TOKEN_TYPES.EndFor, "Expected endfor token");
                  expect(TOKEN_TYPES.CloseStatement, "Expected %} token");
                  break;
                default:
                  throw new SyntaxError(`Unknown statement type: ${tokens[current].type}`);
              }
              return result;
            }
            function parseJinjaExpression() {
              expect(TOKEN_TYPES.OpenExpression, "Expected opening expression token");
              const result = parseExpression();
              expect(TOKEN_TYPES.CloseExpression, "Expected closing expression token");
              return result;
            }
            function parseSetStatement() {
              const left = parseExpression();
              if (is(TOKEN_TYPES.Equals)) {
                ++current;
                const value = parseSetStatement();
                return new SetStatement(left, value);
              }
              return left;
            }
            function parseIfStatement() {
              const test2 = parseExpression();
              expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
              const body = [];
              const alternate = [];
              while (!(tokens[current]?.type === TOKEN_TYPES.OpenStatement && (tokens[current + 1]?.type === TOKEN_TYPES.ElseIf || tokens[current + 1]?.type === TOKEN_TYPES.Else || tokens[current + 1]?.type === TOKEN_TYPES.EndIf))) {
                body.push(parseAny());
              }
              if (tokens[current]?.type === TOKEN_TYPES.OpenStatement && tokens[current + 1]?.type !== TOKEN_TYPES.EndIf) {
                ++current;
                if (is(TOKEN_TYPES.ElseIf)) {
                  expect(TOKEN_TYPES.ElseIf, "Expected elseif token");
                  alternate.push(parseIfStatement());
                } else {
                  expect(TOKEN_TYPES.Else, "Expected else token");
                  expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
                  while (!(tokens[current]?.type === TOKEN_TYPES.OpenStatement && tokens[current + 1]?.type === TOKEN_TYPES.EndIf)) {
                    alternate.push(parseAny());
                  }
                }
              }
              return new If(test2, body, alternate);
            }
            function parseExpressionSequence(primary = false) {
              const fn = primary ? parsePrimaryExpression : parseExpression;
              const expressions = [fn()];
              const isTuple = is(TOKEN_TYPES.Comma);
              while (isTuple) {
                ++current;
                expressions.push(fn());
                if (!is(TOKEN_TYPES.Comma)) {
                  break;
                }
              }
              return isTuple ? new TupleLiteral(expressions) : expressions[0];
            }
            function parseForStatement() {
              const loopVariable = parseExpressionSequence(true);
              if (!(loopVariable instanceof Identifier || loopVariable instanceof TupleLiteral)) {
                throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${loopVariable.type} instead`);
              }
              expect(TOKEN_TYPES.In, "Expected `in` keyword following loop variable");
              const iterable = parseExpression();
              expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
              const body = [];
              while (not(TOKEN_TYPES.OpenStatement, TOKEN_TYPES.EndFor)) {
                body.push(parseAny());
              }
              return new For(loopVariable, iterable, body);
            }
            function parseExpression() {
              return parseTernaryExpression();
            }
            function parseTernaryExpression() {
              const a = parseLogicalOrExpression();
              if (is(TOKEN_TYPES.If)) {
                ++current;
                const predicate = parseLogicalOrExpression();
                expect(TOKEN_TYPES.Else, "Expected else token");
                const b = parseLogicalOrExpression();
                return new If(predicate, [a], [b]);
              }
              return a;
            }
            function parseLogicalOrExpression() {
              let left = parseLogicalAndExpression();
              while (is(TOKEN_TYPES.Or)) {
                const operator = tokens[current];
                ++current;
                const right = parseLogicalAndExpression();
                left = new BinaryExpression(operator, left, right);
              }
              return left;
            }
            function parseLogicalAndExpression() {
              let left = parseLogicalNegationExpression();
              while (is(TOKEN_TYPES.And)) {
                const operator = tokens[current];
                ++current;
                const right = parseLogicalNegationExpression();
                left = new BinaryExpression(operator, left, right);
              }
              return left;
            }
            function parseLogicalNegationExpression() {
              let right;
              while (is(TOKEN_TYPES.Not)) {
                const operator = tokens[current];
                ++current;
                const arg = parseLogicalNegationExpression();
                right = new UnaryExpression(operator, arg);
              }
              return right ?? parseComparisonExpression();
            }
            function parseComparisonExpression() {
              let left = parseAdditiveExpression();
              while (is(TOKEN_TYPES.ComparisonBinaryOperator) || is(TOKEN_TYPES.In) || is(TOKEN_TYPES.NotIn)) {
                const operator = tokens[current];
                ++current;
                const right = parseAdditiveExpression();
                left = new BinaryExpression(operator, left, right);
              }
              return left;
            }
            function parseAdditiveExpression() {
              let left = parseMultiplicativeExpression();
              while (is(TOKEN_TYPES.AdditiveBinaryOperator)) {
                const operator = tokens[current];
                ++current;
                const right = parseMultiplicativeExpression();
                left = new BinaryExpression(operator, left, right);
              }
              return left;
            }
            function parseCallMemberExpression() {
              const member = parseMemberExpression();
              if (is(TOKEN_TYPES.OpenParen)) {
                return parseCallExpression(member);
              }
              return member;
            }
            function parseCallExpression(callee) {
              let callExpression = new CallExpression(callee, parseArgs());
              if (is(TOKEN_TYPES.OpenParen)) {
                callExpression = parseCallExpression(callExpression);
              }
              return callExpression;
            }
            function parseArgs() {
              expect(TOKEN_TYPES.OpenParen, "Expected opening parenthesis for arguments list");
              const args = parseArgumentsList();
              expect(TOKEN_TYPES.CloseParen, "Expected closing parenthesis for arguments list");
              return args;
            }
            function parseArgumentsList() {
              const args = [];
              while (!is(TOKEN_TYPES.CloseParen)) {
                let argument = parseExpression();
                if (is(TOKEN_TYPES.Equals)) {
                  ++current;
                  if (!(argument instanceof Identifier)) {
                    throw new SyntaxError(`Expected identifier for keyword argument`);
                  }
                  const value = parseExpression();
                  argument = new KeywordArgumentExpression(argument, value);
                }
                args.push(argument);
                if (is(TOKEN_TYPES.Comma)) {
                  ++current;
                }
              }
              return args;
            }
            function parseMemberExpressionArgumentsList() {
              const slices = [];
              let isSlice = false;
              while (!is(TOKEN_TYPES.CloseSquareBracket)) {
                if (is(TOKEN_TYPES.Colon)) {
                  slices.push(void 0);
                  ++current;
                  isSlice = true;
                } else {
                  slices.push(parseExpression());
                  if (is(TOKEN_TYPES.Colon)) {
                    ++current;
                    isSlice = true;
                  }
                }
              }
              if (slices.length === 0) {
                throw new SyntaxError(`Expected at least one argument for member/slice expression`);
              }
              if (isSlice) {
                if (slices.length > 3) {
                  throw new SyntaxError(`Expected 0-3 arguments for slice expression`);
                }
                return new SliceExpression(...slices);
              }
              return slices[0];
            }
            function parseMemberExpression() {
              let object = parsePrimaryExpression();
              while (is(TOKEN_TYPES.Dot) || is(TOKEN_TYPES.OpenSquareBracket)) {
                const operator = tokens[current];
                ++current;
                let property;
                const computed = operator.type !== TOKEN_TYPES.Dot;
                if (computed) {
                  property = parseMemberExpressionArgumentsList();
                  expect(TOKEN_TYPES.CloseSquareBracket, "Expected closing square bracket");
                } else {
                  property = parsePrimaryExpression();
                  if (property.type !== "Identifier") {
                    throw new SyntaxError(`Expected identifier following dot operator`);
                  }
                }
                object = new MemberExpression(object, property, computed);
              }
              return object;
            }
            function parseMultiplicativeExpression() {
              let left = parseTestExpression();
              while (is(TOKEN_TYPES.MultiplicativeBinaryOperator)) {
                const operator = tokens[current];
                ++current;
                const right = parseTestExpression();
                left = new BinaryExpression(operator, left, right);
              }
              return left;
            }
            function parseTestExpression() {
              let operand = parseFilterExpression();
              while (is(TOKEN_TYPES.Is)) {
                ++current;
                const negate = is(TOKEN_TYPES.Not);
                if (negate) {
                  ++current;
                }
                let filter = parsePrimaryExpression();
                if (filter instanceof BooleanLiteral) {
                  filter = new Identifier(filter.value.toString());
                }
                if (!(filter instanceof Identifier)) {
                  throw new SyntaxError(`Expected identifier for the test`);
                }
                operand = new TestExpression(operand, negate, filter);
              }
              return operand;
            }
            function parseFilterExpression() {
              let operand = parseCallMemberExpression();
              while (is(TOKEN_TYPES.Pipe)) {
                ++current;
                let filter = parsePrimaryExpression();
                if (!(filter instanceof Identifier)) {
                  throw new SyntaxError(`Expected identifier for the filter`);
                }
                if (is(TOKEN_TYPES.OpenParen)) {
                  filter = parseCallExpression(filter);
                }
                operand = new FilterExpression(operand, filter);
              }
              return operand;
            }
            function parsePrimaryExpression() {
              const token = tokens[current];
              switch (token.type) {
                case TOKEN_TYPES.NumericLiteral:
                  ++current;
                  return new NumericLiteral(Number(token.value));
                case TOKEN_TYPES.StringLiteral:
                  ++current;
                  return new StringLiteral(token.value);
                case TOKEN_TYPES.BooleanLiteral:
                  ++current;
                  return new BooleanLiteral(token.value === "true");
                case TOKEN_TYPES.Identifier:
                  ++current;
                  return new Identifier(token.value);
                case TOKEN_TYPES.OpenParen: {
                  ++current;
                  const expression = parseExpressionSequence();
                  if (tokens[current].type !== TOKEN_TYPES.CloseParen) {
                    throw new SyntaxError(`Expected closing parenthesis, got ${tokens[current].type} instead`);
                  }
                  ++current;
                  return expression;
                }
                case TOKEN_TYPES.OpenSquareBracket: {
                  ++current;
                  const values = [];
                  while (!is(TOKEN_TYPES.CloseSquareBracket)) {
                    values.push(parseExpression());
                    if (is(TOKEN_TYPES.Comma)) {
                      ++current;
                    }
                  }
                  ++current;
                  return new ArrayLiteral(values);
                }
                case TOKEN_TYPES.OpenCurlyBracket: {
                  ++current;
                  const values = /* @__PURE__ */ new Map();
                  while (!is(TOKEN_TYPES.CloseCurlyBracket)) {
                    const key = parseExpression();
                    expect(TOKEN_TYPES.Colon, "Expected colon between key and value in object literal");
                    const value = parseExpression();
                    values.set(key, value);
                    if (is(TOKEN_TYPES.Comma)) {
                      ++current;
                    }
                  }
                  ++current;
                  return new ObjectLiteral(values);
                }
                default:
                  throw new SyntaxError(`Unexpected token: ${token.type}`);
              }
            }
            while (current < tokens.length) {
              program.body.push(parseAny());
            }
            return program;
          }
          function range(start, stop, step = 1) {
            if (stop === void 0) {
              stop = start;
              start = 0;
            }
            const result = [];
            for (let i = start; i < stop; i += step) {
              result.push(i);
            }
            return result;
          }
          function slice(array, start, stop, step = 1) {
            const direction = Math.sign(step);
            if (direction >= 0) {
              start = (start ?? (start = 0)) < 0 ? Math.max(array.length + start, 0) : Math.min(start, array.length);
              stop = (stop ?? (stop = array.length)) < 0 ? Math.max(array.length + stop, 0) : Math.min(stop, array.length);
            } else {
              start = (start ?? (start = array.length - 1)) < 0 ? Math.max(array.length + start, -1) : Math.min(start, array.length - 1);
              stop = (stop ?? (stop = -1)) < -1 ? Math.max(array.length + stop, -1) : Math.min(stop, array.length - 1);
            }
            const result = [];
            for (let i = start; direction * i < direction * stop; i += step) {
              result.push(array[i]);
            }
            return result;
          }
          function titleCase(value) {
            return value.replace(/\b\w/g, (c) => c.toUpperCase());
          }
          var RuntimeValue = class {
            /**
             * Creates a new RuntimeValue.
             */
            constructor(value = void 0) {
              __publicField(this, "type", "RuntimeValue");
              __publicField(this, "value");
              /**
               * A collection of built-in functions for this type.
               */
              __publicField(this, "builtins", /* @__PURE__ */ new Map());
              this.value = value;
            }
            /**
             * Determines truthiness or falsiness of the runtime value.
             * This function should be overridden by subclasses if it has custom truthiness criteria.
             * @returns {BooleanValue} BooleanValue(true) if the value is truthy, BooleanValue(false) otherwise.
             */
            __bool__() {
              return new BooleanValue(!!this.value);
            }
          };
          var NumericValue = class extends RuntimeValue {
            constructor() {
              super(...arguments);
              __publicField(this, "type", "NumericValue");
            }
          };
          var StringValue = class extends RuntimeValue {
            constructor() {
              super(...arguments);
              __publicField(this, "type", "StringValue");
              __publicField(this, "builtins", /* @__PURE__ */ new Map([
                [
                  "upper",
                  new FunctionValue(() => {
                    return new StringValue(this.value.toUpperCase());
                  })
                ],
                [
                  "lower",
                  new FunctionValue(() => {
                    return new StringValue(this.value.toLowerCase());
                  })
                ],
                [
                  "strip",
                  new FunctionValue(() => {
                    return new StringValue(this.value.trim());
                  })
                ],
                [
                  "title",
                  new FunctionValue(() => {
                    return new StringValue(titleCase(this.value));
                  })
                ],
                ["length", new NumericValue(this.value.length)]
              ]));
            }
          };
          var BooleanValue = class extends RuntimeValue {
            constructor() {
              super(...arguments);
              __publicField(this, "type", "BooleanValue");
            }
          };
          var ObjectValue = class extends RuntimeValue {
            constructor() {
              super(...arguments);
              __publicField(this, "type", "ObjectValue");
              __publicField(this, "builtins", /* @__PURE__ */ new Map([
                [
                  "get",
                  new FunctionValue(([key, defaultValue]) => {
                    if (!(key instanceof StringValue)) {
                      throw new Error(`Object key must be a string: got ${key.type}`);
                    }
                    return this.value.get(key.value) ?? defaultValue ?? new NullValue();
                  })
                ],
                [
                  "items",
                  new FunctionValue(() => {
                    return new ArrayValue(
                      Array.from(this.value.entries()).map(([key, value]) => new ArrayValue([new StringValue(key), value]))
                    );
                  })
                ]
              ]));
            }
            /**
             * NOTE: necessary to override since all JavaScript arrays are considered truthy,
             * while only non-empty Python arrays are consider truthy.
             *
             * e.g.,
             *  - JavaScript:  {} && 5 -> 5
             *  - Python:      {} and 5 -> {}
             */
            __bool__() {
              return new BooleanValue(this.value.size > 0);
            }
          };
          var ArrayValue = class extends RuntimeValue {
            constructor() {
              super(...arguments);
              __publicField(this, "type", "ArrayValue");
              __publicField(this, "builtins", /* @__PURE__ */ new Map([["length", new NumericValue(this.value.length)]]));
            }
            /**
             * NOTE: necessary to override since all JavaScript arrays are considered truthy,
             * while only non-empty Python arrays are consider truthy.
             *
             * e.g.,
             *  - JavaScript:  [] && 5 -> 5
             *  - Python:      [] and 5 -> []
             */
            __bool__() {
              return new BooleanValue(this.value.length > 0);
            }
          };
          var TupleValue = class extends ArrayValue {
            constructor() {
              super(...arguments);
              __publicField(this, "type", "TupleValue");
            }
          };
          var FunctionValue = class extends RuntimeValue {
            constructor() {
              super(...arguments);
              __publicField(this, "type", "FunctionValue");
            }
          };
          var NullValue = class extends RuntimeValue {
            constructor() {
              super(...arguments);
              __publicField(this, "type", "NullValue");
            }
          };
          var UndefinedValue = class extends RuntimeValue {
            constructor() {
              super(...arguments);
              __publicField(this, "type", "UndefinedValue");
            }
          };
          var Environment = class {
            constructor(parent) {
              /**
               * The variables declared in this environment.
               */
              __publicField(this, "variables", /* @__PURE__ */ new Map([
                [
                  "namespace",
                  new FunctionValue((args) => {
                    if (args.length === 0) {
                      return new ObjectValue(/* @__PURE__ */ new Map());
                    }
                    if (args.length !== 1 || !(args[0] instanceof ObjectValue)) {
                      throw new Error("`namespace` expects either zero arguments or a single object argument");
                    }
                    return args[0];
                  })
                ]
              ]));
              /**
               * The tests available in this environment.
               */
              __publicField(this, "tests", /* @__PURE__ */ new Map([
                ["boolean", (operand) => operand.type === "BooleanValue"],
                ["callable", (operand) => operand instanceof FunctionValue],
                [
                  "odd",
                  (operand) => {
                    if (operand.type !== "NumericValue") {
                      throw new Error(`Cannot apply test "odd" to type: ${operand.type}`);
                    }
                    return operand.value % 2 !== 0;
                  }
                ],
                [
                  "even",
                  (operand) => {
                    if (operand.type !== "NumericValue") {
                      throw new Error(`Cannot apply test "even" to type: ${operand.type}`);
                    }
                    return operand.value % 2 === 0;
                  }
                ],
                ["false", (operand) => operand.type === "BooleanValue" && !operand.value],
                ["true", (operand) => operand.type === "BooleanValue" && operand.value],
                ["number", (operand) => operand.type === "NumericValue"],
                ["integer", (operand) => operand.type === "NumericValue" && Number.isInteger(operand.value)],
                ["iterable", (operand) => operand instanceof ArrayValue || operand instanceof StringValue],
                [
                  "lower",
                  (operand) => {
                    const str = operand.value;
                    return operand.type === "StringValue" && str === str.toLowerCase();
                  }
                ],
                [
                  "upper",
                  (operand) => {
                    const str = operand.value;
                    return operand.type === "StringValue" && str === str.toUpperCase();
                  }
                ],
                ["none", (operand) => operand.type === "NullValue"],
                ["defined", (operand) => operand.type !== "UndefinedValue"],
                ["undefined", (operand) => operand.type === "UndefinedValue"],
                ["equalto", (a, b) => a.value === b.value]
              ]));
              this.parent = parent;
            }
            /**
             * Set the value of a variable in the current environment.
             */
            set(name2, value) {
              return this.declareVariable(name2, convertToRuntimeValues(value));
            }
            declareVariable(name2, value) {
              if (this.variables.has(name2)) {
                throw new SyntaxError(`Variable already declared: ${name2}`);
              }
              this.variables.set(name2, value);
              return value;
            }
            // private assignVariable(name: string, value: AnyRuntimeValue): AnyRuntimeValue {
            // 	const env = this.resolve(name);
            // 	env.variables.set(name, value);
            // 	return value;
            // }
            /**
             * Set variable in the current scope.
             * See https://jinja.palletsprojects.com/en/3.0.x/templates/#assignments for more information.
             */
            setVariable(name2, value) {
              this.variables.set(name2, value);
              return value;
            }
            /**
             * Resolve the environment in which the variable is declared.
             * @param {string} name The name of the variable.
             * @returns {Environment} The environment in which the variable is declared.
             */
            resolve(name2) {
              if (this.variables.has(name2)) {
                return this;
              }
              if (this.parent) {
                return this.parent.resolve(name2);
              }
              throw new Error(`Unknown variable: ${name2}`);
            }
            lookupVariable(name2) {
              try {
                return this.resolve(name2).variables.get(name2) ?? new UndefinedValue();
              } catch {
                return new UndefinedValue();
              }
            }
          };
          var Interpreter = class {
            constructor(env) {
              __publicField(this, "global");
              this.global = env ?? new Environment();
            }
            /**
             * Run the program.
             */
            run(program) {
              return this.evaluate(program, this.global);
            }
            /**
             * Evaluates expressions following the binary operation type.
             */
            evaluateBinaryExpression(node, environment) {
              const left = this.evaluate(node.left, environment);
              switch (node.operator.value) {
                case "and":
                  return left.__bool__().value ? this.evaluate(node.right, environment) : left;
                case "or":
                  return left.__bool__().value ? left : this.evaluate(node.right, environment);
              }
              const right = this.evaluate(node.right, environment);
              switch (node.operator.value) {
                case "==":
                  return new BooleanValue(left.value == right.value);
                case "!=":
                  return new BooleanValue(left.value != right.value);
              }
              if (left instanceof UndefinedValue || right instanceof UndefinedValue) {
                throw new Error("Cannot perform operation on undefined values");
              } else if (left instanceof NullValue || right instanceof NullValue) {
                throw new Error("Cannot perform operation on null values");
              } else if (left instanceof NumericValue && right instanceof NumericValue) {
                switch (node.operator.value) {
                  case "+":
                    return new NumericValue(left.value + right.value);
                  case "-":
                    return new NumericValue(left.value - right.value);
                  case "*":
                    return new NumericValue(left.value * right.value);
                  case "/":
                    return new NumericValue(left.value / right.value);
                  case "%":
                    return new NumericValue(left.value % right.value);
                  case "<":
                    return new BooleanValue(left.value < right.value);
                  case ">":
                    return new BooleanValue(left.value > right.value);
                  case ">=":
                    return new BooleanValue(left.value >= right.value);
                  case "<=":
                    return new BooleanValue(left.value <= right.value);
                }
              } else if (left instanceof ArrayValue && right instanceof ArrayValue) {
                switch (node.operator.value) {
                  case "+":
                    return new ArrayValue(left.value.concat(right.value));
                }
              } else if (right instanceof ArrayValue) {
                const member = right.value.find((x) => x.value === left.value) !== void 0;
                switch (node.operator.value) {
                  case "in":
                    return new BooleanValue(member);
                  case "not in":
                    return new BooleanValue(!member);
                }
              }
              if (left instanceof StringValue || right instanceof StringValue) {
                switch (node.operator.value) {
                  case "+":
                    return new StringValue(left.value.toString() + right.value.toString());
                }
              }
              if (left instanceof StringValue && right instanceof StringValue) {
                switch (node.operator.value) {
                  case "in":
                    return new BooleanValue(right.value.includes(left.value));
                  case "not in":
                    return new BooleanValue(!right.value.includes(left.value));
                }
              }
              if (left instanceof StringValue && right instanceof ObjectValue) {
                switch (node.operator.value) {
                  case "in":
                    return new BooleanValue(right.value.has(left.value));
                  case "not in":
                    return new BooleanValue(!right.value.has(left.value));
                }
              }
              throw new SyntaxError(`Unknown operator "${node.operator.value}" between ${left.type} and ${right.type}`);
            }
            /**
             * Evaluates expressions following the filter operation type.
             */
            evaluateFilterExpression(node, environment) {
              const operand = this.evaluate(node.operand, environment);
              if (node.filter.type === "Identifier") {
                const filter = node.filter;
                if (operand instanceof ArrayValue) {
                  switch (filter.value) {
                    case "list":
                      return operand;
                    case "first":
                      return operand.value[0];
                    case "last":
                      return operand.value[operand.value.length - 1];
                    case "length":
                      return new NumericValue(operand.value.length);
                    case "reverse":
                      return new ArrayValue(operand.value.reverse());
                    case "sort":
                      return new ArrayValue(
                        operand.value.sort((a, b) => {
                          if (a.type !== b.type) {
                            throw new Error(`Cannot compare different types: ${a.type} and ${b.type}`);
                          }
                          switch (a.type) {
                            case "NumericValue":
                              return a.value - b.value;
                            case "StringValue":
                              return a.value.localeCompare(b.value);
                            default:
                              throw new Error(`Cannot compare type: ${a.type}`);
                          }
                        })
                      );
                    default:
                      throw new Error(`Unknown ArrayValue filter: ${filter.value}`);
                  }
                } else if (operand instanceof StringValue) {
                  switch (filter.value) {
                    case "length":
                      return new NumericValue(operand.value.length);
                    case "upper":
                      return new StringValue(operand.value.toUpperCase());
                    case "lower":
                      return new StringValue(operand.value.toLowerCase());
                    case "title":
                      return new StringValue(titleCase(operand.value));
                    case "capitalize":
                      return new StringValue(operand.value.charAt(0).toUpperCase() + operand.value.slice(1));
                    case "trim":
                      return new StringValue(operand.value.trim());
                    default:
                      throw new Error(`Unknown StringValue filter: ${filter.value}`);
                  }
                } else if (operand instanceof NumericValue) {
                  switch (filter.value) {
                    case "abs":
                      return new NumericValue(Math.abs(operand.value));
                    default:
                      throw new Error(`Unknown NumericValue filter: ${filter.value}`);
                  }
                } else if (operand instanceof ObjectValue) {
                  switch (filter.value) {
                    case "items":
                      return new ArrayValue(
                        Array.from(operand.value.entries()).map(([key, value]) => new ArrayValue([new StringValue(key), value]))
                      );
                    case "length":
                      return new NumericValue(operand.value.size);
                    default:
                      throw new Error(`Unknown ObjectValue filter: ${filter.value}`);
                  }
                }
                throw new Error(`Cannot apply filter "${filter.value}" to type: ${operand.type}`);
              } else if (node.filter.type === "CallExpression") {
                const filter = node.filter;
                if (filter.callee.type !== "Identifier") {
                  throw new Error(`Unknown filter: ${filter.callee.type}`);
                }
                const filterName = filter.callee.value;
                if (operand instanceof ArrayValue) {
                  switch (filterName) {
                    case "selectattr": {
                      if (operand.value.some((x) => !(x instanceof ObjectValue))) {
                        throw new Error("`selectattr` can only be applied to array of objects");
                      }
                      if (filter.args.some((x) => x.type !== "StringLiteral")) {
                        throw new Error("arguments of `selectattr` must be strings");
                      }
                      const [attr, testName, value] = filter.args.map((x) => this.evaluate(x, environment));
                      let testFunction;
                      if (testName) {
                        const test2 = environment.tests.get(testName.value);
                        if (!test2) {
                          throw new Error(`Unknown test: ${testName.value}`);
                        }
                        testFunction = test2;
                      } else {
                        testFunction = (...x) => x[0].__bool__().value;
                      }
                      const filtered = operand.value.filter((item) => {
                        const a = item.value.get(attr.value);
                        if (a) {
                          return testFunction(a, value);
                        }
                        return false;
                      });
                      return new ArrayValue(filtered);
                    }
                  }
                  throw new Error(`Unknown ArrayValue filter: ${filterName}`);
                } else {
                  throw new Error(`Cannot apply filter "${filterName}" to type: ${operand.type}`);
                }
              }
              throw new Error(`Unknown filter: ${node.filter.type}`);
            }
            /**
             * Evaluates expressions following the test operation type.
             */
            evaluateTestExpression(node, environment) {
              const operand = this.evaluate(node.operand, environment);
              const test2 = environment.tests.get(node.test.value);
              if (!test2) {
                throw new Error(`Unknown test: ${node.test.value}`);
              }
              const result = test2(operand);
              return new BooleanValue(node.negate ? !result : result);
            }
            /**
             * Evaluates expressions following the unary operation type.
             */
            evaluateUnaryExpression(node, environment) {
              const argument = this.evaluate(node.argument, environment);
              switch (node.operator.value) {
                case "not":
                  return new BooleanValue(!argument.value);
                default:
                  throw new SyntaxError(`Unknown operator: ${node.operator.value}`);
              }
            }
            evalProgram(program, environment) {
              return this.evaluateBlock(program.body, environment);
            }
            evaluateBlock(statements, environment) {
              let result = "";
              for (const statement of statements) {
                const lastEvaluated = this.evaluate(statement, environment);
                if (lastEvaluated.type !== "NullValue" && lastEvaluated.type !== "UndefinedValue") {
                  result += lastEvaluated.value;
                }
              }
              return new StringValue(result);
            }
            evaluateIdentifier(node, environment) {
              return environment.lookupVariable(node.value);
            }
            evaluateCallExpression(expr, environment) {
              const args = [];
              const kwargs = /* @__PURE__ */ new Map();
              for (const argument of expr.args) {
                if (argument.type === "KeywordArgumentExpression") {
                  const kwarg = argument;
                  kwargs.set(kwarg.key.value, this.evaluate(kwarg.value, environment));
                } else {
                  args.push(this.evaluate(argument, environment));
                }
              }
              if (kwargs.size > 0) {
                args.push(new ObjectValue(kwargs));
              }
              const fn = this.evaluate(expr.callee, environment);
              if (fn.type !== "FunctionValue") {
                throw new Error(`Cannot call something that is not a function: got ${fn.type}`);
              }
              return fn.value(args, environment);
            }
            evaluateSliceExpression(object, expr, environment) {
              if (!(object instanceof ArrayValue || object instanceof StringValue)) {
                throw new Error("Slice object must be an array or string");
              }
              const start = this.evaluate(expr.start, environment);
              const stop = this.evaluate(expr.stop, environment);
              const step = this.evaluate(expr.step, environment);
              if (!(start instanceof NumericValue || start instanceof UndefinedValue)) {
                throw new Error("Slice start must be numeric or undefined");
              }
              if (!(stop instanceof NumericValue || stop instanceof UndefinedValue)) {
                throw new Error("Slice stop must be numeric or undefined");
              }
              if (!(step instanceof NumericValue || step instanceof UndefinedValue)) {
                throw new Error("Slice step must be numeric or undefined");
              }
              if (object instanceof ArrayValue) {
                return new ArrayValue(slice(object.value, start.value, stop.value, step.value));
              } else {
                return new StringValue(slice(Array.from(object.value), start.value, stop.value, step.value).join(""));
              }
            }
            evaluateMemberExpression(expr, environment) {
              const object = this.evaluate(expr.object, environment);
              let property;
              if (expr.computed) {
                if (expr.property.type === "SliceExpression") {
                  return this.evaluateSliceExpression(object, expr.property, environment);
                } else {
                  property = this.evaluate(expr.property, environment);
                }
              } else {
                property = new StringValue(expr.property.value);
              }
              let value;
              if (object instanceof ObjectValue) {
                if (!(property instanceof StringValue)) {
                  throw new Error(`Cannot access property with non-string: got ${property.type}`);
                }
                value = object.value.get(property.value) ?? object.builtins.get(property.value);
              } else if (object instanceof ArrayValue || object instanceof StringValue) {
                if (property instanceof NumericValue) {
                  value = object.value.at(property.value);
                  if (object instanceof StringValue) {
                    value = new StringValue(object.value.at(property.value));
                  }
                } else if (property instanceof StringValue) {
                  value = object.builtins.get(property.value);
                } else {
                  throw new Error(`Cannot access property with non-string/non-number: got ${property.type}`);
                }
              } else {
                if (!(property instanceof StringValue)) {
                  throw new Error(`Cannot access property with non-string: got ${property.type}`);
                }
                value = object.builtins.get(property.value);
              }
              return value instanceof RuntimeValue ? value : new UndefinedValue();
            }
            evaluateSet(node, environment) {
              const rhs = this.evaluate(node.value, environment);
              if (node.assignee.type === "Identifier") {
                const variableName = node.assignee.value;
                environment.setVariable(variableName, rhs);
              } else if (node.assignee.type === "MemberExpression") {
                const member = node.assignee;
                const object = this.evaluate(member.object, environment);
                if (!(object instanceof ObjectValue)) {
                  throw new Error("Cannot assign to member of non-object");
                }
                if (member.property.type !== "Identifier") {
                  throw new Error("Cannot assign to member with non-identifier property");
                }
                object.value.set(member.property.value, rhs);
              } else {
                throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(node.assignee)}`);
              }
              return new NullValue();
            }
            evaluateIf(node, environment) {
              const test2 = this.evaluate(node.test, environment);
              return this.evaluateBlock(test2.__bool__().value ? node.body : node.alternate, environment);
            }
            evaluateFor(node, environment) {
              const scope = new Environment(environment);
              const iterable = this.evaluate(node.iterable, scope);
              if (!(iterable instanceof ArrayValue)) {
                throw new Error(`Expected iterable type in for loop: got ${iterable.type}`);
              }
              let result = "";
              for (let i = 0; i < iterable.value.length; ++i) {
                const loop = /* @__PURE__ */ new Map([
                  ["index", new NumericValue(i + 1)],
                  ["index0", new NumericValue(i)],
                  ["revindex", new NumericValue(iterable.value.length - i)],
                  ["revindex0", new NumericValue(iterable.value.length - i - 1)],
                  ["first", new BooleanValue(i === 0)],
                  ["last", new BooleanValue(i === iterable.value.length - 1)],
                  ["length", new NumericValue(iterable.value.length)],
                  ["previtem", i > 0 ? iterable.value[i - 1] : new UndefinedValue()],
                  ["nextitem", i < iterable.value.length - 1 ? iterable.value[i + 1] : new UndefinedValue()]
                ]);
                scope.setVariable("loop", new ObjectValue(loop));
                const current = iterable.value[i];
                if (node.loopvar.type === "Identifier") {
                  scope.setVariable(node.loopvar.value, current);
                } else if (node.loopvar.type === "TupleLiteral") {
                  const loopvar = node.loopvar;
                  if (current.type !== "ArrayValue") {
                    throw new Error(`Cannot unpack non-iterable type: ${current.type}`);
                  }
                  const c = current;
                  if (loopvar.value.length !== c.value.length) {
                    throw new Error(`Too ${loopvar.value.length > c.value.length ? "few" : "many"} items to unpack`);
                  }
                  for (let j = 0; j < loopvar.value.length; ++j) {
                    if (loopvar.value[j].type !== "Identifier") {
                      throw new Error(`Cannot unpack non-identifier type: ${loopvar.value[j].type}`);
                    }
                    scope.setVariable(loopvar.value[j].value, c.value[j]);
                  }
                }
                const evaluated = this.evaluateBlock(node.body, scope);
                result += evaluated.value;
              }
              return new StringValue(result);
            }
            evaluate(statement, environment) {
              if (statement === void 0)
                return new UndefinedValue();
              switch (statement.type) {
                case "Program":
                  return this.evalProgram(statement, environment);
                case "Set":
                  return this.evaluateSet(statement, environment);
                case "If":
                  return this.evaluateIf(statement, environment);
                case "For":
                  return this.evaluateFor(statement, environment);
                case "NumericLiteral":
                  return new NumericValue(Number(statement.value));
                case "StringLiteral":
                  return new StringValue(statement.value);
                case "BooleanLiteral":
                  return new BooleanValue(statement.value);
                case "ArrayLiteral":
                  return new ArrayValue(statement.value.map((x) => this.evaluate(x, environment)));
                case "TupleLiteral":
                  return new TupleValue(statement.value.map((x) => this.evaluate(x, environment)));
                case "ObjectLiteral": {
                  const mapping = /* @__PURE__ */ new Map();
                  for (const [key, value] of statement.value) {
                    const evaluatedKey = this.evaluate(key, environment);
                    if (!(evaluatedKey instanceof StringValue)) {
                      throw new Error(`Object keys must be strings: got ${evaluatedKey.type}`);
                    }
                    mapping.set(evaluatedKey.value, this.evaluate(value, environment));
                  }
                  return new ObjectValue(mapping);
                }
                case "Identifier":
                  return this.evaluateIdentifier(statement, environment);
                case "CallExpression":
                  return this.evaluateCallExpression(statement, environment);
                case "MemberExpression":
                  return this.evaluateMemberExpression(statement, environment);
                case "UnaryExpression":
                  return this.evaluateUnaryExpression(statement, environment);
                case "BinaryExpression":
                  return this.evaluateBinaryExpression(statement, environment);
                case "FilterExpression":
                  return this.evaluateFilterExpression(statement, environment);
                case "TestExpression":
                  return this.evaluateTestExpression(statement, environment);
                default:
                  throw new SyntaxError(`Unknown node type: ${statement.type}`);
              }
            }
          };
          function convertToRuntimeValues(input) {
            switch (typeof input) {
              case "number":
                return new NumericValue(input);
              case "string":
                return new StringValue(input);
              case "boolean":
                return new BooleanValue(input);
              case "object":
                if (input === null) {
                  return new NullValue();
                } else if (Array.isArray(input)) {
                  return new ArrayValue(input.map(convertToRuntimeValues));
                } else {
                  return new ObjectValue(
                    new Map(Object.entries(input).map(([key, value]) => [key, convertToRuntimeValues(value)]))
                  );
                }
              case "function":
                return new FunctionValue((args, _scope) => {
                  const result = input(...args.map((x) => x.value)) ?? null;
                  return convertToRuntimeValues(result);
                });
              default:
                throw new Error(`Cannot convert to runtime value: ${input}`);
            }
          }
          var Template = class {
            /**
             * @param {string} template The template string
             */
            constructor(template) {
              __publicField(this, "parsed");
              const tokens = tokenize4(template, {
                lstrip_blocks: true,
                trim_blocks: true
              });
              this.parsed = parse(tokens);
            }
            render(items) {
              const env = new Environment();
              env.set("false", false);
              env.set("true", true);
              env.set("raise_exception", (args) => {
                throw new Error(args);
              });
              env.set("range", range);
              for (const [key, value] of Object.entries(items)) {
                env.set(key, value);
              }
              const interpreter = new Interpreter(env);
              const result = interpreter.run(this.parsed);
              return result.value;
            }
          };
        }
      ),
      /***/
      "./src/backends/onnx.js": (
        /*!******************************!*\
          !*** ./src/backends/onnx.js ***!
          \******************************/
        /***/
        (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__3) => {
          var onnxruntime_node__WEBPACK_IMPORTED_MODULE_0___namespace_cache;
          var onnxruntime_web__WEBPACK_IMPORTED_MODULE_1___namespace_cache;
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "ONNX": () => (
              /* binding */
              ONNX
            ),
            /* harmony export */
            "executionProviders": () => (
              /* binding */
              executionProviders
            )
            /* harmony export */
          });
          var onnxruntime_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__3(
            /*! onnxruntime-node */
            "?2ce3"
          );
          var onnxruntime_web__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__3(
            /*! onnxruntime-web */
            "./node_modules/onnxruntime-web/dist/ort-web.min.js"
          );
          let ONNX;
          const executionProviders = [
            // 'webgpu',
            "wasm"
          ];
          if (typeof process !== "undefined" && process?.release?.name === "node") {
            ONNX = onnxruntime_node__WEBPACK_IMPORTED_MODULE_0__ ?? (onnxruntime_node__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (onnxruntime_node__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__3.t(onnxruntime_node__WEBPACK_IMPORTED_MODULE_0__, 2)));
            executionProviders.unshift("cpu");
          } else {
            ONNX = onnxruntime_web__WEBPACK_IMPORTED_MODULE_1__ ?? (onnxruntime_web__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (onnxruntime_web__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__3.t(onnxruntime_web__WEBPACK_IMPORTED_MODULE_1__, 2)));
            const isIOS = typeof navigator !== "undefined" && /iP(hone|od|ad).+16_4.+AppleWebKit/.test(navigator.userAgent);
            if (isIOS) {
              ONNX.env.wasm.simd = false;
            }
          }
        }
      ),
      /***/
      "./src/configs.js": (
        /*!************************!*\
          !*** ./src/configs.js ***!
          \************************/
        /***/
        (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "AutoConfig": () => (
              /* binding */
              AutoConfig
            ),
            /* harmony export */
            "PretrainedConfig": () => (
              /* binding */
              PretrainedConfig
            )
            /* harmony export */
          });
          var _utils_hub_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__3(
            /*! ./utils/hub.js */
            "./src/utils/hub.js"
          );
          async function loadConfig(pretrained_model_name_or_path, options) {
            let info = await (0, _utils_hub_js__WEBPACK_IMPORTED_MODULE_0__.getModelJSON)(pretrained_model_name_or_path, "config.json", true, options);
            return info;
          }
          class PretrainedConfig {
            // NOTE: Typo in original
            /**
             * Create a new PreTrainedTokenizer instance.
             * @param {Object} configJSON The JSON of the config.
             */
            constructor(configJSON) {
              this.model_type = null;
              this.is_encoder_decoder = false;
              Object.assign(this, configJSON);
            }
            /**
             * Loads a pre-trained config from the given `pretrained_model_name_or_path`. 
             * 
             * @param {string} pretrained_model_name_or_path The path to the pre-trained config.
             * @param {PretrainedOptions} options Additional options for loading the config.
             * @throws {Error} Throws an error if the config.json is not found in the `pretrained_model_name_or_path`.
             * 
             * @returns {Promise<PretrainedConfig>} A new instance of the `PretrainedConfig` class.
             */
            static async from_pretrained(pretrained_model_name_or_path, {
              progress_callback = null,
              config: config2 = null,
              cache_dir = null,
              local_files_only = false,
              revision = "main"
            } = {}) {
              let data = config2 ?? await loadConfig(pretrained_model_name_or_path, {
                progress_callback,
                config: config2,
                cache_dir,
                local_files_only,
                revision
              });
              return new this(data);
            }
          }
          class AutoConfig {
            /** @type {PretrainedConfig.from_pretrained} */
            static async from_pretrained(...args) {
              return PretrainedConfig.from_pretrained(...args);
            }
          }
        }
      ),
      /***/
      "./src/env.js": (
        /*!********************!*\
          !*** ./src/env.js ***!
          \********************/
        /***/
        (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "env": () => (
              /* binding */
              env
            )
            /* harmony export */
          });
          var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__3(
            /*! fs */
            "?569f"
          );
          var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__3(
            /*! path */
            "?3f59"
          );
          var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__3(
            /*! url */
            "?154a"
          );
          var _backends_onnx_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__3(
            /*! ./backends/onnx.js */
            "./src/backends/onnx.js"
          );
          const { env: onnx_env } = _backends_onnx_js__WEBPACK_IMPORTED_MODULE_3__.ONNX;
          const VERSION = "2.17.2";
          const WEB_CACHE_AVAILABLE = typeof self !== "undefined" && "caches" in self;
          const FS_AVAILABLE = !isEmpty2(fs__WEBPACK_IMPORTED_MODULE_0__);
          const PATH_AVAILABLE = !isEmpty2(path__WEBPACK_IMPORTED_MODULE_1__);
          const RUNNING_LOCALLY = FS_AVAILABLE && PATH_AVAILABLE;
          const __dirname = RUNNING_LOCALLY ? path__WEBPACK_IMPORTED_MODULE_1__.dirname(path__WEBPACK_IMPORTED_MODULE_1__.dirname(url__WEBPACK_IMPORTED_MODULE_2__.fileURLToPath("file:///home/runner/work/transformers.js/transformers.js/src/env.js"))) : "./";
          const DEFAULT_CACHE_DIR = RUNNING_LOCALLY ? path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname, "/.cache/") : null;
          const DEFAULT_LOCAL_MODEL_PATH = "/models/";
          const localModelPath = RUNNING_LOCALLY ? path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname, DEFAULT_LOCAL_MODEL_PATH) : DEFAULT_LOCAL_MODEL_PATH;
          if (onnx_env?.wasm) {
            onnx_env.wasm.wasmPaths = RUNNING_LOCALLY ? path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname, "/dist/") : `https://cdn.jsdelivr.net/npm/@xenova/transformers@${VERSION}/dist/`;
          }
          const env = {
            /////////////////// Backends settings ///////////////////
            backends: {
              // onnxruntime-web/onnxruntime-node
              onnx: onnx_env,
              // TensorFlow.js
              tfjs: {}
            },
            __dirname,
            version: VERSION,
            /////////////////// Model settings ///////////////////
            allowRemoteModels: true,
            remoteHost: "https://huggingface.co/",
            remotePathTemplate: "{model}/resolve/{revision}/",
            allowLocalModels: true,
            localModelPath,
            useFS: FS_AVAILABLE,
            /////////////////// Cache settings ///////////////////
            useBrowserCache: WEB_CACHE_AVAILABLE,
            useFSCache: FS_AVAILABLE,
            cacheDir: DEFAULT_CACHE_DIR,
            useCustomCache: false,
            customCache: null
            //////////////////////////////////////////////////////
          };
          function isEmpty2(obj) {
            return Object.keys(obj).length === 0;
          }
        }
      ),
      /***/
      "./src/models.js": (
        /*!***********************!*\
          !*** ./src/models.js ***!
          \***********************/
        /***/
        (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "ASTForAudioClassification": () => (
              /* binding */
              ASTForAudioClassification
            ),
            /* harmony export */
            "ASTModel": () => (
              /* binding */
              ASTModel
            ),
            /* harmony export */
            "ASTPreTrainedModel": () => (
              /* binding */
              ASTPreTrainedModel
            ),
            /* harmony export */
            "AlbertForMaskedLM": () => (
              /* binding */
              AlbertForMaskedLM
            ),
            /* harmony export */
            "AlbertForQuestionAnswering": () => (
              /* binding */
              AlbertForQuestionAnswering
            ),
            /* harmony export */
            "AlbertForSequenceClassification": () => (
              /* binding */
              AlbertForSequenceClassification
            ),
            /* harmony export */
            "AlbertModel": () => (
              /* binding */
              AlbertModel
            ),
            /* harmony export */
            "AlbertPreTrainedModel": () => (
              /* binding */
              AlbertPreTrainedModel
            ),
            /* harmony export */
            "AutoModel": () => (
              /* binding */
              AutoModel
            ),
            /* harmony export */
            "AutoModelForAudioClassification": () => (
              /* binding */
              AutoModelForAudioClassification
            ),
            /* harmony export */
            "AutoModelForAudioFrameClassification": () => (
              /* binding */
              AutoModelForAudioFrameClassification
            ),
            /* harmony export */
            "AutoModelForCTC": () => (
              /* binding */
              AutoModelForCTC
            ),
            /* harmony export */
            "AutoModelForCausalLM": () => (
              /* binding */
              AutoModelForCausalLM
            ),
            /* harmony export */
            "AutoModelForDepthEstimation": () => (
              /* binding */
              AutoModelForDepthEstimation
            ),
            /* harmony export */
            "AutoModelForDocumentQuestionAnswering": () => (
              /* binding */
              AutoModelForDocumentQuestionAnswering
            ),
            /* harmony export */
            "AutoModelForImageClassification": () => (
              /* binding */
              AutoModelForImageClassification
            ),
            /* harmony export */
            "AutoModelForImageFeatureExtraction": () => (
              /* binding */
              AutoModelForImageFeatureExtraction
            ),
            /* harmony export */
            "AutoModelForImageMatting": () => (
              /* binding */
              AutoModelForImageMatting
            ),
            /* harmony export */
            "AutoModelForImageSegmentation": () => (
              /* binding */
              AutoModelForImageSegmentation
            ),
            /* harmony export */
            "AutoModelForImageToImage": () => (
              /* binding */
              AutoModelForImageToImage
            ),
            /* harmony export */
            "AutoModelForMaskGeneration": () => (
              /* binding */
              AutoModelForMaskGeneration
            ),
            /* harmony export */
            "AutoModelForMaskedLM": () => (
              /* binding */
              AutoModelForMaskedLM
            ),
            /* harmony export */
            "AutoModelForObjectDetection": () => (
              /* binding */
              AutoModelForObjectDetection
            ),
            /* harmony export */
            "AutoModelForQuestionAnswering": () => (
              /* binding */
              AutoModelForQuestionAnswering
            ),
            /* harmony export */
            "AutoModelForSemanticSegmentation": () => (
              /* binding */
              AutoModelForSemanticSegmentation
            ),
            /* harmony export */
            "AutoModelForSeq2SeqLM": () => (
              /* binding */
              AutoModelForSeq2SeqLM
            ),
            /* harmony export */
            "AutoModelForSequenceClassification": () => (
              /* binding */
              AutoModelForSequenceClassification
            ),
            /* harmony export */
            "AutoModelForSpeechSeq2Seq": () => (
              /* binding */
              AutoModelForSpeechSeq2Seq
            ),
            /* harmony export */
            "AutoModelForTextToSpectrogram": () => (
              /* binding */
              AutoModelForTextToSpectrogram
            ),
            /* harmony export */
            "AutoModelForTextToWaveform": () => (
              /* binding */
              AutoModelForTextToWaveform
            ),
            /* harmony export */
            "AutoModelForTokenClassification": () => (
              /* binding */
              AutoModelForTokenClassification
            ),
            /* harmony export */
            "AutoModelForVision2Seq": () => (
              /* binding */
              AutoModelForVision2Seq
            ),
            /* harmony export */
            "AutoModelForXVector": () => (
              /* binding */
              AutoModelForXVector
            ),
            /* harmony export */
            "AutoModelForZeroShotObjectDetection": () => (
              /* binding */
              AutoModelForZeroShotObjectDetection
            ),
            /* harmony export */
            "BartForConditionalGeneration": () => (
              /* binding */
              BartForConditionalGeneration
            ),
            /* harmony export */
            "BartForSequenceClassification": () => (
              /* binding */
              BartForSequenceClassification
            ),
            /* harmony export */
            "BartModel": () => (
              /* binding */
              BartModel
            ),
            /* harmony export */
            "BartPretrainedModel": () => (
              /* binding */
              BartPretrainedModel
            ),
            /* harmony export */
            "BaseModelOutput": () => (
              /* binding */
              BaseModelOutput
            ),
            /* harmony export */
            "BeitForImageClassification": () => (
              /* binding */
              BeitForImageClassification
            ),
            /* harmony export */
            "BeitModel": () => (
              /* binding */
              BeitModel
            ),
            /* harmony export */
            "BeitPreTrainedModel": () => (
              /* binding */
              BeitPreTrainedModel
            ),
            /* harmony export */
            "BertForMaskedLM": () => (
              /* binding */
              BertForMaskedLM
            ),
            /* harmony export */
            "BertForQuestionAnswering": () => (
              /* binding */
              BertForQuestionAnswering
            ),
            /* harmony export */
            "BertForSequenceClassification": () => (
              /* binding */
              BertForSequenceClassification
            ),
            /* harmony export */
            "BertForTokenClassification": () => (
              /* binding */
              BertForTokenClassification
            ),
            /* harmony export */
            "BertModel": () => (
              /* binding */
              BertModel
            ),
            /* harmony export */
            "BertPreTrainedModel": () => (
              /* binding */
              BertPreTrainedModel
            ),
            /* harmony export */
            "BlenderbotForConditionalGeneration": () => (
              /* binding */
              BlenderbotForConditionalGeneration
            ),
            /* harmony export */
            "BlenderbotModel": () => (
              /* binding */
              BlenderbotModel
            ),
            /* harmony export */
            "BlenderbotPreTrainedModel": () => (
              /* binding */
              BlenderbotPreTrainedModel
            ),
            /* harmony export */
            "BlenderbotSmallForConditionalGeneration": () => (
              /* binding */
              BlenderbotSmallForConditionalGeneration
            ),
            /* harmony export */
            "BlenderbotSmallModel": () => (
              /* binding */
              BlenderbotSmallModel
            ),
            /* harmony export */
            "BlenderbotSmallPreTrainedModel": () => (
              /* binding */
              BlenderbotSmallPreTrainedModel
            ),
            /* harmony export */
            "BloomForCausalLM": () => (
              /* binding */
              BloomForCausalLM
            ),
            /* harmony export */
            "BloomModel": () => (
              /* binding */
              BloomModel
            ),
            /* harmony export */
            "BloomPreTrainedModel": () => (
              /* binding */
              BloomPreTrainedModel
            ),
            /* harmony export */
            "CLIPModel": () => (
              /* binding */
              CLIPModel
            ),
            /* harmony export */
            "CLIPPreTrainedModel": () => (
              /* binding */
              CLIPPreTrainedModel
            ),
            /* harmony export */
            "CLIPSegForImageSegmentation": () => (
              /* binding */
              CLIPSegForImageSegmentation
            ),
            /* harmony export */
            "CLIPSegModel": () => (
              /* binding */
              CLIPSegModel
            ),
            /* harmony export */
            "CLIPSegPreTrainedModel": () => (
              /* binding */
              CLIPSegPreTrainedModel
            ),
            /* harmony export */
            "CLIPTextModelWithProjection": () => (
              /* binding */
              CLIPTextModelWithProjection
            ),
            /* harmony export */
            "CLIPVisionModelWithProjection": () => (
              /* binding */
              CLIPVisionModelWithProjection
            ),
            /* harmony export */
            "CamembertForMaskedLM": () => (
              /* binding */
              CamembertForMaskedLM
            ),
            /* harmony export */
            "CamembertForQuestionAnswering": () => (
              /* binding */
              CamembertForQuestionAnswering
            ),
            /* harmony export */
            "CamembertForSequenceClassification": () => (
              /* binding */
              CamembertForSequenceClassification
            ),
            /* harmony export */
            "CamembertForTokenClassification": () => (
              /* binding */
              CamembertForTokenClassification
            ),
            /* harmony export */
            "CamembertModel": () => (
              /* binding */
              CamembertModel
            ),
            /* harmony export */
            "CamembertPreTrainedModel": () => (
              /* binding */
              CamembertPreTrainedModel
            ),
            /* harmony export */
            "CausalLMOutput": () => (
              /* binding */
              CausalLMOutput
            ),
            /* harmony export */
            "CausalLMOutputWithPast": () => (
              /* binding */
              CausalLMOutputWithPast
            ),
            /* harmony export */
            "ChineseCLIPModel": () => (
              /* binding */
              ChineseCLIPModel
            ),
            /* harmony export */
            "ChineseCLIPPreTrainedModel": () => (
              /* binding */
              ChineseCLIPPreTrainedModel
            ),
            /* harmony export */
            "ClapAudioModelWithProjection": () => (
              /* binding */
              ClapAudioModelWithProjection
            ),
            /* harmony export */
            "ClapModel": () => (
              /* binding */
              ClapModel
            ),
            /* harmony export */
            "ClapPreTrainedModel": () => (
              /* binding */
              ClapPreTrainedModel
            ),
            /* harmony export */
            "ClapTextModelWithProjection": () => (
              /* binding */
              ClapTextModelWithProjection
            ),
            /* harmony export */
            "CodeGenForCausalLM": () => (
              /* binding */
              CodeGenForCausalLM
            ),
            /* harmony export */
            "CodeGenModel": () => (
              /* binding */
              CodeGenModel
            ),
            /* harmony export */
            "CodeGenPreTrainedModel": () => (
              /* binding */
              CodeGenPreTrainedModel
            ),
            /* harmony export */
            "ConvBertForMaskedLM": () => (
              /* binding */
              ConvBertForMaskedLM
            ),
            /* harmony export */
            "ConvBertForQuestionAnswering": () => (
              /* binding */
              ConvBertForQuestionAnswering
            ),
            /* harmony export */
            "ConvBertForSequenceClassification": () => (
              /* binding */
              ConvBertForSequenceClassification
            ),
            /* harmony export */
            "ConvBertForTokenClassification": () => (
              /* binding */
              ConvBertForTokenClassification
            ),
            /* harmony export */
            "ConvBertModel": () => (
              /* binding */
              ConvBertModel
            ),
            /* harmony export */
            "ConvBertPreTrainedModel": () => (
              /* binding */
              ConvBertPreTrainedModel
            ),
            /* harmony export */
            "ConvNextForImageClassification": () => (
              /* binding */
              ConvNextForImageClassification
            ),
            /* harmony export */
            "ConvNextModel": () => (
              /* binding */
              ConvNextModel
            ),
            /* harmony export */
            "ConvNextPreTrainedModel": () => (
              /* binding */
              ConvNextPreTrainedModel
            ),
            /* harmony export */
            "ConvNextV2ForImageClassification": () => (
              /* binding */
              ConvNextV2ForImageClassification
            ),
            /* harmony export */
            "ConvNextV2Model": () => (
              /* binding */
              ConvNextV2Model
            ),
            /* harmony export */
            "ConvNextV2PreTrainedModel": () => (
              /* binding */
              ConvNextV2PreTrainedModel
            ),
            /* harmony export */
            "DPTForDepthEstimation": () => (
              /* binding */
              DPTForDepthEstimation
            ),
            /* harmony export */
            "DPTModel": () => (
              /* binding */
              DPTModel
            ),
            /* harmony export */
            "DPTPreTrainedModel": () => (
              /* binding */
              DPTPreTrainedModel
            ),
            /* harmony export */
            "DebertaForMaskedLM": () => (
              /* binding */
              DebertaForMaskedLM
            ),
            /* harmony export */
            "DebertaForQuestionAnswering": () => (
              /* binding */
              DebertaForQuestionAnswering
            ),
            /* harmony export */
            "DebertaForSequenceClassification": () => (
              /* binding */
              DebertaForSequenceClassification
            ),
            /* harmony export */
            "DebertaForTokenClassification": () => (
              /* binding */
              DebertaForTokenClassification
            ),
            /* harmony export */
            "DebertaModel": () => (
              /* binding */
              DebertaModel
            ),
            /* harmony export */
            "DebertaPreTrainedModel": () => (
              /* binding */
              DebertaPreTrainedModel
            ),
            /* harmony export */
            "DebertaV2ForMaskedLM": () => (
              /* binding */
              DebertaV2ForMaskedLM
            ),
            /* harmony export */
            "DebertaV2ForQuestionAnswering": () => (
              /* binding */
              DebertaV2ForQuestionAnswering
            ),
            /* harmony export */
            "DebertaV2ForSequenceClassification": () => (
              /* binding */
              DebertaV2ForSequenceClassification
            ),
            /* harmony export */
            "DebertaV2ForTokenClassification": () => (
              /* binding */
              DebertaV2ForTokenClassification
            ),
            /* harmony export */
            "DebertaV2Model": () => (
              /* binding */
              DebertaV2Model
            ),
            /* harmony export */
            "DebertaV2PreTrainedModel": () => (
              /* binding */
              DebertaV2PreTrainedModel
            ),
            /* harmony export */
            "DeiTForImageClassification": () => (
              /* binding */
              DeiTForImageClassification
            ),
            /* harmony export */
            "DeiTModel": () => (
              /* binding */
              DeiTModel
            ),
            /* harmony export */
            "DeiTPreTrainedModel": () => (
              /* binding */
              DeiTPreTrainedModel
            ),
            /* harmony export */
            "DepthAnythingForDepthEstimation": () => (
              /* binding */
              DepthAnythingForDepthEstimation
            ),
            /* harmony export */
            "DepthAnythingPreTrainedModel": () => (
              /* binding */
              DepthAnythingPreTrainedModel
            ),
            /* harmony export */
            "DetrForObjectDetection": () => (
              /* binding */
              DetrForObjectDetection
            ),
            /* harmony export */
            "DetrForSegmentation": () => (
              /* binding */
              DetrForSegmentation
            ),
            /* harmony export */
            "DetrModel": () => (
              /* binding */
              DetrModel
            ),
            /* harmony export */
            "DetrObjectDetectionOutput": () => (
              /* binding */
              DetrObjectDetectionOutput
            ),
            /* harmony export */
            "DetrPreTrainedModel": () => (
              /* binding */
              DetrPreTrainedModel
            ),
            /* harmony export */
            "DetrSegmentationOutput": () => (
              /* binding */
              DetrSegmentationOutput
            ),
            /* harmony export */
            "Dinov2ForImageClassification": () => (
              /* binding */
              Dinov2ForImageClassification
            ),
            /* harmony export */
            "Dinov2Model": () => (
              /* binding */
              Dinov2Model
            ),
            /* harmony export */
            "Dinov2PreTrainedModel": () => (
              /* binding */
              Dinov2PreTrainedModel
            ),
            /* harmony export */
            "DistilBertForMaskedLM": () => (
              /* binding */
              DistilBertForMaskedLM
            ),
            /* harmony export */
            "DistilBertForQuestionAnswering": () => (
              /* binding */
              DistilBertForQuestionAnswering
            ),
            /* harmony export */
            "DistilBertForSequenceClassification": () => (
              /* binding */
              DistilBertForSequenceClassification
            ),
            /* harmony export */
            "DistilBertForTokenClassification": () => (
              /* binding */
              DistilBertForTokenClassification
            ),
            /* harmony export */
            "DistilBertModel": () => (
              /* binding */
              DistilBertModel
            ),
            /* harmony export */
            "DistilBertPreTrainedModel": () => (
              /* binding */
              DistilBertPreTrainedModel
            ),
            /* harmony export */
            "DonutSwinModel": () => (
              /* binding */
              DonutSwinModel
            ),
            /* harmony export */
            "DonutSwinPreTrainedModel": () => (
              /* binding */
              DonutSwinPreTrainedModel
            ),
            /* harmony export */
            "EfficientNetForImageClassification": () => (
              /* binding */
              EfficientNetForImageClassification
            ),
            /* harmony export */
            "EfficientNetModel": () => (
              /* binding */
              EfficientNetModel
            ),
            /* harmony export */
            "EfficientNetPreTrainedModel": () => (
              /* binding */
              EfficientNetPreTrainedModel
            ),
            /* harmony export */
            "ElectraForMaskedLM": () => (
              /* binding */
              ElectraForMaskedLM
            ),
            /* harmony export */
            "ElectraForQuestionAnswering": () => (
              /* binding */
              ElectraForQuestionAnswering
            ),
            /* harmony export */
            "ElectraForSequenceClassification": () => (
              /* binding */
              ElectraForSequenceClassification
            ),
            /* harmony export */
            "ElectraForTokenClassification": () => (
              /* binding */
              ElectraForTokenClassification
            ),
            /* harmony export */
            "ElectraModel": () => (
              /* binding */
              ElectraModel
            ),
            /* harmony export */
            "ElectraPreTrainedModel": () => (
              /* binding */
              ElectraPreTrainedModel
            ),
            /* harmony export */
            "EsmForMaskedLM": () => (
              /* binding */
              EsmForMaskedLM
            ),
            /* harmony export */
            "EsmForSequenceClassification": () => (
              /* binding */
              EsmForSequenceClassification
            ),
            /* harmony export */
            "EsmForTokenClassification": () => (
              /* binding */
              EsmForTokenClassification
            ),
            /* harmony export */
            "EsmModel": () => (
              /* binding */
              EsmModel
            ),
            /* harmony export */
            "EsmPreTrainedModel": () => (
              /* binding */
              EsmPreTrainedModel
            ),
            /* harmony export */
            "FalconForCausalLM": () => (
              /* binding */
              FalconForCausalLM
            ),
            /* harmony export */
            "FalconModel": () => (
              /* binding */
              FalconModel
            ),
            /* harmony export */
            "FalconPreTrainedModel": () => (
              /* binding */
              FalconPreTrainedModel
            ),
            /* harmony export */
            "FastViTForImageClassification": () => (
              /* binding */
              FastViTForImageClassification
            ),
            /* harmony export */
            "FastViTModel": () => (
              /* binding */
              FastViTModel
            ),
            /* harmony export */
            "FastViTPreTrainedModel": () => (
              /* binding */
              FastViTPreTrainedModel
            ),
            /* harmony export */
            "GLPNForDepthEstimation": () => (
              /* binding */
              GLPNForDepthEstimation
            ),
            /* harmony export */
            "GLPNModel": () => (
              /* binding */
              GLPNModel
            ),
            /* harmony export */
            "GLPNPreTrainedModel": () => (
              /* binding */
              GLPNPreTrainedModel
            ),
            /* harmony export */
            "GPT2LMHeadModel": () => (
              /* binding */
              GPT2LMHeadModel
            ),
            /* harmony export */
            "GPT2Model": () => (
              /* binding */
              GPT2Model
            ),
            /* harmony export */
            "GPT2PreTrainedModel": () => (
              /* binding */
              GPT2PreTrainedModel
            ),
            /* harmony export */
            "GPTBigCodeForCausalLM": () => (
              /* binding */
              GPTBigCodeForCausalLM
            ),
            /* harmony export */
            "GPTBigCodeModel": () => (
              /* binding */
              GPTBigCodeModel
            ),
            /* harmony export */
            "GPTBigCodePreTrainedModel": () => (
              /* binding */
              GPTBigCodePreTrainedModel
            ),
            /* harmony export */
            "GPTJForCausalLM": () => (
              /* binding */
              GPTJForCausalLM
            ),
            /* harmony export */
            "GPTJModel": () => (
              /* binding */
              GPTJModel
            ),
            /* harmony export */
            "GPTJPreTrainedModel": () => (
              /* binding */
              GPTJPreTrainedModel
            ),
            /* harmony export */
            "GPTNeoForCausalLM": () => (
              /* binding */
              GPTNeoForCausalLM
            ),
            /* harmony export */
            "GPTNeoModel": () => (
              /* binding */
              GPTNeoModel
            ),
            /* harmony export */
            "GPTNeoPreTrainedModel": () => (
              /* binding */
              GPTNeoPreTrainedModel
            ),
            /* harmony export */
            "GPTNeoXForCausalLM": () => (
              /* binding */
              GPTNeoXForCausalLM
            ),
            /* harmony export */
            "GPTNeoXModel": () => (
              /* binding */
              GPTNeoXModel
            ),
            /* harmony export */
            "GPTNeoXPreTrainedModel": () => (
              /* binding */
              GPTNeoXPreTrainedModel
            ),
            /* harmony export */
            "HubertForCTC": () => (
              /* binding */
              HubertForCTC
            ),
            /* harmony export */
            "HubertForSequenceClassification": () => (
              /* binding */
              HubertForSequenceClassification
            ),
            /* harmony export */
            "HubertModel": () => (
              /* binding */
              HubertModel
            ),
            /* harmony export */
            "HubertPreTrainedModel": () => (
              /* binding */
              HubertPreTrainedModel
            ),
            /* harmony export */
            "ImageMattingOutput": () => (
              /* binding */
              ImageMattingOutput
            ),
            /* harmony export */
            "LlamaForCausalLM": () => (
              /* binding */
              LlamaForCausalLM
            ),
            /* harmony export */
            "LlamaModel": () => (
              /* binding */
              LlamaModel
            ),
            /* harmony export */
            "LlamaPreTrainedModel": () => (
              /* binding */
              LlamaPreTrainedModel
            ),
            /* harmony export */
            "LongT5ForConditionalGeneration": () => (
              /* binding */
              LongT5ForConditionalGeneration
            ),
            /* harmony export */
            "LongT5Model": () => (
              /* binding */
              LongT5Model
            ),
            /* harmony export */
            "LongT5PreTrainedModel": () => (
              /* binding */
              LongT5PreTrainedModel
            ),
            /* harmony export */
            "M2M100ForConditionalGeneration": () => (
              /* binding */
              M2M100ForConditionalGeneration
            ),
            /* harmony export */
            "M2M100Model": () => (
              /* binding */
              M2M100Model
            ),
            /* harmony export */
            "M2M100PreTrainedModel": () => (
              /* binding */
              M2M100PreTrainedModel
            ),
            /* harmony export */
            "MBartForCausalLM": () => (
              /* binding */
              MBartForCausalLM
            ),
            /* harmony export */
            "MBartForConditionalGeneration": () => (
              /* binding */
              MBartForConditionalGeneration
            ),
            /* harmony export */
            "MBartForSequenceClassification": () => (
              /* binding */
              MBartForSequenceClassification
            ),
            /* harmony export */
            "MBartModel": () => (
              /* binding */
              MBartModel
            ),
            /* harmony export */
            "MBartPreTrainedModel": () => (
              /* binding */
              MBartPreTrainedModel
            ),
            /* harmony export */
            "MPNetForMaskedLM": () => (
              /* binding */
              MPNetForMaskedLM
            ),
            /* harmony export */
            "MPNetForQuestionAnswering": () => (
              /* binding */
              MPNetForQuestionAnswering
            ),
            /* harmony export */
            "MPNetForSequenceClassification": () => (
              /* binding */
              MPNetForSequenceClassification
            ),
            /* harmony export */
            "MPNetForTokenClassification": () => (
              /* binding */
              MPNetForTokenClassification
            ),
            /* harmony export */
            "MPNetModel": () => (
              /* binding */
              MPNetModel
            ),
            /* harmony export */
            "MPNetPreTrainedModel": () => (
              /* binding */
              MPNetPreTrainedModel
            ),
            /* harmony export */
            "MT5ForConditionalGeneration": () => (
              /* binding */
              MT5ForConditionalGeneration
            ),
            /* harmony export */
            "MT5Model": () => (
              /* binding */
              MT5Model
            ),
            /* harmony export */
            "MT5PreTrainedModel": () => (
              /* binding */
              MT5PreTrainedModel
            ),
            /* harmony export */
            "MarianMTModel": () => (
              /* binding */
              MarianMTModel
            ),
            /* harmony export */
            "MarianModel": () => (
              /* binding */
              MarianModel
            ),
            /* harmony export */
            "MarianPreTrainedModel": () => (
              /* binding */
              MarianPreTrainedModel
            ),
            /* harmony export */
            "MaskedLMOutput": () => (
              /* binding */
              MaskedLMOutput
            ),
            /* harmony export */
            "MistralForCausalLM": () => (
              /* binding */
              MistralForCausalLM
            ),
            /* harmony export */
            "MistralModel": () => (
              /* binding */
              MistralModel
            ),
            /* harmony export */
            "MistralPreTrainedModel": () => (
              /* binding */
              MistralPreTrainedModel
            ),
            /* harmony export */
            "MobileBertForMaskedLM": () => (
              /* binding */
              MobileBertForMaskedLM
            ),
            /* harmony export */
            "MobileBertForQuestionAnswering": () => (
              /* binding */
              MobileBertForQuestionAnswering
            ),
            /* harmony export */
            "MobileBertForSequenceClassification": () => (
              /* binding */
              MobileBertForSequenceClassification
            ),
            /* harmony export */
            "MobileBertModel": () => (
              /* binding */
              MobileBertModel
            ),
            /* harmony export */
            "MobileBertPreTrainedModel": () => (
              /* binding */
              MobileBertPreTrainedModel
            ),
            /* harmony export */
            "MobileViTForImageClassification": () => (
              /* binding */
              MobileViTForImageClassification
            ),
            /* harmony export */
            "MobileViTModel": () => (
              /* binding */
              MobileViTModel
            ),
            /* harmony export */
            "MobileViTPreTrainedModel": () => (
              /* binding */
              MobileViTPreTrainedModel
            ),
            /* harmony export */
            "MobileViTV2ForImageClassification": () => (
              /* binding */
              MobileViTV2ForImageClassification
            ),
            /* harmony export */
            "MobileViTV2Model": () => (
              /* binding */
              MobileViTV2Model
            ),
            /* harmony export */
            "MobileViTV2PreTrainedModel": () => (
              /* binding */
              MobileViTV2PreTrainedModel
            ),
            /* harmony export */
            "ModelOutput": () => (
              /* binding */
              ModelOutput
            ),
            /* harmony export */
            "MptForCausalLM": () => (
              /* binding */
              MptForCausalLM
            ),
            /* harmony export */
            "MptModel": () => (
              /* binding */
              MptModel
            ),
            /* harmony export */
            "MptPreTrainedModel": () => (
              /* binding */
              MptPreTrainedModel
            ),
            /* harmony export */
            "NomicBertModel": () => (
              /* binding */
              NomicBertModel
            ),
            /* harmony export */
            "NomicBertPreTrainedModel": () => (
              /* binding */
              NomicBertPreTrainedModel
            ),
            /* harmony export */
            "OPTForCausalLM": () => (
              /* binding */
              OPTForCausalLM
            ),
            /* harmony export */
            "OPTModel": () => (
              /* binding */
              OPTModel
            ),
            /* harmony export */
            "OPTPreTrainedModel": () => (
              /* binding */
              OPTPreTrainedModel
            ),
            /* harmony export */
            "OwlViTForObjectDetection": () => (
              /* binding */
              OwlViTForObjectDetection
            ),
            /* harmony export */
            "OwlViTModel": () => (
              /* binding */
              OwlViTModel
            ),
            /* harmony export */
            "OwlViTPreTrainedModel": () => (
              /* binding */
              OwlViTPreTrainedModel
            ),
            /* harmony export */
            "Owlv2ForObjectDetection": () => (
              /* binding */
              Owlv2ForObjectDetection
            ),
            /* harmony export */
            "Owlv2Model": () => (
              /* binding */
              Owlv2Model
            ),
            /* harmony export */
            "Owlv2PreTrainedModel": () => (
              /* binding */
              Owlv2PreTrainedModel
            ),
            /* harmony export */
            "PhiForCausalLM": () => (
              /* binding */
              PhiForCausalLM
            ),
            /* harmony export */
            "PhiModel": () => (
              /* binding */
              PhiModel
            ),
            /* harmony export */
            "PhiPreTrainedModel": () => (
              /* binding */
              PhiPreTrainedModel
            ),
            /* harmony export */
            "PreTrainedModel": () => (
              /* binding */
              PreTrainedModel
            ),
            /* harmony export */
            "PretrainedMixin": () => (
              /* binding */
              PretrainedMixin
            ),
            /* harmony export */
            "QuestionAnsweringModelOutput": () => (
              /* binding */
              QuestionAnsweringModelOutput
            ),
            /* harmony export */
            "Qwen2ForCausalLM": () => (
              /* binding */
              Qwen2ForCausalLM
            ),
            /* harmony export */
            "Qwen2Model": () => (
              /* binding */
              Qwen2Model
            ),
            /* harmony export */
            "Qwen2PreTrainedModel": () => (
              /* binding */
              Qwen2PreTrainedModel
            ),
            /* harmony export */
            "ResNetForImageClassification": () => (
              /* binding */
              ResNetForImageClassification
            ),
            /* harmony export */
            "ResNetModel": () => (
              /* binding */
              ResNetModel
            ),
            /* harmony export */
            "ResNetPreTrainedModel": () => (
              /* binding */
              ResNetPreTrainedModel
            ),
            /* harmony export */
            "RoFormerForMaskedLM": () => (
              /* binding */
              RoFormerForMaskedLM
            ),
            /* harmony export */
            "RoFormerForQuestionAnswering": () => (
              /* binding */
              RoFormerForQuestionAnswering
            ),
            /* harmony export */
            "RoFormerForSequenceClassification": () => (
              /* binding */
              RoFormerForSequenceClassification
            ),
            /* harmony export */
            "RoFormerForTokenClassification": () => (
              /* binding */
              RoFormerForTokenClassification
            ),
            /* harmony export */
            "RoFormerModel": () => (
              /* binding */
              RoFormerModel
            ),
            /* harmony export */
            "RoFormerPreTrainedModel": () => (
              /* binding */
              RoFormerPreTrainedModel
            ),
            /* harmony export */
            "RobertaForMaskedLM": () => (
              /* binding */
              RobertaForMaskedLM
            ),
            /* harmony export */
            "RobertaForQuestionAnswering": () => (
              /* binding */
              RobertaForQuestionAnswering
            ),
            /* harmony export */
            "RobertaForSequenceClassification": () => (
              /* binding */
              RobertaForSequenceClassification
            ),
            /* harmony export */
            "RobertaForTokenClassification": () => (
              /* binding */
              RobertaForTokenClassification
            ),
            /* harmony export */
            "RobertaModel": () => (
              /* binding */
              RobertaModel
            ),
            /* harmony export */
            "RobertaPreTrainedModel": () => (
              /* binding */
              RobertaPreTrainedModel
            ),
            /* harmony export */
            "SamImageSegmentationOutput": () => (
              /* binding */
              SamImageSegmentationOutput
            ),
            /* harmony export */
            "SamModel": () => (
              /* binding */
              SamModel
            ),
            /* harmony export */
            "SamPreTrainedModel": () => (
              /* binding */
              SamPreTrainedModel
            ),
            /* harmony export */
            "SegformerForImageClassification": () => (
              /* binding */
              SegformerForImageClassification
            ),
            /* harmony export */
            "SegformerForSemanticSegmentation": () => (
              /* binding */
              SegformerForSemanticSegmentation
            ),
            /* harmony export */
            "SegformerModel": () => (
              /* binding */
              SegformerModel
            ),
            /* harmony export */
            "SegformerPreTrainedModel": () => (
              /* binding */
              SegformerPreTrainedModel
            ),
            /* harmony export */
            "Seq2SeqLMOutput": () => (
              /* binding */
              Seq2SeqLMOutput
            ),
            /* harmony export */
            "SequenceClassifierOutput": () => (
              /* binding */
              SequenceClassifierOutput
            ),
            /* harmony export */
            "SiglipModel": () => (
              /* binding */
              SiglipModel
            ),
            /* harmony export */
            "SiglipPreTrainedModel": () => (
              /* binding */
              SiglipPreTrainedModel
            ),
            /* harmony export */
            "SiglipTextModel": () => (
              /* binding */
              SiglipTextModel
            ),
            /* harmony export */
            "SiglipVisionModel": () => (
              /* binding */
              SiglipVisionModel
            ),
            /* harmony export */
            "SpeechT5ForSpeechToText": () => (
              /* binding */
              SpeechT5ForSpeechToText
            ),
            /* harmony export */
            "SpeechT5ForTextToSpeech": () => (
              /* binding */
              SpeechT5ForTextToSpeech
            ),
            /* harmony export */
            "SpeechT5HifiGan": () => (
              /* binding */
              SpeechT5HifiGan
            ),
            /* harmony export */
            "SpeechT5Model": () => (
              /* binding */
              SpeechT5Model
            ),
            /* harmony export */
            "SpeechT5PreTrainedModel": () => (
              /* binding */
              SpeechT5PreTrainedModel
            ),
            /* harmony export */
            "SqueezeBertForMaskedLM": () => (
              /* binding */
              SqueezeBertForMaskedLM
            ),
            /* harmony export */
            "SqueezeBertForQuestionAnswering": () => (
              /* binding */
              SqueezeBertForQuestionAnswering
            ),
            /* harmony export */
            "SqueezeBertForSequenceClassification": () => (
              /* binding */
              SqueezeBertForSequenceClassification
            ),
            /* harmony export */
            "SqueezeBertModel": () => (
              /* binding */
              SqueezeBertModel
            ),
            /* harmony export */
            "SqueezeBertPreTrainedModel": () => (
              /* binding */
              SqueezeBertPreTrainedModel
            ),
            /* harmony export */
            "StableLmForCausalLM": () => (
              /* binding */
              StableLmForCausalLM
            ),
            /* harmony export */
            "StableLmModel": () => (
              /* binding */
              StableLmModel
            ),
            /* harmony export */
            "StableLmPreTrainedModel": () => (
              /* binding */
              StableLmPreTrainedModel
            ),
            /* harmony export */
            "Starcoder2ForCausalLM": () => (
              /* binding */
              Starcoder2ForCausalLM
            ),
            /* harmony export */
            "Starcoder2Model": () => (
              /* binding */
              Starcoder2Model
            ),
            /* harmony export */
            "Starcoder2PreTrainedModel": () => (
              /* binding */
              Starcoder2PreTrainedModel
            ),
            /* harmony export */
            "Swin2SRForImageSuperResolution": () => (
              /* binding */
              Swin2SRForImageSuperResolution
            ),
            /* harmony export */
            "Swin2SRModel": () => (
              /* binding */
              Swin2SRModel
            ),
            /* harmony export */
            "Swin2SRPreTrainedModel": () => (
              /* binding */
              Swin2SRPreTrainedModel
            ),
            /* harmony export */
            "SwinForImageClassification": () => (
              /* binding */
              SwinForImageClassification
            ),
            /* harmony export */
            "SwinModel": () => (
              /* binding */
              SwinModel
            ),
            /* harmony export */
            "SwinPreTrainedModel": () => (
              /* binding */
              SwinPreTrainedModel
            ),
            /* harmony export */
            "T5ForConditionalGeneration": () => (
              /* binding */
              T5ForConditionalGeneration
            ),
            /* harmony export */
            "T5Model": () => (
              /* binding */
              T5Model
            ),
            /* harmony export */
            "T5PreTrainedModel": () => (
              /* binding */
              T5PreTrainedModel
            ),
            /* harmony export */
            "TableTransformerForObjectDetection": () => (
              /* binding */
              TableTransformerForObjectDetection
            ),
            /* harmony export */
            "TableTransformerModel": () => (
              /* binding */
              TableTransformerModel
            ),
            /* harmony export */
            "TableTransformerObjectDetectionOutput": () => (
              /* binding */
              TableTransformerObjectDetectionOutput
            ),
            /* harmony export */
            "TableTransformerPreTrainedModel": () => (
              /* binding */
              TableTransformerPreTrainedModel
            ),
            /* harmony export */
            "TokenClassifierOutput": () => (
              /* binding */
              TokenClassifierOutput
            ),
            /* harmony export */
            "TrOCRForCausalLM": () => (
              /* binding */
              TrOCRForCausalLM
            ),
            /* harmony export */
            "TrOCRPreTrainedModel": () => (
              /* binding */
              TrOCRPreTrainedModel
            ),
            /* harmony export */
            "UniSpeechForCTC": () => (
              /* binding */
              UniSpeechForCTC
            ),
            /* harmony export */
            "UniSpeechForSequenceClassification": () => (
              /* binding */
              UniSpeechForSequenceClassification
            ),
            /* harmony export */
            "UniSpeechModel": () => (
              /* binding */
              UniSpeechModel
            ),
            /* harmony export */
            "UniSpeechPreTrainedModel": () => (
              /* binding */
              UniSpeechPreTrainedModel
            ),
            /* harmony export */
            "UniSpeechSatForAudioFrameClassification": () => (
              /* binding */
              UniSpeechSatForAudioFrameClassification
            ),
            /* harmony export */
            "UniSpeechSatForCTC": () => (
              /* binding */
              UniSpeechSatForCTC
            ),
            /* harmony export */
            "UniSpeechSatForSequenceClassification": () => (
              /* binding */
              UniSpeechSatForSequenceClassification
            ),
            /* harmony export */
            "UniSpeechSatModel": () => (
              /* binding */
              UniSpeechSatModel
            ),
            /* harmony export */
            "UniSpeechSatPreTrainedModel": () => (
              /* binding */
              UniSpeechSatPreTrainedModel
            ),
            /* harmony export */
            "ViTForImageClassification": () => (
              /* binding */
              ViTForImageClassification
            ),
            /* harmony export */
            "ViTModel": () => (
              /* binding */
              ViTModel
            ),
            /* harmony export */
            "ViTPreTrainedModel": () => (
              /* binding */
              ViTPreTrainedModel
            ),
            /* harmony export */
            "VisionEncoderDecoderModel": () => (
              /* binding */
              VisionEncoderDecoderModel
            ),
            /* harmony export */
            "VitMatteForImageMatting": () => (
              /* binding */
              VitMatteForImageMatting
            ),
            /* harmony export */
            "VitMattePreTrainedModel": () => (
              /* binding */
              VitMattePreTrainedModel
            ),
            /* harmony export */
            "VitsModel": () => (
              /* binding */
              VitsModel
            ),
            /* harmony export */
            "VitsModelOutput": () => (
              /* binding */
              VitsModelOutput
            ),
            /* harmony export */
            "VitsPreTrainedModel": () => (
              /* binding */
              VitsPreTrainedModel
            ),
            /* harmony export */
            "Wav2Vec2BertForCTC": () => (
              /* binding */
              Wav2Vec2BertForCTC
            ),
            /* harmony export */
            "Wav2Vec2BertForSequenceClassification": () => (
              /* binding */
              Wav2Vec2BertForSequenceClassification
            ),
            /* harmony export */
            "Wav2Vec2BertModel": () => (
              /* binding */
              Wav2Vec2BertModel
            ),
            /* harmony export */
            "Wav2Vec2BertPreTrainedModel": () => (
              /* binding */
              Wav2Vec2BertPreTrainedModel
            ),
            /* harmony export */
            "Wav2Vec2ForAudioFrameClassification": () => (
              /* binding */
              Wav2Vec2ForAudioFrameClassification
            ),
            /* harmony export */
            "Wav2Vec2ForCTC": () => (
              /* binding */
              Wav2Vec2ForCTC
            ),
            /* harmony export */
            "Wav2Vec2ForSequenceClassification": () => (
              /* binding */
              Wav2Vec2ForSequenceClassification
            ),
            /* harmony export */
            "Wav2Vec2Model": () => (
              /* binding */
              Wav2Vec2Model
            ),
            /* harmony export */
            "Wav2Vec2PreTrainedModel": () => (
              /* binding */
              Wav2Vec2PreTrainedModel
            ),
            /* harmony export */
            "WavLMForAudioFrameClassification": () => (
              /* binding */
              WavLMForAudioFrameClassification
            ),
            /* harmony export */
            "WavLMForCTC": () => (
              /* binding */
              WavLMForCTC
            ),
            /* harmony export */
            "WavLMForSequenceClassification": () => (
              /* binding */
              WavLMForSequenceClassification
            ),
            /* harmony export */
            "WavLMForXVector": () => (
              /* binding */
              WavLMForXVector
            ),
            /* harmony export */
            "WavLMModel": () => (
              /* binding */
              WavLMModel
            ),
            /* harmony export */
            "WavLMPreTrainedModel": () => (
              /* binding */
              WavLMPreTrainedModel
            ),
            /* harmony export */
            "WhisperForConditionalGeneration": () => (
              /* binding */
              WhisperForConditionalGeneration
            ),
            /* harmony export */
            "WhisperModel": () => (
              /* binding */
              WhisperModel
            ),
            /* harmony export */
            "WhisperPreTrainedModel": () => (
              /* binding */
              WhisperPreTrainedModel
            ),
            /* harmony export */
            "XLMForQuestionAnswering": () => (
              /* binding */
              XLMForQuestionAnswering
            ),
            /* harmony export */
            "XLMForSequenceClassification": () => (
              /* binding */
              XLMForSequenceClassification
            ),
            /* harmony export */
            "XLMForTokenClassification": () => (
              /* binding */
              XLMForTokenClassification
            ),
            /* harmony export */
            "XLMModel": () => (
              /* binding */
              XLMModel
            ),
            /* harmony export */
            "XLMPreTrainedModel": () => (
              /* binding */
              XLMPreTrainedModel
            ),
            /* harmony export */
            "XLMRobertaForMaskedLM": () => (
              /* binding */
              XLMRobertaForMaskedLM
            ),
            /* harmony export */
            "XLMRobertaForQuestionAnswering": () => (
              /* binding */
              XLMRobertaForQuestionAnswering
            ),
            /* harmony export */
            "XLMRobertaForSequenceClassification": () => (
              /* binding */
              XLMRobertaForSequenceClassification
            ),
            /* harmony export */
            "XLMRobertaForTokenClassification": () => (
              /* binding */
              XLMRobertaForTokenClassification
            ),
            /* harmony export */
            "XLMRobertaModel": () => (
              /* binding */
              XLMRobertaModel
            ),
            /* harmony export */
            "XLMRobertaPreTrainedModel": () => (
              /* binding */
              XLMRobertaPreTrainedModel
            ),
            /* harmony export */
            "XLMWithLMHeadModel": () => (
              /* binding */
              XLMWithLMHeadModel
            ),
            /* harmony export */
            "XVectorOutput": () => (
              /* binding */
              XVectorOutput
            ),
            /* harmony export */
            "YolosForObjectDetection": () => (
              /* binding */
              YolosForObjectDetection
            ),
            /* harmony export */
            "YolosModel": () => (
              /* binding */
              YolosModel
            ),
            /* harmony export */
            "YolosObjectDetectionOutput": () => (
              /* binding */
              YolosObjectDetectionOutput
            ),
            /* harmony export */
            "YolosPreTrainedModel": () => (
              /* binding */
              YolosPreTrainedModel
            )
            /* harmony export */
          });
          var _configs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__3(
            /*! ./configs.js */
            "./src/configs.js"
          );
          var _utils_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__3(
            /*! ./utils/core.js */
            "./src/utils/core.js"
          );
          var _utils_hub_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__3(
            /*! ./utils/hub.js */
            "./src/utils/hub.js"
          );
          var _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__3(
            /*! ./utils/generation.js */
            "./src/utils/generation.js"
          );
          var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__3(
            /*! ./utils/tensor.js */
            "./src/utils/tensor.js"
          );
          var _backends_onnx_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__3(
            /*! ./backends/onnx.js */
            "./src/backends/onnx.js"
          );
          var _transformers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__3(
            /*! ./transformers.js */
            "./src/transformers.js"
          );
          const { InferenceSession, Tensor: ONNXTensor, env } = _backends_onnx_js__WEBPACK_IMPORTED_MODULE_5__.ONNX;
          const MODEL_TYPES = {
            EncoderOnly: 0,
            EncoderDecoder: 1,
            Seq2Seq: 2,
            Vision2Seq: 3,
            DecoderOnly: 4,
            MaskGeneration: 5
          };
          const MODEL_TYPE_MAPPING = /* @__PURE__ */ new Map();
          const MODEL_NAME_TO_CLASS_MAPPING = /* @__PURE__ */ new Map();
          const MODEL_CLASS_TO_NAME_MAPPING = /* @__PURE__ */ new Map();
          async function constructSession(pretrained_model_name_or_path, fileName, options) {
            let modelFileName = `onnx/${fileName}${options.quantized ? "_quantized" : ""}.onnx`;
            let buffer = await (0, _utils_hub_js__WEBPACK_IMPORTED_MODULE_2__.getModelFile)(pretrained_model_name_or_path, modelFileName, true, options);
            try {
              return await InferenceSession.create(buffer, {
                executionProviders: _backends_onnx_js__WEBPACK_IMPORTED_MODULE_5__.executionProviders
              });
            } catch (err) {
              if (_backends_onnx_js__WEBPACK_IMPORTED_MODULE_5__.executionProviders.length === 1 && _backends_onnx_js__WEBPACK_IMPORTED_MODULE_5__.executionProviders[0] === "wasm") {
                throw err;
              }
              console.warn(err);
              console.warn(
                "Something went wrong during model construction (most likely a missing operation). Using `wasm` as a fallback. "
              );
              return await InferenceSession.create(buffer, {
                executionProviders: ["wasm"]
              });
            }
          }
          function validateInputs(session, inputs) {
            const checkedInputs = /* @__PURE__ */ Object.create(null);
            const missingInputs = [];
            for (const inputName of session.inputNames) {
              const tensor = inputs[inputName];
              if (!(tensor instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor)) {
                missingInputs.push(inputName);
                continue;
              }
              checkedInputs[inputName] = env.wasm.proxy ? tensor.clone() : tensor;
            }
            if (missingInputs.length > 0) {
              throw new Error(
                `An error occurred during model execution: "Missing the following inputs: ${missingInputs.join(", ")}.`
              );
            }
            const numInputsProvided = Object.keys(inputs).length;
            const numInputsNeeded = session.inputNames.length;
            if (numInputsProvided > numInputsNeeded) {
              let ignored = Object.keys(inputs).filter((inputName) => !session.inputNames.includes(inputName));
              console.warn(`WARNING: Too many inputs were provided (${numInputsProvided} > ${numInputsNeeded}). The following inputs will be ignored: "${ignored.join(", ")}".`);
            }
            return checkedInputs;
          }
          async function sessionRun(session, inputs) {
            const checkedInputs = validateInputs(session, inputs);
            try {
              let output = await session.run(checkedInputs);
              output = replaceTensors(output);
              return output;
            } catch (e) {
              console.error(`An error occurred during model execution: "${e}".`);
              console.error("Inputs given to model:", checkedInputs);
              throw e;
            }
          }
          function replaceTensors(obj) {
            for (let prop in obj) {
              if (obj[prop] instanceof ONNXTensor) {
                obj[prop] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor(obj[prop]);
              } else if (typeof obj[prop] === "object") {
                replaceTensors(obj[prop]);
              }
            }
            return obj;
          }
          function toI64Tensor(items) {
            if (items instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor) {
              return items;
            }
            if (items.length === 0) {
              throw Error("items must be non-empty");
            }
            if (Array.isArray(items[0])) {
              if (items.some((x) => x.length !== items[0].length)) {
                throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");
              }
              return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor(
                "int64",
                BigInt64Array.from(items.flat().map((x) => BigInt(x))),
                [items.length, items[0].length]
              );
            } else {
              return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor(
                "int64",
                BigInt64Array.from(items.map((x) => BigInt(x))),
                [1, items.length]
              );
            }
          }
          function prepareAttentionMask(self2, tokens) {
            let pad_token_id = self2.config.pad_token_id ?? null;
            let eos_token_id = self2.config.eos_token_id ?? null;
            if ((0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.isIntegralNumber)(eos_token_id)) {
              eos_token_id = [eos_token_id];
            }
            let is_pad_token_in_inputs = tokens.indexOf(pad_token_id) !== -1;
            let is_pad_token_not_equal_to_eos_token_id = eos_token_id === null || !eos_token_id.includes(pad_token_id);
            if (is_pad_token_in_inputs && is_pad_token_not_equal_to_eos_token_id) {
              let data = BigInt64Array.from(
                // Note: != so that int matches bigint
                // @ts-ignore
                tokens.data.map((x) => x != pad_token_id)
              );
              return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("int64", data, tokens.dims);
            } else {
              return (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.ones_like)(tokens);
            }
          }
          function preparePositionIds(session, feeds, use_cache_branch) {
            if (!session.inputNames.includes("position_ids"))
              return;
            const data = new BigInt64Array(feeds.attention_mask.data.length);
            for (let i = 0; i < feeds.attention_mask.dims[0]; ++i) {
              let start = i * feeds.attention_mask.dims[1];
              let sum = BigInt(0);
              for (let j = 0; j < feeds.attention_mask.dims[1]; ++j) {
                const index = start + j;
                if (feeds.attention_mask.data[index] === 0n) {
                  data[index] = BigInt(1);
                } else {
                  data[index] = sum;
                  sum += feeds.attention_mask.data[index];
                }
              }
            }
            feeds.position_ids = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("int64", data, feeds.attention_mask.dims);
            if (use_cache_branch) {
              feeds.position_ids = feeds.position_ids.slice(null, -1).unsqueeze_(-1);
            }
          }
          function boolTensor(value) {
            return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("bool", [value], [1]);
          }
          async function seq2seqForward(self2, model_inputs) {
            let { encoder_outputs, past_key_values } = model_inputs;
            if (!encoder_outputs) {
              encoder_outputs = (await encoderForward(self2, model_inputs)).last_hidden_state;
            }
            let decoderFeeds = {
              input_ids: model_inputs.decoder_input_ids,
              encoder_hidden_states: encoder_outputs
            };
            const use_cache_branch = !!past_key_values;
            if (self2.decoder_merged_session.inputNames.includes("use_cache_branch")) {
              decoderFeeds.use_cache_branch = boolTensor(use_cache_branch);
            }
            if (self2.decoder_merged_session.inputNames.includes("encoder_attention_mask")) {
              decoderFeeds.encoder_attention_mask = model_inputs.attention_mask;
            }
            preparePositionIds(self2.decoder_merged_session, decoderFeeds, use_cache_branch);
            self2.addPastKeyValues(decoderFeeds, past_key_values);
            const decoderResults = await sessionRun(self2.decoder_merged_session, decoderFeeds);
            let logits = decoderResults.logits;
            past_key_values = self2.getPastKeyValues(decoderResults, past_key_values);
            const attns = self2.getAttentions(decoderResults);
            return new Seq2SeqLMOutput({ logits, past_key_values, encoder_outputs, ...attns });
          }
          function seq2seqStartBeams(self2, inputTokenIds, generation_config, numOutputTokens) {
            let beams = [];
            let beamId = 0;
            const requires_attention_mask = self2.requires_attention_mask ?? true;
            let decoder_input_ids = generation_config.decoder_input_ids ?? generation_config.decoder_start_token_id ?? generation_config.bos_token_id ?? generation_config.eos_token_id;
            if (decoder_input_ids instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor) {
              decoder_input_ids = decoder_input_ids.tolist().flat();
            } else if (!Array.isArray(decoder_input_ids)) {
              decoder_input_ids = [decoder_input_ids];
            }
            for (let tokens of inputTokenIds) {
              tokens.dims = [1, ...tokens.dims];
              let start = {
                inputs: tokens,
                encoder_outputs: null,
                prev_model_outputs: null,
                output_token_ids: decoder_input_ids,
                done: false,
                score: 0,
                id: beamId++
                // assign unique id to beams
              };
              if (requires_attention_mask) {
                start.attention_mask = prepareAttentionMask(self2, tokens);
              }
              beams.push(start);
            }
            return beams;
          }
          async function seq2seqRunBeam(self2, beam) {
            const input_name = self2.main_input_name;
            let decoder_input_ids = beam.output_token_ids;
            if (beam.prev_model_outputs) {
              decoder_input_ids = decoder_input_ids.slice(-1);
            }
            let model_inputs = {
              [input_name]: beam.inputs,
              decoder_input_ids: toI64Tensor(decoder_input_ids),
              encoder_outputs: beam.encoder_outputs,
              past_key_values: beam.prev_model_outputs?.past_key_values
            };
            if (beam.attention_mask) {
              model_inputs.attention_mask = beam.attention_mask;
            }
            let output = await self2.forward(model_inputs);
            beam.prev_model_outputs = output;
            beam.encoder_outputs = output.encoder_outputs;
            return output;
          }
          function seq2seqUpdatebeam(beam, newTokenId) {
            beam.output_token_ids = [...beam.output_token_ids, newTokenId];
          }
          async function encoderForward(self2, model_inputs) {
            const encoderFeeds = /* @__PURE__ */ Object.create(null);
            for (const key of self2.session.inputNames) {
              encoderFeeds[key] = model_inputs[key];
            }
            if (self2.session.inputNames.includes("token_type_ids") && !encoderFeeds.token_type_ids) {
              encoderFeeds.token_type_ids = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor(
                "int64",
                new BigInt64Array(encoderFeeds.input_ids.data.length),
                encoderFeeds.input_ids.dims
              );
            }
            return await sessionRun(self2.session, encoderFeeds);
          }
          async function decoderForward(self2, model_inputs) {
            let { input_ids, past_key_values, attention_mask } = model_inputs;
            let decoderFeeds = {
              input_ids,
              attention_mask: attention_mask ?? prepareAttentionMask(self2, input_ids)
            };
            const use_cache_branch = !!past_key_values;
            if (self2.session.inputNames.includes("use_cache_branch")) {
              decoderFeeds.use_cache_branch = boolTensor(use_cache_branch);
            }
            preparePositionIds(self2.session, decoderFeeds, use_cache_branch);
            self2.addPastKeyValues(decoderFeeds, past_key_values);
            let decoderResults = await sessionRun(self2.session, decoderFeeds);
            let logits = decoderResults.logits;
            past_key_values = self2.getPastKeyValues(decoderResults, past_key_values);
            return { logits, past_key_values };
          }
          function decoderStartBeams(self2, inputTokenIds, generation_config, numOutputTokens, inputs_attention_mask) {
            let beams = [];
            let beamId = 0;
            for (let tokens of inputTokenIds) {
              let output_token_ids = tokens.tolist().map(Number);
              tokens.dims = [1, ...tokens.dims];
              let attn_mask;
              if (inputs_attention_mask) {
                attn_mask = inputs_attention_mask[beamId];
                attn_mask.dims = [1, ...attn_mask.dims];
              } else {
                attn_mask = prepareAttentionMask(self2, tokens);
              }
              let start = {
                input: tokens,
                model_input_ids: tokens,
                attention_mask: attn_mask,
                prev_model_outputs: null,
                output_token_ids,
                num_output_tokens: numOutputTokens,
                done: false,
                score: 0,
                id: beamId++
                // assign unique id to beams
              };
              beams.push(start);
            }
            return beams;
          }
          async function decoderRunBeam(self2, beam) {
            let attnMaskData = new BigInt64Array(beam.output_token_ids.length).fill(1n);
            let model_inputs = {
              input_ids: beam.model_input_ids,
              attention_mask: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor(
                "int64",
                attnMaskData,
                [1, attnMaskData.length]
              ),
              past_key_values: beam.prev_model_outputs?.past_key_values
            };
            let output = await self2.forward(model_inputs);
            beam.prev_model_outputs = output;
            return output;
          }
          function decoderUpdatebeam(beam, newTokenId) {
            beam.output_token_ids = [...beam.output_token_ids, newTokenId];
            beam.model_input_ids = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("int64", [BigInt(newTokenId)], [1, 1]);
          }
          class PreTrainedModel extends _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.Callable {
            /**
             * Creates a new instance of the `PreTrainedModel` class.
             * @param {Object} config The model configuration.
             * @param {any} session session for the model.
             */
            constructor(config2, session) {
              super();
              __publicField(this, "main_input_name", "input_ids");
              this.config = config2;
              this.session = session;
              const modelName = MODEL_CLASS_TO_NAME_MAPPING.get(this.constructor);
              const modelType = MODEL_TYPE_MAPPING.get(modelName);
              this.can_generate = false;
              this._runBeam = null;
              this._getStartBeams = null;
              this._updateBeam = null;
              this._forward = null;
              if (modelType === MODEL_TYPES.DecoderOnly) {
                this.can_generate = true;
                this._runBeam = decoderRunBeam;
                this._getStartBeams = decoderStartBeams;
                this._updateBeam = decoderUpdatebeam;
                this._forward = decoderForward;
              } else if (modelType === MODEL_TYPES.Seq2Seq || modelType === MODEL_TYPES.Vision2Seq) {
                this.can_generate = true;
                this._runBeam = seq2seqRunBeam;
                this._getStartBeams = seq2seqStartBeams;
                this._updateBeam = seq2seqUpdatebeam;
                this._forward = seq2seqForward;
              } else if (modelType === MODEL_TYPES.EncoderDecoder) {
                this._forward = encoderForward;
              } else {
                this._forward = encoderForward;
              }
            }
            /**
            * Disposes of all the ONNX sessions that were created during inference.
            * @returns {Promise<unknown[]>} An array of promises, one for each ONNX session that is being disposed.
            * @todo Use https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry
            */
            async dispose() {
              const promises = [];
              for (let key of Object.keys(this)) {
                const item = this[key];
                if (item instanceof InferenceSession) {
                  promises.push(item.handler.dispose());
                }
              }
              return await Promise.all(promises);
            }
            /**
             * Instantiate one of the model classes of the library from a pretrained model.
             * 
             * The model class to instantiate is selected based on the `model_type` property of the config object
             * (either passed as an argument or loaded from `pretrained_model_name_or_path` if possible)
             * 
             * @param {string} pretrained_model_name_or_path The name or path of the pretrained model. Can be either:
             * - A string, the *model id* of a pretrained model hosted inside a model repo on huggingface.co.
             *   Valid model ids can be located at the root-level, like `bert-base-uncased`, or namespaced under a
             *   user or organization name, like `dbmdz/bert-base-german-cased`.
             * - A path to a *directory* containing model weights, e.g., `./my_model_directory/`.
             * @param {import('./utils/hub.js').PretrainedOptions} options Additional options for loading the model.
             * 
             * @returns {Promise<PreTrainedModel>} A new instance of the `PreTrainedModel` class.
             */
            static async from_pretrained(pretrained_model_name_or_path, {
              quantized = true,
              progress_callback = null,
              config: config2 = null,
              cache_dir = null,
              local_files_only = false,
              revision = "main",
              model_file_name = null
            } = {}) {
              let options = {
                quantized,
                progress_callback,
                config: config2,
                cache_dir,
                local_files_only,
                revision,
                model_file_name
              };
              const modelName = MODEL_CLASS_TO_NAME_MAPPING.get(this);
              const modelType = MODEL_TYPE_MAPPING.get(modelName);
              let info;
              if (modelType === MODEL_TYPES.DecoderOnly) {
                info = await Promise.all([
                  _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options),
                  constructSession(pretrained_model_name_or_path, options.model_file_name ?? "decoder_model_merged", options),
                  (0, _utils_hub_js__WEBPACK_IMPORTED_MODULE_2__.getModelJSON)(pretrained_model_name_or_path, "generation_config.json", false, options)
                ]);
              } else if (modelType === MODEL_TYPES.Seq2Seq || modelType === MODEL_TYPES.Vision2Seq) {
                info = await Promise.all([
                  _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options),
                  constructSession(pretrained_model_name_or_path, "encoder_model", options),
                  constructSession(pretrained_model_name_or_path, "decoder_model_merged", options),
                  (0, _utils_hub_js__WEBPACK_IMPORTED_MODULE_2__.getModelJSON)(pretrained_model_name_or_path, "generation_config.json", false, options)
                ]);
              } else if (modelType === MODEL_TYPES.MaskGeneration) {
                info = await Promise.all([
                  _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options),
                  constructSession(pretrained_model_name_or_path, "vision_encoder", options),
                  constructSession(pretrained_model_name_or_path, "prompt_encoder_mask_decoder", options)
                ]);
              } else if (modelType === MODEL_TYPES.EncoderDecoder) {
                info = await Promise.all([
                  _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options),
                  constructSession(pretrained_model_name_or_path, "encoder_model", options),
                  constructSession(pretrained_model_name_or_path, "decoder_model_merged", options)
                ]);
              } else {
                if (modelType !== MODEL_TYPES.EncoderOnly) {
                  console.warn(`Model type for '${modelName ?? config2?.model_type}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`);
                }
                info = await Promise.all([
                  _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options),
                  constructSession(pretrained_model_name_or_path, options.model_file_name ?? "model", options)
                ]);
              }
              return new this(...info);
            }
            /**
             * Runs the model with the provided inputs
             * @param {Object} model_inputs Object containing input tensors
             * @returns {Promise<Object>} Object containing output tensors
             */
            async _call(model_inputs) {
              return await this.forward(model_inputs);
            }
            /**
             * Forward method for a pretrained model. If not overridden by a subclass, the correct forward method
             * will be chosen based on the model type.
             * @param {Object} model_inputs The input data to the model in the format specified in the ONNX model.
             * @returns {Promise<Object>} The output data from the model in the format specified in the ONNX model.
             * @throws {Error} This method must be implemented in subclasses.
             */
            async forward(model_inputs) {
              return await this._forward(this, model_inputs);
            }
            /**
             * @param {import('./utils/generation.js').GenerationConfigType} generation_config 
             * @param {number} input_ids_seq_length The starting sequence length for the input ids.
             * @returns {LogitsProcessorList}
             * @private
             */
            _get_logits_processor(generation_config, input_ids_seq_length, logits_processor = null) {
              const processors = new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.LogitsProcessorList();
              if (generation_config.repetition_penalty !== null && generation_config.repetition_penalty !== 1) {
                processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.RepetitionPenaltyLogitsProcessor(generation_config.repetition_penalty));
              }
              if (generation_config.no_repeat_ngram_size !== null && generation_config.no_repeat_ngram_size > 0) {
                processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.NoRepeatNGramLogitsProcessor(generation_config.no_repeat_ngram_size));
              }
              if (generation_config.bad_words_ids !== null) {
                processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.NoBadWordsLogitsProcessor(generation_config.bad_words_ids, generation_config.eos_token_id));
              }
              if (generation_config.min_length !== null && generation_config.eos_token_id !== null && generation_config.min_length > 0) {
                processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.MinLengthLogitsProcessor(generation_config.min_length, generation_config.eos_token_id));
              }
              if (generation_config.min_new_tokens !== null && generation_config.eos_token_id !== null && generation_config.min_new_tokens > 0) {
                processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.MinNewTokensLengthLogitsProcessor(
                  input_ids_seq_length,
                  generation_config.min_new_tokens,
                  generation_config.eos_token_id
                ));
              }
              if (generation_config.forced_bos_token_id !== null) {
                processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.ForcedBOSTokenLogitsProcessor(generation_config.forced_bos_token_id));
              }
              if (generation_config.forced_eos_token_id !== null) {
                processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.ForcedEOSTokenLogitsProcessor(
                  generation_config.max_length,
                  generation_config.forced_eos_token_id
                ));
              }
              if (generation_config.begin_suppress_tokens !== null) {
                let begin_index = input_ids_seq_length > 1 || generation_config.forced_bos_token_id === null ? input_ids_seq_length : input_ids_seq_length + 1;
                if (generation_config.forced_decoder_ids !== null) {
                  begin_index += generation_config.forced_decoder_ids[generation_config.forced_decoder_ids.length - 1][0];
                }
                processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.SuppressTokensAtBeginLogitsProcessor(generation_config.begin_suppress_tokens, begin_index));
              }
              if (generation_config.forced_decoder_ids !== null) {
                processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.ForceTokensLogitsProcessor(generation_config.forced_decoder_ids));
              }
              if (logits_processor !== null) {
                processors.extend(logits_processor);
              }
              return processors;
            }
            /**
             * This function merges multiple generation configs together to form a final generation config to be used by the model for text generation.
             * It first creates an empty `GenerationConfig` object, then it applies the model's own `generation_config` property to it. Finally, if a `generation_config` object was passed in the arguments, it overwrites the corresponding properties in the final config with those of the passed config object.
             * @param {import('./utils/generation.js').GenerationConfigType} generation_config A `GenerationConfig` object containing generation parameters.
             * @returns {import('./utils/generation.js').GenerationConfigType} The final generation config object to be used by the model for text generation.
             */
            _get_generation_config(generation_config) {
              let gen_config = new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.GenerationConfig(this.config);
              if ("generation_config" in this) {
                Object.assign(gen_config, this.generation_config);
              }
              if (generation_config !== null) {
                Object.assign(gen_config, generation_config);
              }
              return gen_config;
            }
            /**
             * @typedef {import('./utils/maths.js').TypedArray} TypedArray
             */
            /**
             * @typedef {{ sequences: Tensor, decoder_attentions: Tensor, cross_attentions: Tensor }} EncoderDecoderOutput
             * @typedef {Object} DecoderOutput
             * 
             * Generates text based on the given inputs and generation configuration using the model.
             * @param {Tensor|Array|TypedArray} inputs An array of input token IDs.
             * @param {Object|GenerationConfig|null} generation_config The generation configuration to use. If null, default configuration will be used.
             * @param {Object|null} logits_processor An optional logits processor to use. If null, a new LogitsProcessorList instance will be created.
             * @param {Object} options options
             * @param {Object} [options.inputs_attention_mask=null] An optional attention mask for the inputs.
             * @returns {Promise<number[][]|EncoderDecoderOutput|DecoderOutput>} An array of generated output sequences, where each sequence is an array of token IDs.
             * @throws {Error} Throws an error if the inputs array is empty.
             */
            async generate(inputs, generation_config = null, logits_processor = null, {
              inputs_attention_mask = null
            } = {}) {
              if (!this.can_generate) {
                const modelName = MODEL_CLASS_TO_NAME_MAPPING.get(this.constructor);
                let errorMessage = `The current model class (${modelName}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;
                const modelType = this.config.model_type;
                const possibleInfo = MODEL_WITH_LM_HEAD_MAPPING_NAMES.get(modelType) ?? MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES.get(modelType) ?? MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES.get(modelType) ?? MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES.get(modelType);
                if (possibleInfo) {
                  errorMessage += ` Please use the following class instead: '${possibleInfo[0]}'`;
                }
                throw Error(errorMessage);
              }
              if (!(inputs instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor) && !(0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.isTypedArray)(inputs) && !Array.isArray(inputs)) {
                throw Error(`\`inputs\` must be a Tensor, TypedArray, or Array, but is "${inputs.constructor.name}".`);
              }
              let input_ids_seq_length;
              if (this.config.is_encoder_decoder) {
                input_ids_seq_length = 0;
              } else {
                input_ids_seq_length = inputs instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor ? inputs.dims.at(-1) : inputs.length;
                if (input_ids_seq_length === 0) {
                  throw Error("Must supply a non-empty array of input token ids.");
                }
              }
              generation_config = this._get_generation_config(generation_config);
              logits_processor = logits_processor ?? new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.LogitsProcessorList();
              logits_processor = this._get_logits_processor(
                generation_config,
                input_ids_seq_length,
                logits_processor
              );
              let eos_token_ids = generation_config.eos_token_id;
              if (eos_token_ids !== null && !Array.isArray(eos_token_ids)) {
                eos_token_ids = [eos_token_ids];
              }
              let numOutputTokens = 1;
              const maxOutputTokens = numOutputTokens + (generation_config.max_new_tokens ?? Infinity);
              const useMaxLength = Number.isInteger(generation_config.max_length) && (generation_config.max_new_tokens ?? null) === null;
              let sampler = _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.Sampler.getSampler(generation_config);
              let beams = this.getStartBeams(inputs, generation_config, numOutputTokens, inputs_attention_mask);
              while (beams.some((x) => !x.done) && numOutputTokens < maxOutputTokens) {
                let newest_beams = [];
                for (let beam of beams) {
                  if (beam.done) {
                    newest_beams.push(beam);
                    continue;
                  }
                  if (useMaxLength && beam.output_token_ids.length >= generation_config.max_length) {
                    beam.done = true;
                    newest_beams.push(beam);
                    continue;
                  }
                  let output = await this.runBeam(beam);
                  if (generation_config.output_attentions) {
                    this.addAttentionsToBeam(beam, output);
                  }
                  if (generation_config.output_scores) {
                  }
                  let logits = output.logits.slice(null, -1, null);
                  logits_processor(beam.output_token_ids, logits);
                  let sampledTokens = sampler(logits);
                  for (let [newTokenId, logProb] of sampledTokens) {
                    let newBeam = { ...beam };
                    this.updateBeam(newBeam, newTokenId);
                    newBeam.score += logProb;
                    if (eos_token_ids && eos_token_ids.includes(newTokenId)) {
                      newBeam.done = true;
                    }
                    newest_beams.push(newBeam);
                  }
                }
                ++numOutputTokens;
                newest_beams = this.groupBeams(newest_beams).map(
                  (group) => group.sort((a, b) => b.score - a.score).slice(0, generation_config.num_beams)
                  // remove outside beam width
                );
                beams = newest_beams.flat();
                if (generation_config.callback_function) {
                  generation_config.callback_function(beams);
                }
              }
              const groupedBeams = this.groupBeams(beams);
              const getFlattened = (key) => groupedBeams.map(
                (batch) => {
                  if (generation_config.num_return_sequences > 1) {
                    return batch.slice(0, generation_config.num_return_sequences).map((x) => x[key]);
                  } else {
                    return [batch[0][key]];
                  }
                }
              ).flat();
              const sequences = getFlattened("output_token_ids");
              if (generation_config.return_dict_in_generate) {
                const decoder_attentions = getFlattened("decoder_attentions");
                const cross_attentions = getFlattened("cross_attentions");
                return {
                  sequences,
                  decoder_attentions,
                  cross_attentions
                };
              } else {
                return sequences;
              }
            }
            /**
             * Helper function to add attentions to beam
             * @param {Object} beam 
             * @param {Object} output
             * @private 
             */
            addAttentionsToBeam(beam, output) {
              if (this.config.is_encoder_decoder) {
                if (!output.cross_attentions || output.cross_attentions.length === 0) {
                  throw Error(
                    "`output_attentions` is true, but the model did not produce cross-attentions. This is most likely because the model was not exported with `output_attentions=True`."
                  );
                }
                if (!beam.cross_attentions) {
                  beam.cross_attentions = [];
                }
                beam.cross_attentions.push(output.cross_attentions);
              }
              if (!output.decoder_attentions || output.decoder_attentions.length === 0) {
                throw Error(
                  "`output_attentions` is true, but the model did not produce decoder-attentions. This is most likely because the model was not exported with `output_attentions=True`."
                );
              }
              if (!beam.decoder_attentions) {
                beam.decoder_attentions = [];
              }
              beam.decoder_attentions.push(output.decoder_attentions);
            }
            /**
             * Groups an array of beam objects by their ids.
             *
             * @param {Array} beams The array of beam objects to group.
             * @returns {Array} An array of arrays, where each inner array contains beam objects with the same id.
             */
            groupBeams(beams) {
              const groups = /* @__PURE__ */ Object.create(null);
              for (const obj of beams) {
                if (groups[obj.id] === void 0) {
                  groups[obj.id] = [obj];
                } else {
                  groups[obj.id].push(obj);
                }
              }
              return Object.values(groups);
            }
            /**
             * Returns an object containing past key values from the given decoder results object.
             *
             * @param {Object} decoderResults The decoder results object.
             * @param {Object} pastKeyValues The previous past key values.
             * @returns {Object} An object containing past key values.
             */
            getPastKeyValues(decoderResults, pastKeyValues) {
              const pkvs = /* @__PURE__ */ Object.create(null);
              for (const name2 in decoderResults) {
                if (name2.startsWith("present")) {
                  let newName = name2.replace("present", "past_key_values");
                  if (pastKeyValues && name2.includes("encoder")) {
                    pkvs[newName] = pastKeyValues[newName];
                  } else {
                    pkvs[newName] = decoderResults[name2];
                  }
                }
              }
              return pkvs;
            }
            /**
             * Returns an object containing attentions from the given decoder results object.
             *
             * @param {Object} decoderResults The decoder results object.
             * @returns {Object} An object containing attentions.
             */
            getAttentions(decoderResults) {
              const attns = /* @__PURE__ */ Object.create(null);
              for (const attnName of ["cross_attentions", "decoder_attentions"]) {
                const result = [];
                for (const name2 in decoderResults) {
                  if (name2.startsWith(attnName)) {
                    const index = name2.split(".").pop();
                    result[index] = decoderResults[name2];
                  }
                }
                attns[attnName] = result;
              }
              return attns;
            }
            /**
             * Adds past key values to the decoder feeds object. If pastKeyValues is null, creates new tensors for past key values.
             *
             * @param {Object} decoderFeeds The decoder feeds object to add past key values to.
             * @param {Object} pastKeyValues An object containing past key values.
             */
            addPastKeyValues(decoderFeeds, pastKeyValues) {
              if (pastKeyValues) {
                Object.assign(decoderFeeds, pastKeyValues);
              } else {
                const batch_size = 1;
                if (this.config.is_encoder_decoder && (this.add_encoder_pkv ?? true)) {
                  let encoder_dims = [batch_size, this.num_encoder_heads, 0, this.encoder_dim_kv];
                  let decoder_dims = [batch_size, this.num_decoder_heads, 0, this.decoder_dim_kv];
                  for (let i = 0; i < this.num_decoder_layers; ++i) {
                    decoderFeeds[`past_key_values.${i}.encoder.key`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("float32", [], encoder_dims);
                    decoderFeeds[`past_key_values.${i}.encoder.value`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("float32", [], encoder_dims);
                    decoderFeeds[`past_key_values.${i}.decoder.key`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("float32", [], decoder_dims);
                    decoderFeeds[`past_key_values.${i}.decoder.value`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("float32", [], decoder_dims);
                  }
                } else if (this.config.model_type === "falcon") {
                  let dims = [batch_size * this.num_heads, 0, this.dim_kv];
                  for (let i = 0; i < this.num_layers; ++i) {
                    decoderFeeds[`past_key_values.${i}.key`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("float32", [], dims);
                    decoderFeeds[`past_key_values.${i}.value`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("float32", [], dims);
                  }
                } else if (this.config.multi_query) {
                  let dims = [batch_size * this.num_heads, 0, 2 * this.dim_kv];
                  for (let i = 0; i < this.num_layers; ++i) {
                    decoderFeeds[`past_key_values.${i}.key_value`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("float32", [], dims);
                  }
                } else if (this.config.model_type === "bloom") {
                  let keyDims = [batch_size * this.num_heads, this.dim_kv, 0];
                  let valueDims = [batch_size * this.num_heads, 0, this.dim_kv];
                  for (let i = 0; i < this.num_layers; ++i) {
                    decoderFeeds[`past_key_values.${i}.key`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("float32", [], keyDims);
                    decoderFeeds[`past_key_values.${i}.value`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("float32", [], valueDims);
                  }
                } else {
                  let dims = [batch_size, this.num_heads, 0, this.dim_kv];
                  for (let i = 0; i < this.num_layers; ++i) {
                    decoderFeeds[`past_key_values.${i}.key`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("float32", [], dims);
                    decoderFeeds[`past_key_values.${i}.value`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("float32", [], dims);
                  }
                }
              }
            }
            /**
             * Initializes and returns the beam for text generation task
             * @param {Tensor} inputTokenIds The input token ids.
             * @param {Object} generation_config The generation config.
             * @param {number} numOutputTokens The number of tokens to be generated.
             * @param {Tensor} inputs_attention_mask Optional input attention mask.
             * @returns {any} A Beam object representing the initialized beam.
             * @private
             */
            getStartBeams(inputTokenIds, generation_config, numOutputTokens, inputs_attention_mask) {
              return this._getStartBeams(this, inputTokenIds, generation_config, numOutputTokens, inputs_attention_mask);
            }
            /**
             * Runs a single step of the beam search generation algorithm.
             * @param {any} beam The current beam being generated.
             * @returns {Promise<any>} The updated beam after a single generation step.
             * @private
             */
            async runBeam(beam) {
              return await this._runBeam(this, beam);
            }
            /**
             * Update a beam with a new token ID.
             * @param {Object} beam The beam to update.
             * @param {number} newTokenId The new token ID to add to the beam's output.
             * @private
             */
            updateBeam(beam, newTokenId) {
              return this._updateBeam(beam, newTokenId);
            }
          }
          class ModelOutput {
          }
          class BaseModelOutput extends ModelOutput {
            /**
             * @param {Object} output The output of the model.
             * @param {Tensor} output.last_hidden_state Sequence of hidden-states at the output of the last layer of the model.
             * @param {Tensor} [output.hidden_states] Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.
             * @param {Tensor} [output.attentions] Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.
             */
            constructor({ last_hidden_state, hidden_states = null, attentions = null }) {
              super();
              this.last_hidden_state = last_hidden_state;
              this.hidden_states = hidden_states;
              this.attentions = attentions;
            }
          }
          class BertPreTrainedModel extends PreTrainedModel {
          }
          class BertModel extends BertPreTrainedModel {
          }
          class BertForMaskedLM extends BertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
             */
            async _call(model_inputs) {
              return new MaskedLMOutput(await super._call(model_inputs));
            }
          }
          class BertForSequenceClassification extends BertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class BertForTokenClassification extends BertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
             */
            async _call(model_inputs) {
              return new TokenClassifierOutput(await super._call(model_inputs));
            }
          }
          class BertForQuestionAnswering extends BertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
             */
            async _call(model_inputs) {
              return new QuestionAnsweringModelOutput(await super._call(model_inputs));
            }
          }
          class NomicBertPreTrainedModel extends PreTrainedModel {
          }
          class NomicBertModel extends NomicBertPreTrainedModel {
          }
          class RoFormerPreTrainedModel extends PreTrainedModel {
          }
          class RoFormerModel extends RoFormerPreTrainedModel {
          }
          class RoFormerForMaskedLM extends RoFormerPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
             */
            async _call(model_inputs) {
              return new MaskedLMOutput(await super._call(model_inputs));
            }
          }
          class RoFormerForSequenceClassification extends RoFormerPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class RoFormerForTokenClassification extends RoFormerPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
             */
            async _call(model_inputs) {
              return new TokenClassifierOutput(await super._call(model_inputs));
            }
          }
          class RoFormerForQuestionAnswering extends RoFormerPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
             */
            async _call(model_inputs) {
              return new QuestionAnsweringModelOutput(await super._call(model_inputs));
            }
          }
          class ConvBertPreTrainedModel extends PreTrainedModel {
          }
          class ConvBertModel extends ConvBertPreTrainedModel {
          }
          class ConvBertForMaskedLM extends ConvBertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
             */
            async _call(model_inputs) {
              return new MaskedLMOutput(await super._call(model_inputs));
            }
          }
          class ConvBertForSequenceClassification extends ConvBertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class ConvBertForTokenClassification extends ConvBertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
             */
            async _call(model_inputs) {
              return new TokenClassifierOutput(await super._call(model_inputs));
            }
          }
          class ConvBertForQuestionAnswering extends ConvBertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
             */
            async _call(model_inputs) {
              return new QuestionAnsweringModelOutput(await super._call(model_inputs));
            }
          }
          class ElectraPreTrainedModel extends PreTrainedModel {
          }
          class ElectraModel extends ElectraPreTrainedModel {
          }
          class ElectraForMaskedLM extends ElectraPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
             */
            async _call(model_inputs) {
              return new MaskedLMOutput(await super._call(model_inputs));
            }
          }
          class ElectraForSequenceClassification extends ElectraPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class ElectraForTokenClassification extends ElectraPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
             */
            async _call(model_inputs) {
              return new TokenClassifierOutput(await super._call(model_inputs));
            }
          }
          class ElectraForQuestionAnswering extends ElectraPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
             */
            async _call(model_inputs) {
              return new QuestionAnsweringModelOutput(await super._call(model_inputs));
            }
          }
          class CamembertPreTrainedModel extends PreTrainedModel {
          }
          class CamembertModel extends CamembertPreTrainedModel {
          }
          class CamembertForMaskedLM extends CamembertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
             */
            async _call(model_inputs) {
              return new MaskedLMOutput(await super._call(model_inputs));
            }
          }
          class CamembertForSequenceClassification extends CamembertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class CamembertForTokenClassification extends CamembertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
             */
            async _call(model_inputs) {
              return new TokenClassifierOutput(await super._call(model_inputs));
            }
          }
          class CamembertForQuestionAnswering extends CamembertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
             */
            async _call(model_inputs) {
              return new QuestionAnsweringModelOutput(await super._call(model_inputs));
            }
          }
          class DebertaPreTrainedModel extends PreTrainedModel {
          }
          class DebertaModel extends DebertaPreTrainedModel {
          }
          class DebertaForMaskedLM extends DebertaPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
             */
            async _call(model_inputs) {
              return new MaskedLMOutput(await super._call(model_inputs));
            }
          }
          class DebertaForSequenceClassification extends DebertaPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class DebertaForTokenClassification extends DebertaPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
             */
            async _call(model_inputs) {
              return new TokenClassifierOutput(await super._call(model_inputs));
            }
          }
          class DebertaForQuestionAnswering extends DebertaPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
             */
            async _call(model_inputs) {
              return new QuestionAnsweringModelOutput(await super._call(model_inputs));
            }
          }
          class DebertaV2PreTrainedModel extends PreTrainedModel {
          }
          class DebertaV2Model extends DebertaV2PreTrainedModel {
          }
          class DebertaV2ForMaskedLM extends DebertaV2PreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
             */
            async _call(model_inputs) {
              return new MaskedLMOutput(await super._call(model_inputs));
            }
          }
          class DebertaV2ForSequenceClassification extends DebertaV2PreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class DebertaV2ForTokenClassification extends DebertaV2PreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
             */
            async _call(model_inputs) {
              return new TokenClassifierOutput(await super._call(model_inputs));
            }
          }
          class DebertaV2ForQuestionAnswering extends DebertaV2PreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
             */
            async _call(model_inputs) {
              return new QuestionAnsweringModelOutput(await super._call(model_inputs));
            }
          }
          class DistilBertPreTrainedModel extends PreTrainedModel {
          }
          class DistilBertModel extends DistilBertPreTrainedModel {
          }
          class DistilBertForSequenceClassification extends DistilBertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class DistilBertForTokenClassification extends DistilBertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
             */
            async _call(model_inputs) {
              return new TokenClassifierOutput(await super._call(model_inputs));
            }
          }
          class DistilBertForQuestionAnswering extends DistilBertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
             */
            async _call(model_inputs) {
              return new QuestionAnsweringModelOutput(await super._call(model_inputs));
            }
          }
          class DistilBertForMaskedLM extends DistilBertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<MaskedLMOutput>} returned object
             */
            async _call(model_inputs) {
              return new MaskedLMOutput(await super._call(model_inputs));
            }
          }
          class EsmPreTrainedModel extends PreTrainedModel {
          }
          class EsmModel extends EsmPreTrainedModel {
          }
          class EsmForMaskedLM extends EsmPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
             */
            async _call(model_inputs) {
              return new MaskedLMOutput(await super._call(model_inputs));
            }
          }
          class EsmForSequenceClassification extends EsmPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class EsmForTokenClassification extends EsmPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
             */
            async _call(model_inputs) {
              return new TokenClassifierOutput(await super._call(model_inputs));
            }
          }
          class MobileBertPreTrainedModel extends PreTrainedModel {
          }
          class MobileBertModel extends MobileBertPreTrainedModel {
          }
          class MobileBertForMaskedLM extends MobileBertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<MaskedLMOutput>} returned object
             */
            async _call(model_inputs) {
              return new MaskedLMOutput(await super._call(model_inputs));
            }
          }
          class MobileBertForSequenceClassification extends MobileBertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} returned object
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class MobileBertForQuestionAnswering extends MobileBertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<QuestionAnsweringModelOutput>} returned object
             */
            async _call(model_inputs) {
              return new QuestionAnsweringModelOutput(await super._call(model_inputs));
            }
          }
          class MPNetPreTrainedModel extends PreTrainedModel {
          }
          class MPNetModel extends MPNetPreTrainedModel {
          }
          class MPNetForMaskedLM extends MPNetPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
             */
            async _call(model_inputs) {
              return new MaskedLMOutput(await super._call(model_inputs));
            }
          }
          class MPNetForSequenceClassification extends MPNetPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class MPNetForTokenClassification extends MPNetPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
             */
            async _call(model_inputs) {
              return new TokenClassifierOutput(await super._call(model_inputs));
            }
          }
          class MPNetForQuestionAnswering extends MPNetPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
             */
            async _call(model_inputs) {
              return new QuestionAnsweringModelOutput(await super._call(model_inputs));
            }
          }
          class SqueezeBertPreTrainedModel extends PreTrainedModel {
          }
          class SqueezeBertModel extends SqueezeBertPreTrainedModel {
          }
          class SqueezeBertForMaskedLM extends SqueezeBertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<MaskedLMOutput>} returned object
             */
            async _call(model_inputs) {
              return new MaskedLMOutput(await super._call(model_inputs));
            }
          }
          class SqueezeBertForSequenceClassification extends SqueezeBertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} returned object
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class SqueezeBertForQuestionAnswering extends SqueezeBertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<QuestionAnsweringModelOutput>} returned object
             */
            async _call(model_inputs) {
              return new QuestionAnsweringModelOutput(await super._call(model_inputs));
            }
          }
          class AlbertPreTrainedModel extends PreTrainedModel {
          }
          class AlbertModel extends AlbertPreTrainedModel {
          }
          class AlbertForSequenceClassification extends AlbertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} returned object
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class AlbertForQuestionAnswering extends AlbertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<QuestionAnsweringModelOutput>} returned object
             */
            async _call(model_inputs) {
              return new QuestionAnsweringModelOutput(await super._call(model_inputs));
            }
          }
          class AlbertForMaskedLM extends AlbertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<MaskedLMOutput>} returned object
             */
            async _call(model_inputs) {
              return new MaskedLMOutput(await super._call(model_inputs));
            }
          }
          class T5PreTrainedModel extends PreTrainedModel {
          }
          ;
          class T5Model extends T5PreTrainedModel {
          }
          class T5ForConditionalGeneration extends T5PreTrainedModel {
            /**
             * Creates a new instance of the `T5ForConditionalGeneration` class.
             * @param {Object} config The model configuration.
             * @param {any} session session for the model.
             * @param {any} decoder_merged_session session for the decoder.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, decoder_merged_session, generation_config) {
              super(config2, session);
              this.decoder_merged_session = decoder_merged_session;
              this.generation_config = generation_config;
              this.num_decoder_layers = this.config.num_decoder_layers;
              this.num_decoder_heads = this.config.num_heads;
              this.decoder_dim_kv = this.config.d_kv;
              this.num_encoder_layers = this.config.num_layers;
              this.num_encoder_heads = this.config.num_heads;
              this.encoder_dim_kv = this.config.d_kv;
            }
          }
          class LongT5PreTrainedModel extends PreTrainedModel {
          }
          ;
          class LongT5Model extends LongT5PreTrainedModel {
          }
          class LongT5ForConditionalGeneration extends LongT5PreTrainedModel {
            /**
             * Creates a new instance of the `LongT5ForConditionalGeneration` class.
             * @param {Object} config The model configuration.
             * @param {any} session session for the model.
             * @param {any} decoder_merged_session session for the decoder.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, decoder_merged_session, generation_config) {
              super(config2, session);
              this.decoder_merged_session = decoder_merged_session;
              this.generation_config = generation_config;
              this.num_decoder_layers = this.config.num_decoder_layers;
              this.num_decoder_heads = this.config.num_heads;
              this.decoder_dim_kv = this.config.d_kv;
              this.num_encoder_layers = this.config.num_layers;
              this.num_encoder_heads = this.config.num_heads;
              this.encoder_dim_kv = this.config.d_kv;
            }
          }
          class MT5PreTrainedModel extends PreTrainedModel {
          }
          ;
          class MT5Model extends MT5PreTrainedModel {
          }
          class MT5ForConditionalGeneration extends MT5PreTrainedModel {
            /**
             * Creates a new instance of the `MT5ForConditionalGeneration` class.
             * @param {any} config The model configuration.
             * @param {any} session The ONNX session containing the encoder weights.
             * @param {any} decoder_merged_session The ONNX session containing the merged decoder weights.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, decoder_merged_session, generation_config) {
              super(config2, session);
              this.decoder_merged_session = decoder_merged_session;
              this.generation_config = generation_config;
              this.num_decoder_layers = this.config.num_decoder_layers;
              this.num_decoder_heads = this.config.num_heads;
              this.decoder_dim_kv = this.config.d_kv;
              this.num_encoder_layers = this.config.num_layers;
              this.num_encoder_heads = this.config.num_heads;
              this.encoder_dim_kv = this.config.d_kv;
            }
          }
          class BartPretrainedModel extends PreTrainedModel {
          }
          ;
          class BartModel extends BartPretrainedModel {
          }
          class BartForConditionalGeneration extends BartPretrainedModel {
            /**
             * Creates a new instance of the `BartForConditionalGeneration` class.
             * @param {Object} config The configuration object for the Bart model.
             * @param {Object} session The ONNX session used to execute the model.
             * @param {Object} decoder_merged_session The ONNX session used to execute the decoder.
             * @param {Object} generation_config The generation configuration object.
             */
            constructor(config2, session, decoder_merged_session, generation_config) {
              super(config2, session);
              this.decoder_merged_session = decoder_merged_session;
              this.generation_config = generation_config;
              this.num_decoder_layers = this.config.decoder_layers;
              this.num_decoder_heads = this.config.decoder_attention_heads;
              this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;
              this.num_encoder_layers = this.config.encoder_layers;
              this.num_encoder_heads = this.config.encoder_attention_heads;
              this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
            }
          }
          class BartForSequenceClassification extends BartPretrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class MBartPreTrainedModel extends PreTrainedModel {
          }
          ;
          class MBartModel extends MBartPreTrainedModel {
          }
          class MBartForConditionalGeneration extends MBartPreTrainedModel {
            /**
             * Creates a new instance of the `MBartForConditionalGeneration` class.
             * @param {Object} config The configuration object for the Bart model.
             * @param {Object} session The ONNX session used to execute the model.
             * @param {Object} decoder_merged_session The ONNX session used to execute the decoder.
             * @param {Object} generation_config The generation configuration object.
             */
            constructor(config2, session, decoder_merged_session, generation_config) {
              super(config2, session);
              this.decoder_merged_session = decoder_merged_session;
              this.generation_config = generation_config;
              this.num_decoder_layers = this.config.decoder_layers;
              this.num_decoder_heads = this.config.decoder_attention_heads;
              this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;
              this.num_encoder_layers = this.config.encoder_layers;
              this.num_encoder_heads = this.config.encoder_attention_heads;
              this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
            }
          }
          class MBartForSequenceClassification extends MBartPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class MBartForCausalLM extends MBartPreTrainedModel {
            /**
             * Creates a new instance of the `MBartForCausalLM` class.
             * @param {Object} config Configuration object for the model.
             * @param {Object} decoder_merged_session ONNX Session object for the decoder.
             * @param {Object} generation_config Configuration object for the generation process.
             */
            constructor(config2, decoder_merged_session, generation_config) {
              super(config2, decoder_merged_session);
              this.generation_config = generation_config;
              this.num_decoder_layers = this.config.decoder_layers;
              this.num_decoder_heads = this.config.decoder_attention_heads;
              this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;
              this.num_encoder_layers = this.config.encoder_layers;
              this.num_encoder_heads = this.config.encoder_attention_heads;
              this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
            }
          }
          class BlenderbotPreTrainedModel extends PreTrainedModel {
          }
          ;
          class BlenderbotModel extends BlenderbotPreTrainedModel {
          }
          class BlenderbotForConditionalGeneration extends BlenderbotPreTrainedModel {
            /**
             * Creates a new instance of the `BlenderbotForConditionalGeneration` class.
             * @param {any} config The model configuration.
             * @param {any} session The ONNX session containing the encoder weights.
             * @param {any} decoder_merged_session The ONNX session containing the merged decoder weights.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, decoder_merged_session, generation_config) {
              super(config2, session);
              this.decoder_merged_session = decoder_merged_session;
              this.generation_config = generation_config;
              this.num_decoder_layers = this.config.decoder_layers;
              this.num_decoder_heads = this.config.decoder_attention_heads;
              this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;
              this.num_encoder_layers = this.config.encoder_layers;
              this.num_encoder_heads = this.config.encoder_attention_heads;
              this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
            }
          }
          class BlenderbotSmallPreTrainedModel extends PreTrainedModel {
          }
          ;
          class BlenderbotSmallModel extends BlenderbotSmallPreTrainedModel {
          }
          class BlenderbotSmallForConditionalGeneration extends BlenderbotSmallPreTrainedModel {
            /**
             * Creates a new instance of the `BlenderbotForConditionalGeneration` class.
             * @param {any} config The model configuration.
             * @param {any} session The ONNX session containing the encoder weights.
             * @param {any} decoder_merged_session The ONNX session containing the merged decoder weights.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, decoder_merged_session, generation_config) {
              super(config2, session);
              this.decoder_merged_session = decoder_merged_session;
              this.generation_config = generation_config;
              this.num_decoder_layers = this.config.decoder_layers;
              this.num_decoder_heads = this.config.decoder_attention_heads;
              this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;
              this.num_encoder_layers = this.config.encoder_layers;
              this.num_encoder_heads = this.config.encoder_attention_heads;
              this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
            }
          }
          class RobertaPreTrainedModel extends PreTrainedModel {
          }
          class RobertaModel extends RobertaPreTrainedModel {
          }
          class RobertaForMaskedLM extends RobertaPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<MaskedLMOutput>} returned object
             */
            async _call(model_inputs) {
              return new MaskedLMOutput(await super._call(model_inputs));
            }
          }
          class RobertaForSequenceClassification extends RobertaPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} returned object
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class RobertaForTokenClassification extends RobertaPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
             */
            async _call(model_inputs) {
              return new TokenClassifierOutput(await super._call(model_inputs));
            }
          }
          class RobertaForQuestionAnswering extends RobertaPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<QuestionAnsweringModelOutput>} returned object
             */
            async _call(model_inputs) {
              return new QuestionAnsweringModelOutput(await super._call(model_inputs));
            }
          }
          class XLMPreTrainedModel extends PreTrainedModel {
          }
          class XLMModel extends XLMPreTrainedModel {
          }
          class XLMWithLMHeadModel extends XLMPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<MaskedLMOutput>} returned object
             */
            async _call(model_inputs) {
              return new MaskedLMOutput(await super._call(model_inputs));
            }
          }
          class XLMForSequenceClassification extends XLMPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} returned object
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class XLMForTokenClassification extends XLMPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
             */
            async _call(model_inputs) {
              return new TokenClassifierOutput(await super._call(model_inputs));
            }
          }
          class XLMForQuestionAnswering extends XLMPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<QuestionAnsweringModelOutput>} returned object
             */
            async _call(model_inputs) {
              return new QuestionAnsweringModelOutput(await super._call(model_inputs));
            }
          }
          class XLMRobertaPreTrainedModel extends PreTrainedModel {
          }
          class XLMRobertaModel extends XLMRobertaPreTrainedModel {
          }
          class XLMRobertaForMaskedLM extends XLMRobertaPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<MaskedLMOutput>} returned object
             */
            async _call(model_inputs) {
              return new MaskedLMOutput(await super._call(model_inputs));
            }
          }
          class XLMRobertaForSequenceClassification extends XLMRobertaPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} returned object
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class XLMRobertaForTokenClassification extends XLMRobertaPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
             */
            async _call(model_inputs) {
              return new TokenClassifierOutput(await super._call(model_inputs));
            }
          }
          class XLMRobertaForQuestionAnswering extends XLMRobertaPreTrainedModel {
            /**
             * Calls the model on new inputs.
             *
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<QuestionAnsweringModelOutput>} returned object
             */
            async _call(model_inputs) {
              return new QuestionAnsweringModelOutput(await super._call(model_inputs));
            }
          }
          class ASTPreTrainedModel extends PreTrainedModel {
          }
          ;
          class ASTModel extends ASTPreTrainedModel {
          }
          class ASTForAudioClassification extends ASTPreTrainedModel {
          }
          class WhisperPreTrainedModel extends PreTrainedModel {
          }
          ;
          class WhisperModel extends WhisperPreTrainedModel {
          }
          class WhisperForConditionalGeneration extends WhisperPreTrainedModel {
            /**
             * Creates a new instance of the `WhisperForConditionalGeneration` class.
             * @param {Object} config Configuration object for the model.
             * @param {Object} session ONNX Session object for the model.
             * @param {Object} decoder_merged_session ONNX Session object for the decoder.
             * @param {Object} generation_config Configuration object for the generation process.
             */
            constructor(config2, session, decoder_merged_session, generation_config) {
              super(config2, session);
              __publicField(this, "requires_attention_mask", false);
              __publicField(this, "main_input_name", "input_features");
              this.decoder_merged_session = decoder_merged_session;
              this.generation_config = generation_config;
              this.num_decoder_layers = this.config.decoder_layers;
              this.num_decoder_heads = this.config.decoder_attention_heads;
              this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;
              this.num_encoder_layers = this.config.encoder_layers;
              this.num_encoder_heads = this.config.encoder_attention_heads;
              this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
            }
            /**
             * @typedef {Object} WhisperGenerationConfig
             * @extends GenerationConfig
             * @property {boolean} [return_timestamps=null] Whether to return the timestamps with the text. This enables the `WhisperTimestampsLogitsProcessor`.
             * @property {boolean} [return_token_timestamps=null] Whether to return token-level timestamps
             * with the text. This can be used with or without the `return_timestamps` option. To get word-level
             * timestamps, use the tokenizer to group the tokens into words.
             * @property {number} [num_frames=null]  The number of audio frames available in this chunk. This is only used generating word-level timestamps.
             */
            /**
             * Generates outputs based on input and generation configuration.
             * @param {Object} inputs Input data for the model.
             * @param {WhisperGenerationConfig} generation_config Configuration object for the generation process.
             * @param {Object} logits_processor Optional logits processor object.
             * @returns {Promise<Object>} Promise object represents the generated outputs.
             */
            async generate(inputs, generation_config = null, logits_processor = null) {
              generation_config = this._get_generation_config(generation_config);
              generation_config.return_timestamps ?? (generation_config.return_timestamps = false);
              if (generation_config.return_timestamps) {
                logits_processor = [new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.WhisperTimeStampLogitsProcessor(generation_config)];
              }
              if (generation_config.return_token_timestamps) {
                generation_config.output_attentions = true;
                generation_config.return_dict_in_generate = true;
                if (generation_config.task === "translate") {
                  console.warn("Token-level timestamps may not be reliable for task 'translate'.");
                }
                if (!generation_config.alignment_heads) {
                  throw new Error(
                    "Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config."
                  );
                }
              }
              const outputs = await super.generate(inputs, generation_config, logits_processor);
              if (generation_config.return_token_timestamps && generation_config.alignment_heads) {
                outputs["token_timestamps"] = this._extract_token_timestamps(
                  outputs,
                  generation_config.alignment_heads,
                  generation_config.num_frames
                );
              }
              return outputs;
            }
            /**
             * Calculates token-level timestamps using the encoder-decoder cross-attentions and
             * dynamic time-warping (DTW) to map each output token to a position in the input audio.
             * @param {Object} generate_outputs Outputs generated by the model
             * @param {Tensor[][][]} generate_outputs.cross_attentions The cross attentions output by the model
             * @param {Tensor[][][]} generate_outputs.decoder_attentions The decoder attentions output by the model
             * @param {number[][]} generate_outputs.sequences The sequences output by the model
             * @param {number[][]} alignment_heads Alignment heads of the model
             * @param {number} [num_frames=null] Number of frames in the input audio.
             * @param {number} [time_precision=0.02] Precision of the timestamps in seconds
             * @returns {Tensor} tensor containing the timestamps in seconds for each predicted token
             */
            _extract_token_timestamps(generate_outputs, alignment_heads, num_frames = null, time_precision = 0.02) {
              if (!generate_outputs.cross_attentions) {
                throw new Error(
                  "Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`."
                );
              }
              let median_filter_width = this.config.median_filter_width;
              if (median_filter_width === void 0) {
                console.warn("Model config has no `median_filter_width`, using default value of 7.");
                median_filter_width = 7;
              }
              const batchedMatrices = generate_outputs.cross_attentions.map((batch) => {
                let cross_attentions = Array.from(
                  { length: this.config.decoder_layers },
                  (_, i) => (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.cat)(batch.map((x) => x[i]), 2)
                );
                let weights = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.stack)(alignment_heads.map(([l, h]) => {
                  return num_frames ? cross_attentions[l].slice(null, h, null, [0, num_frames]) : cross_attentions[l].slice(null, h);
                }));
                weights = weights.transpose(1, 0, 2, 3);
                let [std, calculatedMean] = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.std_mean)(weights, -2, 0, true);
                let smoothedWeights = weights.clone();
                for (let a = 0; a < smoothedWeights.dims[0]; ++a) {
                  let aTensor = smoothedWeights[a];
                  for (let b = 0; b < aTensor.dims[0]; ++b) {
                    let bTensor = aTensor[b];
                    const stdTensor = std[a][b][0];
                    const meanTensor = calculatedMean[a][b][0];
                    for (let c = 0; c < bTensor.dims[0]; ++c) {
                      let cTensor = bTensor[c];
                      for (let d = 0; d < cTensor.data.length; ++d) {
                        cTensor.data[d] = (cTensor.data[d] - meanTensor.data[d]) / stdTensor.data[d];
                      }
                      cTensor.data.set((0, _transformers_js__WEBPACK_IMPORTED_MODULE_6__.medianFilter)(cTensor.data, median_filter_width));
                    }
                  }
                }
                const matrix = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.mean)(smoothedWeights, 1);
                return matrix;
              });
              const timestampsShape = [generate_outputs.sequences.length, generate_outputs.sequences[0].length];
              const timestamps = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor(
                "float32",
                new Float32Array(timestampsShape[0] * timestampsShape[1]),
                timestampsShape
              );
              for (let batch_idx = 0; batch_idx < timestampsShape[0]; ++batch_idx) {
                const matrix = batchedMatrices[batch_idx].neg().squeeze_(0);
                let [text_indices, time_indices] = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.dynamicTimeWarping)(matrix);
                let diffs = Array.from({ length: text_indices.length - 1 }, (v, i) => text_indices[i + 1] - text_indices[i]);
                let jumps = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)([1], diffs).map((x) => !!x);
                let jump_times = [];
                for (let i = 0; i < jumps.length; ++i) {
                  if (jumps[i]) {
                    jump_times.push(time_indices[i] * time_precision);
                  }
                }
                timestamps[batch_idx].data.set(jump_times, 1);
              }
              return timestamps;
            }
          }
          class VisionEncoderDecoderModel extends PreTrainedModel {
            /**
             * Creates a new instance of the `VisionEncoderDecoderModel` class.
             * @param {Object} config The configuration object specifying the hyperparameters and other model settings.
             * @param {Object} session The ONNX session containing the encoder model.
             * @param {any} decoder_merged_session The ONNX session containing the merged decoder model.
             * @param {Object} generation_config Configuration object for the generation process.
             */
            constructor(config2, session, decoder_merged_session, generation_config) {
              super(config2, session);
              __publicField(this, "main_input_name", "pixel_values");
              this.decoder_merged_session = decoder_merged_session;
              this.generation_config = generation_config;
              const encoderConfig = this.config.encoder;
              const decoderConfig = this.config.decoder;
              const encoderModelType = encoderConfig.model_type;
              const encoderModel = MODEL_MAPPING_NAMES_ENCODER_ONLY.get(encoderModelType) ?? MODEL_MAPPING_NAMES_ENCODER_DECODER.get(encoderModelType);
              if (!encoderModel) {
                console.warn(`Model type for encoder '${encoderModelType}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`);
              }
              const decoderModel = MODEL_WITH_LM_HEAD_MAPPING_NAMES.get(decoderConfig.model_type);
              if (!decoderModel) {
                throw new Error(`Unable to construct \`VisionEncoderDecoder\` due to unsupported decoder: "${this.config.decoder.model_type}"`);
              }
              const decoderModelClass = decoderModel[1];
              const decoder = new decoderModelClass(decoderConfig, decoder_merged_session, generation_config);
              this.add_encoder_pkv = "num_decoder_layers" in decoder;
              if (this.add_encoder_pkv) {
                this.num_decoder_layers = decoder.num_decoder_layers;
                this.num_decoder_heads = decoder.num_decoder_heads;
                this.decoder_dim_kv = decoder.decoder_dim_kv;
                this.num_encoder_layers = decoder.num_encoder_layers;
                this.num_encoder_heads = decoder.num_encoder_heads;
                this.encoder_dim_kv = decoder.encoder_dim_kv;
              } else {
                this.num_layers = decoder.num_layers;
                this.num_heads = decoder.num_heads;
                this.dim_kv = decoder.dim_kv;
              }
            }
          }
          class CLIPPreTrainedModel extends PreTrainedModel {
          }
          class CLIPModel extends CLIPPreTrainedModel {
          }
          class CLIPTextModelWithProjection extends CLIPPreTrainedModel {
            /** @type {PreTrainedModel.from_pretrained} */
            static async from_pretrained(pretrained_model_name_or_path, options = {}) {
              options.model_file_name ?? (options.model_file_name = "text_model");
              return super.from_pretrained(pretrained_model_name_or_path, options);
            }
          }
          class CLIPVisionModelWithProjection extends CLIPPreTrainedModel {
            /** @type {PreTrainedModel.from_pretrained} */
            static async from_pretrained(pretrained_model_name_or_path, options = {}) {
              options.model_file_name ?? (options.model_file_name = "vision_model");
              return super.from_pretrained(pretrained_model_name_or_path, options);
            }
          }
          class SiglipPreTrainedModel extends PreTrainedModel {
          }
          class SiglipModel extends SiglipPreTrainedModel {
          }
          class SiglipTextModel extends SiglipPreTrainedModel {
            /** @type {PreTrainedModel.from_pretrained} */
            static async from_pretrained(pretrained_model_name_or_path, options = {}) {
              options.model_file_name ?? (options.model_file_name = "text_model");
              return super.from_pretrained(pretrained_model_name_or_path, options);
            }
          }
          class SiglipVisionModel extends CLIPPreTrainedModel {
            /** @type {PreTrainedModel.from_pretrained} */
            static async from_pretrained(pretrained_model_name_or_path, options = {}) {
              options.model_file_name ?? (options.model_file_name = "vision_model");
              return super.from_pretrained(pretrained_model_name_or_path, options);
            }
          }
          class ChineseCLIPPreTrainedModel extends PreTrainedModel {
          }
          class ChineseCLIPModel extends ChineseCLIPPreTrainedModel {
          }
          class CLIPSegPreTrainedModel extends PreTrainedModel {
          }
          class CLIPSegModel extends CLIPSegPreTrainedModel {
          }
          class CLIPSegForImageSegmentation extends CLIPSegPreTrainedModel {
          }
          class GPT2PreTrainedModel extends PreTrainedModel {
            /**
             * Creates a new instance of the `GPT2PreTrainedModel` class.
             * @param {Object} config The configuration of the model.
             * @param {any} session The ONNX session containing the model weights.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, generation_config) {
              super(config2, session);
              this.generation_config = generation_config;
              this.config.pad_token_id = this.config.eos_token_id;
              this.num_heads = this.config.n_head;
              this.num_layers = this.config.n_layer;
              this.dim_kv = this.config.n_embd / this.num_heads;
            }
          }
          class GPT2Model extends GPT2PreTrainedModel {
          }
          class GPT2LMHeadModel extends GPT2PreTrainedModel {
          }
          class GPTNeoPreTrainedModel extends PreTrainedModel {
            /**
             * Creates a new instance of the `GPTNeoPreTrainedModel` class.
             * @param {Object} config The configuration of the model.
             * @param {any} session The ONNX session containing the model weights.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, generation_config) {
              super(config2, session);
              this.generation_config = generation_config;
              this.config.pad_token_id = this.config.eos_token_id;
              this.num_heads = this.config.num_heads;
              this.num_layers = this.config.num_layers;
              this.dim_kv = this.config.hidden_size / this.num_heads;
            }
          }
          class GPTNeoModel extends GPTNeoPreTrainedModel {
          }
          class GPTNeoForCausalLM extends GPTNeoPreTrainedModel {
          }
          class GPTNeoXPreTrainedModel extends PreTrainedModel {
            /**
             * Creates a new instance of the `GPTNeoXPreTrainedModel` class.
             * @param {Object} config The configuration of the model.
             * @param {any} session The ONNX session containing the model weights.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, generation_config) {
              super(config2, session);
              this.generation_config = generation_config;
              this.config.pad_token_id = this.config.eos_token_id;
              this.num_heads = this.config.num_attention_heads;
              this.num_layers = this.config.num_hidden_layers;
              this.dim_kv = this.config.hidden_size / this.num_heads;
            }
          }
          class GPTNeoXModel extends GPTNeoXPreTrainedModel {
          }
          class GPTNeoXForCausalLM extends GPTNeoXPreTrainedModel {
          }
          class GPTJPreTrainedModel extends PreTrainedModel {
            /**
             * Creates a new instance of the `GPTJPreTrainedModel` class.
             * @param {Object} config The configuration of the model.
             * @param {any} session The ONNX session containing the model weights.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, generation_config) {
              super(config2, session);
              this.generation_config = generation_config;
              this.config.pad_token_id = this.config.eos_token_id;
              this.num_heads = this.config.n_head;
              this.num_layers = this.config.n_layer;
              this.dim_kv = this.config.n_embd / this.num_heads;
            }
          }
          class GPTJModel extends GPTJPreTrainedModel {
          }
          class GPTJForCausalLM extends GPTJPreTrainedModel {
          }
          class GPTBigCodePreTrainedModel extends PreTrainedModel {
            /**
             * Creates a new instance of the `GPTBigCodePreTrainedModel` class.
             * @param {Object} config The configuration of the model.
             * @param {any} session The ONNX session containing the model weights.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, generation_config) {
              super(config2, session);
              this.generation_config = generation_config;
              this.config.pad_token_id = this.config.eos_token_id;
              this.num_heads = this.config.n_head;
              this.num_layers = this.config.n_layer;
              this.dim_kv = this.config.n_embd / this.num_heads;
            }
          }
          class GPTBigCodeModel extends GPTBigCodePreTrainedModel {
          }
          class GPTBigCodeForCausalLM extends GPTBigCodePreTrainedModel {
          }
          class CodeGenPreTrainedModel extends PreTrainedModel {
            /**
             * Creates a new instance of the `CodeGenPreTrainedModel` class.
             * @param {Object} config The model configuration object.
             * @param {Object} session The ONNX session object.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, generation_config) {
              super(config2, session);
              this.generation_config = generation_config;
              this.config.pad_token_id = this.config.eos_token_id;
              this.num_heads = this.config.n_head;
              this.num_layers = this.config.n_layer;
              this.dim_kv = this.config.n_embd / this.num_heads;
            }
          }
          class CodeGenModel extends CodeGenPreTrainedModel {
          }
          class CodeGenForCausalLM extends CodeGenPreTrainedModel {
          }
          class LlamaPreTrainedModel extends PreTrainedModel {
            /**
             * Creates a new instance of the `LlamaPreTrainedModel` class.
             * @param {Object} config The model configuration object.
             * @param {Object} session The ONNX session object.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, generation_config) {
              super(config2, session);
              this.generation_config = generation_config;
              this.config.pad_token_id = this.config.eos_token_id;
              this.num_heads = this.config.num_key_value_heads ?? this.config.num_attention_heads;
              this.num_layers = this.config.num_hidden_layers;
              this.dim_kv = this.config.hidden_size / this.config.num_attention_heads;
            }
          }
          class LlamaModel extends LlamaPreTrainedModel {
          }
          class LlamaForCausalLM extends LlamaPreTrainedModel {
          }
          class Qwen2PreTrainedModel extends PreTrainedModel {
            /**
             * Creates a new instance of the `Qwen2PreTrainedModel` class.
             * @param {Object} config The model configuration object.
             * @param {Object} session The ONNX session object.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, generation_config) {
              super(config2, session);
              this.generation_config = generation_config;
              this.config.pad_token_id = this.config.eos_token_id;
              this.num_heads = this.config.num_key_value_heads ?? this.config.num_attention_heads;
              this.num_layers = this.config.num_hidden_layers;
              this.dim_kv = this.config.hidden_size / this.config.num_attention_heads;
            }
          }
          class Qwen2Model extends Qwen2PreTrainedModel {
          }
          class Qwen2ForCausalLM extends Qwen2PreTrainedModel {
          }
          class PhiPreTrainedModel extends PreTrainedModel {
            /**
             * Creates a new instance of the `PhiPreTrainedModel` class.
             * @param {Object} config The model configuration object.
             * @param {Object} session The ONNX session object.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, generation_config) {
              super(config2, session);
              this.generation_config = generation_config;
              this.config.pad_token_id = this.config.eos_token_id;
              this.num_heads = this.config.num_attention_heads;
              this.num_layers = this.config.num_hidden_layers;
              this.dim_kv = this.config.hidden_size / this.num_heads;
            }
          }
          class PhiModel extends PhiPreTrainedModel {
          }
          class PhiForCausalLM extends PhiPreTrainedModel {
          }
          class BloomPreTrainedModel extends PreTrainedModel {
            /**
             * Creates a new instance of the `BloomPreTrainedModel` class.
             * @param {Object} config The configuration of the model.
             * @param {any} session The ONNX session containing the model weights.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, generation_config) {
              super(config2, session);
              this.generation_config = generation_config;
              this.config.pad_token_id = this.config.eos_token_id;
              this.num_heads = this.config.n_head;
              this.num_layers = this.config.n_layer;
              this.dim_kv = this.config.hidden_size / this.num_heads;
            }
          }
          class BloomModel extends BloomPreTrainedModel {
          }
          class BloomForCausalLM extends BloomPreTrainedModel {
          }
          class MptPreTrainedModel extends PreTrainedModel {
            /**
             * Creates a new instance of the `MptPreTrainedModel` class.
             * @param {Object} config The model configuration object.
             * @param {Object} session The ONNX session object.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, generation_config) {
              super(config2, session);
              this.generation_config = generation_config;
              this.config.pad_token_id = this.config.eos_token_id;
              this.num_heads = this.config.n_heads;
              this.num_layers = this.config.n_layers;
              this.dim_kv = this.config.d_model / this.num_heads;
            }
          }
          class MptModel extends MptPreTrainedModel {
          }
          class MptForCausalLM extends MptPreTrainedModel {
          }
          class OPTPreTrainedModel extends PreTrainedModel {
            /**
             * Creates a new instance of the `OPTPreTrainedModel` class.
             * @param {Object} config The model configuration object.
             * @param {Object} session The ONNX session object.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, generation_config) {
              super(config2, session);
              this.generation_config = generation_config;
              this.config.pad_token_id = this.config.eos_token_id;
              this.num_heads = this.config.num_attention_heads;
              this.num_layers = this.config.num_hidden_layers;
              this.dim_kv = this.config.hidden_size / this.num_heads;
            }
          }
          class OPTModel extends OPTPreTrainedModel {
          }
          class OPTForCausalLM extends OPTPreTrainedModel {
          }
          class ViTPreTrainedModel extends PreTrainedModel {
          }
          class ViTModel extends ViTPreTrainedModel {
          }
          class ViTForImageClassification extends ViTPreTrainedModel {
            /**
             * @param {any} model_inputs
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class FastViTPreTrainedModel extends PreTrainedModel {
          }
          class FastViTModel extends FastViTPreTrainedModel {
          }
          class FastViTForImageClassification extends FastViTPreTrainedModel {
            /**
             * @param {any} model_inputs
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class VitMattePreTrainedModel extends PreTrainedModel {
          }
          class VitMatteForImageMatting extends VitMattePreTrainedModel {
            /**
             * @param {any} model_inputs
             */
            async _call(model_inputs) {
              return new ImageMattingOutput(await super._call(model_inputs));
            }
          }
          class MobileViTPreTrainedModel extends PreTrainedModel {
          }
          class MobileViTModel extends MobileViTPreTrainedModel {
          }
          class MobileViTForImageClassification extends MobileViTPreTrainedModel {
            /**
             * @param {any} model_inputs
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class MobileViTV2PreTrainedModel extends PreTrainedModel {
          }
          class MobileViTV2Model extends MobileViTV2PreTrainedModel {
          }
          class MobileViTV2ForImageClassification extends MobileViTV2PreTrainedModel {
            /**
             * @param {any} model_inputs
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class OwlViTPreTrainedModel extends PreTrainedModel {
          }
          class OwlViTModel extends OwlViTPreTrainedModel {
          }
          class OwlViTForObjectDetection extends OwlViTPreTrainedModel {
          }
          class Owlv2PreTrainedModel extends PreTrainedModel {
          }
          class Owlv2Model extends Owlv2PreTrainedModel {
          }
          class Owlv2ForObjectDetection extends Owlv2PreTrainedModel {
          }
          class BeitPreTrainedModel extends PreTrainedModel {
          }
          class BeitModel extends BeitPreTrainedModel {
          }
          class BeitForImageClassification extends BeitPreTrainedModel {
            /**
             * @param {any} model_inputs
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class DetrPreTrainedModel extends PreTrainedModel {
          }
          class DetrModel extends DetrPreTrainedModel {
          }
          class DetrForObjectDetection extends DetrPreTrainedModel {
            /**
             * @param {any} model_inputs
             */
            async _call(model_inputs) {
              return new DetrObjectDetectionOutput(await super._call(model_inputs));
            }
          }
          class DetrForSegmentation extends DetrPreTrainedModel {
            /**
             * Runs the model with the provided inputs
             * @param {Object} model_inputs Model inputs
             * @returns {Promise<DetrSegmentationOutput>} Object containing segmentation outputs
             */
            async _call(model_inputs) {
              return new DetrSegmentationOutput(await super._call(model_inputs));
            }
          }
          class DetrObjectDetectionOutput extends ModelOutput {
            /**
             * @param {Object} output The output of the model.
             * @param {Tensor} output.logits Classification logits (including no-object) for all queries.
             * @param {Tensor} output.pred_boxes Normalized boxes coordinates for all queries, represented as (center_x, center_y, width, height).
             * These values are normalized in [0, 1], relative to the size of each individual image in the batch (disregarding possible padding).
             */
            constructor({ logits, pred_boxes }) {
              super();
              this.logits = logits;
              this.pred_boxes = pred_boxes;
            }
          }
          class DetrSegmentationOutput extends ModelOutput {
            /**
             * @param {Object} output The output of the model.
             * @param {Tensor} output.logits The output logits of the model.
             * @param {Tensor} output.pred_boxes Predicted boxes.
             * @param {Tensor} output.pred_masks Predicted masks.
             */
            constructor({ logits, pred_boxes, pred_masks }) {
              super();
              this.logits = logits;
              this.pred_boxes = pred_boxes;
              this.pred_masks = pred_masks;
            }
          }
          class TableTransformerPreTrainedModel extends PreTrainedModel {
          }
          class TableTransformerModel extends TableTransformerPreTrainedModel {
          }
          class TableTransformerForObjectDetection extends TableTransformerPreTrainedModel {
            /**
             * @param {any} model_inputs
             */
            async _call(model_inputs) {
              return new TableTransformerObjectDetectionOutput(await super._call(model_inputs));
            }
          }
          class TableTransformerObjectDetectionOutput extends DetrObjectDetectionOutput {
          }
          class DeiTPreTrainedModel extends PreTrainedModel {
          }
          class DeiTModel extends DeiTPreTrainedModel {
          }
          class DeiTForImageClassification extends DeiTPreTrainedModel {
            /**
             * @param {any} model_inputs
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class ResNetPreTrainedModel extends PreTrainedModel {
          }
          class ResNetModel extends ResNetPreTrainedModel {
          }
          class ResNetForImageClassification extends ResNetPreTrainedModel {
            /**
             * @param {any} model_inputs
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class SwinPreTrainedModel extends PreTrainedModel {
          }
          class SwinModel extends SwinPreTrainedModel {
          }
          class SwinForImageClassification extends SwinPreTrainedModel {
            /**
             * @param {any} model_inputs
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class Swin2SRPreTrainedModel extends PreTrainedModel {
          }
          class Swin2SRModel extends Swin2SRPreTrainedModel {
          }
          class Swin2SRForImageSuperResolution extends Swin2SRPreTrainedModel {
          }
          class DPTPreTrainedModel extends PreTrainedModel {
          }
          class DPTModel extends DPTPreTrainedModel {
          }
          class DPTForDepthEstimation extends DPTPreTrainedModel {
          }
          class DepthAnythingPreTrainedModel extends PreTrainedModel {
          }
          class DepthAnythingForDepthEstimation extends DepthAnythingPreTrainedModel {
          }
          class GLPNPreTrainedModel extends PreTrainedModel {
          }
          class GLPNModel extends GLPNPreTrainedModel {
          }
          class GLPNForDepthEstimation extends GLPNPreTrainedModel {
          }
          class DonutSwinPreTrainedModel extends PreTrainedModel {
          }
          class DonutSwinModel extends DonutSwinPreTrainedModel {
          }
          class ConvNextPreTrainedModel extends PreTrainedModel {
          }
          class ConvNextModel extends ConvNextPreTrainedModel {
          }
          class ConvNextForImageClassification extends ConvNextPreTrainedModel {
            /**
             * @param {any} model_inputs
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class ConvNextV2PreTrainedModel extends PreTrainedModel {
          }
          class ConvNextV2Model extends ConvNextV2PreTrainedModel {
          }
          class ConvNextV2ForImageClassification extends ConvNextV2PreTrainedModel {
            /**
             * @param {any} model_inputs
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class Dinov2PreTrainedModel extends PreTrainedModel {
          }
          class Dinov2Model extends Dinov2PreTrainedModel {
          }
          class Dinov2ForImageClassification extends Dinov2PreTrainedModel {
            /**
             * @param {any} model_inputs
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class YolosPreTrainedModel extends PreTrainedModel {
          }
          class YolosModel extends YolosPreTrainedModel {
          }
          class YolosForObjectDetection extends YolosPreTrainedModel {
            /**
             * @param {any} model_inputs
             */
            async _call(model_inputs) {
              return new YolosObjectDetectionOutput(await super._call(model_inputs));
            }
          }
          class YolosObjectDetectionOutput extends ModelOutput {
            /**
             * @param {Object} output The output of the model.
             * @param {Tensor} output.logits Classification logits (including no-object) for all queries.
             * @param {Tensor} output.pred_boxes Normalized boxes coordinates for all queries, represented as (center_x, center_y, width, height).
             * These values are normalized in [0, 1], relative to the size of each individual image in the batch (disregarding possible padding).
             */
            constructor({ logits, pred_boxes }) {
              super();
              this.logits = logits;
              this.pred_boxes = pred_boxes;
            }
          }
          class SamPreTrainedModel extends PreTrainedModel {
          }
          class SamModel extends SamPreTrainedModel {
            /**
             * Creates a new instance of the `SamModel` class.
             * @param {Object} config The configuration object specifying the hyperparameters and other model settings.
             * @param {Object} vision_encoder The ONNX session containing the vision encoder model.
             * @param {any} prompt_encoder_mask_decoder The ONNX session containing the prompt encoder and mask decoder model.
             */
            constructor(config2, vision_encoder, prompt_encoder_mask_decoder) {
              super(config2, vision_encoder);
              this.prompt_encoder_mask_decoder = prompt_encoder_mask_decoder;
            }
            /**
             * Compute image embeddings and positional image embeddings, given the pixel values of an image.
             * @param {Object} model_inputs Object containing the model inputs.
             * @param {Tensor} model_inputs.pixel_values Pixel values obtained using a `SamProcessor`.
             * @returns {Promise<{ image_embeddings: Tensor, image_positional_embeddings: Tensor }>} The image embeddings and positional image embeddings.
             */
            async get_image_embeddings({ pixel_values }) {
              return await encoderForward(this, { pixel_values });
            }
            /**
             * @typedef {Object} SamModelInputs Object containing the model inputs.
             * @property {Tensor} pixel_values Pixel values as a Tensor with shape `(batch_size, num_channels, height, width)`.
             * These can be obtained using a `SamProcessor`.
             * @property {Tensor} input_points Input 2D spatial points with shape `(batch_size, num_points, 2)`.
             * This is used by the prompt encoder to encode the prompt.
             * @property {Tensor} [input_labels] Input labels for the points, as a Tensor of shape `(batch_size, point_batch_size, num_points)`.
             * This is used by the prompt encoder to encode the prompt. There are 4 types of labels:
             *  - `1`: the point is a point that contains the object of interest
             *  - `0`: the point is a point that does not contain the object of interest
             *  - `-1`: the point corresponds to the background
             *  - `-10`: the point is a padding point, thus should be ignored by the prompt encoder
             * @property {Tensor} [image_embeddings] Image embeddings used by the mask decoder.
             * @property {Tensor} [image_positional_embeddings] Image positional embeddings used by the mask decoder.
             */
            /**
             * @param {SamModelInputs} model_inputs Object containing the model inputs.
             * @returns {Promise<Object>} The output of the model.
             */
            async forward(model_inputs) {
              if (!model_inputs.image_embeddings || !model_inputs.image_positional_embeddings) {
                model_inputs = {
                  ...model_inputs,
                  ...await this.get_image_embeddings(model_inputs)
                };
              }
              if (!model_inputs.input_labels) {
                const shape = model_inputs.input_points.dims.slice(0, -1);
                const numElements = shape.reduce((a, b) => a * b, 1);
                model_inputs.input_labels = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor(
                  "int64",
                  new BigInt64Array(numElements).fill(1n),
                  shape
                );
              }
              return await sessionRun(this.prompt_encoder_mask_decoder, {
                input_points: model_inputs.input_points,
                input_labels: model_inputs.input_labels,
                image_embeddings: model_inputs.image_embeddings,
                image_positional_embeddings: model_inputs.image_positional_embeddings
              });
            }
            /**
             * Runs the model with the provided inputs
             * @param {Object} model_inputs Model inputs
             * @returns {Promise<SamImageSegmentationOutput>} Object containing segmentation outputs
             */
            async _call(model_inputs) {
              return new SamImageSegmentationOutput(await super._call(model_inputs));
            }
          }
          class SamImageSegmentationOutput extends ModelOutput {
            /**
             * @param {Object} output The output of the model.
             * @param {Tensor} output.iou_scores The output logits of the model.
             * @param {Tensor} output.pred_masks Predicted boxes.
             */
            constructor({ iou_scores, pred_masks }) {
              super();
              this.iou_scores = iou_scores;
              this.pred_masks = pred_masks;
            }
          }
          class MarianPreTrainedModel extends PreTrainedModel {
          }
          ;
          class MarianModel extends MarianPreTrainedModel {
          }
          class MarianMTModel extends MarianPreTrainedModel {
            /**
             * Creates a new instance of the `MarianMTModel` class.
            * @param {Object} config The model configuration object.
            * @param {Object} session The ONNX session object.
            * @param {any} decoder_merged_session 
            * @param {any} generation_config 
            */
            constructor(config2, session, decoder_merged_session, generation_config) {
              super(config2, session);
              this.decoder_merged_session = decoder_merged_session;
              this.generation_config = generation_config;
              this.num_decoder_layers = this.config.decoder_layers;
              this.num_decoder_heads = this.config.decoder_attention_heads;
              this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;
              this.num_encoder_layers = this.config.encoder_layers;
              this.num_encoder_heads = this.config.encoder_attention_heads;
              this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
            }
          }
          class M2M100PreTrainedModel extends PreTrainedModel {
          }
          ;
          class M2M100Model extends M2M100PreTrainedModel {
          }
          class M2M100ForConditionalGeneration extends M2M100PreTrainedModel {
            /**
             * Creates a new instance of the `M2M100ForConditionalGeneration` class.
            * @param {Object} config The model configuration object.
            * @param {Object} session The ONNX session object.
            * @param {any} decoder_merged_session 
            * @param {any} generation_config 
            */
            constructor(config2, session, decoder_merged_session, generation_config) {
              super(config2, session);
              this.decoder_merged_session = decoder_merged_session;
              this.generation_config = generation_config;
              this.num_decoder_layers = this.config.decoder_layers;
              this.num_decoder_heads = this.config.decoder_attention_heads;
              this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;
              this.num_encoder_layers = this.config.encoder_layers;
              this.num_encoder_heads = this.config.encoder_attention_heads;
              this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
            }
          }
          class Wav2Vec2PreTrainedModel extends PreTrainedModel {
          }
          ;
          class Wav2Vec2Model extends Wav2Vec2PreTrainedModel {
          }
          class Wav2Vec2ForCTC extends Wav2Vec2PreTrainedModel {
            /**
             * @param {Object} model_inputs
             * @param {Tensor} model_inputs.input_values Float values of input raw speech waveform.
             * @param {Tensor} model_inputs.attention_mask Mask to avoid performing convolution and attention on padding token indices. Mask values selected in [0, 1]
             */
            async _call(model_inputs) {
              return new CausalLMOutput(await super._call(model_inputs));
            }
          }
          class Wav2Vec2ForSequenceClassification extends Wav2Vec2PreTrainedModel {
            /**
             * Calls the model on new inputs.
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class Wav2Vec2ForAudioFrameClassification extends Wav2Vec2PreTrainedModel {
            /**
             * Calls the model on new inputs.
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for sequence classification.
             */
            async _call(model_inputs) {
              return new TokenClassifierOutput(await super._call(model_inputs));
            }
          }
          class UniSpeechPreTrainedModel extends PreTrainedModel {
          }
          ;
          class UniSpeechModel extends UniSpeechPreTrainedModel {
          }
          class UniSpeechForCTC extends UniSpeechPreTrainedModel {
            /**
             * @param {Object} model_inputs
             * @param {Tensor} model_inputs.input_values Float values of input raw speech waveform.
             * @param {Tensor} model_inputs.attention_mask Mask to avoid performing convolution and attention on padding token indices. Mask values selected in [0, 1]
             */
            async _call(model_inputs) {
              return new CausalLMOutput(await super._call(model_inputs));
            }
          }
          class UniSpeechForSequenceClassification extends UniSpeechPreTrainedModel {
            /**
             * Calls the model on new inputs.
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class UniSpeechSatPreTrainedModel extends PreTrainedModel {
          }
          ;
          class UniSpeechSatModel extends UniSpeechSatPreTrainedModel {
          }
          class UniSpeechSatForCTC extends UniSpeechSatPreTrainedModel {
            /**
             * @param {Object} model_inputs
             * @param {Tensor} model_inputs.input_values Float values of input raw speech waveform.
             * @param {Tensor} model_inputs.attention_mask Mask to avoid performing convolution and attention on padding token indices. Mask values selected in [0, 1]
             */
            async _call(model_inputs) {
              return new CausalLMOutput(await super._call(model_inputs));
            }
          }
          class UniSpeechSatForSequenceClassification extends UniSpeechSatPreTrainedModel {
            /**
             * Calls the model on new inputs.
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class UniSpeechSatForAudioFrameClassification extends UniSpeechSatPreTrainedModel {
            /**
             * Calls the model on new inputs.
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for sequence classification.
             */
            async _call(model_inputs) {
              return new TokenClassifierOutput(await super._call(model_inputs));
            }
          }
          class Wav2Vec2BertPreTrainedModel extends PreTrainedModel {
          }
          ;
          class Wav2Vec2BertModel extends Wav2Vec2BertPreTrainedModel {
          }
          class Wav2Vec2BertForCTC extends Wav2Vec2BertPreTrainedModel {
            /**
             * @param {Object} model_inputs
             * @param {Tensor} model_inputs.input_features Float values of input mel-spectrogram.
             * @param {Tensor} model_inputs.attention_mask Mask to avoid performing convolution and attention on padding token indices. Mask values selected in [0, 1]
             */
            async _call(model_inputs) {
              return new CausalLMOutput(await super._call(model_inputs));
            }
          }
          class Wav2Vec2BertForSequenceClassification extends Wav2Vec2BertPreTrainedModel {
            /**
             * Calls the model on new inputs.
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class HubertPreTrainedModel extends PreTrainedModel {
          }
          class HubertModel extends Wav2Vec2PreTrainedModel {
          }
          class HubertForCTC extends Wav2Vec2PreTrainedModel {
            /**
             * @param {Object} model_inputs
             * @param {Tensor} model_inputs.input_values Float values of input raw speech waveform.
             * @param {Tensor} model_inputs.attention_mask Mask to avoid performing convolution and attention on padding token indices. Mask values selected in [0, 1]
             */
            async _call(model_inputs) {
              return new CausalLMOutput(await super._call(model_inputs));
            }
          }
          class HubertForSequenceClassification extends Wav2Vec2PreTrainedModel {
            /**
             * Calls the model on new inputs.
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class WavLMPreTrainedModel extends PreTrainedModel {
          }
          ;
          class WavLMModel extends WavLMPreTrainedModel {
          }
          class WavLMForCTC extends WavLMPreTrainedModel {
            /**
             * @param {Object} model_inputs
             * @param {Tensor} model_inputs.input_values Float values of input raw speech waveform.
             * @param {Tensor} model_inputs.attention_mask Mask to avoid performing convolution and attention on padding token indices. Mask values selected in [0, 1]
             */
            async _call(model_inputs) {
              return new CausalLMOutput(await super._call(model_inputs));
            }
          }
          class WavLMForSequenceClassification extends WavLMPreTrainedModel {
            /**
             * Calls the model on new inputs.
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class WavLMForXVector extends WavLMPreTrainedModel {
            /**
             * Calls the model on new inputs.
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<XVectorOutput>} An object containing the model's output logits and speaker embeddings.
             */
            async _call(model_inputs) {
              return new XVectorOutput(await super._call(model_inputs));
            }
          }
          class WavLMForAudioFrameClassification extends WavLMPreTrainedModel {
            /**
             * Calls the model on new inputs.
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for sequence classification.
             */
            async _call(model_inputs) {
              return new TokenClassifierOutput(await super._call(model_inputs));
            }
          }
          class SpeechT5PreTrainedModel extends PreTrainedModel {
          }
          ;
          class SpeechT5Model extends SpeechT5PreTrainedModel {
          }
          ;
          class SpeechT5ForSpeechToText extends SpeechT5PreTrainedModel {
          }
          class SpeechT5ForTextToSpeech extends SpeechT5PreTrainedModel {
            /**
             * Creates a new instance of the `SpeechT5ForTextToSpeech` class.
             * @param {Object} config The model configuration.
             * @param {any} session session for the model.
             * @param {any} decoder_merged_session session for the decoder.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, decoder_merged_session, generation_config) {
              super(config2, session);
              this.decoder_merged_session = decoder_merged_session;
              this.generation_config = generation_config;
              this.num_decoder_layers = this.config.decoder_layers;
              this.num_decoder_heads = this.config.decoder_attention_heads;
              this.decoder_dim_kv = this.config.hidden_size / this.num_decoder_heads;
              this.num_encoder_layers = this.config.encoder_layers;
              this.num_encoder_heads = this.config.encoder_attention_heads;
              this.encoder_dim_kv = this.config.hidden_size / this.num_encoder_heads;
            }
            /**
             * @typedef {Object} SpeechOutput
             * @property {Tensor} [spectrogram] The predicted log-mel spectrogram of shape
             * `(output_sequence_length, config.num_mel_bins)`. Returned when no `vocoder` is provided
             * @property {Tensor} [waveform] The predicted waveform of shape `(num_frames,)`. Returned when a `vocoder` is provided.
             * @property {Tensor} [cross_attentions] The outputs of the decoder's cross-attention layers of shape
             * `(config.decoder_layers, config.decoder_attention_heads, output_sequence_length, input_sequence_length)`. returned when `output_cross_attentions` is `true`.
             */
            /**
             * Converts a sequence of input tokens into a sequence of mel spectrograms, which are subsequently turned into a speech waveform using a vocoder.
             * @param {Tensor} input_values Indices of input sequence tokens in the vocabulary.
             * @param {Tensor} speaker_embeddings Tensor containing the speaker embeddings.
             * @param {Object} options Optional parameters for generating speech.
             * @param {number} [options.threshold=0.5] The generated sequence ends when the predicted stop token probability exceeds this value.
             * @param {number} [options.minlenratio=0.0] Used to calculate the minimum required length for the output sequence.
             * @param {number} [options.maxlenratio=20.0] Used to calculate the maximum allowed length for the output sequence.
             * @param {Object} [options.vocoder=null] The vocoder that converts the mel spectrogram into a speech waveform. If `null`, the output is the mel spectrogram.
             * @param {boolean} [options.output_cross_attentions=false] Whether or not to return the attentions tensors of the decoder's cross-attention layers.
             * @returns {Promise<SpeechOutput>} A promise which resolves to an object containing the spectrogram, waveform, and cross-attention tensors.
             */
            async generate_speech(input_values, speaker_embeddings, {
              threshold = 0.5,
              minlenratio = 0,
              maxlenratio = 20,
              vocoder = null
              // output_cross_attentions = false, // TODO add
            } = {}) {
              const model_inputs = {
                input_ids: input_values
              };
              const { encoder_outputs, encoder_attention_mask } = await encoderForward(this, model_inputs);
              const r = encoder_outputs.dims[1] / this.config.reduction_factor;
              const maxlen = Math.floor(r * maxlenratio);
              const minlen = Math.floor(r * minlenratio);
              const num_mel_bins = this.config.num_mel_bins;
              let spectrogramParts = [];
              let past_key_values = null;
              let decoder_outputs = null;
              let idx = 0;
              while (true) {
                ++idx;
                const use_cache_branch = boolTensor(!!decoder_outputs);
                let output_sequence;
                if (decoder_outputs) {
                  output_sequence = decoder_outputs.output_sequence_out;
                } else {
                  output_sequence = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor(
                    "float32",
                    new Float32Array(num_mel_bins),
                    [1, 1, num_mel_bins]
                  );
                }
                let decoderFeeds = {
                  use_cache_branch,
                  output_sequence,
                  encoder_attention_mask,
                  speaker_embeddings,
                  encoder_hidden_states: encoder_outputs
                };
                this.addPastKeyValues(decoderFeeds, past_key_values);
                decoder_outputs = await sessionRun(this.decoder_merged_session, decoderFeeds);
                past_key_values = this.getPastKeyValues(decoder_outputs, past_key_values);
                const { prob, spectrum } = decoder_outputs;
                spectrogramParts.push(spectrum);
                if (idx >= minlen && // Finished when stop token or maximum length is reached.
                (Array.from(prob.data).filter((p) => p >= threshold).length > 0 || idx >= maxlen)) {
                  break;
                }
              }
              const spectrogram = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.cat)(spectrogramParts);
              const { waveform } = await sessionRun(vocoder.session, { spectrogram });
              return {
                spectrogram,
                waveform
                // cross_attentions: null, // TODO add
              };
            }
          }
          class SpeechT5HifiGan extends PreTrainedModel {
            constructor() {
              super(...arguments);
              __publicField(this, "main_input_name", "spectrogram");
            }
          }
          class TrOCRPreTrainedModel extends PreTrainedModel {
            /**
             * Creates a new instance of the `TrOCRPreTrainedModel` class.
             * @param {Object} config The configuration of the model.
             * @param {any} session The ONNX session containing the model weights.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, generation_config) {
              super(config2, session);
              this.generation_config = generation_config;
              this.config.pad_token_id = this.config.eos_token_id;
              this.num_encoder_layers = this.num_decoder_layers = this.config.decoder_layers;
              this.num_encoder_heads = this.num_decoder_heads = this.config.decoder_attention_heads;
              this.encoder_dim_kv = this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;
            }
          }
          class TrOCRForCausalLM extends TrOCRPreTrainedModel {
          }
          class MistralPreTrainedModel extends PreTrainedModel {
            /**
             * Creates a new instance of the `MistralPreTrainedModel` class.
             * @param {Object} config The configuration of the model.
             * @param {any} session The ONNX session containing the model weights.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, generation_config) {
              super(config2, session);
              this.generation_config = generation_config;
              this.config.pad_token_id = this.config.eos_token_id;
              this.num_heads = this.config.num_key_value_heads;
              this.num_layers = this.config.num_hidden_layers;
              this.dim_kv = this.config.hidden_size / this.config.num_attention_heads;
            }
          }
          class MistralModel extends MistralPreTrainedModel {
          }
          class MistralForCausalLM extends MistralPreTrainedModel {
          }
          class Starcoder2PreTrainedModel extends PreTrainedModel {
            /**
             * Creates a new instance of the `Starcoder2PreTrainedModel` class.
             * @param {Object} config The configuration of the model.
             * @param {any} session The ONNX session containing the model weights.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, generation_config) {
              super(config2, session);
              this.generation_config = generation_config;
              this.config.pad_token_id = this.config.eos_token_id;
              this.num_heads = this.config.num_key_value_heads;
              this.num_layers = this.config.num_hidden_layers;
              this.dim_kv = this.config.hidden_size / this.config.num_attention_heads;
            }
          }
          class Starcoder2Model extends Starcoder2PreTrainedModel {
          }
          class Starcoder2ForCausalLM extends Starcoder2PreTrainedModel {
          }
          class FalconPreTrainedModel extends PreTrainedModel {
            /**
             * Creates a new instance of the `FalconPreTrainedModel` class.
             * @param {Object} config The configuration of the model.
             * @param {any} session The ONNX session containing the model weights.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, generation_config) {
              super(config2, session);
              this.generation_config = generation_config;
              this.config.pad_token_id = this.config.eos_token_id;
              this.num_heads = this.config.num_attention_heads;
              this.num_layers = this.config.num_hidden_layers;
              this.dim_kv = this.config.hidden_size / this.config.num_attention_heads;
            }
          }
          class FalconModel extends FalconPreTrainedModel {
          }
          class FalconForCausalLM extends FalconPreTrainedModel {
          }
          class ClapPreTrainedModel extends PreTrainedModel {
          }
          class ClapModel extends ClapPreTrainedModel {
          }
          class ClapTextModelWithProjection extends ClapPreTrainedModel {
            /** @type {PreTrainedModel.from_pretrained} */
            static async from_pretrained(pretrained_model_name_or_path, options = {}) {
              options.model_file_name ?? (options.model_file_name = "text_model");
              return super.from_pretrained(pretrained_model_name_or_path, options);
            }
          }
          class ClapAudioModelWithProjection extends ClapPreTrainedModel {
            /** @type {PreTrainedModel.from_pretrained} */
            static async from_pretrained(pretrained_model_name_or_path, options = {}) {
              options.model_file_name ?? (options.model_file_name = "audio_model");
              return super.from_pretrained(pretrained_model_name_or_path, options);
            }
          }
          class VitsPreTrainedModel extends PreTrainedModel {
          }
          class VitsModel extends VitsPreTrainedModel {
            /**
             * Calls the model on new inputs.
             * @param {Object} model_inputs The inputs to the model.
             * @returns {Promise<VitsModelOutput>} The outputs for the VITS model.
             */
            async _call(model_inputs) {
              return new VitsModelOutput(await super._call(model_inputs));
            }
          }
          class SegformerPreTrainedModel extends PreTrainedModel {
          }
          class SegformerModel extends SegformerPreTrainedModel {
          }
          class SegformerForImageClassification extends SegformerPreTrainedModel {
          }
          class SegformerForSemanticSegmentation extends SegformerPreTrainedModel {
          }
          class StableLmPreTrainedModel extends PreTrainedModel {
            /**
             * Creates a new instance of the `StableLmPreTrainedModel` class.
             * @param {Object} config The configuration of the model.
             * @param {any} session The ONNX session containing the model weights.
             * @param {GenerationConfig} generation_config The generation configuration.
             */
            constructor(config2, session, generation_config) {
              super(config2, session);
              this.generation_config = generation_config;
              this.config.pad_token_id = this.config.eos_token_id;
              this.num_heads = this.config.num_attention_heads;
              this.num_layers = this.config.num_hidden_layers;
              this.dim_kv = this.config.hidden_size / this.num_heads;
            }
          }
          class StableLmModel extends StableLmPreTrainedModel {
          }
          class StableLmForCausalLM extends StableLmPreTrainedModel {
          }
          class EfficientNetPreTrainedModel extends PreTrainedModel {
          }
          class EfficientNetModel extends EfficientNetPreTrainedModel {
          }
          class EfficientNetForImageClassification extends EfficientNetPreTrainedModel {
            /**
             * @param {any} model_inputs
             */
            async _call(model_inputs) {
              return new SequenceClassifierOutput(await super._call(model_inputs));
            }
          }
          class PretrainedMixin {
            /** @type {PreTrainedModel.from_pretrained} */
            static async from_pretrained(pretrained_model_name_or_path, {
              quantized = true,
              progress_callback = null,
              config: config2 = null,
              cache_dir = null,
              local_files_only = false,
              revision = "main",
              model_file_name = null
            } = {}) {
              let options = {
                quantized,
                progress_callback,
                config: config2,
                cache_dir,
                local_files_only,
                revision,
                model_file_name
              };
              config2 = await _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options);
              if (!options.config) {
                options.config = config2;
              }
              if (!this.MODEL_CLASS_MAPPINGS) {
                throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: " + this.name);
              }
              for (let MODEL_CLASS_MAPPING of this.MODEL_CLASS_MAPPINGS) {
                const modelInfo = MODEL_CLASS_MAPPING.get(config2.model_type);
                if (!modelInfo) {
                  continue;
                }
                return await modelInfo[1].from_pretrained(pretrained_model_name_or_path, options);
              }
              if (this.BASE_IF_FAIL) {
                console.warn(`Unknown model class "${config2.model_type}", attempting to construct from base class.`);
                return await PreTrainedModel.from_pretrained(pretrained_model_name_or_path, options);
              } else {
                throw Error(`Unsupported model type: ${config2.model_type}`);
              }
            }
          }
          /**
           * Mapping from model type to model class.
           * @type {Map<string, Object>[]}
           */
          __publicField(PretrainedMixin, "MODEL_CLASS_MAPPINGS", null);
          /**
           * Whether to attempt to instantiate the base class (`PretrainedModel`) if 
           * the model type is not found in the mapping.
           */
          __publicField(PretrainedMixin, "BASE_IF_FAIL", false);
          const MODEL_MAPPING_NAMES_ENCODER_ONLY = /* @__PURE__ */ new Map([
            ["bert", ["BertModel", BertModel]],
            ["nomic_bert", ["NomicBertModel", NomicBertModel]],
            ["roformer", ["RoFormerModel", RoFormerModel]],
            ["electra", ["ElectraModel", ElectraModel]],
            ["esm", ["EsmModel", EsmModel]],
            ["convbert", ["ConvBertModel", ConvBertModel]],
            ["camembert", ["CamembertModel", CamembertModel]],
            ["deberta", ["DebertaModel", DebertaModel]],
            ["deberta-v2", ["DebertaV2Model", DebertaV2Model]],
            ["mpnet", ["MPNetModel", MPNetModel]],
            ["albert", ["AlbertModel", AlbertModel]],
            ["distilbert", ["DistilBertModel", DistilBertModel]],
            ["roberta", ["RobertaModel", RobertaModel]],
            ["xlm", ["XLMModel", XLMModel]],
            ["xlm-roberta", ["XLMRobertaModel", XLMRobertaModel]],
            ["clap", ["ClapModel", ClapModel]],
            ["clip", ["CLIPModel", CLIPModel]],
            ["clipseg", ["CLIPSegModel", CLIPSegModel]],
            ["chinese_clip", ["ChineseCLIPModel", ChineseCLIPModel]],
            ["siglip", ["SiglipModel", SiglipModel]],
            ["mobilebert", ["MobileBertModel", MobileBertModel]],
            ["squeezebert", ["SqueezeBertModel", SqueezeBertModel]],
            ["wav2vec2", ["Wav2Vec2Model", Wav2Vec2Model]],
            ["wav2vec2-bert", ["Wav2Vec2BertModel", Wav2Vec2BertModel]],
            ["unispeech", ["UniSpeechModel", UniSpeechModel]],
            ["unispeech-sat", ["UniSpeechSatModel", UniSpeechSatModel]],
            ["hubert", ["HubertModel", HubertModel]],
            ["wavlm", ["WavLMModel", WavLMModel]],
            ["audio-spectrogram-transformer", ["ASTModel", ASTModel]],
            ["vits", ["VitsModel", VitsModel]],
            ["detr", ["DetrModel", DetrModel]],
            ["table-transformer", ["TableTransformerModel", TableTransformerModel]],
            ["vit", ["ViTModel", ViTModel]],
            ["fastvit", ["FastViTModel", FastViTModel]],
            ["mobilevit", ["MobileViTModel", MobileViTModel]],
            ["mobilevitv2", ["MobileViTV2Model", MobileViTV2Model]],
            ["owlvit", ["OwlViTModel", OwlViTModel]],
            ["owlv2", ["Owlv2Model", Owlv2Model]],
            ["beit", ["BeitModel", BeitModel]],
            ["deit", ["DeiTModel", DeiTModel]],
            ["convnext", ["ConvNextModel", ConvNextModel]],
            ["convnextv2", ["ConvNextV2Model", ConvNextV2Model]],
            ["dinov2", ["Dinov2Model", Dinov2Model]],
            ["resnet", ["ResNetModel", ResNetModel]],
            ["swin", ["SwinModel", SwinModel]],
            ["swin2sr", ["Swin2SRModel", Swin2SRModel]],
            ["donut-swin", ["DonutSwinModel", DonutSwinModel]],
            ["yolos", ["YolosModel", YolosModel]],
            ["dpt", ["DPTModel", DPTModel]],
            ["glpn", ["GLPNModel", GLPNModel]],
            ["hifigan", ["SpeechT5HifiGan", SpeechT5HifiGan]],
            ["efficientnet", ["EfficientNetModel", EfficientNetModel]]
          ]);
          const MODEL_MAPPING_NAMES_ENCODER_DECODER = /* @__PURE__ */ new Map([
            ["t5", ["T5Model", T5Model]],
            ["longt5", ["LongT5Model", LongT5Model]],
            ["mt5", ["MT5Model", MT5Model]],
            ["bart", ["BartModel", BartModel]],
            ["mbart", ["MBartModel", MBartModel]],
            ["marian", ["MarianModel", MarianModel]],
            ["whisper", ["WhisperModel", WhisperModel]],
            ["m2m_100", ["M2M100Model", M2M100Model]],
            ["blenderbot", ["BlenderbotModel", BlenderbotModel]],
            ["blenderbot-small", ["BlenderbotSmallModel", BlenderbotSmallModel]]
          ]);
          const MODEL_MAPPING_NAMES_DECODER_ONLY = /* @__PURE__ */ new Map([
            ["bloom", ["BloomModel", BloomModel]],
            ["gpt2", ["GPT2Model", GPT2Model]],
            ["gptj", ["GPTJModel", GPTJModel]],
            ["gpt_bigcode", ["GPTBigCodeModel", GPTBigCodeModel]],
            ["gpt_neo", ["GPTNeoModel", GPTNeoModel]],
            ["gpt_neox", ["GPTNeoXModel", GPTNeoXModel]],
            ["codegen", ["CodeGenModel", CodeGenModel]],
            ["llama", ["LlamaModel", LlamaModel]],
            ["qwen2", ["Qwen2Model", Qwen2Model]],
            ["phi", ["PhiModel", PhiModel]],
            ["mpt", ["MptModel", MptModel]],
            ["opt", ["OPTModel", OPTModel]],
            ["mistral", ["MistralModel", MistralModel]],
            ["starcoder2", ["Starcoder2Model", Starcoder2Model]],
            ["falcon", ["FalconModel", FalconModel]]
          ]);
          const MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["speecht5", ["SpeechT5ForSpeechToText", SpeechT5ForSpeechToText]],
            ["whisper", ["WhisperForConditionalGeneration", WhisperForConditionalGeneration]]
          ]);
          const MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["speecht5", ["SpeechT5ForTextToSpeech", SpeechT5ForTextToSpeech]]
          ]);
          const MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["vits", ["VitsModel", VitsModel]]
          ]);
          const MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["bert", ["BertForSequenceClassification", BertForSequenceClassification]],
            ["roformer", ["RoFormerForSequenceClassification", RoFormerForSequenceClassification]],
            ["electra", ["ElectraForSequenceClassification", ElectraForSequenceClassification]],
            ["esm", ["EsmForSequenceClassification", EsmForSequenceClassification]],
            ["convbert", ["ConvBertForSequenceClassification", ConvBertForSequenceClassification]],
            ["camembert", ["CamembertForSequenceClassification", CamembertForSequenceClassification]],
            ["deberta", ["DebertaForSequenceClassification", DebertaForSequenceClassification]],
            ["deberta-v2", ["DebertaV2ForSequenceClassification", DebertaV2ForSequenceClassification]],
            ["mpnet", ["MPNetForSequenceClassification", MPNetForSequenceClassification]],
            ["albert", ["AlbertForSequenceClassification", AlbertForSequenceClassification]],
            ["distilbert", ["DistilBertForSequenceClassification", DistilBertForSequenceClassification]],
            ["roberta", ["RobertaForSequenceClassification", RobertaForSequenceClassification]],
            ["xlm", ["XLMForSequenceClassification", XLMForSequenceClassification]],
            ["xlm-roberta", ["XLMRobertaForSequenceClassification", XLMRobertaForSequenceClassification]],
            ["bart", ["BartForSequenceClassification", BartForSequenceClassification]],
            ["mbart", ["MBartForSequenceClassification", MBartForSequenceClassification]],
            ["mobilebert", ["MobileBertForSequenceClassification", MobileBertForSequenceClassification]],
            ["squeezebert", ["SqueezeBertForSequenceClassification", SqueezeBertForSequenceClassification]]
          ]);
          const MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["bert", ["BertForTokenClassification", BertForTokenClassification]],
            ["roformer", ["RoFormerForTokenClassification", RoFormerForTokenClassification]],
            ["electra", ["ElectraForTokenClassification", ElectraForTokenClassification]],
            ["esm", ["EsmForTokenClassification", EsmForTokenClassification]],
            ["convbert", ["ConvBertForTokenClassification", ConvBertForTokenClassification]],
            ["camembert", ["CamembertForTokenClassification", CamembertForTokenClassification]],
            ["deberta", ["DebertaForTokenClassification", DebertaForTokenClassification]],
            ["deberta-v2", ["DebertaV2ForTokenClassification", DebertaV2ForTokenClassification]],
            ["mpnet", ["MPNetForTokenClassification", MPNetForTokenClassification]],
            ["distilbert", ["DistilBertForTokenClassification", DistilBertForTokenClassification]],
            ["roberta", ["RobertaForTokenClassification", RobertaForTokenClassification]],
            ["xlm", ["XLMForTokenClassification", XLMForTokenClassification]],
            ["xlm-roberta", ["XLMRobertaForTokenClassification", XLMRobertaForTokenClassification]]
          ]);
          const MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["t5", ["T5ForConditionalGeneration", T5ForConditionalGeneration]],
            ["longt5", ["LongT5ForConditionalGeneration", LongT5ForConditionalGeneration]],
            ["mt5", ["MT5ForConditionalGeneration", MT5ForConditionalGeneration]],
            ["bart", ["BartForConditionalGeneration", BartForConditionalGeneration]],
            ["mbart", ["MBartForConditionalGeneration", MBartForConditionalGeneration]],
            ["marian", ["MarianMTModel", MarianMTModel]],
            ["m2m_100", ["M2M100ForConditionalGeneration", M2M100ForConditionalGeneration]],
            ["blenderbot", ["BlenderbotForConditionalGeneration", BlenderbotForConditionalGeneration]],
            ["blenderbot-small", ["BlenderbotSmallForConditionalGeneration", BlenderbotSmallForConditionalGeneration]]
          ]);
          const MODEL_WITH_LM_HEAD_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["bloom", ["BloomForCausalLM", BloomForCausalLM]],
            ["gpt2", ["GPT2LMHeadModel", GPT2LMHeadModel]],
            ["gptj", ["GPTJForCausalLM", GPTJForCausalLM]],
            ["gpt_bigcode", ["GPTBigCodeForCausalLM", GPTBigCodeForCausalLM]],
            ["gpt_neo", ["GPTNeoForCausalLM", GPTNeoForCausalLM]],
            ["gpt_neox", ["GPTNeoXForCausalLM", GPTNeoXForCausalLM]],
            ["codegen", ["CodeGenForCausalLM", CodeGenForCausalLM]],
            ["llama", ["LlamaForCausalLM", LlamaForCausalLM]],
            ["qwen2", ["Qwen2ForCausalLM", Qwen2ForCausalLM]],
            ["phi", ["PhiForCausalLM", PhiForCausalLM]],
            ["mpt", ["MptForCausalLM", MptForCausalLM]],
            ["opt", ["OPTForCausalLM", OPTForCausalLM]],
            ["mbart", ["MBartForCausalLM", MBartForCausalLM]],
            ["mistral", ["MistralForCausalLM", MistralForCausalLM]],
            ["starcoder2", ["Starcoder2ForCausalLM", Starcoder2ForCausalLM]],
            ["falcon", ["FalconForCausalLM", FalconForCausalLM]],
            ["trocr", ["TrOCRForCausalLM", TrOCRForCausalLM]],
            ["stablelm", ["StableLmForCausalLM", StableLmForCausalLM]]
          ]);
          const MODEL_FOR_MASKED_LM_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["bert", ["BertForMaskedLM", BertForMaskedLM]],
            ["roformer", ["RoFormerForMaskedLM", RoFormerForMaskedLM]],
            ["electra", ["ElectraForMaskedLM", ElectraForMaskedLM]],
            ["esm", ["EsmForMaskedLM", EsmForMaskedLM]],
            ["convbert", ["ConvBertForMaskedLM", ConvBertForMaskedLM]],
            ["camembert", ["CamembertForMaskedLM", CamembertForMaskedLM]],
            ["deberta", ["DebertaForMaskedLM", DebertaForMaskedLM]],
            ["deberta-v2", ["DebertaV2ForMaskedLM", DebertaV2ForMaskedLM]],
            ["mpnet", ["MPNetForMaskedLM", MPNetForMaskedLM]],
            ["albert", ["AlbertForMaskedLM", AlbertForMaskedLM]],
            ["distilbert", ["DistilBertForMaskedLM", DistilBertForMaskedLM]],
            ["roberta", ["RobertaForMaskedLM", RobertaForMaskedLM]],
            ["xlm", ["XLMWithLMHeadModel", XLMWithLMHeadModel]],
            ["xlm-roberta", ["XLMRobertaForMaskedLM", XLMRobertaForMaskedLM]],
            ["mobilebert", ["MobileBertForMaskedLM", MobileBertForMaskedLM]],
            ["squeezebert", ["SqueezeBertForMaskedLM", SqueezeBertForMaskedLM]]
          ]);
          const MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["bert", ["BertForQuestionAnswering", BertForQuestionAnswering]],
            ["roformer", ["RoFormerForQuestionAnswering", RoFormerForQuestionAnswering]],
            ["electra", ["ElectraForQuestionAnswering", ElectraForQuestionAnswering]],
            ["convbert", ["ConvBertForQuestionAnswering", ConvBertForQuestionAnswering]],
            ["camembert", ["CamembertForQuestionAnswering", CamembertForQuestionAnswering]],
            ["deberta", ["DebertaForQuestionAnswering", DebertaForQuestionAnswering]],
            ["deberta-v2", ["DebertaV2ForQuestionAnswering", DebertaV2ForQuestionAnswering]],
            ["mpnet", ["MPNetForQuestionAnswering", MPNetForQuestionAnswering]],
            ["albert", ["AlbertForQuestionAnswering", AlbertForQuestionAnswering]],
            ["distilbert", ["DistilBertForQuestionAnswering", DistilBertForQuestionAnswering]],
            ["roberta", ["RobertaForQuestionAnswering", RobertaForQuestionAnswering]],
            ["xlm", ["XLMForQuestionAnswering", XLMForQuestionAnswering]],
            ["xlm-roberta", ["XLMRobertaForQuestionAnswering", XLMRobertaForQuestionAnswering]],
            ["mobilebert", ["MobileBertForQuestionAnswering", MobileBertForQuestionAnswering]],
            ["squeezebert", ["SqueezeBertForQuestionAnswering", SqueezeBertForQuestionAnswering]]
          ]);
          const MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["vision-encoder-decoder", ["VisionEncoderDecoderModel", VisionEncoderDecoderModel]]
          ]);
          const MODEL_FOR_DOCUMENT_QUESTION_ANSWERING_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["vision-encoder-decoder", ["VisionEncoderDecoderModel", VisionEncoderDecoderModel]]
          ]);
          const MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["vit", ["ViTForImageClassification", ViTForImageClassification]],
            ["fastvit", ["FastViTForImageClassification", FastViTForImageClassification]],
            ["mobilevit", ["MobileViTForImageClassification", MobileViTForImageClassification]],
            ["mobilevitv2", ["MobileViTV2ForImageClassification", MobileViTV2ForImageClassification]],
            ["beit", ["BeitForImageClassification", BeitForImageClassification]],
            ["deit", ["DeiTForImageClassification", DeiTForImageClassification]],
            ["convnext", ["ConvNextForImageClassification", ConvNextForImageClassification]],
            ["convnextv2", ["ConvNextV2ForImageClassification", ConvNextV2ForImageClassification]],
            ["dinov2", ["Dinov2ForImageClassification", Dinov2ForImageClassification]],
            ["resnet", ["ResNetForImageClassification", ResNetForImageClassification]],
            ["swin", ["SwinForImageClassification", SwinForImageClassification]],
            ["segformer", ["SegformerForImageClassification", SegformerForImageClassification]],
            ["efficientnet", ["EfficientNetForImageClassification", EfficientNetForImageClassification]]
          ]);
          const MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["detr", ["DetrForObjectDetection", DetrForObjectDetection]],
            ["table-transformer", ["TableTransformerForObjectDetection", TableTransformerForObjectDetection]],
            ["yolos", ["YolosForObjectDetection", YolosForObjectDetection]]
          ]);
          const MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["owlvit", ["OwlViTForObjectDetection", OwlViTForObjectDetection]],
            ["owlv2", ["Owlv2ForObjectDetection", Owlv2ForObjectDetection]]
          ]);
          const MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["detr", ["DetrForSegmentation", DetrForSegmentation]],
            ["clipseg", ["CLIPSegForImageSegmentation", CLIPSegForImageSegmentation]]
          ]);
          const MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["segformer", ["SegformerForSemanticSegmentation", SegformerForSemanticSegmentation]]
          ]);
          const MODEL_FOR_MASK_GENERATION_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["sam", ["SamModel", SamModel]]
          ]);
          const MODEL_FOR_CTC_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["wav2vec2", ["Wav2Vec2ForCTC", Wav2Vec2ForCTC]],
            ["wav2vec2-bert", ["Wav2Vec2BertForCTC", Wav2Vec2BertForCTC]],
            ["unispeech", ["UniSpeechForCTC", UniSpeechForCTC]],
            ["unispeech-sat", ["UniSpeechSatForCTC", UniSpeechSatForCTC]],
            ["wavlm", ["WavLMForCTC", WavLMForCTC]],
            ["hubert", ["HubertForCTC", HubertForCTC]]
          ]);
          const MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["wav2vec2", ["Wav2Vec2ForSequenceClassification", Wav2Vec2ForSequenceClassification]],
            ["wav2vec2-bert", ["Wav2Vec2BertForSequenceClassification", Wav2Vec2BertForSequenceClassification]],
            ["unispeech", ["UniSpeechForSequenceClassification", UniSpeechForSequenceClassification]],
            ["unispeech-sat", ["UniSpeechSatForSequenceClassification", UniSpeechSatForSequenceClassification]],
            ["wavlm", ["WavLMForSequenceClassification", WavLMForSequenceClassification]],
            ["hubert", ["HubertForSequenceClassification", HubertForSequenceClassification]],
            ["audio-spectrogram-transformer", ["ASTForAudioClassification", ASTForAudioClassification]]
          ]);
          const MODEL_FOR_AUDIO_XVECTOR_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["wavlm", ["WavLMForXVector", WavLMForXVector]]
          ]);
          const MODEL_FOR_AUDIO_FRAME_CLASSIFICATION_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["unispeech-sat", ["UniSpeechSatForAudioFrameClassification", UniSpeechSatForAudioFrameClassification]],
            ["wavlm", ["WavLMForAudioFrameClassification", WavLMForAudioFrameClassification]],
            ["wav2vec2", ["Wav2Vec2ForAudioFrameClassification", Wav2Vec2ForAudioFrameClassification]]
          ]);
          const MODEL_FOR_IMAGE_MATTING_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["vitmatte", ["VitMatteForImageMatting", VitMatteForImageMatting]]
          ]);
          const MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["swin2sr", ["Swin2SRForImageSuperResolution", Swin2SRForImageSuperResolution]]
          ]);
          const MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["dpt", ["DPTForDepthEstimation", DPTForDepthEstimation]],
            ["depth_anything", ["DepthAnythingForDepthEstimation", DepthAnythingForDepthEstimation]],
            ["glpn", ["GLPNForDepthEstimation", GLPNForDepthEstimation]]
          ]);
          const MODEL_FOR_IMAGE_FEATURE_EXTRACTION_MAPPING_NAMES = /* @__PURE__ */ new Map([
            ["clip", ["CLIPVisionModelWithProjection", CLIPVisionModelWithProjection]],
            ["siglip", ["SiglipVisionModel", SiglipVisionModel]]
          ]);
          const MODEL_CLASS_TYPE_MAPPING = [
            [MODEL_MAPPING_NAMES_ENCODER_ONLY, MODEL_TYPES.EncoderOnly],
            [MODEL_MAPPING_NAMES_ENCODER_DECODER, MODEL_TYPES.EncoderDecoder],
            [MODEL_MAPPING_NAMES_DECODER_ONLY, MODEL_TYPES.DecoderOnly],
            [MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
            [MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
            [MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES, MODEL_TYPES.Seq2Seq],
            [MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES, MODEL_TYPES.Seq2Seq],
            [MODEL_WITH_LM_HEAD_MAPPING_NAMES, MODEL_TYPES.DecoderOnly],
            [MODEL_FOR_MASKED_LM_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
            [MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
            [MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES, MODEL_TYPES.Vision2Seq],
            [MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
            [MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
            [MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
            [MODEL_FOR_IMAGE_MATTING_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
            [MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
            [MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
            [MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
            [MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
            [MODEL_FOR_MASK_GENERATION_MAPPING_NAMES, MODEL_TYPES.MaskGeneration],
            [MODEL_FOR_CTC_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
            [MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
            [MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES, MODEL_TYPES.Seq2Seq],
            [MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
            [MODEL_FOR_AUDIO_XVECTOR_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
            [MODEL_FOR_AUDIO_FRAME_CLASSIFICATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
            // Custom:
            [MODEL_FOR_IMAGE_FEATURE_EXTRACTION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly]
          ];
          for (const [mappings, type] of MODEL_CLASS_TYPE_MAPPING) {
            for (const [name2, model] of mappings.values()) {
              MODEL_TYPE_MAPPING.set(name2, type);
              MODEL_CLASS_TO_NAME_MAPPING.set(model, name2);
              MODEL_NAME_TO_CLASS_MAPPING.set(name2, model);
            }
          }
          const CUSTOM_MAPPING = [
            ["CLIPTextModelWithProjection", CLIPTextModelWithProjection, MODEL_TYPES.EncoderOnly],
            ["SiglipTextModel", SiglipTextModel, MODEL_TYPES.EncoderOnly],
            ["ClapTextModelWithProjection", ClapTextModelWithProjection, MODEL_TYPES.EncoderOnly],
            ["ClapAudioModelWithProjection", ClapAudioModelWithProjection, MODEL_TYPES.EncoderOnly]
          ];
          for (const [name2, model, type] of CUSTOM_MAPPING) {
            MODEL_TYPE_MAPPING.set(name2, type);
            MODEL_CLASS_TO_NAME_MAPPING.set(model, name2);
            MODEL_NAME_TO_CLASS_MAPPING.set(name2, model);
          }
          class AutoModel extends PretrainedMixin {
          }
          /** @type {Map<string, Object>[]} */
          // @ts-ignore
          __publicField(AutoModel, "MODEL_CLASS_MAPPINGS", MODEL_CLASS_TYPE_MAPPING.map((x) => x[0]));
          __publicField(AutoModel, "BASE_IF_FAIL", true);
          class AutoModelForSequenceClassification extends PretrainedMixin {
          }
          __publicField(AutoModelForSequenceClassification, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES]);
          class AutoModelForTokenClassification extends PretrainedMixin {
          }
          __publicField(AutoModelForTokenClassification, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES]);
          class AutoModelForSeq2SeqLM extends PretrainedMixin {
          }
          __publicField(AutoModelForSeq2SeqLM, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES]);
          class AutoModelForSpeechSeq2Seq extends PretrainedMixin {
          }
          __publicField(AutoModelForSpeechSeq2Seq, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES]);
          class AutoModelForTextToSpectrogram extends PretrainedMixin {
          }
          __publicField(AutoModelForTextToSpectrogram, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES]);
          class AutoModelForTextToWaveform extends PretrainedMixin {
          }
          __publicField(AutoModelForTextToWaveform, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES]);
          class AutoModelForCausalLM extends PretrainedMixin {
          }
          __publicField(AutoModelForCausalLM, "MODEL_CLASS_MAPPINGS", [MODEL_WITH_LM_HEAD_MAPPING_NAMES]);
          class AutoModelForMaskedLM extends PretrainedMixin {
          }
          __publicField(AutoModelForMaskedLM, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_MASKED_LM_MAPPING_NAMES]);
          class AutoModelForQuestionAnswering extends PretrainedMixin {
          }
          __publicField(AutoModelForQuestionAnswering, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES]);
          class AutoModelForVision2Seq extends PretrainedMixin {
          }
          __publicField(AutoModelForVision2Seq, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES]);
          class AutoModelForImageClassification extends PretrainedMixin {
          }
          __publicField(AutoModelForImageClassification, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES]);
          class AutoModelForImageSegmentation extends PretrainedMixin {
          }
          __publicField(AutoModelForImageSegmentation, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES]);
          class AutoModelForSemanticSegmentation extends PretrainedMixin {
          }
          __publicField(AutoModelForSemanticSegmentation, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES]);
          class AutoModelForObjectDetection extends PretrainedMixin {
          }
          __publicField(AutoModelForObjectDetection, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES]);
          class AutoModelForZeroShotObjectDetection extends PretrainedMixin {
          }
          __publicField(AutoModelForZeroShotObjectDetection, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES]);
          class AutoModelForMaskGeneration extends PretrainedMixin {
          }
          __publicField(AutoModelForMaskGeneration, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_MASK_GENERATION_MAPPING_NAMES]);
          class AutoModelForCTC extends PretrainedMixin {
          }
          __publicField(AutoModelForCTC, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_CTC_MAPPING_NAMES]);
          class AutoModelForAudioClassification extends PretrainedMixin {
          }
          __publicField(AutoModelForAudioClassification, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES]);
          class AutoModelForXVector extends PretrainedMixin {
          }
          __publicField(AutoModelForXVector, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_AUDIO_XVECTOR_MAPPING_NAMES]);
          class AutoModelForAudioFrameClassification extends PretrainedMixin {
          }
          __publicField(AutoModelForAudioFrameClassification, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_AUDIO_FRAME_CLASSIFICATION_MAPPING_NAMES]);
          class AutoModelForDocumentQuestionAnswering extends PretrainedMixin {
          }
          __publicField(AutoModelForDocumentQuestionAnswering, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_DOCUMENT_QUESTION_ANSWERING_MAPPING_NAMES]);
          class AutoModelForImageMatting extends PretrainedMixin {
          }
          __publicField(AutoModelForImageMatting, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_IMAGE_MATTING_MAPPING_NAMES]);
          class AutoModelForImageToImage extends PretrainedMixin {
          }
          __publicField(AutoModelForImageToImage, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES]);
          class AutoModelForDepthEstimation extends PretrainedMixin {
          }
          __publicField(AutoModelForDepthEstimation, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES]);
          class AutoModelForImageFeatureExtraction extends PretrainedMixin {
          }
          __publicField(AutoModelForImageFeatureExtraction, "MODEL_CLASS_MAPPINGS", [MODEL_FOR_IMAGE_FEATURE_EXTRACTION_MAPPING_NAMES]);
          class Seq2SeqLMOutput extends ModelOutput {
            /**
             * @param {Object} output The output of the model.
             * @param {Tensor} output.logits The output logits of the model.
             * @param {Tensor} output.past_key_values An tensor of key/value pairs that represent the previous state of the model.
             * @param {Tensor} output.encoder_outputs The output of the encoder in a sequence-to-sequence model.
             * @param {Tensor} [output.decoder_attentions] Attentions weights of the decoder, after the attention softmax, used to compute the weighted average in the self-attention heads.
             * @param {Tensor} [output.cross_attentions] Attentions weights of the decoder's cross-attention layer, after the attention softmax, used to compute the weighted average in the cross-attention heads.
             */
            constructor({ logits, past_key_values, encoder_outputs, decoder_attentions = null, cross_attentions = null }) {
              super();
              this.logits = logits;
              this.past_key_values = past_key_values;
              this.encoder_outputs = encoder_outputs;
              this.decoder_attentions = decoder_attentions;
              this.cross_attentions = cross_attentions;
            }
          }
          class SequenceClassifierOutput extends ModelOutput {
            /**
             * @param {Object} output The output of the model.
             * @param {Tensor} output.logits classification (or regression if config.num_labels==1) scores (before SoftMax).
             */
            constructor({ logits }) {
              super();
              this.logits = logits;
            }
          }
          class XVectorOutput extends ModelOutput {
            /**
             * @param {Object} output The output of the model.
             * @param {Tensor} output.logits Classification hidden states before AMSoftmax, of shape `(batch_size, config.xvector_output_dim)`.
             * @param {Tensor} output.embeddings Utterance embeddings used for vector similarity-based retrieval, of shape `(batch_size, config.xvector_output_dim)`.
             */
            constructor({ logits, embeddings }) {
              super();
              this.logits = logits;
              this.embeddings = embeddings;
            }
          }
          class TokenClassifierOutput extends ModelOutput {
            /**
             * @param {Object} output The output of the model.
             * @param {Tensor} output.logits Classification scores (before SoftMax).
             */
            constructor({ logits }) {
              super();
              this.logits = logits;
            }
          }
          class MaskedLMOutput extends ModelOutput {
            /**
             * @param {Object} output The output of the model.
             * @param {Tensor} output.logits Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).
             */
            constructor({ logits }) {
              super();
              this.logits = logits;
            }
          }
          class QuestionAnsweringModelOutput extends ModelOutput {
            /**
             * @param {Object} output The output of the model.
             * @param {Tensor} output.start_logits Span-start scores (before SoftMax).
             * @param {Tensor} output.end_logits Span-end scores (before SoftMax).
             */
            constructor({ start_logits, end_logits }) {
              super();
              this.start_logits = start_logits;
              this.end_logits = end_logits;
            }
          }
          class CausalLMOutput extends ModelOutput {
            /**
             * @param {Object} output The output of the model.
             * @param {Tensor} output.logits Prediction scores of the language modeling head (scores for each vocabulary token before softmax).
             */
            constructor({ logits }) {
              super();
              this.logits = logits;
            }
          }
          class CausalLMOutputWithPast extends ModelOutput {
            /**
             * @param {Object} output The output of the model.
             * @param {Tensor} output.logits Prediction scores of the language modeling head (scores for each vocabulary token before softmax).
             * @param {Tensor} output.past_key_values Contains pre-computed hidden-states (key and values in the self-attention blocks)
             * that can be used (see `past_key_values` input) to speed up sequential decoding.
             */
            constructor({ logits, past_key_values }) {
              super();
              this.logits = logits;
              this.past_key_values = past_key_values;
            }
          }
          class ImageMattingOutput extends ModelOutput {
            /**
             * @param {Object} output The output of the model.
             * @param {Tensor} output.alphas Estimated alpha values, of shape `(batch_size, num_channels, height, width)`.
             */
            constructor({ alphas }) {
              super();
              this.alphas = alphas;
            }
          }
          class VitsModelOutput extends ModelOutput {
            /**
             * @param {Object} output The output of the model.
             * @param {Tensor} output.waveform The final audio waveform predicted by the model, of shape `(batch_size, sequence_length)`.
             * @param {Tensor} output.spectrogram The log-mel spectrogram predicted at the output of the flow model.
             * This spectrogram is passed to the Hi-Fi GAN decoder model to obtain the final audio waveform.
             */
            constructor({ waveform, spectrogram }) {
              super();
              this.waveform = waveform;
              this.spectrogram = spectrogram;
            }
          }
        }
      ),
      /***/
      "./src/pipelines.js": (
        /*!**************************!*\
          !*** ./src/pipelines.js ***!
          \**************************/
        /***/
        (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "AudioClassificationPipeline": () => (
              /* binding */
              AudioClassificationPipeline
            ),
            /* harmony export */
            "AutomaticSpeechRecognitionPipeline": () => (
              /* binding */
              AutomaticSpeechRecognitionPipeline
            ),
            /* harmony export */
            "DepthEstimationPipeline": () => (
              /* binding */
              DepthEstimationPipeline
            ),
            /* harmony export */
            "DocumentQuestionAnsweringPipeline": () => (
              /* binding */
              DocumentQuestionAnsweringPipeline
            ),
            /* harmony export */
            "FeatureExtractionPipeline": () => (
              /* binding */
              FeatureExtractionPipeline
            ),
            /* harmony export */
            "FillMaskPipeline": () => (
              /* binding */
              FillMaskPipeline
            ),
            /* harmony export */
            "ImageClassificationPipeline": () => (
              /* binding */
              ImageClassificationPipeline
            ),
            /* harmony export */
            "ImageFeatureExtractionPipeline": () => (
              /* binding */
              ImageFeatureExtractionPipeline
            ),
            /* harmony export */
            "ImageSegmentationPipeline": () => (
              /* binding */
              ImageSegmentationPipeline
            ),
            /* harmony export */
            "ImageToImagePipeline": () => (
              /* binding */
              ImageToImagePipeline
            ),
            /* harmony export */
            "ImageToTextPipeline": () => (
              /* binding */
              ImageToTextPipeline
            ),
            /* harmony export */
            "ObjectDetectionPipeline": () => (
              /* binding */
              ObjectDetectionPipeline
            ),
            /* harmony export */
            "Pipeline": () => (
              /* binding */
              Pipeline
            ),
            /* harmony export */
            "QuestionAnsweringPipeline": () => (
              /* binding */
              QuestionAnsweringPipeline
            ),
            /* harmony export */
            "SummarizationPipeline": () => (
              /* binding */
              SummarizationPipeline
            ),
            /* harmony export */
            "Text2TextGenerationPipeline": () => (
              /* binding */
              Text2TextGenerationPipeline
            ),
            /* harmony export */
            "TextClassificationPipeline": () => (
              /* binding */
              TextClassificationPipeline
            ),
            /* harmony export */
            "TextGenerationPipeline": () => (
              /* binding */
              TextGenerationPipeline
            ),
            /* harmony export */
            "TextToAudioPipeline": () => (
              /* binding */
              TextToAudioPipeline
            ),
            /* harmony export */
            "TokenClassificationPipeline": () => (
              /* binding */
              TokenClassificationPipeline
            ),
            /* harmony export */
            "TranslationPipeline": () => (
              /* binding */
              TranslationPipeline
            ),
            /* harmony export */
            "ZeroShotAudioClassificationPipeline": () => (
              /* binding */
              ZeroShotAudioClassificationPipeline
            ),
            /* harmony export */
            "ZeroShotClassificationPipeline": () => (
              /* binding */
              ZeroShotClassificationPipeline
            ),
            /* harmony export */
            "ZeroShotImageClassificationPipeline": () => (
              /* binding */
              ZeroShotImageClassificationPipeline
            ),
            /* harmony export */
            "ZeroShotObjectDetectionPipeline": () => (
              /* binding */
              ZeroShotObjectDetectionPipeline
            ),
            /* harmony export */
            "pipeline": () => (
              /* binding */
              pipeline
            )
            /* harmony export */
          });
          var _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__3(
            /*! ./tokenizers.js */
            "./src/tokenizers.js"
          );
          var _models_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__3(
            /*! ./models.js */
            "./src/models.js"
          );
          var _processors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__3(
            /*! ./processors.js */
            "./src/processors.js"
          );
          var _utils_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__3(
            /*! ./utils/core.js */
            "./src/utils/core.js"
          );
          var _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__3(
            /*! ./utils/maths.js */
            "./src/utils/maths.js"
          );
          var _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__3(
            /*! ./utils/audio.js */
            "./src/utils/audio.js"
          );
          var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__3(
            /*! ./utils/tensor.js */
            "./src/utils/tensor.js"
          );
          var _utils_image_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__3(
            /*! ./utils/image.js */
            "./src/utils/image.js"
          );
          async function prepareImages(images) {
            if (!Array.isArray(images)) {
              images = [images];
            }
            return await Promise.all(images.map((x) => _utils_image_js__WEBPACK_IMPORTED_MODULE_7__.RawImage.read(x)));
          }
          async function prepareAudios(audios, sampling_rate) {
            if (!Array.isArray(audios)) {
              audios = [audios];
            }
            return await Promise.all(audios.map((x) => {
              if (typeof x === "string" || x instanceof URL) {
                return (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.read_audio)(x, sampling_rate);
              } else if (x instanceof Float64Array) {
                return new Float32Array(x);
              }
              return x;
            }));
          }
          function get_bounding_box(box, asInteger) {
            if (asInteger) {
              box = box.map((x) => x | 0);
            }
            const [xmin, ymin, xmax, ymax] = box;
            return { xmin, ymin, xmax, ymax };
          }
          class Pipeline extends _utils_core_js__WEBPACK_IMPORTED_MODULE_3__.Callable {
            /**
             * Create a new Pipeline.
             * @param {Object} options An object containing the following properties:
             * @param {string} [options.task] The task of the pipeline. Useful for specifying subtasks.
             * @param {PreTrainedModel} [options.model] The model used by the pipeline.
             * @param {PreTrainedTokenizer} [options.tokenizer=null] The tokenizer used by the pipeline (if any).
             * @param {Processor} [options.processor=null] The processor used by the pipeline (if any).
             */
            constructor({ task, model, tokenizer = null, processor = null }) {
              super();
              this.task = task;
              this.model = model;
              this.tokenizer = tokenizer;
              this.processor = processor;
            }
            /** @type {DisposeType} */
            async dispose() {
              await this.model.dispose();
            }
          }
          class TextClassificationPipeline extends /** @type {new (options: TextPipelineConstructorArgs) => TextClassificationPipelineType} */
          Pipeline {
            /**
             * Create a new TextClassificationPipeline.
             * @param {TextPipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
            }
            /** @type {TextClassificationPipelineCallback} */
            async _call(texts, {
              topk = 1
            } = {}) {
              const model_inputs = this.tokenizer(texts, {
                padding: true,
                truncation: true
              });
              const outputs = await this.model(model_inputs);
              const function_to_apply = this.model.config.problem_type === "multi_label_classification" ? (batch) => batch.sigmoid().data : (batch) => (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(batch.data);
              const id2label = this.model.config.id2label;
              const toReturn = [];
              for (const batch of outputs.logits) {
                const output = function_to_apply(batch);
                const scores = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.getTopItems)(output, topk);
                const vals = scores.map((x) => ({
                  label: id2label[x[0]],
                  score: x[1]
                }));
                if (topk === 1) {
                  toReturn.push(...vals);
                } else {
                  toReturn.push(vals);
                }
              }
              return Array.isArray(texts) || topk === 1 ? (
                /** @type {TextClassificationOutput} */
                toReturn
              ) : (
                /** @type {TextClassificationOutput[]} */
                toReturn[0]
              );
            }
          }
          class TokenClassificationPipeline extends /** @type {new (options: TextPipelineConstructorArgs) => TokenClassificationPipelineType} */
          Pipeline {
            /**
             * Create a new TokenClassificationPipeline.
             * @param {TextPipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
            }
            /** @type {TokenClassificationPipelineCallback} */
            async _call(texts, {
              ignore_labels = ["O"]
            } = {}) {
              const isBatched = Array.isArray(texts);
              const model_inputs = this.tokenizer(isBatched ? texts : [texts], {
                padding: true,
                truncation: true
              });
              const outputs = await this.model(model_inputs);
              const logits = outputs.logits;
              const id2label = this.model.config.id2label;
              const toReturn = [];
              for (let i = 0; i < logits.dims[0]; ++i) {
                const ids = model_inputs.input_ids[i];
                const batch = logits[i];
                const tokens = [];
                for (let j = 0; j < batch.dims[0]; ++j) {
                  const tokenData = batch[j];
                  const topScoreIndex = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.max)(tokenData.data)[1];
                  const entity2 = id2label ? id2label[topScoreIndex] : `LABEL_${topScoreIndex}`;
                  if (ignore_labels.includes(entity2)) {
                    continue;
                  }
                  const word = this.tokenizer.decode([ids[j].item()], { skip_special_tokens: true });
                  if (word === "") {
                    continue;
                  }
                  const scores = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(tokenData.data);
                  tokens.push({
                    entity: entity2,
                    score: scores[topScoreIndex],
                    index: j,
                    word,
                    // TODO: null for now, but will add
                    start: null,
                    end: null
                  });
                }
                toReturn.push(tokens);
              }
              return isBatched ? toReturn : toReturn[0];
            }
          }
          class QuestionAnsweringPipeline extends /** @type {new (options: TextPipelineConstructorArgs) => QuestionAnsweringPipelineType} */
          Pipeline {
            /**
             * Create a new QuestionAnsweringPipeline.
             * @param {TextPipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
            }
            /** @type {QuestionAnsweringPipelineCallback} */
            async _call(question, context, {
              topk = 1
            } = {}) {
              const inputs = this.tokenizer(question, {
                text_pair: context,
                padding: true,
                truncation: true
              });
              const output = await this.model(inputs);
              const toReturn = [];
              for (let j = 0; j < output.start_logits.dims[0]; ++j) {
                const ids = inputs.input_ids[j];
                const sepIndex = ids.indexOf(this.tokenizer.sep_token_id);
                const s1 = Array.from((0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(output.start_logits[j].data)).map((x, i) => [x, i]).filter((x) => x[1] > sepIndex);
                const e1 = Array.from((0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(output.end_logits[j].data)).map((x, i) => [x, i]).filter((x) => x[1] > sepIndex);
                const options = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_3__.product)(s1, e1).filter((x) => x[0][1] <= x[1][1]).map((x) => [x[0][1], x[1][1], x[0][0] * x[1][0]]).sort((a, b) => b[2] - a[2]);
                for (let k = 0; k < Math.min(options.length, topk); ++k) {
                  const [start, end, score] = options[k];
                  const answer_tokens = [...ids].slice(start, end + 1);
                  const answer = this.tokenizer.decode(answer_tokens, {
                    skip_special_tokens: true
                  });
                  toReturn.push({
                    answer,
                    score
                  });
                }
              }
              return topk === 1 ? toReturn[0] : toReturn;
            }
          }
          class FillMaskPipeline extends /** @type {new (options: TextPipelineConstructorArgs) => FillMaskPipelineType} */
          Pipeline {
            /**
             * Create a new FillMaskPipeline.
             * @param {TextPipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
            }
            /** @type {FillMaskPipelineCallback} */
            async _call(texts, {
              topk = 5
            } = {}) {
              const model_inputs = this.tokenizer(texts, {
                padding: true,
                truncation: true
              });
              const outputs = await this.model(model_inputs);
              const toReturn = [];
              for (let i = 0; i < model_inputs.input_ids.dims[0]; ++i) {
                const ids = model_inputs.input_ids[i];
                const mask_token_index = ids.indexOf(this.tokenizer.mask_token_id);
                if (mask_token_index === -1) {
                  throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);
                }
                const logits = outputs.logits[i];
                const itemLogits = logits[mask_token_index];
                const scores = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.getTopItems)((0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(itemLogits.data), topk);
                toReturn.push(scores.map((x) => {
                  const sequence = [...ids];
                  sequence[mask_token_index] = x[0];
                  return {
                    score: x[1],
                    token: x[0],
                    token_str: this.tokenizer.model.vocab[x[0]],
                    sequence: this.tokenizer.decode(sequence, { skip_special_tokens: true })
                  };
                }));
              }
              return Array.isArray(texts) ? toReturn : toReturn[0];
            }
          }
          class Text2TextGenerationPipeline extends /** @type {new (options: TextPipelineConstructorArgs) => Text2TextGenerationPipelineType} */
          Pipeline {
            /**
             * Create a new Text2TextGenerationPipeline.
             * @param {TextPipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
              /** @type {'generated_text'} */
              __publicField(this, "_key", "generated_text");
            }
            /** @type {Text2TextGenerationPipelineCallback} */
            async _call(texts, generate_kwargs = {}) {
              if (!Array.isArray(texts)) {
                texts = [texts];
              }
              if (this.model.config.prefix) {
                texts = texts.map((x) => this.model.config.prefix + x);
              }
              const task_specific_params = this.model.config.task_specific_params;
              if (task_specific_params && task_specific_params[this.task]) {
                if (task_specific_params[this.task].prefix) {
                  texts = texts.map((x) => task_specific_params[this.task].prefix + x);
                }
              }
              const tokenizer = this.tokenizer;
              const tokenizer_options = {
                padding: true,
                truncation: true
              };
              let input_ids;
              if (this instanceof TranslationPipeline && "_build_translation_inputs" in tokenizer) {
                input_ids = tokenizer._build_translation_inputs(texts, tokenizer_options, generate_kwargs).input_ids;
              } else {
                input_ids = tokenizer(texts, tokenizer_options).input_ids;
              }
              const outputTokenIds = await this.model.generate(input_ids, generate_kwargs);
              return tokenizer.batch_decode(outputTokenIds, {
                skip_special_tokens: true
              }).map((text2) => ({ [this._key]: text2 }));
            }
          }
          class SummarizationPipeline extends /** @type {new (options: TextPipelineConstructorArgs) => SummarizationPipelineType} */
          /** @type {any} */
          Text2TextGenerationPipeline {
            /**
             * Create a new SummarizationPipeline.
             * @param {TextPipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
              /** @type {'summary_text'} */
              __publicField(this, "_key", "summary_text");
            }
          }
          class TranslationPipeline extends /** @type {new (options: TextPipelineConstructorArgs) => TranslationPipelineType} */
          /** @type {any} */
          Text2TextGenerationPipeline {
            /**
             * Create a new TranslationPipeline.
             * @param {TextPipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
              /** @type {'translation_text'} */
              __publicField(this, "_key", "translation_text");
            }
          }
          function isChat(x) {
            return Array.isArray(x) && x.every((x2) => "role" in x2 && "content" in x2);
          }
          class TextGenerationPipeline extends /** @type {new (options: TextPipelineConstructorArgs) => TextGenerationPipelineType} */
          Pipeline {
            /**
             * Create a new TextGenerationPipeline.
             * @param {TextPipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
            }
            /** @type {TextGenerationPipelineCallback} */
            async _call(texts, generate_kwargs = {}) {
              let isBatched = false;
              let isChatInput = false;
              let inputs;
              if (typeof texts === "string") {
                inputs = texts = [texts];
              } else if (Array.isArray(texts) && texts.every((x) => typeof x === "string")) {
                isBatched = true;
                inputs = /** @type {string[]} */
                texts;
              } else {
                if (isChat(texts)) {
                  texts = [
                    /** @type {Chat} */
                    texts
                  ];
                } else if (Array.isArray(texts) && texts.every(isChat)) {
                  isBatched = true;
                } else {
                  throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");
                }
                isChatInput = true;
                inputs = /** @type {string[]} */
                /** @type {Chat[]} */
                texts.map(
                  (x) => this.tokenizer.apply_chat_template(x, {
                    tokenize: false,
                    add_generation_prompt: true
                  })
                );
              }
              const add_special_tokens = generate_kwargs.add_special_tokens ?? false;
              const return_full_text = isChatInput ? false : generate_kwargs.return_full_text ?? true;
              this.tokenizer.padding_side = "left";
              const { input_ids, attention_mask } = this.tokenizer(inputs, {
                add_special_tokens,
                padding: true,
                truncation: true
              });
              const outputTokenIds = await this.model.generate(input_ids, generate_kwargs, null, {
                inputs_attention_mask: attention_mask
              });
              let decoded = this.tokenizer.batch_decode(outputTokenIds, {
                skip_special_tokens: true
              });
              let promptLengths;
              if (!return_full_text && input_ids.dims.at(-1) > 0) {
                promptLengths = this.tokenizer.batch_decode(input_ids, {
                  skip_special_tokens: true
                }).map((x) => x.length);
              }
              const toReturn = Array.from({ length: texts.length }, (_) => []);
              for (let i = 0; i < decoded.length; ++i) {
                const textIndex = Math.floor(i / outputTokenIds.length * texts.length);
                if (promptLengths) {
                  decoded[i] = decoded[i].slice(promptLengths[textIndex]);
                }
                toReturn[textIndex].push({
                  generated_text: isChatInput ? [
                    .../** @type {Chat[]} */
                    texts[textIndex],
                    { role: "assistant", content: decoded[i] }
                  ] : decoded[i]
                });
              }
              return !isBatched && toReturn.length === 1 ? toReturn[0] : toReturn;
            }
          }
          class ZeroShotClassificationPipeline extends /** @type {new (options: TextPipelineConstructorArgs) => ZeroShotClassificationPipelineType} */
          Pipeline {
            /**
             * Create a new ZeroShotClassificationPipeline.
             * @param {TextPipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
              this.label2id = Object.fromEntries(
                Object.entries(
                  /** @type {any} */
                  this.model.config.label2id
                ).map(
                  ([k, v]) => [k.toLowerCase(), v]
                )
              );
              this.entailment_id = this.label2id["entailment"];
              if (this.entailment_id === void 0) {
                console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id.");
                this.entailment_id = 2;
              }
              this.contradiction_id = this.label2id["contradiction"] ?? this.label2id["not_entailment"];
              if (this.contradiction_id === void 0) {
                console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id.");
                this.contradiction_id = 0;
              }
            }
            /** @type {ZeroShotClassificationPipelineCallback} */
            async _call(texts, candidate_labels, {
              hypothesis_template = "This example is {}.",
              multi_label = false
            } = {}) {
              const isBatched = Array.isArray(texts);
              if (!isBatched) {
                texts = [
                  /** @type {string} */
                  texts
                ];
              }
              if (!Array.isArray(candidate_labels)) {
                candidate_labels = [candidate_labels];
              }
              const hypotheses = candidate_labels.map(
                (x) => hypothesis_template.replace("{}", x)
              );
              const softmaxEach = multi_label || candidate_labels.length === 1;
              const toReturn = [];
              for (const premise of texts) {
                const entails_logits = [];
                for (const hypothesis of hypotheses) {
                  const inputs = this.tokenizer(premise, {
                    text_pair: hypothesis,
                    padding: true,
                    truncation: true
                  });
                  const outputs = await this.model(inputs);
                  if (softmaxEach) {
                    entails_logits.push([
                      outputs.logits.data[this.contradiction_id],
                      outputs.logits.data[this.entailment_id]
                    ]);
                  } else {
                    entails_logits.push(outputs.logits.data[this.entailment_id]);
                  }
                }
                const scores = softmaxEach ? entails_logits.map((x) => (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(x)[1]) : (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(entails_logits);
                const scores_sorted = scores.map((x, i) => [x, i]).sort((a, b) => b[0] - a[0]);
                toReturn.push({
                  sequence: premise,
                  labels: scores_sorted.map((x) => candidate_labels[x[1]]),
                  scores: scores_sorted.map((x) => x[0])
                });
              }
              return isBatched ? toReturn : toReturn[0];
            }
          }
          class FeatureExtractionPipeline extends /** @type {new (options: TextPipelineConstructorArgs) => FeatureExtractionPipelineType} */
          Pipeline {
            /**
             * Create a new FeatureExtractionPipeline.
             * @param {TextPipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
            }
            /** @type {FeatureExtractionPipelineCallback} */
            async _call(texts, {
              pooling = (
                /** @type {'none'} */
                "none"
              ),
              normalize: normalize3 = false,
              quantize = false,
              precision = (
                /** @type {'binary'} */
                "binary"
              )
            } = {}) {
              const model_inputs = this.tokenizer(texts, {
                padding: true,
                truncation: true
              });
              const outputs = await this.model(model_inputs);
              let result = outputs.last_hidden_state ?? outputs.logits ?? outputs.token_embeddings;
              if (pooling === "none") {
              } else if (pooling === "mean") {
                result = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_6__.mean_pooling)(result, model_inputs.attention_mask);
              } else if (pooling === "cls") {
                result = result.slice(null, 0);
              } else {
                throw Error(`Pooling method '${pooling}' not supported.`);
              }
              if (normalize3) {
                result = result.normalize(2, -1);
              }
              if (quantize) {
                result = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_6__.quantize_embeddings)(result, precision);
              }
              return result;
            }
          }
          class ImageFeatureExtractionPipeline extends /** @type {new (options: ImagePipelineConstructorArgs) => ImageFeatureExtractionPipelineType} */
          Pipeline {
            /**
             * Create a new ImageFeatureExtractionPipeline.
             * @param {ImagePipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
            }
            /** @type {ImageFeatureExtractionPipelineCallback} */
            async _call(images, {
              pool = null
            } = {}) {
              const preparedImages = await prepareImages(images);
              const { pixel_values } = await this.processor(preparedImages);
              const outputs = await this.model({ pixel_values });
              let result;
              if (pool) {
                if (!("pooler_output" in outputs)) {
                  throw Error(`No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.`);
                }
                result = outputs.pooler_output;
              } else {
                result = outputs.last_hidden_state ?? outputs.logits ?? outputs.image_embeds;
              }
              return result;
            }
          }
          class AudioClassificationPipeline extends /** @type {new (options: AudioPipelineConstructorArgs) => AudioClassificationPipelineType} */
          Pipeline {
            /**
             * Create a new AudioClassificationPipeline.
             * @param {AudioPipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
            }
            /** @type {AudioClassificationPipelineCallback} */
            async _call(audio, {
              topk = null
            } = {}) {
              const single = !Array.isArray(audio);
              const sampling_rate = this.processor.feature_extractor.config.sampling_rate;
              const preparedAudios = await prepareAudios(audio, sampling_rate);
              const id2label = this.model.config.id2label;
              const toReturn = [];
              for (const aud of preparedAudios) {
                const inputs = await this.processor(aud);
                const output = await this.model(inputs);
                const logits = output.logits[0];
                const scores = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.getTopItems)((0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(logits.data), topk);
                const vals = scores.map((x) => ({
                  label: (
                    /** @type {string} */
                    id2label[x[0]]
                  ),
                  score: (
                    /** @type {number} */
                    x[1]
                  )
                }));
                if (topk === 1) {
                  toReturn.push(...vals);
                } else {
                  toReturn.push(vals);
                }
              }
              return !single || topk === 1 ? (
                /** @type {AudioClassificationOutput} */
                toReturn
              ) : (
                /** @type {AudioClassificationOutput[]} */
                toReturn[0]
              );
            }
          }
          class ZeroShotAudioClassificationPipeline extends /** @type {new (options: TextAudioPipelineConstructorArgs) => ZeroShotAudioClassificationPipelineType} */
          Pipeline {
            /**
             * Create a new ZeroShotAudioClassificationPipeline.
             * @param {TextAudioPipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
            }
            /** @type {ZeroShotAudioClassificationPipelineCallback} */
            async _call(audio, candidate_labels, {
              hypothesis_template = "This is a sound of {}."
            } = {}) {
              const single = !Array.isArray(audio);
              if (single) {
                audio = [
                  /** @type {AudioInput} */
                  audio
                ];
              }
              const texts = candidate_labels.map(
                (x) => hypothesis_template.replace("{}", x)
              );
              const text_inputs = this.tokenizer(texts, {
                padding: true,
                truncation: true
              });
              const sampling_rate = this.processor.feature_extractor.config.sampling_rate;
              const preparedAudios = await prepareAudios(audio, sampling_rate);
              const toReturn = [];
              for (const aud of preparedAudios) {
                const audio_inputs = await this.processor(aud);
                const output = await this.model({ ...text_inputs, ...audio_inputs });
                const probs = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(output.logits_per_audio.data);
                toReturn.push([...probs].map((x, i) => ({
                  score: x,
                  label: candidate_labels[i]
                })));
              }
              return single ? toReturn[0] : toReturn;
            }
          }
          class AutomaticSpeechRecognitionPipeline extends /** @type {new (options: TextAudioPipelineConstructorArgs) => AutomaticSpeechRecognitionPipelineType} */
          Pipeline {
            /**
             * Create a new AutomaticSpeechRecognitionPipeline.
             * @param {TextAudioPipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
            }
            /** @type {AutomaticSpeechRecognitionPipelineCallback} */
            async _call(audio, kwargs = {}) {
              switch (this.model.config.model_type) {
                case "whisper":
                  return this._call_whisper(audio, kwargs);
                case "wav2vec2":
                case "wav2vec2-bert":
                case "unispeech":
                case "unispeech-sat":
                case "hubert":
                  return this._call_wav2vec2(audio, kwargs);
                default:
                  throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`);
              }
            }
            /**
             * @type {AutomaticSpeechRecognitionPipelineCallback}
             * @private
             */
            async _call_wav2vec2(audio, kwargs = {}) {
              if (kwargs.language) {
                console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".');
              }
              if (kwargs.task) {
                console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');
              }
              const single = !Array.isArray(audio);
              if (single) {
                audio = [
                  /** @type {AudioInput} */
                  audio
                ];
              }
              const sampling_rate = this.processor.feature_extractor.config.sampling_rate;
              const preparedAudios = await prepareAudios(audio, sampling_rate);
              const toReturn = [];
              for (const aud of preparedAudios) {
                const inputs = await this.processor(aud);
                const output = await this.model(inputs);
                const logits = output.logits[0];
                const predicted_ids = [];
                for (const item of logits) {
                  predicted_ids.push((0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.max)(item.data)[1]);
                }
                const predicted_sentences = this.tokenizer.decode(predicted_ids);
                toReturn.push({ text: predicted_sentences });
              }
              return single ? toReturn[0] : toReturn;
            }
            /**
             * @type {AutomaticSpeechRecognitionPipelineCallback}
             * @private
             */
            async _call_whisper(audio, kwargs = {}) {
              const return_timestamps = kwargs.return_timestamps ?? false;
              const chunk_length_s = kwargs.chunk_length_s ?? 0;
              const chunk_callback = kwargs.chunk_callback ?? null;
              const force_full_sequences = kwargs.force_full_sequences ?? false;
              let stride_length_s = kwargs.stride_length_s ?? null;
              if (return_timestamps === "word") {
                kwargs["return_token_timestamps"] = true;
              }
              const language = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_3__.pop)(kwargs, "language", null);
              const task = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_3__.pop)(kwargs, "task", null);
              if (language || task || return_timestamps) {
                if (kwargs.forced_decoder_ids) {
                  throw new Error("Cannot specify `language`/`task`/`return_timestamps` and `forced_decoder_ids` at the same time.");
                }
                const decoder_prompt_ids = this.tokenizer.get_decoder_prompt_ids({ language, task, no_timestamps: !return_timestamps });
                if (decoder_prompt_ids.length > 0) {
                  kwargs.forced_decoder_ids = decoder_prompt_ids;
                }
              }
              const single = !Array.isArray(audio);
              if (single) {
                audio = [
                  /** @type {AudioInput} */
                  audio
                ];
              }
              const time_precision = this.processor.feature_extractor.config.chunk_length / this.model.config.max_source_positions;
              const hop_length = this.processor.feature_extractor.config.hop_length;
              const sampling_rate = this.processor.feature_extractor.config.sampling_rate;
              const preparedAudios = await prepareAudios(audio, sampling_rate);
              const toReturn = [];
              for (const aud of preparedAudios) {
                let chunks = [];
                if (chunk_length_s > 0) {
                  if (stride_length_s === null) {
                    stride_length_s = chunk_length_s / 6;
                  } else if (chunk_length_s <= stride_length_s) {
                    throw Error("`chunk_length_s` must be larger than `stride_length_s`.");
                  }
                  const window2 = sampling_rate * chunk_length_s;
                  const stride = sampling_rate * stride_length_s;
                  const jump = window2 - 2 * stride;
                  let offset = 0;
                  while (offset < aud.length) {
                    const subarr = aud.subarray(offset, offset + window2);
                    const feature = await this.processor(subarr);
                    const isFirst = offset === 0;
                    const isLast = offset + jump >= aud.length;
                    chunks.push({
                      stride: [
                        subarr.length,
                        isFirst ? 0 : stride,
                        isLast ? 0 : stride
                      ],
                      input_features: feature.input_features,
                      is_last: isLast
                    });
                    offset += jump;
                  }
                } else {
                  chunks = [{
                    stride: [aud.length, 0, 0],
                    input_features: (await this.processor(aud)).input_features,
                    is_last: true
                  }];
                }
                for (const chunk of chunks) {
                  kwargs.num_frames = Math.floor(chunk.stride[0] / hop_length);
                  const data = await this.model.generate(chunk.input_features, kwargs);
                  if (return_timestamps === "word") {
                    chunk.tokens = data.sequences[0];
                    chunk.token_timestamps = data.token_timestamps.tolist()[0].map(
                      (x) => (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.round)(x, 2)
                    );
                  } else {
                    chunk.tokens = data[0];
                  }
                  chunk.stride = chunk.stride.map((x) => x / sampling_rate);
                  if (chunk_callback !== null) {
                    chunk_callback(chunk);
                  }
                }
                const [full_text, optional] = this.tokenizer._decode_asr(chunks, {
                  time_precision,
                  return_timestamps,
                  force_full_sequences
                });
                toReturn.push({ text: full_text, ...optional });
              }
              return single ? toReturn[0] : toReturn;
            }
          }
          class ImageToTextPipeline extends /** @type {new (options: TextImagePipelineConstructorArgs) => ImageToTextPipelineType} */
          Pipeline {
            /**
             * Create a new ImageToTextPipeline.
             * @param {TextImagePipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
            }
            /** @type {ImageToTextPipelineCallback} */
            async _call(images, generate_kwargs = {}) {
              const isBatched = Array.isArray(images);
              const preparedImages = await prepareImages(images);
              const { pixel_values } = await this.processor(preparedImages);
              const toReturn = [];
              for (const batch of pixel_values) {
                batch.dims = [1, ...batch.dims];
                const output = await this.model.generate(batch, generate_kwargs);
                const decoded = this.tokenizer.batch_decode(output, {
                  skip_special_tokens: true
                }).map((x) => ({ generated_text: x.trim() }));
                toReturn.push(decoded);
              }
              return isBatched ? toReturn : toReturn[0];
            }
          }
          class ImageClassificationPipeline extends /** @type {new (options: ImagePipelineConstructorArgs) => ImageClassificationPipelineType} */
          Pipeline {
            /**
             * Create a new ImageClassificationPipeline.
             * @param {ImagePipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
            }
            /** @type {ImageClassificationPipelineCallback} */
            async _call(images, {
              topk = 1
            } = {}) {
              const isBatched = Array.isArray(images);
              const preparedImages = await prepareImages(images);
              const { pixel_values } = await this.processor(preparedImages);
              const output = await this.model({ pixel_values });
              const id2label = this.model.config.id2label;
              const toReturn = [];
              for (const batch of output.logits) {
                const scores = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.getTopItems)((0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(batch.data), topk);
                const vals = scores.map((x) => ({
                  label: id2label[x[0]],
                  score: x[1]
                }));
                if (topk === 1) {
                  toReturn.push(...vals);
                } else {
                  toReturn.push(vals);
                }
              }
              return isBatched || topk === 1 ? (
                /** @type {ImageClassificationOutput} */
                toReturn
              ) : (
                /** @type {ImageClassificationOutput[]} */
                toReturn[0]
              );
            }
          }
          class ImageSegmentationPipeline extends /** @type {new (options: ImagePipelineConstructorArgs) => ImageSegmentationPipelineType} */
          Pipeline {
            /**
             * Create a new ImageSegmentationPipeline.
             * @param {ImagePipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
              this.subtasks_mapping = {
                // Mapping of subtasks to their corresponding post-processing function names.
                panoptic: "post_process_panoptic_segmentation",
                instance: "post_process_instance_segmentation",
                semantic: "post_process_semantic_segmentation"
              };
            }
            /** @type {ImageSegmentationPipelineCallback} */
            async _call(images, {
              threshold = 0.5,
              mask_threshold = 0.5,
              overlap_mask_area_threshold = 0.8,
              label_ids_to_fuse = null,
              target_sizes = null,
              subtask = null
            } = {}) {
              const isBatched = Array.isArray(images);
              if (isBatched && images.length !== 1) {
                throw Error("Image segmentation pipeline currently only supports a batch size of 1.");
              }
              const preparedImages = await prepareImages(images);
              const imageSizes = preparedImages.map((x) => [x.height, x.width]);
              const { pixel_values, pixel_mask } = await this.processor(preparedImages);
              const output = await this.model({ pixel_values, pixel_mask });
              let fn = null;
              if (subtask !== null) {
                fn = this.subtasks_mapping[subtask];
              } else {
                for (let [task, func] of Object.entries(this.subtasks_mapping)) {
                  if (func in this.processor.feature_extractor) {
                    fn = this.processor.feature_extractor[func].bind(this.processor.feature_extractor);
                    subtask = task;
                    break;
                  }
                }
              }
              const id2label = this.model.config.id2label;
              const annotation = [];
              if (subtask === "panoptic" || subtask === "instance") {
                const processed = fn(
                  output,
                  threshold,
                  mask_threshold,
                  overlap_mask_area_threshold,
                  label_ids_to_fuse,
                  target_sizes ?? imageSizes
                  // TODO FIX?
                )[0];
                const segmentation = processed.segmentation;
                for (const segment of processed.segments_info) {
                  const maskData = new Uint8ClampedArray(segmentation.data.length);
                  for (let i = 0; i < segmentation.data.length; ++i) {
                    if (segmentation.data[i] === segment.id) {
                      maskData[i] = 255;
                    }
                  }
                  const mask = new _utils_image_js__WEBPACK_IMPORTED_MODULE_7__.RawImage(maskData, segmentation.dims[1], segmentation.dims[0], 1);
                  annotation.push({
                    score: segment.score,
                    label: id2label[segment.label_id],
                    mask
                  });
                }
              } else if (subtask === "semantic") {
                const { segmentation, labels } = fn(output, target_sizes ?? imageSizes)[0];
                for (const label of labels) {
                  const maskData = new Uint8ClampedArray(segmentation.data.length);
                  for (let i = 0; i < segmentation.data.length; ++i) {
                    if (segmentation.data[i] === label) {
                      maskData[i] = 255;
                    }
                  }
                  const mask = new _utils_image_js__WEBPACK_IMPORTED_MODULE_7__.RawImage(maskData, segmentation.dims[1], segmentation.dims[0], 1);
                  annotation.push({
                    score: null,
                    label: id2label[label],
                    mask
                  });
                }
              } else {
                throw Error(`Subtask ${subtask} not supported.`);
              }
              return annotation;
            }
          }
          class ZeroShotImageClassificationPipeline extends /** @type {new (options: TextImagePipelineConstructorArgs) => ZeroShotImageClassificationPipelineType} */
          Pipeline {
            /**
             * Create a new ZeroShotImageClassificationPipeline.
             * @param {TextImagePipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
            }
            /** @type {ZeroShotImageClassificationPipelineCallback} */
            async _call(images, candidate_labels, {
              hypothesis_template = "This is a photo of {}"
            } = {}) {
              const isBatched = Array.isArray(images);
              const preparedImages = await prepareImages(images);
              const texts = candidate_labels.map(
                (x) => hypothesis_template.replace("{}", x)
              );
              const text_inputs = this.tokenizer(texts, {
                padding: this.model.config.model_type === "siglip" ? "max_length" : true,
                truncation: true
              });
              const { pixel_values } = await this.processor(preparedImages);
              const output = await this.model({ ...text_inputs, pixel_values });
              const function_to_apply = this.model.config.model_type === "siglip" ? (batch) => batch.sigmoid().data : (batch) => (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(batch.data);
              const toReturn = [];
              for (const batch of output.logits_per_image) {
                const probs = function_to_apply(batch);
                const result = [...probs].map((x, i) => ({
                  score: x,
                  label: candidate_labels[i]
                }));
                result.sort((a, b) => b.score - a.score);
                toReturn.push(result);
              }
              return isBatched ? toReturn : toReturn[0];
            }
          }
          class ObjectDetectionPipeline extends /** @type {new (options: ImagePipelineConstructorArgs) => ObjectDetectionPipelineType} */
          Pipeline {
            /**
             * Create a new ObjectDetectionPipeline.
             * @param {ImagePipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
            }
            /** @type {ObjectDetectionPipelineCallback} */
            async _call(images, {
              threshold = 0.9,
              percentage = false
            } = {}) {
              const isBatched = Array.isArray(images);
              if (isBatched && images.length !== 1) {
                throw Error("Object detection pipeline currently only supports a batch size of 1.");
              }
              const preparedImages = await prepareImages(images);
              const imageSizes = percentage ? null : preparedImages.map((x) => [x.height, x.width]);
              const { pixel_values, pixel_mask } = await this.processor(preparedImages);
              const output = await this.model({ pixel_values, pixel_mask });
              const processed = this.processor.feature_extractor.post_process_object_detection(output, threshold, imageSizes);
              const id2label = this.model.config.id2label;
              const result = processed.map((batch) => batch.boxes.map((box, i) => ({
                score: batch.scores[i],
                label: id2label[batch.classes[i]],
                box: get_bounding_box(box, !percentage)
              })));
              return isBatched ? result : result[0];
            }
          }
          class ZeroShotObjectDetectionPipeline extends /** @type {new (options: TextImagePipelineConstructorArgs) => ZeroShotObjectDetectionPipelineType} */
          Pipeline {
            /**
             * Create a new ZeroShotObjectDetectionPipeline.
             * @param {TextImagePipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
            }
            /** @type {ZeroShotObjectDetectionPipelineCallback} */
            async _call(images, candidate_labels, {
              threshold = 0.1,
              topk = null,
              percentage = false
            } = {}) {
              const isBatched = Array.isArray(images);
              const preparedImages = await prepareImages(images);
              const text_inputs = this.tokenizer(candidate_labels, {
                padding: true,
                truncation: true
              });
              const model_inputs = await this.processor(preparedImages);
              const toReturn = [];
              for (let i = 0; i < preparedImages.length; ++i) {
                const image2 = preparedImages[i];
                const imageSize = percentage ? null : [[image2.height, image2.width]];
                const pixel_values = model_inputs.pixel_values[i].unsqueeze_(0);
                const output = await this.model({ ...text_inputs, pixel_values });
                const processed = this.processor.feature_extractor.post_process_object_detection(output, threshold, imageSize, true)[0];
                let result = processed.boxes.map((box, i2) => ({
                  score: processed.scores[i2],
                  label: candidate_labels[processed.classes[i2]],
                  box: get_bounding_box(box, !percentage)
                })).sort((a, b) => b.score - a.score);
                if (topk !== null) {
                  result = result.slice(0, topk);
                }
                toReturn.push(result);
              }
              return isBatched ? toReturn : toReturn[0];
            }
          }
          class DocumentQuestionAnsweringPipeline extends /** @type {new (options: TextImagePipelineConstructorArgs) => DocumentQuestionAnsweringPipelineType} */
          Pipeline {
            /**
             * Create a new DocumentQuestionAnsweringPipeline.
             * @param {TextImagePipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
            }
            /** @type {DocumentQuestionAnsweringPipelineCallback} */
            async _call(image2, question, generate_kwargs = {}) {
              const preparedImage = (await prepareImages(image2))[0];
              const { pixel_values } = await this.processor(preparedImage);
              const task_prompt = `<s_docvqa><s_question>${question}</s_question><s_answer>`;
              const decoder_input_ids = this.tokenizer(task_prompt, {
                add_special_tokens: false,
                padding: true,
                truncation: true
              }).input_ids;
              const output = await this.model.generate(
                pixel_values,
                {
                  ...generate_kwargs,
                  decoder_input_ids,
                  max_length: this.model.config.decoder.max_position_embeddings
                }
              );
              const decoded = this.tokenizer.batch_decode(output)[0];
              const match2 = decoded.match(/<s_answer>(.*?)<\/s_answer>/);
              let answer = null;
              if (match2 && match2.length >= 2) {
                answer = match2[1].trim();
              }
              return [{ answer }];
            }
          }
          class TextToAudioPipeline extends /** @type {new (options: TextToAudioPipelineConstructorArgs) => TextToAudioPipelineType} */
          Pipeline {
            /**
             * Create a new TextToAudioPipeline.
             * @param {TextToAudioPipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
              __publicField(this, "DEFAULT_VOCODER_ID", "Xenova/speecht5_hifigan");
              this.vocoder = options.vocoder ?? null;
            }
            /** @type {TextToAudioPipelineCallback} */
            async _call(text_inputs, {
              speaker_embeddings = null
            } = {}) {
              if (this.processor) {
                return this._call_text_to_spectrogram(text_inputs, { speaker_embeddings });
              } else {
                return this._call_text_to_waveform(text_inputs);
              }
            }
            async _call_text_to_waveform(text_inputs) {
              const inputs = this.tokenizer(text_inputs, {
                padding: true,
                truncation: true
              });
              const { waveform } = await this.model(inputs);
              const sampling_rate = this.model.config.sampling_rate;
              return {
                audio: waveform.data,
                sampling_rate
              };
            }
            async _call_text_to_spectrogram(text_inputs, { speaker_embeddings }) {
              if (!this.vocoder) {
                console.log("No vocoder specified, using default HifiGan vocoder.");
                this.vocoder = await _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID, { quantized: false });
              }
              if (typeof speaker_embeddings === "string" || speaker_embeddings instanceof URL) {
                speaker_embeddings = new Float32Array(
                  await (await fetch(speaker_embeddings)).arrayBuffer()
                );
              }
              if (speaker_embeddings instanceof Float32Array) {
                speaker_embeddings = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_6__.Tensor(
                  "float32",
                  speaker_embeddings,
                  [1, speaker_embeddings.length]
                );
              } else if (!(speaker_embeddings instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_6__.Tensor)) {
                throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");
              }
              const { input_ids } = this.tokenizer(text_inputs, {
                padding: true,
                truncation: true
              });
              const { waveform } = await this.model.generate_speech(input_ids, speaker_embeddings, { vocoder: this.vocoder });
              const sampling_rate = this.processor.feature_extractor.config.sampling_rate;
              return {
                audio: waveform.data,
                sampling_rate
              };
            }
          }
          class ImageToImagePipeline extends /** @type {new (options: ImagePipelineConstructorArgs) => ImageToImagePipelineType} */
          Pipeline {
            /**
             * Create a new ImageToImagePipeline.
             * @param {ImagePipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
            }
            /** @type {ImageToImagePipelineCallback} */
            async _call(images) {
              const preparedImages = await prepareImages(images);
              const inputs = await this.processor(preparedImages);
              const outputs = await this.model(inputs);
              const toReturn = [];
              for (const batch of outputs.reconstruction) {
                const output = batch.squeeze().clamp_(0, 1).mul_(255).round_().to("uint8");
                toReturn.push(_utils_image_js__WEBPACK_IMPORTED_MODULE_7__.RawImage.fromTensor(output));
              }
              return toReturn.length > 1 ? toReturn : toReturn[0];
            }
          }
          class DepthEstimationPipeline extends /** @type {new (options: ImagePipelineConstructorArgs) => DepthEstimationPipelineType} */
          Pipeline {
            /**
             * Create a new DepthEstimationPipeline.
             * @param {ImagePipelineConstructorArgs} options An object used to instantiate the pipeline.
             */
            constructor(options) {
              super(options);
            }
            /** @type {DepthEstimationPipelineCallback} */
            async _call(images) {
              const preparedImages = await prepareImages(images);
              const inputs = await this.processor(preparedImages);
              const { predicted_depth } = await this.model(inputs);
              const toReturn = [];
              for (let i = 0; i < preparedImages.length; ++i) {
                const prediction = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_6__.interpolate)(predicted_depth[i], preparedImages[i].size.reverse(), "bilinear", false);
                const formatted = prediction.mul_(255 / (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.max)(prediction.data)[0]).to("uint8");
                toReturn.push({
                  predicted_depth: predicted_depth[i],
                  depth: _utils_image_js__WEBPACK_IMPORTED_MODULE_7__.RawImage.fromTensor(formatted)
                });
              }
              return toReturn.length > 1 ? toReturn : toReturn[0];
            }
          }
          const SUPPORTED_TASKS = Object.freeze({
            "text-classification": {
              "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
              "pipeline": TextClassificationPipeline,
              "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSequenceClassification,
              "default": {
                // TODO: replace with original
                // "model": "distilbert-base-uncased-finetuned-sst-2-english",
                "model": "Xenova/distilbert-base-uncased-finetuned-sst-2-english"
              },
              "type": "text"
            },
            "token-classification": {
              "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
              "pipeline": TokenClassificationPipeline,
              "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForTokenClassification,
              "default": {
                // TODO: replace with original
                // "model": "Davlan/bert-base-multilingual-cased-ner-hrl",
                "model": "Xenova/bert-base-multilingual-cased-ner-hrl"
              },
              "type": "text"
            },
            "question-answering": {
              "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
              "pipeline": QuestionAnsweringPipeline,
              "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForQuestionAnswering,
              "default": {
                // TODO: replace with original
                // "model": "distilbert-base-cased-distilled-squad",
                "model": "Xenova/distilbert-base-cased-distilled-squad"
              },
              "type": "text"
            },
            "fill-mask": {
              "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
              "pipeline": FillMaskPipeline,
              "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForMaskedLM,
              "default": {
                // TODO: replace with original
                // "model": "bert-base-uncased",
                "model": "Xenova/bert-base-uncased"
              },
              "type": "text"
            },
            "summarization": {
              "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
              "pipeline": SummarizationPipeline,
              "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSeq2SeqLM,
              "default": {
                // TODO: replace with original
                // "model": "sshleifer/distilbart-cnn-6-6",
                "model": "Xenova/distilbart-cnn-6-6"
              },
              "type": "text"
            },
            "translation": {
              "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
              "pipeline": TranslationPipeline,
              "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSeq2SeqLM,
              "default": {
                // TODO: replace with original
                // "model": "t5-small",
                "model": "Xenova/t5-small"
              },
              "type": "text"
            },
            "text2text-generation": {
              "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
              "pipeline": Text2TextGenerationPipeline,
              "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSeq2SeqLM,
              "default": {
                // TODO: replace with original
                // "model": "google/flan-t5-small",
                "model": "Xenova/flan-t5-small"
              },
              "type": "text"
            },
            "text-generation": {
              "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
              "pipeline": TextGenerationPipeline,
              "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForCausalLM,
              "default": {
                // TODO: replace with original
                // "model": "gpt2",
                "model": "Xenova/gpt2"
              },
              "type": "text"
            },
            "zero-shot-classification": {
              "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
              "pipeline": ZeroShotClassificationPipeline,
              "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSequenceClassification,
              "default": {
                // TODO: replace with original
                // "model": "typeform/distilbert-base-uncased-mnli",
                "model": "Xenova/distilbert-base-uncased-mnli"
              },
              "type": "text"
            },
            "audio-classification": {
              "pipeline": AudioClassificationPipeline,
              "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForAudioClassification,
              "processor": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
              "default": {
                // TODO: replace with original
                // "model": "superb/wav2vec2-base-superb-ks",
                "model": "Xenova/wav2vec2-base-superb-ks"
              },
              "type": "audio"
            },
            "zero-shot-audio-classification": {
              "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
              "pipeline": ZeroShotAudioClassificationPipeline,
              "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModel,
              "processor": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
              "default": {
                // TODO: replace with original
                // "model": "laion/clap-htsat-fused",
                "model": "Xenova/clap-htsat-unfused"
              },
              "type": "multimodal"
            },
            "automatic-speech-recognition": {
              "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
              "pipeline": AutomaticSpeechRecognitionPipeline,
              "model": [_models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSpeechSeq2Seq, _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForCTC],
              "processor": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
              "default": {
                // TODO: replace with original
                // "model": "openai/whisper-tiny.en",
                "model": "Xenova/whisper-tiny.en"
              },
              "type": "multimodal"
            },
            "text-to-audio": {
              "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
              "pipeline": TextToAudioPipeline,
              "model": [_models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForTextToWaveform, _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForTextToSpectrogram],
              "processor": [
                _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
                /* Some don't use a processor */
                null
              ],
              "default": {
                // TODO: replace with original
                // "model": "microsoft/speecht5_tts",
                "model": "Xenova/speecht5_tts"
              },
              "type": "text"
            },
            "image-to-text": {
              "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
              "pipeline": ImageToTextPipeline,
              "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForVision2Seq,
              "processor": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
              "default": {
                // TODO: replace with original
                // "model": "nlpconnect/vit-gpt2-image-captioning",
                "model": "Xenova/vit-gpt2-image-captioning"
              },
              "type": "multimodal"
            },
            "image-classification": {
              // no tokenizer
              "pipeline": ImageClassificationPipeline,
              "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForImageClassification,
              "processor": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
              "default": {
                // TODO: replace with original
                // "model": "google/vit-base-patch16-224",
                "model": "Xenova/vit-base-patch16-224"
              },
              "type": "multimodal"
            },
            "image-segmentation": {
              // no tokenizer
              "pipeline": ImageSegmentationPipeline,
              "model": [_models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForImageSegmentation, _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSemanticSegmentation],
              "processor": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
              "default": {
                // TODO: replace with original
                // "model": "facebook/detr-resnet-50-panoptic",
                "model": "Xenova/detr-resnet-50-panoptic"
              },
              "type": "multimodal"
            },
            "zero-shot-image-classification": {
              "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
              "pipeline": ZeroShotImageClassificationPipeline,
              "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModel,
              "processor": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
              "default": {
                // TODO: replace with original
                // "model": "openai/clip-vit-base-patch32",
                "model": "Xenova/clip-vit-base-patch32"
              },
              "type": "multimodal"
            },
            "object-detection": {
              // no tokenizer
              "pipeline": ObjectDetectionPipeline,
              "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForObjectDetection,
              "processor": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
              "default": {
                // TODO: replace with original
                // "model": "facebook/detr-resnet-50",
                "model": "Xenova/detr-resnet-50"
              },
              "type": "multimodal"
            },
            "zero-shot-object-detection": {
              "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
              "pipeline": ZeroShotObjectDetectionPipeline,
              "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForZeroShotObjectDetection,
              "processor": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
              "default": {
                // TODO: replace with original
                // "model": "google/owlvit-base-patch32",
                "model": "Xenova/owlvit-base-patch32"
              },
              "type": "multimodal"
            },
            "document-question-answering": {
              "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
              "pipeline": DocumentQuestionAnsweringPipeline,
              "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForDocumentQuestionAnswering,
              "processor": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
              "default": {
                // TODO: replace with original
                // "model": "naver-clova-ix/donut-base-finetuned-docvqa",
                "model": "Xenova/donut-base-finetuned-docvqa"
              },
              "type": "multimodal"
            },
            "image-to-image": {
              // no tokenizer
              "pipeline": ImageToImagePipeline,
              "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForImageToImage,
              "processor": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
              "default": {
                // TODO: replace with original
                // "model": "caidas/swin2SR-classical-sr-x2-64",
                "model": "Xenova/swin2SR-classical-sr-x2-64"
              },
              "type": "image"
            },
            "depth-estimation": {
              // no tokenizer
              "pipeline": DepthEstimationPipeline,
              "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForDepthEstimation,
              "processor": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
              "default": {
                // TODO: replace with original
                // "model": "Intel/dpt-large",
                "model": "Xenova/dpt-large"
              },
              "type": "image"
            },
            // This task serves as a useful interface for dealing with sentence-transformers (https://huggingface.co/sentence-transformers).
            "feature-extraction": {
              "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
              "pipeline": FeatureExtractionPipeline,
              "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModel,
              "default": {
                // TODO: replace with original
                // "model": "sentence-transformers/all-MiniLM-L6-v2",
                "model": "Xenova/all-MiniLM-L6-v2"
              },
              "type": "text"
            },
            "image-feature-extraction": {
              "processor": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
              "pipeline": ImageFeatureExtractionPipeline,
              "model": [_models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForImageFeatureExtraction, _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModel],
              "default": {
                // TODO: replace with original
                // "model": "google/vit-base-patch16-224",
                "model": "Xenova/vit-base-patch16-224-in21k"
              },
              "type": "image"
            }
          });
          const TASK_ALIASES = Object.freeze({
            "sentiment-analysis": "text-classification",
            "ner": "token-classification",
            // "vqa": "visual-question-answering", // TODO: Add
            "asr": "automatic-speech-recognition",
            "text-to-speech": "text-to-audio",
            // Add for backwards compatibility
            "embeddings": "feature-extraction"
          });
          async function pipeline(task, model = null, {
            quantized = true,
            progress_callback = null,
            config: config2 = null,
            cache_dir = null,
            local_files_only = false,
            revision = "main",
            model_file_name = null
          } = {}) {
            task = TASK_ALIASES[task] ?? task;
            const pipelineInfo = SUPPORTED_TASKS[task.split("_", 1)[0]];
            if (!pipelineInfo) {
              throw Error(`Unsupported pipeline: ${task}. Must be one of [${Object.keys(SUPPORTED_TASKS)}]`);
            }
            if (!model) {
              model = pipelineInfo.default.model;
              console.log(`No model specified. Using default model: "${model}".`);
            }
            const pretrainedOptions = {
              quantized,
              progress_callback,
              config: config2,
              cache_dir,
              local_files_only,
              revision,
              model_file_name
            };
            const classes = /* @__PURE__ */ new Map([
              ["tokenizer", pipelineInfo.tokenizer],
              ["model", pipelineInfo.model],
              ["processor", pipelineInfo.processor]
            ]);
            const results = await loadItems(classes, model, pretrainedOptions);
            results.task = task;
            (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_3__.dispatchCallback)(progress_callback, {
              "status": "ready",
              "task": task,
              "model": model
            });
            const pipelineClass = pipelineInfo.pipeline;
            return new pipelineClass(results);
          }
          async function loadItems(mapping, model, pretrainedOptions) {
            const result = /* @__PURE__ */ Object.create(null);
            const promises = [];
            for (let [name2, cls] of mapping.entries()) {
              if (!cls)
                continue;
              let promise;
              if (Array.isArray(cls)) {
                promise = new Promise(async (resolve, reject) => {
                  let e;
                  for (let c of cls) {
                    if (c === null) {
                      resolve(null);
                      return;
                    }
                    try {
                      resolve(await c.from_pretrained(model, pretrainedOptions));
                      return;
                    } catch (err) {
                      e = err;
                    }
                  }
                  reject(e);
                });
              } else {
                promise = cls.from_pretrained(model, pretrainedOptions);
              }
              result[name2] = promise;
              promises.push(promise);
            }
            await Promise.all(promises);
            for (let [name2, promise] of Object.entries(result)) {
              result[name2] = await promise;
            }
            return result;
          }
        }
      ),
      /***/
      "./src/processors.js": (
        /*!***************************!*\
          !*** ./src/processors.js ***!
          \***************************/
        /***/
        (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "ASTFeatureExtractor": () => (
              /* binding */
              ASTFeatureExtractor
            ),
            /* harmony export */
            "AutoProcessor": () => (
              /* binding */
              AutoProcessor
            ),
            /* harmony export */
            "BeitFeatureExtractor": () => (
              /* binding */
              BeitFeatureExtractor
            ),
            /* harmony export */
            "BitImageProcessor": () => (
              /* binding */
              BitImageProcessor
            ),
            /* harmony export */
            "CLIPFeatureExtractor": () => (
              /* binding */
              CLIPFeatureExtractor
            ),
            /* harmony export */
            "ChineseCLIPFeatureExtractor": () => (
              /* binding */
              ChineseCLIPFeatureExtractor
            ),
            /* harmony export */
            "ClapFeatureExtractor": () => (
              /* binding */
              ClapFeatureExtractor
            ),
            /* harmony export */
            "ConvNextFeatureExtractor": () => (
              /* binding */
              ConvNextFeatureExtractor
            ),
            /* harmony export */
            "ConvNextImageProcessor": () => (
              /* binding */
              ConvNextImageProcessor
            ),
            /* harmony export */
            "DPTFeatureExtractor": () => (
              /* binding */
              DPTFeatureExtractor
            ),
            /* harmony export */
            "DPTImageProcessor": () => (
              /* binding */
              DPTImageProcessor
            ),
            /* harmony export */
            "DeiTFeatureExtractor": () => (
              /* binding */
              DeiTFeatureExtractor
            ),
            /* harmony export */
            "DetrFeatureExtractor": () => (
              /* binding */
              DetrFeatureExtractor
            ),
            /* harmony export */
            "DonutFeatureExtractor": () => (
              /* binding */
              DonutFeatureExtractor
            ),
            /* harmony export */
            "EfficientNetImageProcessor": () => (
              /* binding */
              EfficientNetImageProcessor
            ),
            /* harmony export */
            "FeatureExtractor": () => (
              /* binding */
              FeatureExtractor
            ),
            /* harmony export */
            "GLPNFeatureExtractor": () => (
              /* binding */
              GLPNFeatureExtractor
            ),
            /* harmony export */
            "ImageFeatureExtractor": () => (
              /* binding */
              ImageFeatureExtractor
            ),
            /* harmony export */
            "MobileViTFeatureExtractor": () => (
              /* binding */
              MobileViTFeatureExtractor
            ),
            /* harmony export */
            "MobileViTImageProcessor": () => (
              /* binding */
              MobileViTImageProcessor
            ),
            /* harmony export */
            "NougatImageProcessor": () => (
              /* binding */
              NougatImageProcessor
            ),
            /* harmony export */
            "OwlViTFeatureExtractor": () => (
              /* binding */
              OwlViTFeatureExtractor
            ),
            /* harmony export */
            "OwlViTProcessor": () => (
              /* binding */
              OwlViTProcessor
            ),
            /* harmony export */
            "Owlv2ImageProcessor": () => (
              /* binding */
              Owlv2ImageProcessor
            ),
            /* harmony export */
            "Processor": () => (
              /* binding */
              Processor
            ),
            /* harmony export */
            "SamImageProcessor": () => (
              /* binding */
              SamImageProcessor
            ),
            /* harmony export */
            "SamProcessor": () => (
              /* binding */
              SamProcessor
            ),
            /* harmony export */
            "SeamlessM4TFeatureExtractor": () => (
              /* binding */
              SeamlessM4TFeatureExtractor
            ),
            /* harmony export */
            "SegformerFeatureExtractor": () => (
              /* binding */
              SegformerFeatureExtractor
            ),
            /* harmony export */
            "SiglipImageProcessor": () => (
              /* binding */
              SiglipImageProcessor
            ),
            /* harmony export */
            "SpeechT5FeatureExtractor": () => (
              /* binding */
              SpeechT5FeatureExtractor
            ),
            /* harmony export */
            "SpeechT5Processor": () => (
              /* binding */
              SpeechT5Processor
            ),
            /* harmony export */
            "Swin2SRImageProcessor": () => (
              /* binding */
              Swin2SRImageProcessor
            ),
            /* harmony export */
            "ViTFeatureExtractor": () => (
              /* binding */
              ViTFeatureExtractor
            ),
            /* harmony export */
            "ViTImageProcessor": () => (
              /* binding */
              ViTImageProcessor
            ),
            /* harmony export */
            "VitMatteImageProcessor": () => (
              /* binding */
              VitMatteImageProcessor
            ),
            /* harmony export */
            "Wav2Vec2FeatureExtractor": () => (
              /* binding */
              Wav2Vec2FeatureExtractor
            ),
            /* harmony export */
            "Wav2Vec2ProcessorWithLM": () => (
              /* binding */
              Wav2Vec2ProcessorWithLM
            ),
            /* harmony export */
            "WhisperFeatureExtractor": () => (
              /* binding */
              WhisperFeatureExtractor
            ),
            /* harmony export */
            "WhisperProcessor": () => (
              /* binding */
              WhisperProcessor
            ),
            /* harmony export */
            "YolosFeatureExtractor": () => (
              /* binding */
              YolosFeatureExtractor
            )
            /* harmony export */
          });
          var _utils_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__3(
            /*! ./utils/core.js */
            "./src/utils/core.js"
          );
          var _utils_hub_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__3(
            /*! ./utils/hub.js */
            "./src/utils/hub.js"
          );
          var _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__3(
            /*! ./utils/maths.js */
            "./src/utils/maths.js"
          );
          var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__3(
            /*! ./utils/tensor.js */
            "./src/utils/tensor.js"
          );
          var _utils_image_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__3(
            /*! ./utils/image.js */
            "./src/utils/image.js"
          );
          var _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__3(
            /*! ./utils/audio.js */
            "./src/utils/audio.js"
          );
          function center_to_corners_format([centerX, centerY, width, height]) {
            return [
              centerX - width / 2,
              centerY - height / 2,
              centerX + width / 2,
              centerY + height / 2
            ];
          }
          function post_process_object_detection(outputs, threshold = 0.5, target_sizes = null, is_zero_shot = false) {
            const out_logits = outputs.logits;
            const out_bbox = outputs.pred_boxes;
            const [batch_size, num_boxes, num_classes] = out_logits.dims;
            if (target_sizes !== null && target_sizes.length !== batch_size) {
              throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");
            }
            let toReturn = [];
            for (let i = 0; i < batch_size; ++i) {
              let target_size = target_sizes !== null ? target_sizes[i] : null;
              let info = {
                boxes: [],
                classes: [],
                scores: []
              };
              let logits = out_logits[i];
              let bbox = out_bbox[i];
              for (let j = 0; j < num_boxes; ++j) {
                let logit = logits[j];
                let indices = [];
                let probs;
                if (is_zero_shot) {
                  probs = logit.sigmoid().data;
                  for (let k = 0; k < probs.length; ++k) {
                    if (probs[k] > threshold) {
                      indices.push(k);
                    }
                  }
                } else {
                  let maxIndex = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(logit.data)[1];
                  if (maxIndex === num_classes - 1) {
                    continue;
                  }
                  indices.push(maxIndex);
                  probs = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.softmax)(logit.data);
                }
                for (const index of indices) {
                  let box = bbox[j].data;
                  box = center_to_corners_format(box);
                  if (target_size !== null) {
                    box = box.map((x, i2) => x * target_size[(i2 + 1) % 2]);
                  }
                  info.boxes.push(box);
                  info.classes.push(index);
                  info.scores.push(probs[index]);
                }
              }
              toReturn.push(info);
            }
            return toReturn;
          }
          function validate_audio_inputs(audio, feature_extractor) {
            if (!(audio instanceof Float32Array || audio instanceof Float64Array)) {
              throw new Error(
                `${feature_extractor} expects input to be a Float32Array or a Float64Array, but got ${audio?.constructor?.name ?? typeof audio} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`
              );
            }
          }
          function constraint_to_multiple_of(val, multiple, minVal = 0, maxVal = null) {
            const a = val / multiple;
            let x = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.bankers_round)(a) * multiple;
            if (maxVal !== null && x > maxVal) {
              x = Math.floor(a) * multiple;
            }
            if (x < minVal) {
              x = Math.ceil(a) * multiple;
            }
            return x;
          }
          function enforce_size_divisibility([width, height], divisor) {
            return [
              Math.max(Math.floor(width / divisor), 1) * divisor,
              Math.max(Math.floor(height / divisor), 1) * divisor
            ];
          }
          class FeatureExtractor extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
            /**
             * Constructs a new FeatureExtractor instance.
             *
             * @param {Object} config The configuration for the feature extractor.
             */
            constructor(config2) {
              super();
              this.config = config2;
            }
          }
          class ImageFeatureExtractor extends FeatureExtractor {
            /**
             * Constructs a new ImageFeatureExtractor instance.
             *
             * @param {Object} config The configuration for the feature extractor.
             * @param {number[]} config.image_mean The mean values for image normalization.
             * @param {number[]} config.image_std The standard deviation values for image normalization.
             * @param {boolean} config.do_rescale Whether to rescale the image pixel values to the [0,1] range.
             * @param {number} config.rescale_factor The factor to use for rescaling the image pixel values.
             * @param {boolean} config.do_normalize Whether to normalize the image pixel values.
             * @param {boolean} config.do_resize Whether to resize the image.
             * @param {number} config.resample What method to use for resampling.
             * @param {number|Object} config.size The size to resize the image to.
             * @param {boolean} [config.do_flip_channel_order=false] Whether to flip the color channels from RGB to BGR.
             * Can be overridden by the `do_flip_channel_order` parameter in the `preprocess` method.
             */
            constructor(config2) {
              super(config2);
              this.image_mean = this.config.image_mean ?? this.config.mean;
              this.image_std = this.config.image_std ?? this.config.std;
              this.resample = this.config.resample ?? 2;
              this.do_rescale = this.config.do_rescale ?? true;
              this.rescale_factor = this.config.rescale_factor ?? 1 / 255;
              this.do_normalize = this.config.do_normalize;
              this.do_resize = this.config.do_resize;
              this.do_thumbnail = this.config.do_thumbnail;
              this.size = this.config.size;
              this.size_divisibility = this.config.size_divisibility ?? this.config.size_divisor;
              this.do_center_crop = this.config.do_center_crop;
              this.crop_size = this.config.crop_size;
              this.do_convert_rgb = this.config.do_convert_rgb ?? true;
              this.do_crop_margin = this.config.do_crop_margin;
              this.pad_size = this.config.pad_size;
              this.do_pad = this.config.do_pad;
              if (this.do_pad && !this.pad_size && this.size && this.size.width !== void 0 && this.size.height !== void 0) {
                this.pad_size = this.size;
              }
              this.do_flip_channel_order = this.config.do_flip_channel_order ?? false;
            }
            /**
             * Resize the image to make a thumbnail. The image is resized so that no dimension is larger than any
             * corresponding dimension of the specified size.
             * @param {RawImage} image The image to be resized.
             * @param {{height:number, width:number}} size The size `{"height": h, "width": w}` to resize the image to.
             * @param {string | 0 | 1 | 2 | 3 | 4 | 5} [resample=2] The resampling filter to use.
             * @returns {Promise<RawImage>} The resized image.
             */
            async thumbnail(image2, size, resample = 2) {
              const input_height = image2.height;
              const input_width = image2.width;
              const output_height = size.height;
              const output_width = size.width;
              let height = Math.min(input_height, output_height);
              let width = Math.min(input_width, output_width);
              if (height === input_height && width === input_width) {
                return image2;
              }
              if (input_height > input_width) {
                width = Math.floor(input_width * height / input_height);
              } else if (input_width > input_height) {
                height = Math.floor(input_height * width / input_width);
              }
              return await image2.resize(width, height, { resample });
            }
            /**
             * Crops the margin of the image. Gray pixels are considered margin (i.e., pixels with a value below the threshold).
             * @param {RawImage} image The image to be cropped.
             * @param {number} gray_threshold Value below which pixels are considered to be gray.
             * @returns {Promise<RawImage>} The cropped image.
             */
            async crop_margin(image2, gray_threshold = 200) {
              const gray_image = image2.clone().grayscale();
              const minValue = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.min)(gray_image.data)[0];
              const maxValue = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(gray_image.data)[0];
              const diff = maxValue - minValue;
              if (diff === 0) {
                return image2;
              }
              const threshold = gray_threshold / 255;
              let x_min = gray_image.width, y_min = gray_image.height, x_max = 0, y_max = 0;
              for (let j = 0; j < gray_image.height; ++j) {
                const row = j * gray_image.width;
                for (let i = 0; i < gray_image.width; ++i) {
                  if ((gray_image.data[row + i] - minValue) / diff < threshold) {
                    x_min = Math.min(x_min, i);
                    y_min = Math.min(y_min, j);
                    x_max = Math.max(x_max, i);
                    y_max = Math.max(y_max, j);
                  }
                }
              }
              image2 = await image2.crop([x_min, y_min, x_max, y_max]);
              return image2;
            }
            /**
             * Pad the image by a certain amount.
             * @param {Float32Array} pixelData The pixel data to pad.
             * @param {number[]} imgDims The dimensions of the image (height, width, channels).
             * @param {{width:number; height:number}|number} padSize The dimensions of the padded image.
             * @param {Object} options The options for padding.
             * @param {'constant'|'symmetric'} [options.mode='constant'] The type of padding to add.
             * @param {boolean} [options.center=false] Whether to center the image.
             * @param {number} [options.constant_values=0] The constant value to use for padding.
             * @returns {[Float32Array, number[]]} The padded pixel data and image dimensions.
             */
            pad_image(pixelData, imgDims, padSize, {
              mode = "constant",
              center = false,
              constant_values = 0
            } = {}) {
              const [imageHeight, imageWidth, imageChannels] = imgDims;
              let paddedImageWidth, paddedImageHeight;
              if (typeof padSize === "number") {
                paddedImageWidth = padSize;
                paddedImageHeight = padSize;
              } else {
                paddedImageWidth = padSize.width;
                paddedImageHeight = padSize.height;
              }
              if (paddedImageWidth !== imageWidth || paddedImageHeight !== imageHeight) {
                const paddedPixelData = new Float32Array(paddedImageWidth * paddedImageHeight * imageChannels);
                if (Array.isArray(constant_values)) {
                  for (let i = 0; i < paddedPixelData.length; ++i) {
                    paddedPixelData[i] = constant_values[i % imageChannels];
                  }
                } else if (constant_values !== 0) {
                  paddedPixelData.fill(constant_values);
                }
                const [left, top] = center ? [Math.floor((paddedImageWidth - imageWidth) / 2), Math.floor((paddedImageHeight - imageHeight) / 2)] : [0, 0];
                for (let i = 0; i < imageHeight; ++i) {
                  const a = (i + top) * paddedImageWidth;
                  const b = i * imageWidth;
                  for (let j = 0; j < imageWidth; ++j) {
                    const c = (a + j + left) * imageChannels;
                    const d = (b + j) * imageChannels;
                    for (let k = 0; k < imageChannels; ++k) {
                      paddedPixelData[c + k] = pixelData[d + k];
                    }
                  }
                }
                if (mode === "symmetric") {
                  if (center) {
                    throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");
                  }
                  const h1 = imageHeight - 1;
                  const w1 = imageWidth - 1;
                  for (let i = 0; i < paddedImageHeight; ++i) {
                    const a = i * paddedImageWidth;
                    const b = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.calculateReflectOffset)(i, h1) * imageWidth;
                    for (let j = 0; j < paddedImageWidth; ++j) {
                      if (i < imageHeight && j < imageWidth)
                        continue;
                      const c = (a + j) * imageChannels;
                      const d = (b + (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.calculateReflectOffset)(j, w1)) * imageChannels;
                      for (let k = 0; k < imageChannels; ++k) {
                        paddedPixelData[c + k] = pixelData[d + k];
                      }
                    }
                  }
                }
                pixelData = paddedPixelData;
                imgDims = [paddedImageHeight, paddedImageWidth, imageChannels];
              }
              return [pixelData, imgDims];
            }
            /**
             * Rescale the image' pixel values by `this.rescale_factor`.
             * @param {Float32Array} pixelData The pixel data to rescale.
             * @returns {void}
             */
            rescale(pixelData) {
              for (let i = 0; i < pixelData.length; ++i) {
                pixelData[i] = this.rescale_factor * pixelData[i];
              }
            }
            /**
             * Find the target (width, height) dimension of the output image after
             * resizing given the input image and the desired size.
             * @param {RawImage} image The image to resize.
             * @param {any} size The size to use for resizing the image. 
             * @returns {[number, number]} The target (width, height) dimension of the output image after resizing.
             */
            get_resize_output_image_size(image2, size) {
              const [srcWidth, srcHeight] = image2.size;
              let shortest_edge;
              let longest_edge;
              if (this.do_thumbnail) {
                const { height, width } = size;
                shortest_edge = Math.min(height, width);
              } else if (Number.isInteger(size)) {
                shortest_edge = size;
                longest_edge = this.config.max_size ?? shortest_edge;
              } else if (size !== void 0) {
                shortest_edge = size.shortest_edge;
                longest_edge = size.longest_edge;
              }
              if (shortest_edge !== void 0 || longest_edge !== void 0) {
                const shortResizeFactor = shortest_edge === void 0 ? 1 : Math.max(shortest_edge / srcWidth, shortest_edge / srcHeight);
                const newWidth = srcWidth * shortResizeFactor;
                const newHeight = srcHeight * shortResizeFactor;
                const longResizeFactor = longest_edge === void 0 ? 1 : Math.min(longest_edge / newWidth, longest_edge / newHeight);
                let finalWidth = Math.floor(Number((newWidth * longResizeFactor).toFixed(2)));
                let finalHeight = Math.floor(Number((newHeight * longResizeFactor).toFixed(2)));
                if (this.size_divisibility !== void 0) {
                  [finalWidth, finalHeight] = enforce_size_divisibility([finalWidth, finalHeight], this.size_divisibility);
                }
                return [finalWidth, finalHeight];
              } else if (size !== void 0 && size.width !== void 0 && size.height !== void 0) {
                let newWidth = size.width;
                let newHeight = size.height;
                if (this.config.keep_aspect_ratio && this.config.ensure_multiple_of) {
                  let scale_height = newHeight / srcHeight;
                  let scale_width = newWidth / srcWidth;
                  if (Math.abs(1 - scale_width) < Math.abs(1 - scale_height)) {
                    scale_height = scale_width;
                  } else {
                    scale_width = scale_height;
                  }
                  newHeight = constraint_to_multiple_of(scale_height * srcHeight, this.config.ensure_multiple_of);
                  newWidth = constraint_to_multiple_of(scale_width * srcWidth, this.config.ensure_multiple_of);
                }
                return [newWidth, newHeight];
              } else if (this.size_divisibility !== void 0) {
                return enforce_size_divisibility([srcWidth, srcHeight], this.size_divisibility);
              } else {
                throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(size)}`);
              }
            }
            /**
             * Resizes the image.
             * @param {RawImage} image The image to resize.
             * @returns {Promise<RawImage>} The resized image.
             */
            async resize(image2) {
              const [newWidth, newHeight] = this.get_resize_output_image_size(image2, this.size);
              return await image2.resize(newWidth, newHeight, {
                resample: this.resample
              });
            }
            /**
             * @typedef {object} PreprocessedImage
             * @property {HeightWidth} original_size The original size of the image.
             * @property {HeightWidth} reshaped_input_size The reshaped input size of the image.
             * @property {Tensor} pixel_values The pixel values of the preprocessed image.
             */
            /**
             * Preprocesses the given image.
             *
             * @param {RawImage} image The image to preprocess.
             * @param {Object} overrides The overrides for the preprocessing options.
             * @returns {Promise<PreprocessedImage>} The preprocessed image.
             */
            async preprocess(image2, {
              do_normalize = null,
              do_pad = null,
              do_convert_rgb = null,
              do_convert_grayscale = null,
              do_flip_channel_order = null
            } = {}) {
              if (this.do_crop_margin) {
                image2 = await this.crop_margin(image2);
              }
              const [srcWidth, srcHeight] = image2.size;
              if (do_convert_rgb ?? this.do_convert_rgb) {
                image2 = image2.rgb();
              } else if (do_convert_grayscale) {
                image2 = image2.grayscale();
              }
              if (this.do_resize) {
                image2 = await this.resize(image2);
              }
              if (this.do_thumbnail) {
                image2 = await this.thumbnail(image2, this.size, this.resample);
              }
              if (this.do_center_crop) {
                let crop_width;
                let crop_height;
                if (Number.isInteger(this.crop_size)) {
                  crop_width = this.crop_size;
                  crop_height = this.crop_size;
                } else {
                  crop_width = this.crop_size.width;
                  crop_height = this.crop_size.height;
                }
                image2 = await image2.center_crop(crop_width, crop_height);
              }
              const reshaped_input_size = [image2.height, image2.width];
              let pixelData = Float32Array.from(image2.data);
              let imgDims = [image2.height, image2.width, image2.channels];
              if (this.do_rescale) {
                this.rescale(pixelData);
              }
              if (do_normalize ?? this.do_normalize) {
                let image_mean = this.image_mean;
                if (!Array.isArray(this.image_mean)) {
                  image_mean = new Array(image2.channels).fill(image_mean);
                }
                let image_std = this.image_std;
                if (!Array.isArray(this.image_std)) {
                  image_std = new Array(image2.channels).fill(image_mean);
                }
                if (image_mean.length !== image2.channels || image_std.length !== image2.channels) {
                  throw new Error(`When set to arrays, the length of \`image_mean\` (${image_mean.length}) and \`image_std\` (${image_std.length}) must match the number of channels in the image (${image2.channels}).`);
                }
                for (let i = 0; i < pixelData.length; i += image2.channels) {
                  for (let j = 0; j < image2.channels; ++j) {
                    pixelData[i + j] = (pixelData[i + j] - image_mean[j]) / image_std[j];
                  }
                }
              }
              if (do_pad ?? this.do_pad) {
                if (this.pad_size) {
                  const padded = this.pad_image(pixelData, [image2.height, image2.width, image2.channels], this.pad_size);
                  [pixelData, imgDims] = padded;
                } else if (this.size_divisibility) {
                  const [paddedWidth, paddedHeight] = enforce_size_divisibility([imgDims[1], imgDims[0]], this.size_divisibility);
                  [pixelData, imgDims] = this.pad_image(pixelData, imgDims, { width: paddedWidth, height: paddedHeight });
                }
              }
              if (do_flip_channel_order ?? this.do_flip_channel_order) {
                if (imgDims[2] !== 3) {
                  throw new Error("Flipping channel order is only supported for RGB images.");
                }
                for (let i = 0; i < pixelData.length; i += 3) {
                  const temp = pixelData[i];
                  pixelData[i] = pixelData[i + 2];
                  pixelData[i + 2] = temp;
                }
              }
              const pixel_values = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor("float32", pixelData, imgDims).permute(2, 0, 1);
              return {
                original_size: [srcHeight, srcWidth],
                reshaped_input_size,
                pixel_values
              };
            }
            /**
             * Calls the feature extraction process on an array of images,
             * preprocesses each image, and concatenates the resulting
             * features into a single Tensor.
             * @param {RawImage[]} images The image(s) to extract features from.
             * @param {...any} args Additional arguments.
             * @returns {Promise<ImageFeatureExtractorResult>} An object containing the concatenated pixel values (and other metadata) of the preprocessed images.
             */
            async _call(images, ...args) {
              if (!Array.isArray(images)) {
                images = [images];
              }
              const imageData = await Promise.all(images.map((x) => this.preprocess(x)));
              const pixel_values = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.stack)(imageData.map((x) => x.pixel_values), 0);
              return {
                pixel_values,
                // Original sizes of images
                original_sizes: imageData.map((x) => x.original_size),
                // Reshaped sizes of images, before padding or cropping
                reshaped_input_sizes: imageData.map((x) => x.reshaped_input_size)
              };
            }
          }
          class SegformerFeatureExtractor extends ImageFeatureExtractor {
            /**
             * Converts the output of `SegformerForSemanticSegmentation` into semantic segmentation maps.
             * @param {*} outputs Raw outputs of the model.
             * @param {number[][]} [target_sizes=null] List of tuples corresponding to the requested final size
             * (height, width) of each prediction. If unset, predictions will not be resized.
             * @returns {{segmentation: Tensor; labels: number[]}[]} The semantic segmentation maps.
             */
            post_process_semantic_segmentation(outputs, target_sizes = null) {
              const logits = outputs.logits;
              const batch_size = logits.dims[0];
              if (target_sizes !== null && target_sizes.length !== batch_size) {
                throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");
              }
              const toReturn = [];
              for (let i = 0; i < batch_size; ++i) {
                const target_size = target_sizes !== null ? target_sizes[i] : null;
                let data = logits[i];
                if (target_size !== null) {
                  data = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.interpolate)(data, target_size, "bilinear", false);
                }
                const [height, width] = target_size ?? data.dims.slice(-2);
                const segmentation = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(
                  "int32",
                  new Int32Array(height * width),
                  [height, width]
                );
                const buffer = data[0].data;
                for (let j = 1; j < data.dims[0]; ++j) {
                  const row = data[j].data;
                  for (let k = 0; k < row.length; ++k) {
                    if (row[k] > buffer[k]) {
                      buffer[k] = row[k];
                      segmentation.data[k] = j;
                    }
                  }
                }
                const hasLabel = new Array(data.dims[0]);
                const out = segmentation.data;
                for (let j = 0; j < out.length; ++j) {
                  const index = out[j];
                  hasLabel[index] = index;
                }
                const labels = hasLabel.filter((x) => x !== void 0);
                toReturn.push({ segmentation, labels });
              }
              return toReturn;
            }
          }
          class DPTFeatureExtractor extends ImageFeatureExtractor {
          }
          class DPTImageProcessor extends DPTFeatureExtractor {
          }
          class BitImageProcessor extends ImageFeatureExtractor {
          }
          class GLPNFeatureExtractor extends ImageFeatureExtractor {
          }
          class CLIPFeatureExtractor extends ImageFeatureExtractor {
          }
          class ChineseCLIPFeatureExtractor extends ImageFeatureExtractor {
          }
          class SiglipImageProcessor extends ImageFeatureExtractor {
          }
          class ConvNextFeatureExtractor extends ImageFeatureExtractor {
            constructor(config2) {
              super(config2);
              this.crop_pct = this.config.crop_pct ?? 224 / 256;
            }
            async resize(image2) {
              const shortest_edge = this.size?.shortest_edge;
              if (shortest_edge === void 0) {
                throw new Error(`Size dictionary must contain 'shortest_edge' key.`);
              }
              if (shortest_edge < 384) {
                const resize_shortest_edge = Math.floor(shortest_edge / this.crop_pct);
                const [newWidth, newHeight] = this.get_resize_output_image_size(image2, {
                  shortest_edge: resize_shortest_edge
                });
                image2 = await image2.resize(newWidth, newHeight, {
                  resample: this.resample
                });
                image2 = await image2.center_crop(shortest_edge, shortest_edge);
              } else {
                image2 = await image2.resize(shortest_edge, shortest_edge, {
                  resample: this.resample
                });
              }
              return image2;
            }
          }
          class ConvNextImageProcessor extends ConvNextFeatureExtractor {
          }
          class ViTFeatureExtractor extends ImageFeatureExtractor {
          }
          class ViTImageProcessor extends ImageFeatureExtractor {
          }
          class EfficientNetImageProcessor extends ImageFeatureExtractor {
            constructor(config2) {
              super(config2);
              this.include_top = this.config.include_top ?? true;
              if (this.include_top) {
                this.image_std = this.image_std.map((x) => x * x);
              }
            }
          }
          class MobileViTFeatureExtractor extends ImageFeatureExtractor {
          }
          class MobileViTImageProcessor extends MobileViTFeatureExtractor {
          }
          class OwlViTFeatureExtractor extends ImageFeatureExtractor {
            /** @type {post_process_object_detection} */
            post_process_object_detection(...args) {
              return post_process_object_detection(...args);
            }
          }
          class Owlv2ImageProcessor extends OwlViTFeatureExtractor {
          }
          class DeiTFeatureExtractor extends ImageFeatureExtractor {
          }
          class BeitFeatureExtractor extends ImageFeatureExtractor {
          }
          class DonutFeatureExtractor extends ImageFeatureExtractor {
            pad_image(pixelData, imgDims, padSize, options = {}) {
              const [imageHeight, imageWidth, imageChannels] = imgDims;
              let image_mean = this.image_mean;
              if (!Array.isArray(this.image_mean)) {
                image_mean = new Array(imageChannels).fill(image_mean);
              }
              let image_std = this.image_std;
              if (!Array.isArray(image_std)) {
                image_std = new Array(imageChannels).fill(image_mean);
              }
              const constant_values = image_mean.map((x, i) => -x / image_std[i]);
              return super.pad_image(pixelData, imgDims, padSize, {
                center: true,
                // Since normalization is done after padding, we need to use certain constant values to ensure the same behaviour is observed.
                // For more information, see https://github.com/huggingface/transformers/blob/main/src/transformers/models/donut/image_processing_donut.py#L433-L451
                constant_values,
                ...options
              });
            }
          }
          class NougatImageProcessor extends DonutFeatureExtractor {
          }
          class DetrFeatureExtractor extends ImageFeatureExtractor {
            /**
             * Calls the feature extraction process on an array of images, preprocesses
             * each image, and concatenates the resulting features into a single Tensor.
             * @param {RawImage[]} images The image(s) to extract features from.
             * @returns {Promise<DetrFeatureExtractorResult>} An object containing the concatenated pixel values of the preprocessed images.
             */
            async _call(images) {
              const result = await super._call(images);
              const maskSize = [result.pixel_values.dims[0], 64, 64];
              const pixel_mask = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(
                "int64",
                new BigInt64Array(maskSize.reduce((a, b) => a * b)).fill(1n),
                maskSize
              );
              return { ...result, pixel_mask };
            }
            /**
             * Post-processes the outputs of the model (for object detection).
             * @param {Object} outputs The outputs of the model that must be post-processed
             * @param {Tensor} outputs.logits The logits
             * @param {Tensor} outputs.pred_boxes The predicted boxes.
             * @return {Object[]} An array of objects containing the post-processed outputs.
             */
            /** @type {post_process_object_detection} */
            post_process_object_detection(...args) {
              return post_process_object_detection(...args);
            }
            /**
             * Binarize the given masks using `object_mask_threshold`, it returns the associated values of `masks`, `scores` and `labels`.
             * @param {Tensor} class_logits The class logits.
             * @param {Tensor} mask_logits The mask logits.
             * @param {number} object_mask_threshold A number between 0 and 1 used to binarize the masks.
             * @param {number} num_labels The number of labels.
             * @returns {[Tensor[], number[], number[]]} The binarized masks, the scores, and the labels.
             */
            remove_low_and_no_objects(class_logits, mask_logits, object_mask_threshold, num_labels) {
              let mask_probs_item = [];
              let pred_scores_item = [];
              let pred_labels_item = [];
              for (let j = 0; j < class_logits.dims[0]; ++j) {
                let cls = class_logits[j];
                let mask = mask_logits[j];
                let pred_label = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(cls.data)[1];
                if (pred_label === num_labels) {
                  continue;
                }
                let scores = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.softmax)(cls.data);
                let pred_score = scores[pred_label];
                if (pred_score > object_mask_threshold) {
                  mask_probs_item.push(mask);
                  pred_scores_item.push(pred_score);
                  pred_labels_item.push(pred_label);
                }
              }
              return [mask_probs_item, pred_scores_item, pred_labels_item];
            }
            /**
             * Checks whether the segment is valid or not.
             * @param {Int32Array} mask_labels Labels for each pixel in the mask.
             * @param {Tensor[]} mask_probs Probabilities for each pixel in the masks.
             * @param {number} k The class id of the segment.
             * @param {number} mask_threshold The mask threshold.
             * @param {number} overlap_mask_area_threshold The overlap mask area threshold.
             * @returns {[boolean, number[]]} Whether the segment is valid or not, and the indices of the valid labels.
             */
            check_segment_validity(mask_labels, mask_probs, k, mask_threshold = 0.5, overlap_mask_area_threshold = 0.8) {
              let mask_k = [];
              let mask_k_area = 0;
              let original_area = 0;
              for (let i = 0; i < mask_labels.length; ++i) {
                if (mask_labels[i] === k) {
                  mask_k.push(i);
                  ++mask_k_area;
                }
                if (mask_probs[k].data[i] >= mask_threshold) {
                  ++original_area;
                }
              }
              let mask_exists = mask_k_area > 0 && original_area > 0;
              if (mask_exists) {
                let area_ratio = mask_k_area / original_area;
                mask_exists = area_ratio > overlap_mask_area_threshold;
              }
              return [mask_exists, mask_k];
            }
            /**
             * Computes the segments.
             * @param {Tensor[]} mask_probs The mask probabilities.
             * @param {number[]} pred_scores The predicted scores.
             * @param {number[]} pred_labels The predicted labels.
             * @param {number} mask_threshold The mask threshold.
             * @param {number} overlap_mask_area_threshold The overlap mask area threshold.
             * @param {Set<number>} label_ids_to_fuse The label ids to fuse.
             * @param {number[]} target_size The target size of the image.
             * @returns {[Tensor, Array<{id: number, label_id: number, score: number}>]} The computed segments.
             */
            compute_segments(mask_probs, pred_scores, pred_labels, mask_threshold, overlap_mask_area_threshold, label_ids_to_fuse = null, target_size = null) {
              let [height, width] = target_size ?? mask_probs[0].dims;
              let segmentation = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(
                "int32",
                new Int32Array(height * width),
                [height, width]
              );
              let segments = [];
              if (target_size !== null) {
                for (let i = 0; i < mask_probs.length; ++i) {
                  mask_probs[i] = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.interpolate)(mask_probs[i], target_size, "bilinear", false);
                }
              }
              let mask_labels = new Int32Array(mask_probs[0].data.length);
              let bestScores = new Float32Array(mask_probs[0].data.length);
              for (let i = 0; i < mask_probs.length; ++i) {
                let score = pred_scores[i];
                for (let j = 0; j < mask_probs[i].data.length; ++j) {
                  mask_probs[i].data[j] *= score;
                  if (mask_probs[i].data[j] > bestScores[j]) {
                    mask_labels[j] = i;
                    bestScores[j] = mask_probs[i].data[j];
                  }
                }
              }
              let current_segment_id = 0;
              for (let k = 0; k < pred_labels.length; ++k) {
                let pred_class = pred_labels[k];
                let [mask_exists, mask_k] = this.check_segment_validity(
                  mask_labels,
                  mask_probs,
                  k,
                  mask_threshold,
                  overlap_mask_area_threshold
                );
                if (!mask_exists) {
                  continue;
                }
                ++current_segment_id;
                for (let index of mask_k) {
                  segmentation.data[index] = current_segment_id;
                }
                segments.push({
                  id: current_segment_id,
                  label_id: pred_class,
                  // was_fused: should_fuse, TODO
                  score: pred_scores[k]
                });
              }
              return [segmentation, segments];
            }
            /**
             * Post-process the model output to generate the final panoptic segmentation.
             * @param {*} outputs The model output to post process
             * @param {number} [threshold=0.5] The probability score threshold to keep predicted instance masks.
             * @param {number} [mask_threshold=0.5] Threshold to use when turning the predicted masks into binary values.
             * @param {number} [overlap_mask_area_threshold=0.8] The overlap mask area threshold to merge or discard small disconnected parts within each binary instance mask.
             * @param {Set<number>} [label_ids_to_fuse=null] The labels in this state will have all their instances be fused together.
             * @param {number[][]} [target_sizes=null] The target sizes to resize the masks to.
             * @returns {Array<{ segmentation: Tensor, segments_info: Array<{id: number, label_id: number, score: number}>}>}
             */
            post_process_panoptic_segmentation(outputs, threshold = 0.5, mask_threshold = 0.5, overlap_mask_area_threshold = 0.8, label_ids_to_fuse = null, target_sizes = null) {
              if (label_ids_to_fuse === null) {
                console.warn("`label_ids_to_fuse` unset. No instance will be fused.");
                label_ids_to_fuse = /* @__PURE__ */ new Set();
              }
              const class_queries_logits = outputs.logits;
              const masks_queries_logits = outputs.pred_masks;
              const mask_probs = masks_queries_logits.sigmoid();
              let [batch_size, num_queries, num_labels] = class_queries_logits.dims;
              num_labels -= 1;
              if (target_sizes !== null && target_sizes.length !== batch_size) {
                throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");
              }
              let toReturn = [];
              for (let i = 0; i < batch_size; ++i) {
                let target_size = target_sizes !== null ? target_sizes[i] : null;
                let class_logits = class_queries_logits[i];
                let mask_logits = mask_probs[i];
                let [mask_probs_item, pred_scores_item, pred_labels_item] = this.remove_low_and_no_objects(class_logits, mask_logits, threshold, num_labels);
                if (pred_labels_item.length === 0) {
                  let [height, width] = target_size ?? mask_logits.dims.slice(-2);
                  let segmentation2 = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(
                    "int32",
                    new Int32Array(height * width).fill(-1),
                    [height, width]
                  );
                  toReturn.push({
                    segmentation: segmentation2,
                    segments_info: []
                  });
                  continue;
                }
                let [segmentation, segments] = this.compute_segments(
                  mask_probs_item,
                  pred_scores_item,
                  pred_labels_item,
                  mask_threshold,
                  overlap_mask_area_threshold,
                  label_ids_to_fuse,
                  target_size
                );
                toReturn.push({
                  segmentation,
                  segments_info: segments
                });
              }
              return toReturn;
            }
            post_process_instance_segmentation() {
              throw Error("Not implemented yet");
            }
          }
          class YolosFeatureExtractor extends ImageFeatureExtractor {
            /** @type {post_process_object_detection} */
            post_process_object_detection(...args) {
              return post_process_object_detection(...args);
            }
          }
          class SamImageProcessor extends ImageFeatureExtractor {
            /**
             * 
             * @param {any} input_points 
             * @param {HeightWidth[]} original_sizes 
             * @param {HeightWidth[]} reshaped_input_sizes 
             * @returns {Tensor}
             */
            reshape_input_points(input_points, original_sizes, reshaped_input_sizes) {
              input_points = structuredClone(input_points);
              let shape = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.calculateDimensions)(input_points);
              if (shape.length === 3) {
                shape = [1, ...shape];
                input_points = [input_points];
              } else if (shape.length !== 4) {
                throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");
              }
              for (let i = 0; i < input_points.length; ++i) {
                let originalImageSize = original_sizes[i];
                let reshapedImageSize = reshaped_input_sizes[i];
                let resizeFactors = [
                  reshapedImageSize[0] / originalImageSize[0],
                  reshapedImageSize[1] / originalImageSize[1]
                ];
                for (let j = 0; j < input_points[i].length; ++j) {
                  for (let k = 0; k < input_points[i][j].length; ++k) {
                    for (let w = 0; w < input_points[i][j][k].length; ++w) {
                      input_points[i][j][k][w] *= resizeFactors[w];
                    }
                  }
                }
              }
              return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(
                "float32",
                Float32Array.from(input_points.flat(Infinity)),
                shape
              );
            }
            /**
             * 
             * @param {any} input_labels 
             * @param {Tensor} input_points 
             * @returns {Tensor}
             */
            add_input_labels(input_labels, input_points) {
              let shape = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.calculateDimensions)(input_labels);
              if (shape.length === 2) {
                shape = [1, ...shape];
                input_labels = [input_labels];
              } else if (shape.length !== 3) {
                throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");
              }
              if (shape.some((x, i) => x !== input_points.dims[i])) {
                throw Error(`The first ${shape.length} dimensions of 'input_points' and 'input_labels' must be the same.`);
              }
              return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(
                "int64",
                input_labels.flat(Infinity).map(BigInt),
                shape
              );
            }
            /**
             * @param {any[]} images The URL(s) of the image(s) to extract features from.
             * @param {any} [input_points] A 3D or 4D array, representing the input points provided by the user.
             * - 3D: `[point_batch_size, nb_points_per_image, 2]`. In this case, `batch_size` is assumed to be 1.
             * - 4D: `[batch_size, point_batch_size, nb_points_per_image, 2]`.
             * @param {any} [input_labels] A 2D or 3D array, representing the input labels for the points, used by the prompt encoder to encode the prompt.
             * - 2D: `[point_batch_size, nb_points_per_image]`. In this case, `batch_size` is assumed to be 1.
             * - 3D: `[batch_size, point_batch_size, nb_points_per_image]`.
             * @returns {Promise<SamImageProcessorResult>}
             */
            async _call(images, input_points = null, input_labels = null) {
              const processed = await super._call(images);
              if (input_points) {
                processed.input_points = this.reshape_input_points(
                  input_points,
                  processed.original_sizes,
                  processed.reshaped_input_sizes
                );
              }
              if (input_labels) {
                if (!processed.input_points) {
                  throw Error("`input_points` must be provided if `input_labels` are provided.");
                }
                processed.input_labels = this.add_input_labels(input_labels, processed.input_points);
              }
              return processed;
            }
            /**
             * Remove padding and upscale masks to the original image size.
             * @param {Tensor} masks Batched masks from the mask_decoder in (batch_size, num_channels, height, width) format.
             * @param {number[][]} original_sizes The original sizes of each image before it was resized to the model's expected input shape, in (height, width) format.
             * @param {number[][]} reshaped_input_sizes The size of each image as it is fed to the model, in (height, width) format. Used to remove padding.
             * @param {Object} options Optional parameters for post-processing.
             * @param {number} [options.mask_threshold] The threshold to use for binarizing the masks.
             * @param {boolean} [options.binarize] Whether to binarize the masks.
             * @param {Object} [options.pad_size] The target size the images were padded to before being passed to the model. If `null`, the target size is assumed to be the processor's `pad_size`.
             * @param {number} [options.pad_size.height] The height the images were padded to.
             * @param {number} [options.pad_size.width] The width the images were padded to.
             * @returns {Tensor[]} Batched masks in batch_size, num_channels, height, width) format, where (height, width) is given by original_size.
             */
            post_process_masks(masks, original_sizes, reshaped_input_sizes, {
              mask_threshold = 0,
              binarize = true,
              pad_size = null
            } = {}) {
              const output_masks = [];
              pad_size = pad_size ?? this.pad_size;
              const target_image_size = [pad_size.height, pad_size.width];
              for (let i = 0; i < original_sizes.length; ++i) {
                const original_size = original_sizes[i];
                const reshaped_input_size = reshaped_input_sizes[i];
                const mask = masks[i];
                const interpolated_masks = [];
                for (let j = 0; j < mask.dims[0]; ++j) {
                  const m = mask[j];
                  let interpolated_mask = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.interpolate)(m, target_image_size, "bilinear", false);
                  interpolated_mask = interpolated_mask.slice(null, [0, reshaped_input_size[0]], [0, reshaped_input_size[1]]);
                  interpolated_mask = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.interpolate)(interpolated_mask, original_size, "bilinear", false);
                  if (binarize) {
                    const binarizedMaskData = new Uint8Array(interpolated_mask.data.length);
                    for (let i2 = 0; i2 < interpolated_mask.data.length; ++i2) {
                      if (interpolated_mask.data[i2] > mask_threshold) {
                        binarizedMaskData[i2] = 1;
                      }
                    }
                    interpolated_mask = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(
                      "bool",
                      binarizedMaskData,
                      interpolated_mask.dims
                    );
                  }
                  interpolated_masks.push(interpolated_mask);
                }
                output_masks.push((0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.stack)(interpolated_masks));
              }
              return output_masks;
            }
          }
          class Swin2SRImageProcessor extends ImageFeatureExtractor {
            pad_image(pixelData, imgDims, padSize, options = {}) {
              const [imageHeight, imageWidth, imageChannels] = imgDims;
              return super.pad_image(pixelData, imgDims, {
                // NOTE: For Swin2SR models, the original python implementation adds padding even when the image's width/height is already
                // a multiple of `pad_size`. However, this is most likely a bug (PR: https://github.com/mv-lab/swin2sr/pull/19).
                // For this reason, we only add padding when the image's width/height is not a multiple of `pad_size`.
                width: imageWidth + (padSize - imageWidth % padSize) % padSize,
                height: imageHeight + (padSize - imageHeight % padSize) % padSize
              }, {
                mode: "symmetric",
                center: false,
                constant_values: -1,
                ...options
              });
            }
          }
          class VitMatteImageProcessor extends ImageFeatureExtractor {
            /**
             * Calls the feature extraction process on an array of images, preprocesses
             * each image, and concatenates the resulting features into a single Tensor.
             * @param {RawImage[]} images The image(s) to extract features from.
             * @param {RawImage[]} trimaps The trimaps(s) to extract features from.
             * @returns {Promise<ImageFeatureExtractorResult>} An object containing the concatenated pixel values of the preprocessed images.
             */
            async _call(images, trimaps) {
              if (!Array.isArray(images)) {
                images = [images];
              }
              if (!Array.isArray(trimaps)) {
                trimaps = [trimaps];
              }
              const imageData = await Promise.all(images.map((x) => this.preprocess(x)));
              const trimapData = await Promise.all(trimaps.map((x) => this.preprocess(x, {
                do_normalize: false,
                do_convert_rgb: false,
                do_convert_grayscale: true
              })));
              const pixel_values = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.stack)(imageData.map(
                // Concatenate images and trimaps
                (x, i) => (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.cat)([x.pixel_values, trimapData[i].pixel_values], 0)
              ), 0);
              return {
                pixel_values,
                // Original sizes of images
                original_sizes: imageData.map((x) => x.original_size),
                // Reshaped sizes of images, before padding or cropping
                reshaped_input_sizes: imageData.map((x) => x.reshaped_input_size)
              };
            }
          }
          class WhisperFeatureExtractor extends FeatureExtractor {
            constructor(config2) {
              var _a2;
              super(config2);
              (_a2 = this.config).mel_filters ?? (_a2.mel_filters = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.mel_filter_bank)(
                Math.floor(1 + this.config.n_fft / 2),
                // num_frequency_bins
                this.config.feature_size,
                // num_mel_filters
                0,
                // min_frequency
                8e3,
                // max_frequency
                this.config.sampling_rate,
                // sampling_rate
                "slaney",
                // norm
                "slaney"
                // mel_scale
              ));
              this.window = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.window_function)(this.config.n_fft, "hann");
            }
            /**
             * Computes the log-Mel spectrogram of the provided audio waveform.
             * @param {Float32Array|Float64Array} waveform The audio waveform to process.
             * @returns {{data: Float32Array, dims: number[]}} An object containing the log-Mel spectrogram data as a Float32Array and its dimensions as an array of numbers.
             */
            _extract_fbank_features(waveform) {
              const { data, dims } = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.spectrogram)(
                waveform,
                this.window,
                // window
                this.config.n_fft,
                // frame_length
                this.config.hop_length,
                // hop_length
                {
                  power: 2,
                  mel_filters: this.config.mel_filters,
                  log_mel: "log10",
                  // Custom
                  max_num_frames: this.config.nb_max_frames
                  // 3000
                }
              );
              const maxValue = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(data)[0];
              for (let i = 0; i < data.length; ++i) {
                data[i] = (Math.max(data[i], maxValue - 8) + 4) / 4;
              }
              return { data, dims };
            }
            /**
             * Asynchronously extracts features from a given audio using the provided configuration.
             * @param {Float32Array|Float64Array} audio The audio data as a Float32Array/Float64Array.
             * @returns {Promise<{ input_features: Tensor }>} A Promise resolving to an object containing the extracted input features as a Tensor.
             */
            async _call(audio) {
              validate_audio_inputs(audio, "WhisperFeatureExtractor");
              let waveform;
              if (audio.length > this.config.n_samples) {
                console.warn(
                  "Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."
                );
                waveform = audio.slice(0, this.config.n_samples);
              } else {
                waveform = new Float32Array(this.config.n_samples);
                waveform.set(audio);
              }
              const { data, dims } = this._extract_fbank_features(waveform);
              return {
                input_features: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(
                  "float32",
                  data,
                  [1, ...dims]
                )
              };
            }
          }
          class Wav2Vec2FeatureExtractor extends FeatureExtractor {
            /**
             * @param {Float32Array} input_values 
             * @returns {Float32Array} 
             */
            _zero_mean_unit_var_norm(input_values) {
              const sum = input_values.reduce((a, b) => a + b, 0);
              const mean = sum / input_values.length;
              const variance = input_values.reduce((a, b) => a + (b - mean) ** 2, 0) / input_values.length;
              return input_values.map((x) => (x - mean) / Math.sqrt(variance + 1e-7));
            }
            /**
             * Asynchronously extracts features from a given audio using the provided configuration.
             * @param {Float32Array|Float64Array} audio The audio data as a Float32Array/Float64Array.
             * @returns {Promise<{ input_values: Tensor; attention_mask: Tensor }>} A Promise resolving to an object containing the extracted input features and attention mask as Tensors.
             */
            async _call(audio) {
              validate_audio_inputs(audio, "Wav2Vec2FeatureExtractor");
              if (audio instanceof Float64Array) {
                audio = new Float32Array(audio);
              }
              let input_values = audio;
              if (this.config.do_normalize) {
                input_values = this._zero_mean_unit_var_norm(input_values);
              }
              const shape = [1, input_values.length];
              return {
                input_values: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor("float32", input_values, shape),
                attention_mask: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor("int64", new BigInt64Array(input_values.length).fill(1n), shape)
              };
            }
          }
          class SeamlessM4TFeatureExtractor extends FeatureExtractor {
            constructor(config2) {
              super(config2);
              const sampling_rate = this.config.sampling_rate;
              const mel_filters = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.mel_filter_bank)(
                256,
                // num_frequency_bins
                this.config.num_mel_bins,
                // num_mel_filters
                20,
                // min_frequency
                Math.floor(sampling_rate / 2),
                // max_frequency
                sampling_rate,
                // sampling_rate
                null,
                // norm
                "kaldi",
                // mel_scale
                true
                // triangularize_in_mel_space
              );
              for (let i = 0; i < mel_filters.length; ++i) {
                mel_filters[i].push(0);
              }
              this.mel_filters = mel_filters;
              this.window = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.window_function)(400, "povey", {
                periodic: false
              });
            }
            /**
             * Computes the log-Mel spectrogram of the provided audio waveform.
             * @param {Float32Array|Float64Array} waveform The audio waveform to process.
             * @param {number} max_length The maximum number of frames to return.
             * @returns {{data: Float32Array, dims: number[]}} An object containing the log-Mel spectrogram data as a Float32Array and its dimensions as an array of numbers.
             */
            _extract_fbank_features(waveform, max_length) {
              waveform = waveform.map((x) => x * 32768);
              return (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.spectrogram)(
                waveform,
                this.window,
                // window
                400,
                // frame_length
                160,
                // hop_length
                {
                  fft_length: 512,
                  power: 2,
                  center: false,
                  preemphasis: 0.97,
                  mel_filters: this.mel_filters,
                  log_mel: "log",
                  mel_floor: 1192092955078125e-22,
                  remove_dc_offset: true,
                  // Custom
                  max_num_frames: max_length,
                  transpose: true
                }
              );
            }
            /**
             * Asynchronously extracts features from a given audio using the provided configuration.
             * @param {Float32Array|Float64Array} audio The audio data as a Float32Array/Float64Array.
             * @param {Object} options Optional parameters for feature extraction.
             * @param {boolean} [options.padding=true] Whether to pad the sequence to a multiple of `pad_to_multiple_of`.
             * @param {number} [options.pad_to_multiple_of=2] The number to pad the sequence to a multiple of.
             * @param {boolean} [options.do_normalize_per_mel_bins=true] Whether or not to zero-mean unit-variance normalize the input per mel-channel.
             * @param {boolean} [options.return_attention_mask=true] Whether to return the attention mask.
             * @returns {Promise<{ input_features: Tensor, attention_mask?: Tensor }>} A Promise resolving to an object containing the extracted input features and attention masks as Tensors.
             */
            async _call(audio, {
              padding = true,
              pad_to_multiple_of = 2,
              do_normalize_per_mel_bins = true,
              return_attention_mask = true
            } = {}) {
              validate_audio_inputs(audio, "SeamlessM4TFeatureExtractor");
              let features = this._extract_fbank_features(audio, this.config.max_length);
              if (do_normalize_per_mel_bins) {
                const [num_features, feature_size] = features.dims;
                for (let i = 0; i < feature_size; ++i) {
                  let sum = 0;
                  for (let j = 0; j < num_features; ++j) {
                    sum += features.data[j * feature_size + i];
                  }
                  const mean = sum / num_features;
                  let variance = 0;
                  for (let j = 0; j < num_features; ++j) {
                    variance += (features.data[j * feature_size + i] - mean) ** 2;
                  }
                  variance /= num_features - 1;
                  const std = Math.sqrt(variance + 1e-7);
                  for (let j = 0; j < num_features; ++j) {
                    const index = j * feature_size + i;
                    features.data[index] = (features.data[index] - mean) / std;
                  }
                }
              }
              let padded_attention_mask;
              if (padding) {
                const [num_frames2, num_channels2] = features.dims;
                const pad_size = num_frames2 % pad_to_multiple_of;
                if (pad_size > 0) {
                  const padded_data = new Float32Array(num_channels2 * (num_frames2 + pad_size));
                  padded_data.set(features.data);
                  padded_data.fill(this.config.padding_value, features.data.length);
                  const numPaddedFrames = num_frames2 + pad_size;
                  features = {
                    data: padded_data,
                    dims: [numPaddedFrames, num_channels2]
                  };
                  if (return_attention_mask) {
                    padded_attention_mask = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(
                      "int64",
                      new BigInt64Array(numPaddedFrames),
                      [1, numPaddedFrames]
                    );
                    padded_attention_mask.data.fill(1n, 0, num_frames2);
                  }
                }
              }
              const [num_frames, num_channels] = features.dims;
              const stride = this.config.stride;
              const remainder = num_frames % stride;
              if (remainder !== 0) {
                throw new Error(`The number of frames (${num_frames}) must be a multiple of the stride (${stride}).`);
              }
              const input_features = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(
                "float32",
                features.data,
                features.dims
              ).view(
                1,
                Math.floor(num_frames / stride),
                num_channels * stride
              );
              const result = { input_features };
              if (return_attention_mask) {
                const reshapedNumFrames = input_features.dims[1];
                const attention_mask = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(
                  "int64",
                  new BigInt64Array(reshapedNumFrames),
                  [1, reshapedNumFrames]
                );
                if (padded_attention_mask) {
                  for (let i = 1, j = 0; i < num_frames; i += stride, ++j) {
                    attention_mask.data[j] = padded_attention_mask.data[i];
                  }
                } else {
                  attention_mask.data.fill(1n);
                }
                result.attention_mask = attention_mask;
              }
              return result;
            }
          }
          class ASTFeatureExtractor extends FeatureExtractor {
            constructor(config2) {
              super(config2);
              const sampling_rate = this.config.sampling_rate;
              const mel_filters = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.mel_filter_bank)(
                256,
                // num_frequency_bins
                this.config.num_mel_bins,
                // num_mel_filters
                20,
                // min_frequency
                Math.floor(sampling_rate / 2),
                // max_frequency
                sampling_rate,
                // sampling_rate
                null,
                // norm
                "kaldi",
                // mel_scale
                true
                // triangularize_in_mel_space
              );
              for (let i = 0; i < mel_filters.length; ++i) {
                mel_filters[i].push(0);
              }
              this.mel_filters = mel_filters;
              this.window = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.window_function)(400, "hann", {
                periodic: false
              });
              this.mean = this.config.mean;
              this.std = this.config.std;
            }
            /**
             * Computes the log-Mel spectrogram of the provided audio waveform.
             * @param {Float32Array|Float64Array} waveform The audio waveform to process.
             * @param {number} max_length The maximum number of frames to return.
             * @returns {{data: Float32Array, dims: number[]}} An object containing the log-Mel spectrogram data as a Float32Array and its dimensions as an array of numbers.
             */
            _extract_fbank_features(waveform, max_length) {
              return (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.spectrogram)(
                waveform,
                this.window,
                // window
                400,
                // frame_length
                160,
                // hop_length
                {
                  fft_length: 512,
                  power: 2,
                  center: false,
                  preemphasis: 0.97,
                  mel_filters: this.mel_filters,
                  log_mel: "log",
                  mel_floor: 1192092955078125e-22,
                  remove_dc_offset: true,
                  // Custom
                  max_num_frames: max_length,
                  transpose: true
                }
              );
            }
            /**
             * Asynchronously extracts features from a given audio using the provided configuration.
             * @param {Float32Array|Float64Array} audio The audio data as a Float32Array/Float64Array.
             * @returns {Promise<{ input_values: Tensor }>} A Promise resolving to an object containing the extracted input features as a Tensor.
             */
            async _call(audio) {
              validate_audio_inputs(audio, "ASTFeatureExtractor");
              const features = this._extract_fbank_features(audio, this.config.max_length);
              if (this.config.do_normalize) {
                const denom = this.std * 2;
                for (let i = 0; i < features.data.length; ++i) {
                  features.data[i] = (features.data[i] - this.mean) / denom;
                }
              }
              return {
                input_values: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(
                  "float32",
                  features.data,
                  [1, ...features.dims]
                )
              };
            }
          }
          class ClapFeatureExtractor extends FeatureExtractor {
            constructor(config2) {
              super(config2);
              this.mel_filters = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.mel_filter_bank)(
                this.config.nb_frequency_bins,
                // num_frequency_bins
                this.config.feature_size,
                // num_mel_filters
                this.config.frequency_min,
                // min_frequency
                this.config.frequency_max,
                // max_frequency
                this.config.sampling_rate,
                // sampling_rate
                null,
                // norm
                "htk"
                // mel_scale
              );
              this.mel_filters_slaney = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.mel_filter_bank)(
                this.config.nb_frequency_bins,
                // num_frequency_bins
                this.config.feature_size,
                // num_mel_filters
                this.config.frequency_min,
                // min_frequency
                this.config.frequency_max,
                // max_frequency
                this.config.sampling_rate,
                // sampling_rate
                "slaney",
                // norm
                "slaney"
                // mel_scale
              );
              this.window = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.window_function)(this.config.fft_window_size, "hann");
            }
            /**
             * Extracts the mel spectrogram and prepares it for the mode based on the `truncation` and `padding` arguments.
             * 
             * Four different path are possible:
             *   - `truncation="fusion"` and the length of the waveform is greater than the max length: the mel spectrogram
             *     will be computed on the entire audio. 3 random crops and a dowsampled version of the full mel spectrogram
             *     are then stacked together. They will later be used for `feature_fusion`.
             *   - `truncation="rand_trunc"` and the length of the waveform is smaller than the max length: the audio is
             *     padded based on `padding`.
             *   - `truncation="fusion"` and the length of the waveform is smaller than the max length: the audio is padded
             *     based on `padding`, and is repeated `4` times.
             *   - `truncation="rand_trunc"` and the length of the waveform is greater than the max length: the mel
             *     spectrogram will be computed on a random crop of the waveform.
             * 
             * @param {Float32Array|Float64Array} waveform The input waveform.
             * @param {number} max_length The maximum length of the waveform.
             * @param {string} truncation The truncation strategy to use.
             * @param {string} padding The padding strategy to use.
             * @returns {{ data: Float32Array; dims: number[]; longer: boolean; }} An object containing the mel spectrogram data as a Float32Array, its dimensions as an array of numbers, and a boolean indicating whether the waveform was longer than the max length.
             */
            _get_input_mel(waveform, max_length, truncation, padding) {
              let input_mel;
              let longer = false;
              const diff = waveform.length - max_length;
              if (diff > 0) {
                if (truncation === "rand_trunc") {
                  longer = true;
                  const idx = Math.floor(Math.random() * (diff + 1));
                  waveform = waveform.subarray(idx, idx + max_length);
                  input_mel = this._extract_fbank_features(waveform, this.mel_filters_slaney, this.config.nb_max_samples);
                  input_mel.dims = [1, ...input_mel.dims];
                } else {
                  throw new Error(`Truncation strategy "${truncation}" not implemented`);
                }
              } else {
                if (diff < 0) {
                  let padded = new Float64Array(max_length);
                  padded.set(waveform);
                  if (padding === "repeat") {
                    for (let i = waveform.length; i < max_length; i += waveform.length) {
                      padded.set(waveform.subarray(0, Math.min(waveform.length, max_length - i)), i);
                    }
                  } else if (padding === "repeatpad") {
                    for (let i = waveform.length; i < -diff; i += waveform.length) {
                      padded.set(waveform, i);
                    }
                  }
                  waveform = padded;
                }
                if (truncation === "fusion") {
                  throw new Error(`Truncation strategy "${truncation}" not implemented`);
                }
                input_mel = this._extract_fbank_features(waveform, this.mel_filters_slaney, this.config.nb_max_samples);
                input_mel.dims = [1, ...input_mel.dims];
              }
              return {
                ...input_mel,
                longer
              };
            }
            /**
             * Compute the log-mel spectrogram of the provided `waveform` using the Hann window.
             * In CLAP, two different filter banks are used depending on the truncation pattern:
             *  - `self.mel_filters`: they correspond to the default parameters of `torchaudio` which can be obtained from
             *    calling `torchaudio.transforms.MelSpectrogram().mel_scale.fb`. These filters are used when `truncation`
             *    is set to `"fusion"`.
             *  - `self.mel_filteres_slaney` : they correspond to the default parameters of `librosa` which used
             *    `librosa.filters.mel` when computing the mel spectrogram. These filters were only used in the original
             *    implementation when the truncation mode is not `"fusion"`.
             * 
             * @param {Float32Array|Float64Array} waveform The audio waveform to process.
             * @param {number[][]} mel_filters The mel filters to use.
             * @param {number} [max_length=null] The maximum number of frames to return.
             * @returns {{data: Float32Array, dims: number[]}} An object containing the log-Mel spectrogram data as a Float32Array and its dimensions as an array of numbers.
             */
            _extract_fbank_features(waveform, mel_filters, max_length = null) {
              return (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.spectrogram)(
                waveform,
                this.window,
                // window
                this.config.fft_window_size,
                // frame_length
                this.config.hop_length,
                // hop_length
                {
                  power: 2,
                  mel_filters,
                  log_mel: "dB",
                  // Custom
                  max_num_frames: max_length,
                  do_pad: false,
                  transpose: true
                }
              );
            }
            /**
             * Asynchronously extracts features from a given audio using the provided configuration.
             * @param {Float32Array|Float64Array} audio The audio data as a Float32Array/Float64Array.
             * @returns {Promise<{ input_features: Tensor }>} A Promise resolving to an object containing the extracted input features as a Tensor.
             */
            async _call(audio, {
              max_length = null
            } = {}) {
              validate_audio_inputs(audio, "ClapFeatureExtractor");
              const padded_inputs = this._get_input_mel(
                audio,
                max_length ?? this.config.nb_max_samples,
                this.config.truncation,
                this.config.padding
              );
              return {
                input_features: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(
                  "float32",
                  padded_inputs.data,
                  [1, ...padded_inputs.dims]
                )
              };
            }
          }
          class SpeechT5FeatureExtractor extends FeatureExtractor {
          }
          class Processor extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
            /**
             * Creates a new Processor with the given feature extractor.
             * @param {FeatureExtractor} feature_extractor The function used to extract features from the input.
             */
            constructor(feature_extractor) {
              super();
              this.feature_extractor = feature_extractor;
            }
            /**
             * Calls the feature_extractor function with the given input.
             * @param {any} input The input to extract features from.
             * @param {...any} args Additional arguments.
             * @returns {Promise<any>} A Promise that resolves with the extracted features.
             */
            async _call(input, ...args) {
              return await this.feature_extractor(input, ...args);
            }
          }
          class SamProcessor extends Processor {
            /**
             * @borrows SamImageProcessor#_call as _call
             */
            async _call(...args) {
              return await this.feature_extractor(...args);
            }
            /**
             * @borrows SamImageProcessor#post_process_masks as post_process_masks
             */
            post_process_masks(...args) {
              return this.feature_extractor.post_process_masks(...args);
            }
            /**
             * @borrows SamImageProcessor#reshape_input_points as reshape_input_points
             */
            reshape_input_points(...args) {
              return this.feature_extractor.reshape_input_points(...args);
            }
          }
          class WhisperProcessor extends Processor {
            /**
             * Calls the feature_extractor function with the given audio input.
             * @param {any} audio The audio input to extract features from.
             * @returns {Promise<any>} A Promise that resolves with the extracted features.
             */
            async _call(audio) {
              return await this.feature_extractor(audio);
            }
          }
          class Wav2Vec2ProcessorWithLM extends Processor {
            /**
             * Calls the feature_extractor function with the given audio input.
             * @param {any} audio The audio input to extract features from.
             * @returns {Promise<any>} A Promise that resolves with the extracted features.
             */
            async _call(audio) {
              return await this.feature_extractor(audio);
            }
          }
          class SpeechT5Processor extends Processor {
            /**
             * Calls the feature_extractor function with the given input.
             * @param {any} input The input to extract features from.
             * @returns {Promise<any>} A Promise that resolves with the extracted features.
             */
            async _call(input) {
              return await this.feature_extractor(input);
            }
          }
          class OwlViTProcessor extends Processor {
          }
          class AutoProcessor {
            /**
             * Instantiate one of the processor classes of the library from a pretrained model.
             * 
             * The processor class to instantiate is selected based on the `feature_extractor_type` property of the config object
             * (either passed as an argument or loaded from `pretrained_model_name_or_path` if possible)
             * 
             * @param {string} pretrained_model_name_or_path The name or path of the pretrained model. Can be either:
             * - A string, the *model id* of a pretrained processor hosted inside a model repo on huggingface.co.
             *   Valid model ids can be located at the root-level, like `bert-base-uncased`, or namespaced under a
             *   user or organization name, like `dbmdz/bert-base-german-cased`.
             * - A path to a *directory* containing processor files, e.g., `./my_model_directory/`.
             * @param {import('./utils/hub.js').PretrainedOptions} options Additional options for loading the processor.
             * 
             * @returns {Promise<Processor>} A new instance of the Processor class.
             */
            static async from_pretrained(pretrained_model_name_or_path, {
              progress_callback = null,
              config: config2 = null,
              cache_dir = null,
              local_files_only = false,
              revision = "main"
            } = {}) {
              let preprocessorConfig = config2 ?? await (0, _utils_hub_js__WEBPACK_IMPORTED_MODULE_1__.getModelJSON)(pretrained_model_name_or_path, "preprocessor_config.json", true, {
                progress_callback,
                config: config2,
                cache_dir,
                local_files_only,
                revision
              });
              let key = preprocessorConfig.feature_extractor_type ?? preprocessorConfig.image_processor_type;
              let feature_extractor_class = this.FEATURE_EXTRACTOR_CLASS_MAPPING[key];
              if (!feature_extractor_class) {
                if (preprocessorConfig.size !== void 0) {
                  console.warn(`Feature extractor type "${key}" not found, assuming ImageFeatureExtractor due to size parameter in config.`);
                  feature_extractor_class = ImageFeatureExtractor;
                } else {
                  throw new Error(`Unknown Feature Extractor type: ${key}`);
                }
              }
              let processor_class = this.PROCESSOR_CLASS_MAPPING[preprocessorConfig.processor_class] ?? Processor;
              let feature_extractor = new feature_extractor_class(preprocessorConfig);
              return new processor_class(feature_extractor);
            }
          }
          __publicField(AutoProcessor, "FEATURE_EXTRACTOR_CLASS_MAPPING", {
            ImageFeatureExtractor,
            WhisperFeatureExtractor,
            ViTFeatureExtractor,
            MobileViTFeatureExtractor,
            MobileViTImageProcessor,
            OwlViTFeatureExtractor,
            Owlv2ImageProcessor,
            CLIPFeatureExtractor,
            ChineseCLIPFeatureExtractor,
            SiglipImageProcessor,
            ConvNextFeatureExtractor,
            ConvNextImageProcessor,
            SegformerFeatureExtractor,
            BitImageProcessor,
            DPTImageProcessor,
            DPTFeatureExtractor,
            GLPNFeatureExtractor,
            BeitFeatureExtractor,
            DeiTFeatureExtractor,
            DetrFeatureExtractor,
            YolosFeatureExtractor,
            DonutFeatureExtractor,
            NougatImageProcessor,
            EfficientNetImageProcessor,
            ViTImageProcessor,
            VitMatteImageProcessor,
            SamImageProcessor,
            Swin2SRImageProcessor,
            Wav2Vec2FeatureExtractor,
            SeamlessM4TFeatureExtractor,
            SpeechT5FeatureExtractor,
            ASTFeatureExtractor,
            ClapFeatureExtractor
          });
          __publicField(AutoProcessor, "PROCESSOR_CLASS_MAPPING", {
            WhisperProcessor,
            Wav2Vec2ProcessorWithLM,
            SamProcessor,
            SpeechT5Processor,
            OwlViTProcessor
          });
        }
      ),
      /***/
      "./src/tokenizers.js": (
        /*!***************************!*\
          !*** ./src/tokenizers.js ***!
          \***************************/
        /***/
        (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "AlbertTokenizer": () => (
              /* binding */
              AlbertTokenizer
            ),
            /* harmony export */
            "AutoTokenizer": () => (
              /* binding */
              AutoTokenizer
            ),
            /* harmony export */
            "BartTokenizer": () => (
              /* binding */
              BartTokenizer
            ),
            /* harmony export */
            "BertTokenizer": () => (
              /* binding */
              BertTokenizer
            ),
            /* harmony export */
            "BlenderbotSmallTokenizer": () => (
              /* binding */
              BlenderbotSmallTokenizer
            ),
            /* harmony export */
            "BlenderbotTokenizer": () => (
              /* binding */
              BlenderbotTokenizer
            ),
            /* harmony export */
            "BloomTokenizer": () => (
              /* binding */
              BloomTokenizer
            ),
            /* harmony export */
            "CLIPTokenizer": () => (
              /* binding */
              CLIPTokenizer
            ),
            /* harmony export */
            "CamembertTokenizer": () => (
              /* binding */
              CamembertTokenizer
            ),
            /* harmony export */
            "CodeGenTokenizer": () => (
              /* binding */
              CodeGenTokenizer
            ),
            /* harmony export */
            "CodeLlamaTokenizer": () => (
              /* binding */
              CodeLlamaTokenizer
            ),
            /* harmony export */
            "CohereTokenizer": () => (
              /* binding */
              CohereTokenizer
            ),
            /* harmony export */
            "ConvBertTokenizer": () => (
              /* binding */
              ConvBertTokenizer
            ),
            /* harmony export */
            "DebertaTokenizer": () => (
              /* binding */
              DebertaTokenizer
            ),
            /* harmony export */
            "DebertaV2Tokenizer": () => (
              /* binding */
              DebertaV2Tokenizer
            ),
            /* harmony export */
            "DistilBertTokenizer": () => (
              /* binding */
              DistilBertTokenizer
            ),
            /* harmony export */
            "ElectraTokenizer": () => (
              /* binding */
              ElectraTokenizer
            ),
            /* harmony export */
            "EsmTokenizer": () => (
              /* binding */
              EsmTokenizer
            ),
            /* harmony export */
            "FalconTokenizer": () => (
              /* binding */
              FalconTokenizer
            ),
            /* harmony export */
            "GPT2Tokenizer": () => (
              /* binding */
              GPT2Tokenizer
            ),
            /* harmony export */
            "GPTNeoXTokenizer": () => (
              /* binding */
              GPTNeoXTokenizer
            ),
            /* harmony export */
            "GemmaTokenizer": () => (
              /* binding */
              GemmaTokenizer
            ),
            /* harmony export */
            "Grok1Tokenizer": () => (
              /* binding */
              Grok1Tokenizer
            ),
            /* harmony export */
            "HerbertTokenizer": () => (
              /* binding */
              HerbertTokenizer
            ),
            /* harmony export */
            "LlamaTokenizer": () => (
              /* binding */
              LlamaTokenizer
            ),
            /* harmony export */
            "M2M100Tokenizer": () => (
              /* binding */
              M2M100Tokenizer
            ),
            /* harmony export */
            "MBart50Tokenizer": () => (
              /* binding */
              MBart50Tokenizer
            ),
            /* harmony export */
            "MBartTokenizer": () => (
              /* binding */
              MBartTokenizer
            ),
            /* harmony export */
            "MPNetTokenizer": () => (
              /* binding */
              MPNetTokenizer
            ),
            /* harmony export */
            "MarianTokenizer": () => (
              /* binding */
              MarianTokenizer
            ),
            /* harmony export */
            "MobileBertTokenizer": () => (
              /* binding */
              MobileBertTokenizer
            ),
            /* harmony export */
            "NllbTokenizer": () => (
              /* binding */
              NllbTokenizer
            ),
            /* harmony export */
            "NougatTokenizer": () => (
              /* binding */
              NougatTokenizer
            ),
            /* harmony export */
            "PreTrainedTokenizer": () => (
              /* binding */
              PreTrainedTokenizer
            ),
            /* harmony export */
            "Qwen2Tokenizer": () => (
              /* binding */
              Qwen2Tokenizer
            ),
            /* harmony export */
            "RoFormerTokenizer": () => (
              /* binding */
              RoFormerTokenizer
            ),
            /* harmony export */
            "RobertaTokenizer": () => (
              /* binding */
              RobertaTokenizer
            ),
            /* harmony export */
            "SiglipTokenizer": () => (
              /* binding */
              SiglipTokenizer
            ),
            /* harmony export */
            "SpeechT5Tokenizer": () => (
              /* binding */
              SpeechT5Tokenizer
            ),
            /* harmony export */
            "SqueezeBertTokenizer": () => (
              /* binding */
              SqueezeBertTokenizer
            ),
            /* harmony export */
            "T5Tokenizer": () => (
              /* binding */
              T5Tokenizer
            ),
            /* harmony export */
            "TokenizerModel": () => (
              /* binding */
              TokenizerModel
            ),
            /* harmony export */
            "VitsTokenizer": () => (
              /* binding */
              VitsTokenizer
            ),
            /* harmony export */
            "Wav2Vec2CTCTokenizer": () => (
              /* binding */
              Wav2Vec2CTCTokenizer
            ),
            /* harmony export */
            "WhisperTokenizer": () => (
              /* binding */
              WhisperTokenizer
            ),
            /* harmony export */
            "XLMRobertaTokenizer": () => (
              /* binding */
              XLMRobertaTokenizer
            ),
            /* harmony export */
            "XLMTokenizer": () => (
              /* binding */
              XLMTokenizer
            )
            /* harmony export */
          });
          var _utils_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__3(
            /*! ./utils/core.js */
            "./src/utils/core.js"
          );
          var _utils_hub_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__3(
            /*! ./utils/hub.js */
            "./src/utils/hub.js"
          );
          var _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__3(
            /*! ./utils/maths.js */
            "./src/utils/maths.js"
          );
          var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__3(
            /*! ./utils/tensor.js */
            "./src/utils/tensor.js"
          );
          var _utils_data_structures_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__3(
            /*! ./utils/data-structures.js */
            "./src/utils/data-structures.js"
          );
          var _huggingface_jinja__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__3(
            /*! @huggingface/jinja */
            "./node_modules/@huggingface/jinja/dist/index.js"
          );
          async function loadTokenizer(pretrained_model_name_or_path, options) {
            const info = await Promise.all([
              (0, _utils_hub_js__WEBPACK_IMPORTED_MODULE_1__.getModelJSON)(pretrained_model_name_or_path, "tokenizer.json", true, options),
              (0, _utils_hub_js__WEBPACK_IMPORTED_MODULE_1__.getModelJSON)(pretrained_model_name_or_path, "tokenizer_config.json", true, options)
            ]);
            if (options.legacy !== null) {
              info[1].legacy = options.legacy;
            }
            return info;
          }
          function regexSplit(text2, regex) {
            const result = [];
            let prev = 0;
            for (const match2 of text2.matchAll(regex)) {
              const fullMatch = match2[0];
              if (prev < match2.index) {
                result.push(text2.slice(prev, match2.index));
              }
              if (fullMatch.length > 0) {
                result.push(fullMatch);
              }
              prev = match2.index + fullMatch.length;
            }
            if (prev < text2.length) {
              result.push(text2.slice(prev));
            }
            return result;
          }
          function createPattern(pattern, invert = true) {
            if (pattern.Regex !== void 0) {
              let regex = pattern.Regex.replace(/\\([#&~])/g, "$1");
              for (const [key, value] of PROBLEMATIC_REGEX_MAP) {
                regex = regex.replaceAll(key, value);
              }
              return new RegExp(regex, "gu");
            } else if (pattern.String !== void 0) {
              const escaped = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.escapeRegExp)(pattern.String);
              return new RegExp(invert ? escaped : `(${escaped})`, "gu");
            } else {
              console.warn("Unknown pattern type:", pattern);
              return null;
            }
          }
          function objectToMap(obj) {
            return new Map(Object.entries(obj));
          }
          function prepareTensorForDecode(tensor) {
            const dims = tensor.dims;
            switch (dims.length) {
              case 1:
                return tensor.tolist();
              case 2:
                if (dims[0] !== 1) {
                  throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");
                }
                return tensor.tolist()[0];
              default:
                throw new Error(`Expected tensor to have 1-2 dimensions, got ${dims.length}.`);
            }
          }
          function clean_up_tokenization(text2) {
            return text2.replace(/ \./g, ".").replace(/ \?/g, "?").replace(/ \!/g, "!").replace(/ ,/g, ",").replace(/ \' /g, "'").replace(/ n\'t/g, "n't").replace(/ \'m/g, "'m").replace(/ \'s/g, "'s").replace(/ \'ve/g, "'ve").replace(/ \'re/g, "'re");
          }
          function remove_accents(text2) {
            return text2.replace(/[\u0300-\u036f]/g, "");
          }
          function lowercase_and_remove_accent(text2) {
            return remove_accents(text2.toLowerCase());
          }
          function fuse(arr, value, mapping) {
            const fused = [];
            let i = 0;
            while (i < arr.length) {
              fused.push(arr[i]);
              if ((mapping.get(arr[i]) ?? value) !== value) {
                ++i;
                continue;
              }
              while (i < arr.length && (mapping.get(arr[i]) ?? value) === value) {
                ++i;
              }
            }
            return fused;
          }
          function whitespace_split(text2) {
            return text2.match(/\S+/g) || [];
          }
          const PUNCTUATION_REGEX = "\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E";
          const PROBLEMATIC_REGEX_MAP = /* @__PURE__ */ new Map([
            // This uses the case insensitive group modifier, which is not supported in JavaScript.
            // When parsing the regex, an "Invalid group" error is thrown.
            ["(?i:'s|'t|'re|'ve|'m|'ll|'d)", "(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"]
          ]);
          class AddedToken {
            /**
             * Creates a new instance of AddedToken.
             * @param {Object} config Added token configuration object.
             * @param {string} config.content The content of the added token.
             * @param {number} config.id The id of the added token.
             * @param {boolean} [config.single_word=false] Whether this token must be a single word or can break words.
             * @param {boolean} [config.lstrip=false] Whether this token should strip whitespaces on its left.
             * @param {boolean} [config.rstrip=false] Whether this token should strip whitespaces on its right.
             * @param {boolean} [config.normalized=false] Whether this token should be normalized.
             * @param {boolean} [config.special=false] Whether this token is special.
             */
            constructor(config2) {
              this.content = config2.content;
              this.id = config2.id;
              this.single_word = config2.single_word ?? false;
              this.lstrip = config2.lstrip ?? false;
              this.rstrip = config2.rstrip ?? false;
              this.special = config2.special ?? false;
              this.normalized = config2.normalized ?? null;
            }
          }
          class TokenizerModel extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
            /**
             * Creates a new instance of TokenizerModel.
             * @param {Object} config The configuration object for the TokenizerModel.
             */
            constructor(config2) {
              super();
              this.config = config2;
              this.vocab = [];
              this.tokens_to_ids = /* @__PURE__ */ new Map();
              this.unk_token_id = void 0;
              this.unk_token = void 0;
              this.end_of_word_suffix = void 0;
              this.fuse_unk = this.config.fuse_unk ?? false;
            }
            /**
             * Instantiates a new TokenizerModel instance based on the configuration object provided.
             * @param {Object} config The configuration object for the TokenizerModel.
             * @param {...*} args Optional arguments to pass to the specific TokenizerModel constructor.
             * @returns {TokenizerModel} A new instance of a TokenizerModel.
             * @throws Will throw an error if the TokenizerModel type in the config is not recognized.
             */
            static fromConfig(config2, ...args) {
              switch (config2.type) {
                case "WordPiece":
                  return new WordPieceTokenizer(config2);
                case "Unigram":
                  return new Unigram(config2, ...args);
                case "BPE":
                  return new BPE(config2);
                default:
                  if (config2.vocab) {
                    return new LegacyTokenizerModel(config2, ...args);
                  }
                  throw new Error(`Unknown TokenizerModel type: ${config2.type}`);
              }
            }
            /**
             * Internal function to call the TokenizerModel instance.
             * @param {string[]} tokens The tokens to encode.
             * @returns {string[]} The encoded token IDs.
             */
            _call(tokens) {
              let ids = this.encode(tokens);
              if (this.fuse_unk) {
                ids = fuse(ids, this.unk_token_id, this.tokens_to_ids);
              }
              return ids;
            }
            /**
             * Encodes a list of tokens into a list of token IDs.
             * @param {string[]} tokens The tokens to encode.
             * @returns {string[]} The encoded tokens.
             * @throws Will throw an error if not implemented in a subclass.
             */
            encode(tokens) {
              throw Error("encode should be implemented in subclass.");
            }
            /**
             * Converts a list of tokens into a list of token IDs.
             * @param {string[]} tokens The tokens to convert.
             * @returns {number[]} The converted token IDs.
             */
            convert_tokens_to_ids(tokens) {
              return tokens.map((t) => this.tokens_to_ids.get(t) ?? this.unk_token_id);
            }
            /**
             * Converts a list of token IDs into a list of tokens.
             * @param {number[]} ids The token IDs to convert.
             * @returns {string[]} The converted tokens.
             */
            convert_ids_to_tokens(ids) {
              return ids.map((i) => this.vocab[i] ?? this.unk_token);
            }
          }
          class WordPieceTokenizer extends TokenizerModel {
            /**
             * @param {Object} config The configuration object.
             * @param {Object} config.vocab A mapping of tokens to ids.
             * @param {string} config.unk_token The unknown token string.
             * @param {string} config.continuing_subword_prefix The prefix to use for continuing subwords.
             * @param {number} [config.max_input_chars_per_word=100] The maximum number of characters per word.
             */
            constructor(config2) {
              super(config2);
              this.tokens_to_ids = objectToMap(config2.vocab);
              this.unk_token_id = this.tokens_to_ids.get(config2.unk_token);
              this.unk_token = config2.unk_token;
              this.max_input_chars_per_word = config2.max_input_chars_per_word ?? 100;
              this.vocab = new Array(this.tokens_to_ids.size);
              for (const [key, value] of this.tokens_to_ids) {
                this.vocab[value] = key;
              }
            }
            /**
             * Encodes an array of tokens using WordPiece encoding.
             * @param {string[]} tokens The tokens to encode.
             * @returns {string[]} An array of encoded tokens.
             */
            encode(tokens) {
              const outputTokens = [];
              for (const token of tokens) {
                const chars = [...token];
                if (chars.length > this.max_input_chars_per_word) {
                  outputTokens.push(this.unk_token);
                  continue;
                }
                let isUnknown = false;
                let start = 0;
                const subTokens = [];
                while (start < chars.length) {
                  let end = chars.length;
                  let currentSubstring = null;
                  while (start < end) {
                    let substr = chars.slice(start, end).join("");
                    if (start > 0) {
                      substr = this.config.continuing_subword_prefix + substr;
                    }
                    if (this.tokens_to_ids.has(substr)) {
                      currentSubstring = substr;
                      break;
                    }
                    --end;
                  }
                  if (currentSubstring === null) {
                    isUnknown = true;
                    break;
                  }
                  subTokens.push(currentSubstring);
                  start = end;
                }
                if (isUnknown) {
                  outputTokens.push(this.unk_token);
                } else {
                  outputTokens.push(...subTokens);
                }
              }
              return outputTokens;
            }
          }
          class Unigram extends TokenizerModel {
            /**
             * Create a new Unigram tokenizer model.
             * @param {Object} config The configuration object for the Unigram model.
             * @param {number} config.unk_id The ID of the unknown token
             * @param {any[][]} config.vocab A 2D array representing a mapping of tokens to scores.
             * @param {Object} moreConfig Additional configuration object for the Unigram model.
             */
            constructor(config2, moreConfig) {
              super(config2);
              const vocabSize = config2.vocab.length;
              this.vocab = new Array(vocabSize);
              this.scores = new Array(vocabSize);
              for (let i = 0; i < vocabSize; ++i) {
                const piece = config2.vocab[i];
                this.vocab[i] = piece[0];
                this.scores[i] = piece[1];
              }
              this.unk_token_id = config2.unk_id;
              this.unk_token = this.vocab[config2.unk_id];
              this.tokens_to_ids = new Map(this.vocab.map((x, i) => [x, i]));
              this.bosToken = " ";
              this.bosTokenId = this.tokens_to_ids.get(this.bosToken);
              this.eosToken = moreConfig.eos_token;
              this.eosTokenId = this.tokens_to_ids.get(this.eosToken);
              this.unkToken = this.vocab[this.unk_token_id];
              this.minScore = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.min)(this.scores)[0];
              this.unkScore = this.minScore - 10;
              this.scores[this.unk_token_id] = this.unkScore;
              this.trie = new _utils_data_structures_js__WEBPACK_IMPORTED_MODULE_4__.CharTrie();
              this.trie.extend(this.vocab);
              this.fuse_unk = true;
            }
            /**
             * Populates lattice nodes.
             * @param {TokenLattice} lattice The token lattice to populate with nodes.
             */
            populateNodes(lattice) {
              const sentence = lattice.sentence;
              const len = sentence.length;
              let beginPos = 0;
              while (beginPos < len) {
                const mblen = 1;
                let hasSingleNode = false;
                const tokens = [];
                for (let token of this.trie.commonPrefixSearch(sentence.slice(beginPos))) {
                  tokens.push(token);
                  const tokenId = this.tokens_to_ids.get(token);
                  const tokenScore = this.scores[tokenId];
                  const n = token.length;
                  lattice.insert(beginPos, n, tokenScore, tokenId);
                  if (!hasSingleNode && n === mblen) {
                    hasSingleNode = true;
                  }
                }
                if (!hasSingleNode) {
                  lattice.insert(beginPos, mblen, this.unkScore, this.unk_token_id);
                }
                beginPos += mblen;
              }
            }
            /**
             * Encodes an array of tokens into an array of subtokens using the unigram model.
             *
             * @param {string} normalized The normalized string.
             * @returns {string[]} An array of subtokens obtained by encoding the input tokens using the unigram model.
             */
            tokenize(normalized) {
              const lattice = new _utils_data_structures_js__WEBPACK_IMPORTED_MODULE_4__.TokenLattice(normalized, this.bosTokenId, this.eosTokenId);
              this.populateNodes(lattice);
              return lattice.tokens();
            }
            /**
             * Encodes an array of tokens using Unigram encoding.
             * @param {string[]} tokens The tokens to encode.
             * @returns {string[]} An array of encoded tokens.
             */
            encode(tokens) {
              const toReturn = [];
              for (const token of tokens) {
                const tokenized = this.tokenize(token);
                toReturn.push(...tokenized);
              }
              return toReturn;
            }
          }
          const BYTES_TO_UNICODE = (() => {
            const bs = [
              ...Array.from({ length: "~".charCodeAt(0) - "!".charCodeAt(0) + 1 }, (_, i) => i + "!".charCodeAt(0)),
              ...Array.from({ length: "\xAC".charCodeAt(0) - "\xA1".charCodeAt(0) + 1 }, (_, i) => i + "\xA1".charCodeAt(0)),
              ...Array.from({ length: "\xFF".charCodeAt(0) - "\xAE".charCodeAt(0) + 1 }, (_, i) => i + "\xAE".charCodeAt(0))
            ];
            const cs = bs.slice();
            let n = 0;
            for (let b = 0; b < 256; ++b) {
              if (!bs.includes(b)) {
                bs.push(b);
                cs.push(256 + n);
                n += 1;
              }
            }
            const ccs = cs.map((n2) => String.fromCharCode(n2));
            return Object.fromEntries(bs.map((b, i) => [b, ccs[i]]));
          })();
          const UNICODE_TO_BYTES = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.reverseDictionary)(BYTES_TO_UNICODE);
          class BPE extends TokenizerModel {
            /**
             * Create a BPE instance.
             * @param {Object} config The configuration object for BPE.
             * @param {Object} config.vocab A mapping of tokens to ids.
             * @param {string[]} config.merges An array of BPE merges as strings.
             * @param {string} config.unk_token The unknown token used for out of vocabulary words.
             * @param {string} config.end_of_word_suffix The suffix to place at the end of each word.
             * @param {string} [config.continuing_subword_suffix] The suffix to insert between words.
             * @param {boolean} [config.byte_fallback=false] Whether to use spm byte-fallback trick (defaults to False)
             * @param {boolean} [config.ignore_merges=false] Whether or not to match tokens with the vocab before using merges.
             */
            constructor(config2) {
              super(config2);
              this.BPE_SPLIT_TOKEN = " ";
              this.tokens_to_ids = objectToMap(config2.vocab);
              this.unk_token_id = this.tokens_to_ids.get(config2.unk_token);
              this.unk_token = config2.unk_token;
              this.vocab = new Array(this.tokens_to_ids.size);
              for (const [key, value] of this.tokens_to_ids) {
                this.vocab[value] = key;
              }
              this.bpe_ranks = new Map(config2.merges.map((x, i) => [x, i]));
              this.merges = config2.merges.map((x) => x.split(this.BPE_SPLIT_TOKEN));
              this.end_of_word_suffix = config2.end_of_word_suffix;
              this.continuing_subword_suffix = config2.continuing_subword_suffix ?? null;
              this.byte_fallback = this.config.byte_fallback ?? false;
              if (this.byte_fallback) {
                this.text_encoder = new TextEncoder();
              }
              this.ignore_merges = this.config.ignore_merges ?? false;
              this.cache = /* @__PURE__ */ new Map();
            }
            /**
             * Apply Byte-Pair-Encoding (BPE) to a given token. Efficient heap-based priority
             * queue implementation adapted from https://github.com/belladoreai/llama-tokenizer-js.
             * @param {string} token The token to encode.
             * @returns {string[]} The BPE encoded tokens.
             */
            bpe(token) {
              if (token.length === 0) {
                return [];
              }
              const cached = this.cache.get(token);
              if (cached !== void 0) {
                return cached;
              }
              const word = Array.from(token);
              if (this.end_of_word_suffix) {
                word[word.length - 1] += this.end_of_word_suffix;
              }
              let result = [];
              if (word.length > 1) {
                const queue = new _utils_data_structures_js__WEBPACK_IMPORTED_MODULE_4__.PriorityQueue((a, b) => a.score < b.score);
                let startingNode = {
                  token: word[0],
                  bias: 0,
                  prev: null,
                  next: null
                };
                let previousNode = startingNode;
                for (let i = 1; i < word.length; ++i) {
                  const currentNode = {
                    bias: i / word.length,
                    // Add fractional component to break ties
                    token: word[i],
                    prev: previousNode,
                    next: null
                  };
                  previousNode.next = currentNode;
                  this._add_node(queue, previousNode);
                  previousNode = currentNode;
                }
                while (!queue.isEmpty()) {
                  const node = queue.pop();
                  if (node.deleted || !node.next || node.next.deleted)
                    continue;
                  node.deleted = true;
                  node.next.deleted = true;
                  if (node.prev) {
                    const newPreviousNode = { ...node.prev };
                    node.prev.deleted = true;
                    node.prev = newPreviousNode;
                    if (newPreviousNode.prev) {
                      newPreviousNode.prev.next = newPreviousNode;
                    } else {
                      startingNode = newPreviousNode;
                    }
                  }
                  const merged = {
                    token: node.token + node.next.token,
                    bias: node.bias,
                    prev: node.prev,
                    next: node.next.next
                  };
                  if (merged.prev) {
                    merged.prev.next = merged;
                    this._add_node(queue, merged.prev);
                  } else {
                    startingNode = merged;
                  }
                  if (merged.next) {
                    merged.next.prev = merged;
                    this._add_node(queue, merged);
                  }
                }
                for (let currentNode = startingNode; currentNode !== null; currentNode = currentNode.next) {
                  result.push(currentNode.token);
                }
              } else {
                result = word;
              }
              if (this.continuing_subword_suffix) {
                for (let i = 0; i < result.length - 1; ++i) {
                  result[i] += this.continuing_subword_suffix;
                }
              }
              this.cache.set(token, result);
              return result;
            }
            /**
             * Helper function to add a node to the priority queue.
             * @param {PriorityQueue} queue 
             * @param {BPENode} node
             * @private
             */
            _add_node(queue, node) {
              const rank = this.bpe_ranks.get(node.token + this.BPE_SPLIT_TOKEN + node.next.token);
              if (rank !== void 0) {
                node.score = rank + node.bias;
                queue.push(node);
              }
            }
            /**
             * Encodes the input sequence of tokens using the BPE algorithm and returns the resulting subword tokens.
             * @param {string[]} tokens The input sequence of tokens to encode.
             * @returns {string[]} The resulting subword tokens after applying the BPE algorithm to the input sequence of tokens.
             */
            encode(tokens) {
              const outputTokens = [];
              for (const token of tokens) {
                if (this.ignore_merges && this.tokens_to_ids.has(token)) {
                  outputTokens.push(token);
                  continue;
                }
                const bpe_token_list = this.bpe(token);
                for (const t of bpe_token_list) {
                  if (this.tokens_to_ids.has(t)) {
                    outputTokens.push(t);
                  } else {
                    if (this.byte_fallback) {
                      outputTokens.push(
                        ...Array.from(this.text_encoder.encode(t)).map((x) => `<0x${x.toString(16).toUpperCase().padStart(2, "0")}>`)
                      );
                    } else {
                      outputTokens.push(this.unk_token);
                    }
                  }
                }
              }
              return outputTokens;
            }
          }
          class LegacyTokenizerModel extends TokenizerModel {
            /**
             * Create a LegacyTokenizerModel instance.
             * @param {Object} config The configuration object for LegacyTokenizerModel.
             * @param {Object} config.vocab A (possibly nested) mapping of tokens to ids.
             * @param {Object} moreConfig Additional configuration object for the LegacyTokenizerModel model.
             */
            constructor(config2, moreConfig) {
              super(config2);
              this.tokens_to_ids = objectToMap(
                moreConfig.target_lang ? config2.vocab[moreConfig.target_lang] : config2.vocab
              );
              this.bos_token = moreConfig.bos_token;
              this.bos_token_id = this.tokens_to_ids.get(this.bos_token);
              this.eos_token = moreConfig.eos_token;
              this.eos_token_id = this.tokens_to_ids.get(this.eos_token);
              this.pad_token = moreConfig.pad_token;
              this.pad_token_id = this.tokens_to_ids.get(this.pad_token);
              this.unk_token = moreConfig.unk_token;
              this.unk_token_id = this.tokens_to_ids.get(this.unk_token);
              this.vocab = new Array(this.tokens_to_ids.size);
              for (const [key, value] of this.tokens_to_ids) {
                this.vocab[value] = key;
              }
            }
            encode(tokens) {
              return tokens;
            }
          }
          class Normalizer extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
            /**
             * @param {Object} config The configuration object for the normalizer.
             */
            constructor(config2) {
              super();
              this.config = config2;
            }
            /**
             * Factory method for creating normalizers from config objects.
             * @static
             * @param {Object} config The configuration object for the normalizer.
             * @returns {Normalizer} A Normalizer object.
             * @throws {Error} If an unknown Normalizer type is specified in the config.
             */
            static fromConfig(config2) {
              if (config2 === null)
                return null;
              switch (config2.type) {
                case "BertNormalizer":
                  return new BertNormalizer(config2);
                case "Precompiled":
                  return new Precompiled(config2);
                case "Sequence":
                  return new NormalizerSequence(config2);
                case "Replace":
                  return new Replace(config2);
                case "NFC":
                  return new NFC(config2);
                case "NFKC":
                  return new NFKC(config2);
                case "NFKD":
                  return new NFKD(config2);
                case "Strip":
                  return new StripNormalizer(config2);
                case "StripAccents":
                  return new StripAccents(config2);
                case "Lowercase":
                  return new Lowercase(config2);
                case "Prepend":
                  return new Prepend(config2);
                default:
                  throw new Error(`Unknown Normalizer type: ${config2.type}`);
              }
            }
            /**
             * Normalize the input text.
             * @abstract
             * @param {string} text The text to normalize.
             * @returns {string} The normalized text.
             * @throws {Error} If this method is not implemented in a subclass.
             */
            normalize(text2) {
              throw Error("normalize should be implemented in subclass.");
            }
            /**
             * Alias for {@link Normalizer#normalize}.
             * @param {string} text The text to normalize.
             * @returns {string} The normalized text.
             */
            _call(text2) {
              return this.normalize(text2);
            }
          }
          class Replace extends Normalizer {
            /**
             * Normalize the input text by replacing the pattern with the content.
             * @param {string} text The input text to be normalized.
             * @returns {string} The normalized text after replacing the pattern with the content.
             */
            normalize(text2) {
              const pattern = createPattern(this.config.pattern);
              return pattern === null ? text2 : text2.replaceAll(pattern, this.config.content);
            }
          }
          class NFC extends Normalizer {
            /**
             * Normalize the input text by applying Unicode normalization form C (NFC).
             * @param {string} text The input text to be normalized.
             * @returns {string} The normalized text.
             */
            normalize(text2) {
              text2 = text2.normalize("NFC");
              return text2;
            }
          }
          class NFKC extends Normalizer {
            /**
             * Normalize text using NFKC normalization.
             * @param {string} text The text to be normalized.
             * @returns {string} The normalized text.
             */
            normalize(text2) {
              text2 = text2.normalize("NFKC");
              return text2;
            }
          }
          class NFKD extends Normalizer {
            /**
             * Normalize text using NFKD normalization.
             * @param {string} text The text to be normalized.
             * @returns {string} The normalized text.
             */
            normalize(text2) {
              text2 = text2.normalize("NFKD");
              return text2;
            }
          }
          class StripNormalizer extends Normalizer {
            /**
             * Strip leading and/or trailing whitespace from the input text.
             * @param {string} text The input text.
             * @returns {string} The normalized text.
             */
            normalize(text2) {
              if (this.config.strip_left && this.config.strip_right) {
                text2 = text2.trim();
              } else {
                if (this.config.strip_left) {
                  text2 = text2.trimStart();
                }
                if (this.config.strip_right) {
                  text2 = text2.trimEnd();
                }
              }
              return text2;
            }
          }
          class StripAccents extends Normalizer {
            /**
             * Remove all accents from the text.
             * @param {string} text The input text.
             * @returns {string} The normalized text without accents.
             */
            normalize(text2) {
              text2 = remove_accents(text2);
              return text2;
            }
          }
          class Lowercase extends Normalizer {
            /**
             * Lowercases the input string.
             * @param {string} text The text to normalize.
             * @returns {string} The normalized text.
             */
            normalize(text2) {
              text2 = text2.toLowerCase();
              return text2;
            }
          }
          class Prepend extends Normalizer {
            /**
             * Prepends the input string.
             * @param {string} text The text to normalize.
             * @returns {string} The normalized text.
             */
            normalize(text2) {
              text2 = this.config.prepend + text2;
              return text2;
            }
          }
          class NormalizerSequence extends Normalizer {
            /**
            * Create a new instance of NormalizerSequence.
            * @param {Object} config The configuration object.
            * @param {Object[]} config.normalizers An array of Normalizer configuration objects.
            */
            constructor(config2) {
              super(config2);
              this.normalizers = config2.normalizers.map((x) => Normalizer.fromConfig(x));
            }
            /**
            * Apply a sequence of Normalizers to the input text.
            * @param {string} text The text to normalize.
            * @returns {string} The normalized text.
            */
            normalize(text2) {
              return this.normalizers.reduce((t, normalizer) => {
                return normalizer.normalize(t);
              }, text2);
            }
          }
          class BertNormalizer extends Normalizer {
            /**
             * Adds whitespace around any CJK (Chinese, Japanese, or Korean) character in the input text.
             *
             * @param {string} text The input text to tokenize.
             * @returns {string} The tokenized text with whitespace added around CJK characters.
             */
            _tokenize_chinese_chars(text2) {
              const output = [];
              for (let i = 0; i < text2.length; ++i) {
                const char = text2[i];
                const cp = char.charCodeAt(0);
                if (this._is_chinese_char(cp)) {
                  output.push(" ");
                  output.push(char);
                  output.push(" ");
                } else {
                  output.push(char);
                }
              }
              return output.join("");
            }
            /**
             * Checks whether the given Unicode codepoint represents a CJK (Chinese, Japanese, or Korean) character.
             *
             * A "chinese character" is defined as anything in the CJK Unicode block:
             * https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)
             *
             * Note that the CJK Unicode block is NOT all Japanese and Korean characters, despite its name.
             * The modern Korean Hangul alphabet is a different block, as is Japanese Hiragana and Katakana.
             * Those alphabets are used to write space-separated words, so they are not treated specially
             * and are handled like all other languages.
             *
             * @param {number} cp The Unicode codepoint to check.
             * @returns {boolean} True if the codepoint represents a CJK character, false otherwise.
             */
            _is_chinese_char(cp) {
              return cp >= 19968 && cp <= 40959 || cp >= 13312 && cp <= 19903 || cp >= 131072 && cp <= 173791 || cp >= 173824 && cp <= 177983 || cp >= 177984 && cp <= 178207 || cp >= 178208 && cp <= 183983 || cp >= 63744 && cp <= 64255 || cp >= 194560 && cp <= 195103;
            }
            /**
             * Strips accents from the given text.
             * @param {string} text The text to strip accents from.
             * @returns {string} The text with accents removed.
             */
            stripAccents(text2) {
              return text2.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
            }
            /**
             * Checks whether `char` is a control character.
             * @param {string} char The character to check.
             * @returns {boolean} Whether `char` is a control character.
             * @private
             */
            _is_control(char) {
              switch (char) {
                case "	":
                case "\n":
                case "\r":
                  return false;
                default:
                  return /^\p{Cc}|\p{Cf}|\p{Co}|\p{Cs}$/u.test(char);
              }
            }
            /**
             * Performs invalid character removal and whitespace cleanup on text.
             * @param {string} text The text to clean.
             * @returns {string} The cleaned text.
             * @private
             */
            _clean_text(text2) {
              const output = [];
              for (const char of text2) {
                const cp = char.charCodeAt(0);
                if (cp === 0 || cp === 65533 || this._is_control(char)) {
                  continue;
                }
                if (/^\s$/.test(char)) {
                  output.push(" ");
                } else {
                  output.push(char);
                }
              }
              return output.join("");
            }
            /**
             * Normalizes the given text based on the configuration.
             * @param {string} text The text to normalize.
             * @returns {string} The normalized text.
             */
            normalize(text2) {
              if (this.config.clean_text) {
                text2 = this._clean_text(text2);
              }
              if (this.config.handle_chinese_chars) {
                text2 = this._tokenize_chinese_chars(text2);
              }
              if (this.config.lowercase) {
                text2 = text2.toLowerCase();
                if (this.config.strip_accents !== false) {
                  text2 = this.stripAccents(text2);
                }
              } else if (this.config.strip_accents) {
                text2 = this.stripAccents(text2);
              }
              return text2;
            }
          }
          class PreTokenizer extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
            /**
            * Factory method that returns an instance of a subclass of `PreTokenizer` based on the provided configuration.
            *
            * @static
            * @param {Object} config A configuration object for the pre-tokenizer.
            * @returns {PreTokenizer} An instance of a subclass of `PreTokenizer`.
            * @throws {Error} If the provided configuration object does not correspond to any known pre-tokenizer.
            */
            static fromConfig(config2) {
              if (config2 === null)
                return null;
              switch (config2.type) {
                case "BertPreTokenizer":
                  return new BertPreTokenizer(config2);
                case "Sequence":
                  return new PreTokenizerSequence(config2);
                case "Whitespace":
                  return new WhitespacePreTokenizer(config2);
                case "WhitespaceSplit":
                  return new WhitespaceSplit(config2);
                case "Metaspace":
                  return new MetaspacePreTokenizer(config2);
                case "ByteLevel":
                  return new ByteLevelPreTokenizer(config2);
                case "Split":
                  return new SplitPreTokenizer(config2);
                case "Punctuation":
                  return new PunctuationPreTokenizer(config2);
                case "Digits":
                  return new DigitsPreTokenizer(config2);
                case "Replace":
                  return new ReplacePreTokenizer(config2);
                default:
                  throw new Error(`Unknown PreTokenizer type: ${config2.type}`);
              }
            }
            /**
             * Method that should be implemented by subclasses to define the specific pre-tokenization logic.
             *
             * @abstract
             * @param {string} text The text to pre-tokenize.
             * @param {Object} [options] Additional options for the pre-tokenization logic.
             * @returns {string[]} The pre-tokenized text.
             * @throws {Error} If the method is not implemented in the subclass.
             */
            pre_tokenize_text(text2, options) {
              throw Error("pre_tokenize_text should be implemented in subclass.");
            }
            /**
             * Tokenizes the given text into pre-tokens.
             * @param {string|string[]} text The text or array of texts to pre-tokenize.
             * @param {Object} [options] Additional options for the pre-tokenization logic.
             * @returns {string[]} An array of pre-tokens.
             */
            pre_tokenize(text2, options) {
              return (Array.isArray(text2) ? text2.map((x) => this.pre_tokenize_text(x, options)) : this.pre_tokenize_text(text2, options)).flat();
            }
            /**
             * Alias for {@link PreTokenizer#pre_tokenize}.
             * @param {string|string[]} text The text or array of texts to pre-tokenize.
             * @param {Object} [options] Additional options for the pre-tokenization logic.
             * @returns {string[]} An array of pre-tokens.
             */
            _call(text2, options) {
              return this.pre_tokenize(text2, options);
            }
          }
          class BertPreTokenizer extends PreTokenizer {
            /**
             * A PreTokenizer that splits text into wordpieces using a basic tokenization scheme
             * similar to that used in the original implementation of BERT.
             * 
             * @param {Object} config The configuration object.
             */
            constructor(config2) {
              super();
              this.pattern = new RegExp(`[^\\s${PUNCTUATION_REGEX}]+|[${PUNCTUATION_REGEX}]`, "gu");
            }
            /**
             * Tokenizes a single text using the BERT pre-tokenization scheme.
             * 
             * @param {string} text The text to tokenize.
             * @param {Object} [options] Additional options for the pre-tokenization logic.
             * @returns {string[]} An array of tokens.
             */
            pre_tokenize_text(text2, options) {
              return text2.trim().match(this.pattern) || [];
            }
          }
          class ByteLevelPreTokenizer extends PreTokenizer {
            /**
             * Creates a new instance of the `ByteLevelPreTokenizer` class.
             * @param {Object} config The configuration object.
             */
            constructor(config2) {
              super();
              this.config = config2;
              this.add_prefix_space = this.config.add_prefix_space;
              this.trim_offsets = this.config.trim_offsets;
              this.use_regex = this.config.use_regex ?? true;
              this.pattern = /'s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+/gu;
              this.byte_encoder = BYTES_TO_UNICODE;
              this.text_encoder = new TextEncoder();
            }
            /**
             * Tokenizes a single piece of text using byte-level tokenization.
             * @param {string} text The text to tokenize.
             * @param {Object} [options] Additional options for the pre-tokenization logic.
             * @returns {string[]} An array of tokens.
             */
            pre_tokenize_text(text2, options) {
              if (this.add_prefix_space && !text2.startsWith(" ")) {
                text2 = " " + text2;
              }
              const tokens = this.use_regex ? text2.match(this.pattern) || [] : [text2];
              return tokens.map(
                (token) => Array.from(this.text_encoder.encode(token), (byte) => this.byte_encoder[byte]).join("")
              );
            }
          }
          class SplitPreTokenizer extends PreTokenizer {
            /**
             * @param {Object} config The configuration options for the pre-tokenizer.
             * @param {Object} config.pattern The pattern used to split the text. Can be a string or a regex object.
             * @param {string|undefined} config.pattern.String The string to use for splitting. Only defined if the pattern is a string.
             * @param {string|undefined} config.pattern.Regex The regex to use for splitting. Only defined if the pattern is a regex.
             * @param {SplitDelimiterBehavior} config.behavior The behavior to use when splitting.
             * @param {boolean} config.invert Whether to split (invert=false) or match (invert=true) the pattern.
             */
            constructor(config2) {
              super();
              this.config = config2;
              this.pattern = createPattern(this.config.pattern, this.config.invert);
            }
            /**
             * Tokenizes text by splitting it using the given pattern.
             * @param {string} text The text to tokenize.
             * @param {Object} [options] Additional options for the pre-tokenization logic.
             * @returns {string[]} An array of tokens.
             */
            pre_tokenize_text(text2, options) {
              if (this.pattern === null) {
                return [];
              }
              if (this.config.invert) {
                return text2.match(this.pattern) || [];
              } else {
                return regexSplit(text2, this.pattern);
              }
            }
          }
          class PunctuationPreTokenizer extends PreTokenizer {
            /**
             * @param {Object} config The configuration options for the pre-tokenizer.
             * @param {SplitDelimiterBehavior} config.behavior The behavior to use when splitting.
             */
            constructor(config2) {
              super();
              this.config = config2;
              this.pattern = new RegExp(`[^${PUNCTUATION_REGEX}]+|[${PUNCTUATION_REGEX}]+`, "gu");
            }
            /**
             * Tokenizes text by splitting it using the given pattern.
             * @param {string} text The text to tokenize.
             * @param {Object} [options] Additional options for the pre-tokenization logic.
             * @returns {string[]} An array of tokens.
             */
            pre_tokenize_text(text2, options) {
              return text2.match(this.pattern) || [];
            }
          }
          class DigitsPreTokenizer extends PreTokenizer {
            /**
             * @param {Object} config The configuration options for the pre-tokenizer.
             * @param {boolean} config.individual_digits Whether to split on individual digits.
             */
            constructor(config2) {
              super();
              this.config = config2;
              const digit_pattern = `[^\\d]+|\\d${this.config.individual_digits ? "" : "+"}`;
              this.pattern = new RegExp(digit_pattern, "gu");
            }
            /**
             * Tokenizes text by splitting it using the given pattern.
             * @param {string} text The text to tokenize.
             * @param {Object} [options] Additional options for the pre-tokenization logic.
             * @returns {string[]} An array of tokens.
             */
            pre_tokenize_text(text2, options) {
              return text2.match(this.pattern) || [];
            }
          }
          class PostProcessor extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
            /**
             * @param {Object} config The configuration for the post-processor.
             */
            constructor(config2) {
              super();
              this.config = config2;
            }
            /**
             * Factory method to create a PostProcessor object from a configuration object.
             *
             * @param {Object} config Configuration object representing a PostProcessor.
             * @returns {PostProcessor} A PostProcessor object created from the given configuration.
             * @throws {Error} If an unknown PostProcessor type is encountered.
             */
            static fromConfig(config2) {
              if (config2 === null)
                return null;
              switch (config2.type) {
                case "TemplateProcessing":
                  return new TemplateProcessing(config2);
                case "ByteLevel":
                  return new ByteLevelPostProcessor(config2);
                case "RobertaProcessing":
                  return new RobertaProcessing(config2);
                case "BertProcessing":
                  return new BertProcessing(config2);
                case "Sequence":
                  return new PostProcessorSequence(config2);
                default:
                  throw new Error(`Unknown PostProcessor type: ${config2.type}`);
              }
            }
            /**
             * Method to be implemented in subclass to apply post-processing on the given tokens.
             *
             * @param {Array} tokens The input tokens to be post-processed.
             * @param {...*} args Additional arguments required by the post-processing logic.
             * @returns {PostProcessedOutput} The post-processed tokens.
             * @throws {Error} If the method is not implemented in subclass.
             */
            post_process(tokens, ...args) {
              throw Error("post_process should be implemented in subclass.");
            }
            /**
             * Alias for {@link PostProcessor#post_process}.
             * @param {Array} tokens The text or array of texts to post-process.
             * @param {...*} args Additional arguments required by the post-processing logic.
             * @returns {PostProcessedOutput} The post-processed tokens.
             */
            _call(tokens, ...args) {
              return this.post_process(tokens, ...args);
            }
          }
          class BertProcessing extends PostProcessor {
            /**
             * @param {Object} config The configuration for the post-processor.
             * @param {string[]} config.cls The special tokens to add to the beginning of the input.
             * @param {string[]} config.sep The special tokens to add to the end of the input.
             */
            constructor(config2) {
              super(config2);
              this.cls = config2.cls[0];
              this.sep = config2.sep[0];
            }
            /**
             * Adds the special tokens to the beginning and end of the input.
             * @param {string[]} tokens The input tokens.
             * @param {string[]} [tokens_pair=null] An optional second set of input tokens.
             * @returns {PostProcessedOutput} The post-processed tokens with the special tokens added to the beginning and end.
             */
            post_process(tokens, tokens_pair = null, {
              add_special_tokens = true
            } = {}) {
              if (add_special_tokens) {
                tokens = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)([this.cls], tokens, [this.sep]);
              }
              let token_type_ids = new Array(tokens.length).fill(0);
              if (tokens_pair !== null) {
                const middle = add_special_tokens && this instanceof RobertaProcessing ? [this.sep] : [];
                const after = add_special_tokens ? [this.sep] : [];
                tokens = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(tokens, middle, tokens_pair, after);
                token_type_ids = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(token_type_ids, new Array(tokens_pair.length + middle.length + after.length).fill(1));
              }
              return { tokens, token_type_ids };
            }
          }
          class RobertaProcessing extends BertProcessing {
          }
          class TemplateProcessing extends PostProcessor {
            /**
             * Creates a new instance of `TemplateProcessing`.
             * @param {Object} config The configuration options for the post processor.
             * @param {Array} config.single The template for a single sequence of tokens.
             * @param {Array} config.pair The template for a pair of sequences of tokens.
             */
            constructor(config2) {
              super(config2);
              this.single = config2.single;
              this.pair = config2.pair;
            }
            /**
             * Replaces special tokens in the template with actual tokens.
             * @param {string[]} tokens The list of tokens for the first sequence.
             * @param {string[]} [tokens_pair=null] The list of tokens for the second sequence (optional).
             * @returns {PostProcessedOutput} An object containing the list of tokens with the special tokens replaced with actual tokens.
             */
            post_process(tokens, tokens_pair = null, {
              add_special_tokens = true
            } = {}) {
              const type = tokens_pair === null ? this.single : this.pair;
              let processedTokens = [];
              let types = [];
              for (const item of type) {
                if ("SpecialToken" in item) {
                  if (add_special_tokens) {
                    processedTokens.push(item.SpecialToken.id);
                    types.push(item.SpecialToken.type_id);
                  }
                } else if ("Sequence" in item) {
                  if (item.Sequence.id === "A") {
                    processedTokens = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(processedTokens, tokens);
                    types = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(types, new Array(tokens.length).fill(item.Sequence.type_id));
                  } else if (item.Sequence.id === "B") {
                    processedTokens = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(processedTokens, tokens_pair);
                    types = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(types, new Array(tokens_pair.length).fill(item.Sequence.type_id));
                  }
                }
              }
              return { tokens: processedTokens, token_type_ids: types };
            }
          }
          class ByteLevelPostProcessor extends PostProcessor {
            /**
             * Post process the given tokens.
             * @param {string[]} tokens The list of tokens for the first sequence.
             * @param {string[]} [tokens_pair=null] The list of tokens for the second sequence (optional).
             * @returns {PostProcessedOutput} An object containing the post-processed tokens.
             */
            post_process(tokens, tokens_pair = null) {
              if (tokens_pair) {
                tokens = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(tokens, tokens_pair);
              }
              return { tokens };
            }
          }
          class PostProcessorSequence extends PostProcessor {
            /**
             * Creates a new instance of PostProcessorSequence.
             * @param {Object} config The configuration object.
             * @param {Object[]} config.processors The list of post-processors to apply.
             */
            constructor(config2) {
              super(config2);
              this.processors = config2.processors.map((x) => PostProcessor.fromConfig(x));
            }
            /**
             * Post process the given tokens.
             * @param {string[]} tokens The list of tokens for the first sequence.
             * @param {string[]} [tokens_pair=null] The list of tokens for the second sequence (optional).
             * @returns {PostProcessedOutput} An object containing the post-processed tokens.
             */
            post_process(tokens, tokens_pair = null, options = {}) {
              let token_type_ids;
              for (const processor of this.processors) {
                if (processor instanceof ByteLevelPostProcessor) {
                  const output = processor.post_process(tokens);
                  tokens = output.tokens;
                  if (tokens_pair) {
                    const pair_output = processor.post_process(tokens_pair);
                    tokens_pair = pair_output.tokens;
                  }
                } else {
                  const output = processor.post_process(tokens, tokens_pair, options);
                  tokens = output.tokens;
                  token_type_ids = output.token_type_ids;
                }
              }
              return { tokens, token_type_ids };
            }
          }
          class Decoder extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
            /**
            * Creates an instance of `Decoder`.
            *
            * @param {Object} config The configuration object.
            */
            constructor(config2) {
              super();
              this.config = config2;
              this.added_tokens = [];
              this.end_of_word_suffix = null;
              this.trim_offsets = config2.trim_offsets;
            }
            /**
            * Creates a decoder instance based on the provided configuration.
            *
            * @param {Object} config The configuration object.
            * @returns {Decoder} A decoder instance.
            * @throws {Error} If an unknown decoder type is provided.
            */
            static fromConfig(config2) {
              if (config2 === null)
                return null;
              switch (config2.type) {
                case "WordPiece":
                  return new WordPieceDecoder(config2);
                case "Metaspace":
                  return new MetaspaceDecoder(config2);
                case "ByteLevel":
                  return new ByteLevelDecoder(config2);
                case "Replace":
                  return new ReplaceDecoder(config2);
                case "ByteFallback":
                  return new ByteFallback(config2);
                case "Fuse":
                  return new FuseDecoder(config2);
                case "Strip":
                  return new StripDecoder(config2);
                case "Sequence":
                  return new DecoderSequence(config2);
                case "CTC":
                  return new CTCDecoder(config2);
                case "BPEDecoder":
                  return new BPEDecoder(config2);
                default:
                  throw new Error(`Unknown Decoder type: ${config2.type}`);
              }
            }
            /**
            * Calls the `decode` method.
            *
            * @param {string[]} tokens The list of tokens.
            * @returns {string} The decoded string.
            */
            _call(tokens) {
              return this.decode(tokens);
            }
            /**
            * Decodes a list of tokens.
            * @param {string[]} tokens The list of tokens.
            * @returns {string} The decoded string.
            */
            decode(tokens) {
              return this.decode_chain(tokens).join("");
            }
            /**
             * Apply the decoder to a list of tokens.
             * 
             * @param {string[]} tokens The list of tokens.
             * @returns {string[]} The decoded list of tokens.
             * @throws {Error} If the `decode_chain` method is not implemented in the subclass.
             */
            decode_chain(tokens) {
              throw Error("`decode_chain` should be implemented in subclass.");
            }
          }
          class ReplaceDecoder extends Decoder {
            /** @type {Decoder['decode_chain']} */
            decode_chain(tokens) {
              const pattern = createPattern(this.config.pattern);
              return pattern === null ? tokens : tokens.map((token) => token.replaceAll(pattern, this.config.content));
            }
          }
          class ByteFallback extends Decoder {
            constructor(config2) {
              super(config2);
              this.text_decoder = new TextDecoder();
            }
            /** @type {Decoder['decode_chain']} */
            decode_chain(tokens) {
              const new_tokens = [];
              let previous_byte_tokens = [];
              for (const token of tokens) {
                let bytes = null;
                if (token.length === 6 && token.startsWith("<0x") && token.endsWith(">")) {
                  const byte = parseInt(token.slice(3, 5), 16);
                  if (!isNaN(byte)) {
                    bytes = byte;
                  }
                }
                if (bytes !== null) {
                  previous_byte_tokens.push(bytes);
                } else {
                  if (previous_byte_tokens.length > 0) {
                    const string = this.text_decoder.decode(Uint8Array.from(previous_byte_tokens));
                    new_tokens.push(string);
                    previous_byte_tokens = [];
                  }
                  new_tokens.push(token);
                }
              }
              if (previous_byte_tokens.length > 0) {
                const string = this.text_decoder.decode(Uint8Array.from(previous_byte_tokens));
                new_tokens.push(string);
                previous_byte_tokens = [];
              }
              return new_tokens;
            }
          }
          class FuseDecoder extends Decoder {
            /** @type {Decoder['decode_chain']} */
            decode_chain(tokens) {
              return [tokens.join("")];
            }
          }
          class StripDecoder extends Decoder {
            constructor(config2) {
              super(config2);
              this.content = this.config.content;
              this.start = this.config.start;
              this.stop = this.config.stop;
            }
            /** @type {Decoder['decode_chain']} */
            decode_chain(tokens) {
              return tokens.map((token) => {
                let start_cut = 0;
                for (let i = 0; i < this.start; ++i) {
                  if (token[i] === this.content) {
                    start_cut = i + 1;
                    continue;
                  } else {
                    break;
                  }
                }
                let stop_cut = token.length;
                for (let i = 0; i < this.stop; ++i) {
                  const index = token.length - i - 1;
                  if (token[index] === this.content) {
                    stop_cut = index;
                    continue;
                  } else {
                    break;
                  }
                }
                return token.slice(start_cut, stop_cut);
              });
            }
          }
          class WordPieceDecoder extends Decoder {
            /**
             * Creates a new instance of WordPieceDecoder.
             * @param {Object} config The configuration object.
             * @param {string} config.prefix The prefix used for WordPiece encoding.
             * @param {boolean} config.cleanup Whether to cleanup the decoded string.
             */
            constructor(config2) {
              super(config2);
              this.cleanup = config2.cleanup;
            }
            /** @type {Decoder['decode_chain']} */
            decode_chain(tokens) {
              return tokens.map((token, i) => {
                if (i !== 0) {
                  if (token.startsWith(this.config.prefix)) {
                    token = token.replace(this.config.prefix, "");
                  } else {
                    token = " " + token;
                  }
                }
                if (this.cleanup) {
                  token = clean_up_tokenization(token);
                }
                return token;
              });
            }
          }
          class ByteLevelDecoder extends Decoder {
            /**
             * Create a `ByteLevelDecoder` object.
             * @param {Object} config Configuration object.
             */
            constructor(config2) {
              super(config2);
              this.byte_decoder = UNICODE_TO_BYTES;
              this.text_decoder = new TextDecoder("utf-8", {
                fatal: false,
                ignoreBOM: true
              });
              this.end_of_word_suffix = null;
            }
            /**
             * Convert an array of tokens to string by decoding each byte.
             * @param {string[]} tokens Array of tokens to be decoded.
             * @returns {string} The decoded string.
             */
            convert_tokens_to_string(tokens) {
              const text2 = tokens.join("");
              const byteArray = new Uint8Array([...text2].map((c) => this.byte_decoder[c]));
              const decoded_text = this.text_decoder.decode(byteArray);
              return decoded_text;
            }
            /** @type {Decoder['decode_chain']} */
            decode_chain(tokens) {
              const sub_texts = [];
              let current_sub_text = [];
              for (const token of tokens) {
                if (this.added_tokens.find((x) => x.content === token) !== void 0) {
                  if (current_sub_text.length > 0) {
                    sub_texts.push(this.convert_tokens_to_string(current_sub_text));
                    current_sub_text = [];
                  }
                  sub_texts.push(token);
                } else {
                  current_sub_text.push(token);
                }
              }
              if (current_sub_text.length > 0) {
                sub_texts.push(this.convert_tokens_to_string(current_sub_text));
              }
              return sub_texts;
            }
          }
          class CTCDecoder extends Decoder {
            constructor(config2) {
              super(config2);
              this.pad_token = this.config.pad_token;
              this.word_delimiter_token = this.config.word_delimiter_token;
              this.cleanup = this.config.cleanup;
            }
            /**
             * Converts a connectionist-temporal-classification (CTC) output tokens into a single string.
             * @param {string[]} tokens Array of tokens to be decoded.
             * @returns {string} The decoded string.
             */
            convert_tokens_to_string(tokens) {
              if (tokens.length === 0)
                return "";
              const grouped_tokens = [tokens[0]];
              for (let i = 1; i < tokens.length; ++i) {
                if (tokens[i] !== grouped_tokens.at(-1)) {
                  grouped_tokens.push(tokens[i]);
                }
              }
              const filtered_tokens = grouped_tokens.filter((token) => token !== this.pad_token);
              let text2 = filtered_tokens.join("");
              if (this.cleanup) {
                text2 = clean_up_tokenization(text2).replaceAll(this.word_delimiter_token, " ").trim();
              }
              return text2;
            }
            /** @type {Decoder['decode_chain']} */
            decode_chain(tokens) {
              return [this.convert_tokens_to_string(tokens)];
            }
          }
          class DecoderSequence extends Decoder {
            /**
             * Creates a new instance of DecoderSequence.
             * @param {Object} config The configuration object.
             * @param {Object[]} config.decoders The list of decoders to apply.
             */
            constructor(config2) {
              super(config2);
              this.decoders = config2.decoders.map((x) => Decoder.fromConfig(x));
            }
            /** @type {Decoder['decode_chain']} */
            decode_chain(tokens) {
              return this.decoders.reduce((toks, decoder) => {
                return decoder.decode_chain(toks);
              }, tokens);
            }
          }
          class BPEDecoder extends Decoder {
            constructor(config2) {
              super(config2);
              this.suffix = this.config.suffix;
            }
            /** @type {Decoder['decode_chain']} */
            decode_chain(tokens) {
              return tokens.map((token, i) => {
                return token.replaceAll(this.suffix, i === tokens.length - 1 ? "" : " ");
              });
            }
          }
          class VitsDecoder extends Decoder {
            /** @type {Decoder['decode_chain']} */
            decode_chain(tokens) {
              let decoded = "";
              for (let i = 1; i < tokens.length; i += 2) {
                decoded += tokens[i];
              }
              return [decoded];
            }
          }
          class MetaspacePreTokenizer extends PreTokenizer {
            /**
             * @param {Object} config The configuration object for the MetaspacePreTokenizer.
             * @param {boolean} config.add_prefix_space Whether to add a prefix space to the first token.
             * @param {string} config.replacement The character to replace spaces with.
             * @param {string} [config.str_rep=config.replacement] An optional string representation of the replacement character.
             * @param {'first'|'never'|'always'} [config.prepend_scheme='always'] The metaspace prepending scheme.
             */
            constructor(config2) {
              super();
              this.addPrefixSpace = config2.add_prefix_space;
              this.replacement = config2.replacement;
              this.strRep = config2.str_rep || this.replacement;
              this.prepend_scheme = config2.prepend_scheme ?? "always";
            }
            /**
             * This method takes a string, replaces spaces with the replacement character,
             * adds a prefix space if requested, and returns a new list of tokens.
             * @param {string} text The text to pre-tokenize.
             * @param {Object} [options] The options for the pre-tokenization.
             * @param {number} [options.section_index] The index of the section to pre-tokenize.
             * @returns {string[]} A new list of pre-tokenized tokens.
             */
            pre_tokenize_text(text2, {
              section_index = void 0
            } = {}) {
              let normalized = text2.replaceAll(" ", this.strRep);
              if (
                // We add a prefix space if:
                //  (1) The addPrefixSpace option is enabled and the normalized
                //      token does not already start with the replacement character.
                this.addPrefixSpace && !normalized.startsWith(this.replacement) && (this.prepend_scheme === "always" || this.prepend_scheme === "first" && section_index === 0)
              ) {
                normalized = this.strRep + normalized;
              }
              return [normalized];
            }
          }
          class MetaspaceDecoder extends Decoder {
            /**
             * Constructs a new MetaspaceDecoder object.
             * @param {Object} config The configuration object for the MetaspaceDecoder.
             * @param {boolean} config.add_prefix_space Whether to add a prefix space to the decoded string.
             * @param {string} config.replacement The string to replace spaces with.
             */
            constructor(config2) {
              super(config2);
              this.addPrefixSpace = config2.add_prefix_space;
              this.replacement = config2.replacement;
            }
            /** @type {Decoder['decode_chain']} */
            decode_chain(tokens) {
              const result = [];
              for (let i = 0; i < tokens.length; ++i) {
                let normalized = tokens[i].replaceAll(this.replacement, " ");
                if (this.addPrefixSpace && i == 0 && normalized.startsWith(" ")) {
                  normalized = normalized.substring(1);
                }
                result.push(normalized);
              }
              return result;
            }
          }
          class Precompiled extends Normalizer {
            /**
             * Create a new instance of Precompiled normalizer.
             * @param {Object} config The configuration object.
             * @param {any} config.precompiled_charsmap Precompiled chars mapping.
             */
            constructor(config2) {
              super(config2);
              this.charsmap = config2.precompiled_charsmap;
            }
            /**
             * Normalizes the given text by applying the precompiled charsmap.
             * @param {string} text The text to normalize.
             * @returns {string} The normalized text.
             */
            normalize(text2) {
              text2 = text2.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm, "");
              text2 = text2.replace(/[\u0009\u000A\u000C\u000D\u1680\u200B\u200C\u200E\u200F\u2028\u2029\u2581\uFEFF\uFFFD]/gm, " ");
              if (text2.includes("\uFF5E")) {
                const parts = text2.split("\uFF5E");
                text2 = parts.map((part) => part.normalize("NFKC")).join("\uFF5E");
              } else {
                text2 = text2.normalize("NFKC");
              }
              return text2;
            }
          }
          class PreTokenizerSequence extends PreTokenizer {
            /**
             * Creates an instance of PreTokenizerSequence.
             * @param {Object} config The configuration object for the pre-tokenizer sequence.
             * @param {Object[]} config.pretokenizers An array of pre-tokenizer configurations.
             */
            constructor(config2) {
              super();
              this.tokenizers = config2.pretokenizers.map((x) => PreTokenizer.fromConfig(x));
            }
            /**
             * Applies each pre-tokenizer in the sequence to the input text in turn.
             * @param {string} text The text to pre-tokenize.
             * @param {Object} [options] Additional options for the pre-tokenization logic.
             * @returns {string[]} The pre-tokenized text.
             */
            pre_tokenize_text(text2, options) {
              return this.tokenizers.reduce((preTokenizedText, tokenizer) => {
                return tokenizer.pre_tokenize(preTokenizedText, options);
              }, [text2]);
            }
          }
          class WhitespacePreTokenizer extends PreTokenizer {
            /**
             * Creates an instance of WhitespacePreTokenizer.
             * @param {Object} config The configuration object for the pre-tokenizer.
             */
            constructor(config2) {
              super();
            }
            /**
             * Pre-tokenizes the input text by splitting it on word boundaries.
             * @param {string} text The text to be pre-tokenized.
             * @param {Object} [options] Additional options for the pre-tokenization logic.
             * @returns {string[]} An array of tokens produced by splitting the input text on whitespace.
             */
            pre_tokenize_text(text2, options) {
              return text2.match(/\w+|[^\w\s]+/g) || [];
            }
          }
          class WhitespaceSplit extends PreTokenizer {
            /**
             * Creates an instance of WhitespaceSplit.
             * @param {Object} config The configuration object for the pre-tokenizer.
             */
            constructor(config2) {
              super();
            }
            /**
             * Pre-tokenizes the input text by splitting it on whitespace characters.
             * @param {string} text The text to be pre-tokenized.
             * @param {Object} [options] Additional options for the pre-tokenization logic.
             * @returns {string[]} An array of tokens produced by splitting the input text on whitespace.
             */
            pre_tokenize_text(text2, options) {
              return whitespace_split(text2);
            }
          }
          class ReplacePreTokenizer extends PreTokenizer {
            /**
             * @param {Object} config The configuration options for the pre-tokenizer.
             * @param {Object} config.pattern The pattern used to split the text. Can be a string or a regex object.
             * @param {string} config.content What to replace the pattern with.
             */
            constructor(config2) {
              super();
              this.config = config2;
              this.pattern = createPattern(this.config.pattern);
              this.content = this.config.content;
            }
            /**
             * Pre-tokenizes the input text by replacing certain characters.
             * @param {string} text The text to be pre-tokenized.
             * @param {Object} [options] Additional options for the pre-tokenization logic.
             * @returns {string[]} An array of tokens produced by replacing certain characters.
             */
            pre_tokenize_text(text2, options) {
              if (this.pattern === null) {
                return [text2];
              }
              return [text2.replaceAll(this.pattern, this.config.content)];
            }
          }
          const SPECIAL_TOKEN_ATTRIBUTES = [
            "bos_token",
            "eos_token",
            "unk_token",
            "sep_token",
            "pad_token",
            "cls_token",
            "mask_token"
            // additional_special_tokens (TODO)
          ];
          function padHelper(item, length, value_fn, side) {
            for (const key of Object.keys(item)) {
              const diff = length - item[key].length;
              const value = value_fn(key);
              const padData = new Array(diff).fill(value);
              item[key] = side === "right" ? (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(item[key], padData) : (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(padData, item[key]);
            }
          }
          function truncateHelper(item, length) {
            for (const key of Object.keys(item)) {
              item[key].length = length;
            }
          }
          class PreTrainedTokenizer extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
            /**
             * Create a new PreTrainedTokenizer instance.
             * @param {Object} tokenizerJSON The JSON of the tokenizer.
             * @param {Object} tokenizerConfig The config of the tokenizer.
             */
            constructor(tokenizerJSON, tokenizerConfig) {
              super();
              __publicField(this, "return_token_type_ids", false);
              __publicField(this, "_default_chat_template", `{% for message in messages %}{{'<|im_start|>' + message['role'] + '
' + message['content'] + '<|im_end|>' + '
'}}{% endfor %}{% if add_generation_prompt %}{{ '<|im_start|>assistant
' }}{% endif %}`);
              this._tokenizer_config = tokenizerConfig;
              this.normalizer = Normalizer.fromConfig(tokenizerJSON.normalizer);
              this.pre_tokenizer = PreTokenizer.fromConfig(tokenizerJSON.pre_tokenizer);
              this.model = TokenizerModel.fromConfig(tokenizerJSON.model, tokenizerConfig);
              this.post_processor = PostProcessor.fromConfig(tokenizerJSON.post_processor);
              this.decoder = Decoder.fromConfig(tokenizerJSON.decoder);
              this.special_tokens = [];
              this.all_special_ids = [];
              this.added_tokens = [];
              for (const addedToken of tokenizerJSON.added_tokens) {
                const token = new AddedToken(addedToken);
                this.added_tokens.push(token);
                this.model.tokens_to_ids.set(token.content, token.id);
                this.model.vocab[token.id] = token.content;
                if (token.special) {
                  this.special_tokens.push(token.content);
                  this.all_special_ids.push(token.id);
                }
              }
              this.additional_special_tokens = tokenizerConfig.additional_special_tokens ?? [];
              this.special_tokens.push(...this.additional_special_tokens);
              this.special_tokens = [...new Set(this.special_tokens)];
              if (this.decoder) {
                this.decoder.added_tokens = this.added_tokens;
                this.decoder.end_of_word_suffix = this.model.end_of_word_suffix;
              }
              this.added_tokens_regex = this.added_tokens.length > 0 ? new RegExp(
                this.added_tokens.map((x) => `${x.lstrip ? "\\s*" : ""}(${(0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.escapeRegExp)(x.content)})${x.rstrip ? "\\s*" : ""}`).join("|")
              ) : null;
              this.mask_token = this.getToken("mask_token");
              this.mask_token_id = this.model.tokens_to_ids.get(this.mask_token);
              this.pad_token = this.getToken("pad_token", "eos_token");
              this.pad_token_id = this.model.tokens_to_ids.get(this.pad_token);
              this.sep_token = this.getToken("sep_token");
              this.sep_token_id = this.model.tokens_to_ids.get(this.sep_token);
              this.unk_token = this.getToken("unk_token");
              this.unk_token_id = this.model.tokens_to_ids.get(this.unk_token);
              this.model_max_length = tokenizerConfig.model_max_length;
              this.remove_space = tokenizerConfig.remove_space;
              this.clean_up_tokenization_spaces = tokenizerConfig.clean_up_tokenization_spaces ?? true;
              this.do_lowercase_and_remove_accent = tokenizerConfig.do_lowercase_and_remove_accent ?? false;
              this.padding_side = "right";
              this.legacy = false;
              this.chat_template = tokenizerConfig.chat_template ?? null;
              if (Array.isArray(this.chat_template)) {
                const chat_template = /* @__PURE__ */ Object.create(null);
                for (const { name: name2, template } of this.chat_template) {
                  if (typeof name2 !== "string" || typeof template !== "string") {
                    throw new Error('Chat template must be a list of objects with "name" and "template" properties');
                  }
                  chat_template[name2] = template;
                }
                this.chat_template = chat_template;
              }
              this._compiled_template_cache = /* @__PURE__ */ new Map();
            }
            /**
             * Returns the value of the first matching key in the tokenizer config object.
             * @param {...string} keys One or more keys to search for in the tokenizer config object.
             * @returns {string|null} The value associated with the first matching key, or null if no match is found.
             * @throws {Error} If an object is found for a matching key and its __type property is not "AddedToken".
             */
            getToken(...keys) {
              for (const key of keys) {
                const item = this._tokenizer_config[key];
                if (!item)
                  continue;
                if (typeof item === "object") {
                  if (item.__type === "AddedToken") {
                    return item.content;
                  } else {
                    throw Error(`Unknown token: ${item}`);
                  }
                } else {
                  return item;
                }
              }
              return null;
            }
            /**
             * Loads a pre-trained tokenizer from the given `pretrained_model_name_or_path`. 
             * 
             * @param {string} pretrained_model_name_or_path The path to the pre-trained tokenizer.
             * @param {PretrainedTokenizerOptions} options Additional options for loading the tokenizer.
             * 
             * @throws {Error} Throws an error if the tokenizer.json or tokenizer_config.json files are not found in the `pretrained_model_name_or_path`.
             * @returns {Promise<PreTrainedTokenizer>} A new instance of the `PreTrainedTokenizer` class.
             */
            static async from_pretrained(pretrained_model_name_or_path, {
              progress_callback = null,
              config: config2 = null,
              cache_dir = null,
              local_files_only = false,
              revision = "main",
              legacy = null
            } = {}) {
              const info = await loadTokenizer(pretrained_model_name_or_path, {
                progress_callback,
                config: config2,
                cache_dir,
                local_files_only,
                revision,
                legacy
              });
              return new this(...info);
            }
            /**
             * @typedef {number[]|number[][]|Tensor} BatchEncodingItem
             * 
             * @typedef {Object} BatchEncoding Holds the output of the tokenizer's call function.
             * @property {BatchEncodingItem} input_ids List of token ids to be fed to a model.
             * @property {BatchEncodingItem} attention_mask List of indices specifying which tokens should be attended to by the model.
             * @property {BatchEncodingItem} [token_type_ids] List of token type ids to be fed to a model.
             */
            /**
             * Encode/tokenize the given text(s).
             * @param {string|string[]} text The text to tokenize.
             * @param {Object} options An optional object containing the following properties:
             * @param {string|string[]} [options.text_pair=null] Optional second sequence to be encoded. If set, must be the same type as text.
             * @param {boolean|'max_length'} [options.padding=false] Whether to pad the input sequences.
             * @param {boolean} [options.add_special_tokens=true] Whether or not to add the special tokens associated with the corresponding model.
             * @param {boolean} [options.truncation=null] Whether to truncate the input sequences.
             * @param {number} [options.max_length=null] Maximum length of the returned list and optionally padding length.
             * @param {boolean} [options.return_tensor=true] Whether to return the results as Tensors or arrays.
             * @param {boolean} [options.return_token_type_ids=null] Whether to return the token type ids.
             * @returns {BatchEncoding} Object to be passed to the model.
             */
            _call(text2, {
              text_pair = null,
              add_special_tokens = true,
              padding = false,
              truncation = null,
              max_length = null,
              return_tensor = true,
              // Different to HF
              return_token_type_ids = null
            } = {}) {
              const isBatched = Array.isArray(text2);
              let encodedTokens;
              if (isBatched) {
                if (text2.length === 0) {
                  throw Error("text array must be non-empty");
                }
                if (text_pair !== null) {
                  if (!Array.isArray(text_pair)) {
                    throw Error("text_pair must also be an array");
                  } else if (text2.length !== text_pair.length) {
                    throw Error("text and text_pair must have the same length");
                  }
                  encodedTokens = text2.map(
                    (t, i) => this._encode_plus(t, text_pair[i], { add_special_tokens, return_token_type_ids })
                  );
                } else {
                  encodedTokens = text2.map((x) => this._encode_plus(x, null, { add_special_tokens, return_token_type_ids }));
                }
              } else {
                if (text2 === null || text2 === void 0) {
                  throw Error("text may not be null or undefined");
                }
                if (Array.isArray(text_pair)) {
                  throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");
                }
                encodedTokens = [this._encode_plus(text2, text_pair, { add_special_tokens, return_token_type_ids })];
              }
              if (max_length === null) {
                if (padding === "max_length") {
                  max_length = this.model_max_length;
                } else {
                  max_length = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(encodedTokens.map((x) => x.input_ids.length))[0];
                }
              } else {
                if (!truncation) {
                  console.warn(`Truncation was not explicitly activated but \`max_length\` is provided a specific value, please use \`truncation=true\` to explicitly truncate examples to max length.`);
                }
              }
              max_length = Math.min(max_length, this.model_max_length);
              if (padding || truncation) {
                for (let i = 0; i < encodedTokens.length; ++i) {
                  if (encodedTokens[i].input_ids.length === max_length) {
                    continue;
                  } else if (encodedTokens[i].input_ids.length > max_length) {
                    if (truncation) {
                      truncateHelper(encodedTokens[i], max_length);
                    }
                  } else {
                    if (padding) {
                      padHelper(
                        encodedTokens[i],
                        max_length,
                        (key) => key === "input_ids" ? this.pad_token_id : 0,
                        this.padding_side
                      );
                    }
                  }
                }
              }
              const result = {};
              if (return_tensor) {
                if (!(padding && truncation)) {
                  if (encodedTokens.some((x) => {
                    for (const key of Object.keys(x)) {
                      if (x[key].length !== encodedTokens[0][key]?.length) {
                        return true;
                      }
                    }
                    return false;
                  })) {
                    throw Error(
                      "Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length."
                    );
                  }
                }
                const dims = [encodedTokens.length, encodedTokens[0].input_ids.length];
                for (const key of Object.keys(encodedTokens[0])) {
                  result[key] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(
                    "int64",
                    BigInt64Array.from(encodedTokens.flatMap((x) => x[key]).map(BigInt)),
                    dims
                  );
                }
              } else {
                for (const key of Object.keys(encodedTokens[0])) {
                  result[key] = encodedTokens.map((x) => x[key]);
                }
                if (!isBatched) {
                  for (const key of Object.keys(result)) {
                    result[key] = result[key][0];
                  }
                }
              }
              return (
                /** @type {BatchEncoding} */
                result
              );
            }
            /**
             * Encodes a single text using the preprocessor pipeline of the tokenizer.
             *
             * @param {string|null} text The text to encode.
             * @returns {string[]|null} The encoded tokens.
             */
            _encode_text(text2) {
              if (text2 === null)
                return null;
              const sections = this.added_tokens_regex ? text2.split(this.added_tokens_regex).filter((x) => x) : [text2];
              const tokens = sections.map((x, section_index) => {
                const addedToken = this.added_tokens.find((t) => t.content === x);
                if (addedToken !== void 0) {
                  return x;
                } else {
                  if (this.remove_space === true) {
                    x = x.trim().split(/\s+/).join(" ");
                  }
                  if (this.do_lowercase_and_remove_accent) {
                    x = lowercase_and_remove_accent(x);
                  }
                  if (this.normalizer !== null) {
                    x = this.normalizer(x);
                  }
                  if (x.length === 0) {
                    return [];
                  }
                  const sectionTokens = this.pre_tokenizer !== null ? this.pre_tokenizer(x, {
                    section_index
                  }) : [x];
                  const tokens2 = this.model(sectionTokens);
                  return tokens2;
                }
              }).flat();
              return tokens;
            }
            /**
             * Encodes a single text or a pair of texts using the model's tokenizer.
             *
             * @param {string} text The text to encode.
             * @param {string|null} text_pair The optional second text to encode.
             * @param {Object} options An optional object containing the following properties:
             * @param {boolean} [options.add_special_tokens=true] Whether or not to add the special tokens associated with the corresponding model.
             * @param {boolean} [options.return_token_type_ids=null] Whether to return token_type_ids.
             * @returns {EncodingSingle} An object containing the encoded text.
             * @private
             */
            _encode_plus(text2, text_pair = null, {
              add_special_tokens = true,
              return_token_type_ids = null
            } = {}) {
              const tokens = this._encode_text(text2);
              const tokens2 = this._encode_text(text_pair);
              const combinedTokens = this.post_processor ? this.post_processor(tokens, tokens2, { add_special_tokens }) : { tokens: (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(tokens ?? [], tokens2 ?? []) };
              const input_ids = this.model.convert_tokens_to_ids(combinedTokens.tokens);
              const result = {
                input_ids,
                attention_mask: new Array(input_ids.length).fill(1)
              };
              if ((return_token_type_ids ?? this.return_token_type_ids) && combinedTokens.token_type_ids) {
                result.token_type_ids = combinedTokens.token_type_ids;
              }
              return result;
            }
            /**
             * Encodes a single text or a pair of texts using the model's tokenizer.
             *
             * @param {string} text The text to encode.
             * @param {string|null} text_pair The optional second text to encode.
             * @param {Object} options An optional object containing the following properties:
             * @param {boolean} [options.add_special_tokens=true] Whether or not to add the special tokens associated with the corresponding model.
             * @param {boolean} [options.return_token_type_ids=null] Whether to return token_type_ids.
             * @returns {number[]} An array of token IDs representing the encoded text(s).
             */
            encode(text2, text_pair = null, {
              add_special_tokens = true,
              return_token_type_ids = null
            } = {}) {
              const { input_ids } = this._encode_plus(text2, text_pair, {
                add_special_tokens,
                return_token_type_ids
              });
              return input_ids;
            }
            /**
             * Decode a batch of tokenized sequences.
             * @param {number[][]|Tensor} batch List/Tensor of tokenized input sequences.
             * @param {Object} decode_args (Optional) Object with decoding arguments.
             * @returns {string[]} List of decoded sequences.
             */
            batch_decode(batch, decode_args = {}) {
              if (batch instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor) {
                batch = batch.tolist();
              }
              return batch.map((x) => this.decode(x, decode_args));
            }
            /**
             * Decodes a sequence of token IDs back to a string.
             *
             * @param {number[]|Tensor} token_ids List/Tensor of token IDs to decode.
             * @param {Object} [decode_args={}]
             * @param {boolean} [decode_args.skip_special_tokens=false] If true, special tokens are removed from the output string.
             * @param {boolean} [decode_args.clean_up_tokenization_spaces=true] If true, spaces before punctuations and abbreviated forms are removed.
             *
             * @returns {string} The decoded string.
             * @throws {Error} If `token_ids` is not a non-empty array of integers.
             */
            decode(token_ids, decode_args = {}) {
              if (token_ids instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor) {
                token_ids = prepareTensorForDecode(token_ids);
              }
              if (!Array.isArray(token_ids) || token_ids.length === 0 || !(0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.isIntegralNumber)(token_ids[0])) {
                throw Error("token_ids must be a non-empty array of integers.");
              }
              return this.decode_single(token_ids, decode_args);
            }
            /**
             * Decode a single list of token ids to a string.
             * @param {number[]} token_ids List of token ids to decode
             * @param {Object} decode_args Optional arguments for decoding
             * @param {boolean} [decode_args.skip_special_tokens=false] Whether to skip special tokens during decoding
             * @param {boolean} [decode_args.clean_up_tokenization_spaces=null] Whether to clean up tokenization spaces during decoding.
             * If null, the value is set to `this.decoder.cleanup` if it exists, falling back to `this.clean_up_tokenization_spaces` if it exists, falling back to `true`.
             * @returns {string} The decoded string
             */
            decode_single(token_ids, {
              skip_special_tokens = false,
              clean_up_tokenization_spaces = null
            }) {
              let tokens = this.model.convert_ids_to_tokens(token_ids);
              if (skip_special_tokens) {
                tokens = tokens.filter((x) => !this.special_tokens.includes(x));
              }
              let decoded = this.decoder ? this.decoder(tokens) : tokens.join(" ");
              if (this.decoder && this.decoder.end_of_word_suffix) {
                decoded = decoded.replaceAll(this.decoder.end_of_word_suffix, " ");
                if (skip_special_tokens) {
                  decoded = decoded.trim();
                }
              }
              if (clean_up_tokenization_spaces ?? this.clean_up_tokenization_spaces) {
                decoded = clean_up_tokenization(decoded);
              }
              return decoded;
            }
            get default_chat_template() {
              if (!this._warned_about_chat_template) {
                console.warn(
                  "No chat template is defined for this tokenizer - using a default chat template that implements the ChatML format. If the default is not appropriate for your model, please set `tokenizer.chat_template` to an appropriate template. See https://huggingface.co/docs/transformers/main/chat_templating for more information."
                );
                this._warned_about_chat_template = true;
              }
              return this._default_chat_template;
            }
            /**
             * Converts a list of message objects with `"role"` and `"content"` keys to a list of token
             * ids. This method is intended for use with chat models, and will read the tokenizer's chat_template attribute to
             * determine the format and control tokens to use when converting. When chat_template is None, it will fall back
             * to the default_chat_template specified at the class level.
             * 
             * See [here](https://huggingface.co/docs/transformers/chat_templating) for more information.
             * 
             * **Example:** Applying a chat template to a conversation.
             * 
             * ```javascript
             * import { AutoTokenizer } from "@xenova/transformers";
             * 
             * const tokenizer = await AutoTokenizer.from_pretrained("Xenova/mistral-tokenizer-v1");
             * 
             * const chat = [
             *   { "role": "user", "content": "Hello, how are you?" },
             *   { "role": "assistant", "content": "I'm doing great. How can I help you today?" },
             *   { "role": "user", "content": "I'd like to show off how chat templating works!" },
             * ]
             * 
             * const text = tokenizer.apply_chat_template(chat, { tokenize: false });
             * // "<s>[INST] Hello, how are you? [/INST]I'm doing great. How can I help you today?</s> [INST] I'd like to show off how chat templating works! [/INST]"
             * 
             * const input_ids = tokenizer.apply_chat_template(chat, { tokenize: true, return_tensor: false });
             * // [1, 733, 16289, 28793, 22557, 28725, 910, 460, 368, 28804, 733, 28748, 16289, 28793, 28737, 28742, 28719, 2548, 1598, 28723, 1602, 541, 315, 1316, 368, 3154, 28804, 2, 28705, 733, 16289, 28793, 315, 28742, 28715, 737, 298, 1347, 805, 910, 10706, 5752, 1077, 3791, 28808, 733, 28748, 16289, 28793]
             * ```
             * 
             * @param {Message[]} conversation A list of message objects with `"role"` and `"content"` keys.
             * @param {Object} options An optional object containing the following properties:
             * @param {string} [options.chat_template=null] A Jinja template to use for this conversion. If
             * this is not passed, the model's default chat template will be used instead.
             * @param {boolean} [options.add_generation_prompt=false] Whether to end the prompt with the token(s) that indicate
             * the start of an assistant message. This is useful when you want to generate a response from the model.
             * Note that this argument will be passed to the chat template, and so it must be supported in the
             * template for this argument to have any effect.
             * @param {boolean} [options.tokenize=true] Whether to tokenize the output. If false, the output will be a string.
             * @param {boolean} [options.padding=false] Whether to pad sequences to the maximum length. Has no effect if tokenize is false.
             * @param {boolean} [options.truncation=false] Whether to truncate sequences to the maximum length. Has no effect if tokenize is false.
             * @param {number} [options.max_length=null] Maximum length (in tokens) to use for padding or truncation. Has no effect if tokenize is false.
             * If not specified, the tokenizer's `max_length` attribute will be used as a default.
             * @param {boolean} [options.return_tensor=true] Whether to return the output as a Tensor or an Array. Has no effect if tokenize is false.
             * @param {Object} [options.tokenizer_kwargs={}] Additional options to pass to the tokenizer.
             * @returns {string | Tensor | number[]| number[][]} The tokenized output.
             */
            apply_chat_template(conversation, {
              chat_template = null,
              add_generation_prompt = false,
              tokenize: tokenize4 = true,
              padding = false,
              truncation = false,
              max_length = null,
              return_tensor = true,
              tokenizer_kwargs = {},
              ...kwargs
            } = {}) {
              if (this.chat_template && typeof this.chat_template === "object" || this.chat_template === null && this.default_chat_template && typeof this.default_chat_template === "object") {
                const template_dict = this.chat_template ?? this.default_chat_template;
                if (chat_template !== null && Object.hasOwn(template_dict, chat_template)) {
                  chat_template = template_dict[chat_template];
                } else if (chat_template === null && "default" in template_dict) {
                  chat_template = template_dict["default"];
                } else if (chat_template === null) {
                  throw Error(
                    `This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(template_dict).sort()}.`
                  );
                }
              } else {
                chat_template ?? (chat_template = this.chat_template ?? this.default_chat_template);
              }
              if (typeof chat_template !== "string") {
                throw Error(`chat_template must be a string, but got ${typeof chat_template}`);
              }
              let compiledTemplate = this._compiled_template_cache.get(chat_template);
              if (compiledTemplate === void 0) {
                compiledTemplate = new _huggingface_jinja__WEBPACK_IMPORTED_MODULE_5__.Template(chat_template);
                this._compiled_template_cache.set(chat_template, compiledTemplate);
              }
              const special_tokens_map = /* @__PURE__ */ Object.create(null);
              for (const key of SPECIAL_TOKEN_ATTRIBUTES) {
                const value = this.getToken(key);
                if (value) {
                  special_tokens_map[key] = value;
                }
              }
              const rendered = compiledTemplate.render({
                messages: conversation,
                add_generation_prompt,
                ...special_tokens_map,
                ...kwargs
              });
              if (tokenize4) {
                return this._call(rendered, {
                  add_special_tokens: false,
                  padding,
                  truncation,
                  max_length,
                  return_tensor,
                  ...tokenizer_kwargs
                }).input_ids;
              }
              return rendered;
            }
          }
          class BertTokenizer extends PreTrainedTokenizer {
            constructor() {
              super(...arguments);
              __publicField(this, "return_token_type_ids", true);
            }
          }
          class AlbertTokenizer extends PreTrainedTokenizer {
            constructor() {
              super(...arguments);
              __publicField(this, "return_token_type_ids", true);
            }
          }
          class MobileBertTokenizer extends PreTrainedTokenizer {
            constructor() {
              super(...arguments);
              __publicField(this, "return_token_type_ids", true);
            }
          }
          class SqueezeBertTokenizer extends PreTrainedTokenizer {
            constructor() {
              super(...arguments);
              __publicField(this, "return_token_type_ids", true);
            }
          }
          class DebertaTokenizer extends PreTrainedTokenizer {
            constructor() {
              super(...arguments);
              __publicField(this, "return_token_type_ids", true);
            }
          }
          class DebertaV2Tokenizer extends PreTrainedTokenizer {
            constructor() {
              super(...arguments);
              __publicField(this, "return_token_type_ids", true);
            }
          }
          class HerbertTokenizer extends PreTrainedTokenizer {
            constructor() {
              super(...arguments);
              __publicField(this, "return_token_type_ids", true);
            }
          }
          class ConvBertTokenizer extends PreTrainedTokenizer {
            constructor() {
              super(...arguments);
              __publicField(this, "return_token_type_ids", true);
            }
          }
          class RoFormerTokenizer extends PreTrainedTokenizer {
            constructor() {
              super(...arguments);
              __publicField(this, "return_token_type_ids", true);
            }
          }
          class DistilBertTokenizer extends PreTrainedTokenizer {
          }
          class CamembertTokenizer extends PreTrainedTokenizer {
          }
          class XLMTokenizer extends PreTrainedTokenizer {
            constructor(tokenizerJSON, tokenizerConfig) {
              super(tokenizerJSON, tokenizerConfig);
              __publicField(this, "return_token_type_ids", true);
              console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.');
            }
          }
          class ElectraTokenizer extends PreTrainedTokenizer {
            constructor() {
              super(...arguments);
              __publicField(this, "return_token_type_ids", true);
            }
          }
          class T5Tokenizer extends PreTrainedTokenizer {
          }
          class GPT2Tokenizer extends PreTrainedTokenizer {
            constructor() {
              super(...arguments);
              __publicField(this, "_default_chat_template", `{% for message in messages %}" "{{ message.content }}{{ eos_token }}" "{% endfor %}`);
            }
          }
          class BartTokenizer extends PreTrainedTokenizer {
          }
          class MBartTokenizer extends PreTrainedTokenizer {
            constructor(tokenizerJSON, tokenizerConfig) {
              super(tokenizerJSON, tokenizerConfig);
              this.languageRegex = /^[a-z]{2}_[A-Z]{2}$/;
              this.language_codes = this.special_tokens.filter((x) => this.languageRegex.test(x));
              this.lang_to_token = (x) => x;
            }
            /**
             * Helper function to build translation inputs for an `MBartTokenizer`.
             * @param {string|string[]} raw_inputs The text to tokenize.
             * @param {Object} tokenizer_options Options to be sent to the tokenizer
             * @param {Object} generate_kwargs Generation options.
             * @returns {Object} Object to be passed to the model.
             */
            _build_translation_inputs(raw_inputs, tokenizer_options, generate_kwargs) {
              return _build_translation_inputs(this, raw_inputs, tokenizer_options, generate_kwargs);
            }
          }
          class MBart50Tokenizer extends MBartTokenizer {
          }
          class RobertaTokenizer extends PreTrainedTokenizer {
          }
          class BloomTokenizer extends GPT2Tokenizer {
            // NOTE: `GPT2Tokenizer` to get the correct chat template
            constructor(tokenizerJSON, tokenizerConfig) {
              const splitChars = ".,!?\u2026\u3002\uFF0C\u3001\u0964\u06D4\u060C";
              const patternObject = tokenizerJSON.pre_tokenizer?.pretokenizers[0]?.pattern;
              if (patternObject && patternObject.Regex === ` ?[^(\\s|[${splitChars}])]+`) {
                patternObject.Regex = ` ?[^\\s${splitChars}]+`;
              }
              super(tokenizerJSON, tokenizerConfig);
            }
          }
          const SPIECE_UNDERLINE = "\u2581";
          class LlamaTokenizer extends PreTrainedTokenizer {
            constructor(tokenizerJSON, tokenizerConfig) {
              super(tokenizerJSON, tokenizerConfig);
              __publicField(this, "_default_chat_template", `{% if messages[0]['role'] == 'system' %}{% set loop_messages = messages[1:] %}{% set system_message = messages[0]['content'] %}{% elif USE_DEFAULT_PROMPT == true and not '<<SYS>>' in messages[0]['content'] %}{% set loop_messages = messages %}{% set system_message = 'DEFAULT_SYSTEM_MESSAGE' %}{% else %}{% set loop_messages = messages %}{% set system_message = false %}{% endif %}{% for message in loop_messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if loop.index0 == 0 and system_message != false %}{% set content = '<<SYS>>
' + system_message + '
<</SYS>>

' + message['content'] %}{% else %}{% set content = message['content'] %}{% endif %}{% if message['role'] == 'user' %}{{ bos_token + '[INST] ' + content.strip() + ' [/INST]' }}{% elif message['role'] == 'system' %}{{ '<<SYS>>
' + content.strip() + '
<</SYS>>

' }}{% elif message['role'] == 'assistant' %}{{ ' '  + content.strip() + ' ' + eos_token }}{% endif %}{% endfor %}`);
              __publicField(this, "DEFAULT_SYSTEM_PROMPT", "You are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe. Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature.\n\nIf a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you don't know the answer to a question, please don't share false information.");
              this.use_default_system_prompt = tokenizerConfig.use_default_system_prompt ?? false;
              this.legacy = tokenizerConfig.legacy ?? true;
              if (!this.legacy) {
                this.normalizer = null;
                this.pre_tokenizer = new MetaspacePreTokenizer({
                  replacement: SPIECE_UNDERLINE,
                  add_prefix_space: true,
                  prepend_scheme: "first"
                });
              }
            }
            /**
             * Helper function to handle legacy encoding of SPM tokenizers.
             * Adapted from https://github.com/huggingface/transformers/blob/e6dcf8abd6f65bb4b6dfc1831b20d9ba49ce00e2/src/transformers/models/t5/tokenization_t5.py#L374-L387
             * @param {string} text The text to encode.
             * @returns {string[]} The encoded tokens.
             */
            _encode_text(text2) {
              if (text2 === null)
                return null;
              if (this.legacy || text2.length === 0) {
                return super._encode_text(text2);
              }
              let tokens = super._encode_text(SPIECE_UNDERLINE + text2.replaceAll(SPIECE_UNDERLINE, " "));
              if (tokens.length > 1 && tokens[0] === SPIECE_UNDERLINE && this.special_tokens.includes(tokens[1])) {
                tokens = tokens.slice(1);
              }
              return tokens;
            }
            get default_chat_template() {
              return super.default_chat_template.replaceAll("USE_DEFAULT_PROMPT", this.use_default_system_prompt ? "true" : "false").replaceAll("DEFAULT_SYSTEM_MESSAGE", this.DEFAULT_SYSTEM_PROMPT.replaceAll("\n", "\\n").replaceAll("'", "\\'"));
            }
          }
          class CodeLlamaTokenizer extends LlamaTokenizer {
          }
          class XLMRobertaTokenizer extends PreTrainedTokenizer {
          }
          class MPNetTokenizer extends PreTrainedTokenizer {
          }
          class FalconTokenizer extends PreTrainedTokenizer {
          }
          class GPTNeoXTokenizer extends PreTrainedTokenizer {
          }
          class EsmTokenizer extends PreTrainedTokenizer {
          }
          class Qwen2Tokenizer extends PreTrainedTokenizer {
          }
          class GemmaTokenizer extends PreTrainedTokenizer {
            constructor() {
              super(...arguments);
              __publicField(this, "_default_chat_template", "{% if messages[0]['role'] == 'system' %}{{ raise_exception('System role not supported') }}{% endif %}{% for message in messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if (message['role'] == 'assistant') %}{% set role = 'model' %}{% else %}{% set role = message['role'] %}{% endif %}{{ '<start_of_turn>' + role + '\n' + message['content'] | trim + '<end_of_turn>\n' }}{% endfor %}{% if add_generation_prompt %}{{'<start_of_turn>model\n'}}{% endif %}");
            }
          }
          class Grok1Tokenizer extends PreTrainedTokenizer {
          }
          function _build_translation_inputs(self2, raw_inputs, tokenizer_options, generate_kwargs) {
            if (!("language_codes" in self2) || !Array.isArray(self2.language_codes)) {
              throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");
            }
            if (!("languageRegex" in self2) || !(self2.languageRegex instanceof RegExp)) {
              throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");
            }
            if (!("lang_to_token" in self2) || typeof self2.lang_to_token !== "function") {
              throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");
            }
            const src_lang_token = generate_kwargs.src_lang;
            const tgt_lang_token = generate_kwargs.tgt_lang;
            if (!self2.language_codes.includes(tgt_lang_token)) {
              throw new Error(`Target language code "${tgt_lang_token}" is not valid. Must be one of: {${self2.language_codes.join(", ")}}`);
            }
            if (src_lang_token !== void 0) {
              if (!self2.language_codes.includes(src_lang_token)) {
                throw new Error(`Source language code "${src_lang_token}" is not valid. Must be one of: {${self2.language_codes.join(", ")}}`);
              }
              for (const item of self2.post_processor.config.single) {
                if ("SpecialToken" in item && self2.languageRegex.test(item.SpecialToken.id)) {
                  item.SpecialToken.id = self2.lang_to_token(src_lang_token);
                  break;
                }
              }
            }
            generate_kwargs.forced_bos_token_id = self2.model.convert_tokens_to_ids([self2.lang_to_token(tgt_lang_token)])[0];
            return self2._call(raw_inputs, tokenizer_options);
          }
          class NllbTokenizer extends PreTrainedTokenizer {
            constructor(tokenizerJSON, tokenizerConfig) {
              super(tokenizerJSON, tokenizerConfig);
              this.languageRegex = /^[a-z]{3}_[A-Z][a-z]{3}$/;
              this.language_codes = this.special_tokens.filter((x) => this.languageRegex.test(x));
              this.lang_to_token = (x) => x;
            }
            /**
             * Helper function to build translation inputs for an `NllbTokenizer`.
             * @param {string|string[]} raw_inputs The text to tokenize.
             * @param {Object} tokenizer_options Options to be sent to the tokenizer
             * @param {Object} generate_kwargs Generation options.
             * @returns {Object} Object to be passed to the model.
             */
            _build_translation_inputs(raw_inputs, tokenizer_options, generate_kwargs) {
              return _build_translation_inputs(this, raw_inputs, tokenizer_options, generate_kwargs);
            }
          }
          class M2M100Tokenizer extends PreTrainedTokenizer {
            constructor(tokenizerJSON, tokenizerConfig) {
              super(tokenizerJSON, tokenizerConfig);
              this.languageRegex = /^__[a-z]{2,3}__$/;
              this.language_codes = this.special_tokens.filter((x) => this.languageRegex.test(x)).map((x) => x.slice(2, -2));
              this.lang_to_token = (x) => `__${x}__`;
            }
            /**
             * Helper function to build translation inputs for an `M2M100Tokenizer`.
             * @param {string|string[]} raw_inputs The text to tokenize.
             * @param {Object} tokenizer_options Options to be sent to the tokenizer
             * @param {Object} generate_kwargs Generation options.
             * @returns {Object} Object to be passed to the model.
             */
            _build_translation_inputs(raw_inputs, tokenizer_options, generate_kwargs) {
              return _build_translation_inputs(this, raw_inputs, tokenizer_options, generate_kwargs);
            }
          }
          const WHISPER_LANGUAGES = [
            ["en", "english"],
            ["zh", "chinese"],
            ["de", "german"],
            ["es", "spanish"],
            ["ru", "russian"],
            ["ko", "korean"],
            ["fr", "french"],
            ["ja", "japanese"],
            ["pt", "portuguese"],
            ["tr", "turkish"],
            ["pl", "polish"],
            ["ca", "catalan"],
            ["nl", "dutch"],
            ["ar", "arabic"],
            ["sv", "swedish"],
            ["it", "italian"],
            ["id", "indonesian"],
            ["hi", "hindi"],
            ["fi", "finnish"],
            ["vi", "vietnamese"],
            ["he", "hebrew"],
            ["uk", "ukrainian"],
            ["el", "greek"],
            ["ms", "malay"],
            ["cs", "czech"],
            ["ro", "romanian"],
            ["da", "danish"],
            ["hu", "hungarian"],
            ["ta", "tamil"],
            ["no", "norwegian"],
            ["th", "thai"],
            ["ur", "urdu"],
            ["hr", "croatian"],
            ["bg", "bulgarian"],
            ["lt", "lithuanian"],
            ["la", "latin"],
            ["mi", "maori"],
            ["ml", "malayalam"],
            ["cy", "welsh"],
            ["sk", "slovak"],
            ["te", "telugu"],
            ["fa", "persian"],
            ["lv", "latvian"],
            ["bn", "bengali"],
            ["sr", "serbian"],
            ["az", "azerbaijani"],
            ["sl", "slovenian"],
            ["kn", "kannada"],
            ["et", "estonian"],
            ["mk", "macedonian"],
            ["br", "breton"],
            ["eu", "basque"],
            ["is", "icelandic"],
            ["hy", "armenian"],
            ["ne", "nepali"],
            ["mn", "mongolian"],
            ["bs", "bosnian"],
            ["kk", "kazakh"],
            ["sq", "albanian"],
            ["sw", "swahili"],
            ["gl", "galician"],
            ["mr", "marathi"],
            ["pa", "punjabi"],
            ["si", "sinhala"],
            ["km", "khmer"],
            ["sn", "shona"],
            ["yo", "yoruba"],
            ["so", "somali"],
            ["af", "afrikaans"],
            ["oc", "occitan"],
            ["ka", "georgian"],
            ["be", "belarusian"],
            ["tg", "tajik"],
            ["sd", "sindhi"],
            ["gu", "gujarati"],
            ["am", "amharic"],
            ["yi", "yiddish"],
            ["lo", "lao"],
            ["uz", "uzbek"],
            ["fo", "faroese"],
            ["ht", "haitian creole"],
            ["ps", "pashto"],
            ["tk", "turkmen"],
            ["nn", "nynorsk"],
            ["mt", "maltese"],
            ["sa", "sanskrit"],
            ["lb", "luxembourgish"],
            ["my", "myanmar"],
            ["bo", "tibetan"],
            ["tl", "tagalog"],
            ["mg", "malagasy"],
            ["as", "assamese"],
            ["tt", "tatar"],
            ["haw", "hawaiian"],
            ["ln", "lingala"],
            ["ha", "hausa"],
            ["ba", "bashkir"],
            ["jw", "javanese"],
            ["su", "sundanese"]
          ];
          const WHISPER_LANGUAGE_MAPPING = new Map(WHISPER_LANGUAGES);
          const WHISPER_TO_LANGUAGE_CODE_MAPPING = new Map([
            ...WHISPER_LANGUAGES.map(([k, v]) => [v, k]),
            ...[
              ["burmese", "my"],
              ["valencian", "ca"],
              ["flemish", "nl"],
              ["haitian", "ht"],
              ["letzeburgesch", "lb"],
              ["pushto", "ps"],
              ["panjabi", "pa"],
              ["moldavian", "ro"],
              ["moldovan", "ro"],
              ["sinhalese", "si"],
              ["castilian", "es"]
            ]
          ]);
          class WhisperTokenizer extends PreTrainedTokenizer {
            constructor() {
              super(...arguments);
              __publicField(this, "_default_chat_template", `{% for message in messages %}" "{{ message.content }}{{ eos_token }}" "{% endfor %}`);
            }
            /**
             * Decodes automatic speech recognition (ASR) sequences.
             * @param {Array<{tokens: number[], token_timestamps?: number[], stride: number[]}>} sequences The sequences to decode.
             * @param {Object} options The options to use for decoding.
             * @returns {Array<string|{chunks?: undefined|Array<{language: string|null, timestamp: Array<number|null>, text: string}>}>} The decoded sequences.
             */
            _decode_asr(sequences, {
              return_timestamps = false,
              return_language = false,
              time_precision = null,
              force_full_sequences = true
            } = {}) {
              if (time_precision === null) {
                throw Error("Must specify time_precision");
              }
              let last_language = null;
              const returnWordTimestamps = return_timestamps === "word";
              function new_chunk() {
                return { "language": last_language, "timestamp": [null, null], "text": "" };
              }
              const chunks = [];
              let chunk = new_chunk();
              let time_offset = 0;
              const timestamp_begin = this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0] + 1;
              let previous_tokens = [];
              let previous_token_timestamps = [];
              let skip = false;
              let right_stride_start = null;
              const all_special_ids = new Set(this.all_special_ids);
              for (const output of sequences) {
                const token_ids = output.tokens;
                const token_timestamps = returnWordTimestamps ? output.token_timestamps : null;
                let last_timestamp = null;
                let first_timestamp = timestamp_begin;
                if ("stride" in output) {
                  const [chunk_len, stride_left, stride_right] = output.stride;
                  time_offset -= stride_left;
                  right_stride_start = chunk_len - stride_right;
                  if (stride_left) {
                    first_timestamp = stride_left / time_precision + timestamp_begin;
                  }
                  if (stride_right) {
                    for (let i = token_ids.length - 1; i >= 0; --i) {
                      const token = token_ids[i];
                      if (token >= timestamp_begin) {
                        if (last_timestamp !== null && (token - timestamp_begin) * time_precision < right_stride_start) {
                          break;
                        }
                        last_timestamp = token;
                      }
                    }
                  }
                }
                let current_tokens = [];
                let current_token_timestamps = [];
                for (let i = 0; i < token_ids.length; ++i) {
                  const token = token_ids[i];
                  if (all_special_ids.has(token)) {
                    const text2 = this.decode([token]);
                    const language = WHISPER_LANGUAGE_MAPPING.get(text2.slice(2, -2));
                    if (language !== void 0) {
                      if (last_language !== null && language !== last_language && !return_timestamps) {
                        previous_tokens.push(current_tokens);
                        const resolved_tokens = this.findLongestCommonSequence(previous_tokens)[0];
                        const resolved_text = this.decode(resolved_tokens);
                        chunk.text = resolved_text;
                        chunks.push(chunk);
                        previous_tokens = [];
                        current_tokens = [];
                        chunk = new_chunk();
                      }
                      last_language = chunk.language = language;
                    } else {
                    }
                  } else if (token >= timestamp_begin) {
                    const time = (token - timestamp_begin) * time_precision + time_offset;
                    const rounded_time = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.round)(time, 2);
                    if (last_timestamp !== null && token >= last_timestamp) {
                      skip = true;
                    } else if (skip || previous_tokens.length > 0 && token < first_timestamp) {
                      skip = false;
                    } else if (chunk.timestamp[0] === null) {
                      chunk.timestamp[0] = rounded_time;
                    } else {
                      if (rounded_time === chunk.timestamp[0]) {
                      } else {
                        chunk.timestamp[1] = rounded_time;
                        previous_tokens.push(current_tokens);
                        if (returnWordTimestamps) {
                          previous_token_timestamps.push(current_token_timestamps);
                        }
                        const [resolved_tokens, resolved_token_timestamps] = this.findLongestCommonSequence(
                          previous_tokens,
                          previous_token_timestamps
                        );
                        const resolved_text = this.decode(resolved_tokens);
                        chunk.text = resolved_text;
                        if (returnWordTimestamps) {
                          chunk.words = this.collateWordTimestamps(
                            resolved_tokens,
                            resolved_token_timestamps,
                            last_language
                          );
                        }
                        chunks.push(chunk);
                        previous_tokens = [];
                        current_tokens = [];
                        previous_token_timestamps = [];
                        current_token_timestamps = [];
                        chunk = new_chunk();
                      }
                    }
                  } else {
                    current_tokens.push(token);
                    if (returnWordTimestamps) {
                      let start_time = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.round)(token_timestamps[i] + time_offset, 2);
                      let end_time;
                      if (i + 1 < token_timestamps.length) {
                        end_time = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.round)(token_timestamps[i + 1] + time_offset, 2);
                      } else {
                        end_time = null;
                      }
                      current_token_timestamps.push([start_time, end_time]);
                    }
                  }
                }
                if ("stride" in output) {
                  const [chunk_len, stride_left, stride_right] = output.stride;
                  time_offset += chunk_len - stride_right;
                }
                if (current_tokens.length > 0) {
                  previous_tokens.push(current_tokens);
                  if (returnWordTimestamps) {
                    previous_token_timestamps.push(current_token_timestamps);
                  }
                } else if (previous_tokens.every((p) => p.length === 0)) {
                  chunk = new_chunk();
                  previous_tokens = [];
                  current_tokens = [];
                  previous_token_timestamps = [];
                  current_token_timestamps = [];
                }
              }
              if (previous_tokens.length > 0) {
                if (force_full_sequences && return_timestamps) {
                  throw new Error(
                    "Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation."
                  );
                }
                const [resolved_tokens, resolved_token_timestamps] = this.findLongestCommonSequence(previous_tokens, previous_token_timestamps);
                const resolved_text = this.decode(resolved_tokens);
                chunk.text = resolved_text;
                if (returnWordTimestamps) {
                  chunk.words = this.collateWordTimestamps(
                    resolved_tokens,
                    resolved_token_timestamps,
                    last_language
                  );
                }
                chunks.push(chunk);
              }
              let optional = /* @__PURE__ */ Object.create(null);
              const full_text = chunks.map((chunk2) => chunk2.text).join("");
              if (return_timestamps || return_language) {
                for (let i = 0; i < chunks.length; ++i) {
                  const chunk2 = chunks[i];
                  if (!return_timestamps) {
                    delete chunk2["timestamp"];
                  }
                  if (!return_language) {
                    delete chunk2["language"];
                  }
                }
                if (returnWordTimestamps) {
                  const new_chunks = [];
                  for (const chunk2 of chunks) {
                    for (const word of chunk2.words) {
                      new_chunks.push(word);
                    }
                  }
                  optional = { "chunks": new_chunks };
                } else {
                  optional = { "chunks": chunks };
                }
              }
              return [full_text, optional];
            }
            /**
             * Finds the longest common sequence among the provided sequences.
             * @param {number[][]} sequences An array of sequences of token ids to compare.
             * @returns {number[][]} The longest common sequence found.
             * @throws {Error} If there is a bug within the function.
             * @private
             */
            findLongestCommonSequence(sequences, token_timestamp_sequences = null) {
              let leftSequence = sequences[0];
              let leftLength = leftSequence.length;
              let totalSequence = [];
              const use_token_timestamp_sequences = Array.isArray(token_timestamp_sequences) && token_timestamp_sequences.length > 0;
              let total_token_timestamp_sequence = use_token_timestamp_sequences ? [] : null;
              let left_token_timestamp_sequence = use_token_timestamp_sequences ? token_timestamp_sequences[0] : null;
              for (let i = 1; i < sequences.length; ++i) {
                const rightSequence = sequences[i];
                let max = 0;
                let maxIndices = [leftLength, leftLength, 0, 0];
                const rightLength = rightSequence.length;
                for (let j = 1; j < leftLength + rightLength; ++j) {
                  const eps = j / 1e4;
                  const leftStart2 = Math.max(0, leftLength - j);
                  const leftStop2 = Math.min(leftLength, leftLength + rightLength - j);
                  const left = leftSequence.slice(leftStart2, leftStop2);
                  const rightStart2 = Math.max(0, j - leftLength);
                  const rightStop2 = Math.min(rightLength, j);
                  const right = rightSequence.slice(rightStart2, rightStop2);
                  if (left.length !== right.length) {
                    throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");
                  }
                  const matches = left.filter((elem, idx) => elem === right[idx]).length;
                  const matching = matches / j + eps;
                  if (matches > 1 && matching > max) {
                    max = matching;
                    maxIndices = [leftStart2, leftStop2, rightStart2, rightStop2];
                  }
                }
                const [leftStart, leftStop, rightStart, rightStop] = maxIndices;
                const leftMid = Math.floor((leftStop + leftStart) / 2);
                const rightMid = Math.floor((rightStop + rightStart) / 2);
                totalSequence.push(...leftSequence.slice(0, leftMid));
                leftSequence = rightSequence.slice(rightMid);
                leftLength = leftSequence.length;
                if (use_token_timestamp_sequences) {
                  total_token_timestamp_sequence.push(...left_token_timestamp_sequence.slice(0, leftMid));
                  left_token_timestamp_sequence = token_timestamp_sequences[i].slice(rightMid);
                }
              }
              totalSequence.push(...leftSequence);
              if (use_token_timestamp_sequences) {
                total_token_timestamp_sequence.push(...left_token_timestamp_sequence);
                return [totalSequence, total_token_timestamp_sequence];
              } else {
                return [totalSequence, []];
              }
            }
            /** @private */
            collateWordTimestamps(tokens, token_timestamps, language) {
              const [words, _, token_indices] = this.combineTokensIntoWords(tokens, language);
              const timings = [];
              for (let i = 0; i < words.length; ++i) {
                const indices = token_indices[i];
                timings.push({
                  text: words[i],
                  timestamp: [
                    token_timestamps[indices.at(0)][0],
                    token_timestamps[indices.at(-1)][1]
                  ]
                });
              }
              return timings;
            }
            /**
             * Groups tokens by word. Returns a tuple containing a list of strings with the words,
             * and a list of `token_id` sequences with the tokens making up each word.
             * @param {number[]} tokens 
             * @param {string} [language] 
             * @param {string} prepend_punctionations 
             * @param {string} append_punctuations 
             * 
             * @private
             */
            combineTokensIntoWords(tokens, language, prepend_punctionations = `"'\u201C\xA1\xBF([{-`, append_punctuations = `"'.\u3002,\uFF0C!\uFF01?\uFF1F:\uFF1A\u201D)]}\u3001`) {
              language = language ?? "english";
              let words, word_tokens, token_indices;
              if (["chinese", "japanese", "thai", "lao", "myanmar"].includes(language)) {
                [words, word_tokens, token_indices] = this.splitTokensOnUnicode(tokens);
              } else {
                [words, word_tokens, token_indices] = this.splitTokensOnSpaces(tokens);
              }
              return this.mergePunctuations(words, word_tokens, token_indices, prepend_punctionations, append_punctuations);
            }
            /** @type {PreTrainedTokenizer['decode']} */
            decode(token_ids, decode_args) {
              let text2;
              if (decode_args && decode_args.decode_with_timestamps) {
                if (token_ids instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor) {
                  token_ids = prepareTensorForDecode(token_ids);
                }
                text2 = this.decodeWithTimestamps(token_ids, decode_args);
              } else {
                text2 = super.decode(token_ids, decode_args);
              }
              return text2;
            }
            /**
             * @param {number[]} token_ids List of token IDs to decode.
             * @param {Object} decode_args Optional arguments for decoding
             * @private
             */
            decodeWithTimestamps(token_ids, decode_args) {
              const time_precision = decode_args?.time_precision ?? 0.02;
              const timestamp_begin = Array.from(this.all_special_ids).at(-1) + 1;
              let outputs = [[]];
              for (const token of token_ids) {
                if (token >= timestamp_begin) {
                  const timestamp = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.round)((token - timestamp_begin) * time_precision, 2);
                  outputs.push(`<|${timestamp}|>`);
                  outputs.push([]);
                } else {
                  outputs[outputs.length - 1].push(token);
                }
              }
              outputs = outputs.map(
                (s) => {
                  if (typeof s === "string") {
                    return s;
                  } else {
                    return super.decode(s, decode_args);
                  }
                }
              );
              return outputs.join("");
            }
            /**
             * Combine tokens into words by splitting at any position where the tokens are decoded as valid unicode points.
             * @param {number[]} tokens 
             * @returns {*}
             * @private
             */
            splitTokensOnUnicode(tokens) {
              const decoded_full = this.decode(tokens, {
                // @ts-ignore
                decode_with_timestamps: true
              });
              const replacement_char = "\uFFFD";
              const words = [];
              const word_tokens = [];
              const token_indices = [];
              let current_tokens = [];
              let current_indices = [];
              let unicode_offset = 0;
              for (let token_idx = 0; token_idx < tokens.length; ++token_idx) {
                const token = tokens[token_idx];
                current_tokens.push(token);
                current_indices.push(token_idx);
                const decoded = this.decode(current_tokens, {
                  // @ts-ignore
                  decode_with_timestamps: true
                });
                if (!decoded.includes(replacement_char) || decoded_full[unicode_offset + decoded.indexOf(replacement_char)] === replacement_char) {
                  words.push(decoded);
                  word_tokens.push(current_tokens);
                  token_indices.push(current_indices);
                  current_tokens = [];
                  current_indices = [];
                  unicode_offset += decoded.length;
                }
              }
              return [words, word_tokens, token_indices];
            }
            /**
             * Combine tokens into words by splitting at whitespace and punctuation tokens.
             * @param {number[]} tokens 
             * @private
             */
            splitTokensOnSpaces(tokens) {
              const [subwords, subword_tokens_list, subword_indices_list] = this.splitTokensOnUnicode(tokens);
              const words = [];
              const word_tokens = [];
              const token_indices = [];
              const punctuationRegex = new RegExp(`^[${PUNCTUATION_REGEX}]$`, "gu");
              for (let i = 0; i < subwords.length; ++i) {
                const subword = subwords[i];
                const subword_tokens = subword_tokens_list[i];
                const subword_indices = subword_indices_list[i];
                const special = subword_tokens[0] >= this.model.tokens_to_ids.get("<|endoftext|>");
                const with_space = subword.startsWith(" ");
                const trimmed = subword.trim();
                const punctuation = punctuationRegex.test(trimmed);
                if (special || with_space || punctuation || words.length === 0) {
                  words.push(subword);
                  word_tokens.push(subword_tokens);
                  token_indices.push(subword_indices);
                } else {
                  const ix = words.length - 1;
                  words[ix] += subword;
                  word_tokens[ix].push(...subword_tokens);
                  token_indices[ix].push(...subword_indices);
                }
              }
              return [words, word_tokens, token_indices];
            }
            /**
             * Merges punctuation tokens with neighboring words.
             * @param {string[]} words 
             * @param {number[][]} tokens 
             * @param {number[][]} indices 
             * @param {string} prepended 
             * @param {string} appended 
             * @private
             */
            mergePunctuations(words, tokens, indices, prepended, appended) {
              const newWords = structuredClone(words);
              const newTokens = structuredClone(tokens);
              const newIndices = structuredClone(indices);
              let i = newWords.length - 2;
              let j = newWords.length - 1;
              while (i >= 0) {
                if (newWords[i].startsWith(" ") && prepended.includes(newWords[i].trim())) {
                  newWords[j] = newWords[i] + newWords[j];
                  newTokens[j] = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(newTokens[i], newTokens[j]);
                  newIndices[j] = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(newIndices[i], newIndices[j]);
                  newWords[i] = "";
                  newTokens[i] = [];
                  newIndices[i] = [];
                } else {
                  j = i;
                }
                --i;
              }
              i = 0;
              j = 1;
              while (j < newWords.length) {
                if (!newWords[i].endsWith(" ") && appended.includes(newWords[j])) {
                  newWords[i] += newWords[j];
                  newTokens[i] = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(newTokens[i], newTokens[j]);
                  newIndices[i] = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(newIndices[i], newIndices[j]);
                  newWords[j] = "";
                  newTokens[j] = [];
                  newIndices[j] = [];
                } else {
                  i = j;
                }
                ++j;
              }
              return [
                newWords.filter((x) => x),
                newTokens.filter((x) => x.length > 0),
                newIndices.filter((x) => x.length > 0)
              ];
            }
            /**
             * Helper function to build translation inputs for a `WhisperTokenizer`,
             * depending on the language, task, and whether to predict timestamp tokens.
             * 
             * Used to override the prefix tokens appended to the start of the label sequence.
             * 
             * **Example: Get ids for a language**
             * ```javascript
             * // instantiate the tokenizer and set the prefix token to Spanish
             * const tokenizer = await WhisperTokenizer.from_pretrained('Xenova/whisper-tiny');
             * const forced_decoder_ids = tokenizer.get_decoder_prompt_ids({ language: 'spanish' });
             * // [(1, 50262), (2, 50363)]
             * ```
             * 
             * @param {Object} options Options to generate the decoder prompt.
             * @param {string} [options.language] The language of the transcription text.
             * The corresponding language id token is appended to the start of the sequence for multilingual
             * speech recognition and speech translation tasks, e.g. for "Spanish" the token "<|es|>" is appended
             * to the start of sequence.
             * @param {string} [options.task] Task identifier to append at the start of sequence (if any).
             * This should be used for mulitlingual fine-tuning, with "transcribe" for speech recognition and
             * "translate" for speech translation.
             * @param {boolean} [options.no_timestamps] Whether to add the <|notimestamps|> token at the start of the sequence.
             * @returns {number[][]} The decoder prompt ids.
             */
            get_decoder_prompt_ids({
              language = null,
              task = null,
              no_timestamps = true
            } = {}) {
              const forced_decoder_ids = [];
              if (language) {
                language = language.toLowerCase();
                let language_code = WHISPER_TO_LANGUAGE_CODE_MAPPING.get(language);
                if (language_code === void 0) {
                  if (WHISPER_LANGUAGE_MAPPING.has(language)) {
                    language_code = language;
                  } else {
                    const is_language_code = language.length === 2;
                    const langs = is_language_code ? WHISPER_LANGUAGE_MAPPING.keys() : WHISPER_LANGUAGE_MAPPING.values();
                    throw new Error(`Language "${language}" is not supported. Must be one of: ${JSON.stringify(langs)}`);
                  }
                }
                const language_token_id = this.model.tokens_to_ids.get(`<|${language_code}|>`);
                if (language_token_id === void 0) {
                  throw new Error(`Unable to find language "${language_code}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);
                }
                forced_decoder_ids.push(language_token_id);
              } else {
                forced_decoder_ids.push(null);
              }
              if (task) {
                task = task.toLowerCase();
                if (task !== "transcribe" && task !== "translate") {
                  throw new Error(`Task "${task}" is not supported. Must be one of: ["transcribe", "translate"]`);
                }
                const task_token_id = this.model.tokens_to_ids.get(`<|${task}|>`);
                if (task_token_id === void 0) {
                  throw new Error(`Unable to find task "${task}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);
                }
                forced_decoder_ids.push(task_token_id);
              } else {
                forced_decoder_ids.push(null);
              }
              if (no_timestamps) {
                const no_timestamps_id = this.model.tokens_to_ids.get(`<|notimestamps|>`);
                if (no_timestamps_id === void 0) {
                  throw new Error('Unable to find "<|notimestamps|>" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.');
                }
                forced_decoder_ids.push(no_timestamps_id);
              }
              return forced_decoder_ids.map((x, i) => [i + 1, x]).filter((x) => x[1] !== null);
            }
          }
          class CodeGenTokenizer extends PreTrainedTokenizer {
          }
          class CLIPTokenizer extends PreTrainedTokenizer {
          }
          class SiglipTokenizer extends PreTrainedTokenizer {
          }
          class MarianTokenizer extends PreTrainedTokenizer {
            /**
             * Create a new MarianTokenizer instance.
             * @param {Object} tokenizerJSON The JSON of the tokenizer.
             * @param {Object} tokenizerConfig The config of the tokenizer.
             */
            constructor(tokenizerJSON, tokenizerConfig) {
              super(tokenizerJSON, tokenizerConfig);
              this.languageRegex = /^(>>\w+<<)\s*/g;
              this.supported_language_codes = this.model.vocab.filter(
                (x) => this.languageRegex.test(x)
              );
              console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.');
            }
            /**
             * Encodes a single text. Overriding this method is necessary since the language codes
             * must be removed before encoding with sentencepiece model.
             * @see https://github.com/huggingface/transformers/blob/12d51db243a00726a548a43cc333390ebae731e3/src/transformers/models/marian/tokenization_marian.py#L204-L213
             *
             * @param {string|null} text The text to encode.
             * @returns {Array} The encoded tokens.
             */
            _encode_text(text2) {
              if (text2 === null)
                return null;
              const [matchInfo, ...remainder] = text2.trim().split(this.languageRegex);
              if (remainder.length === 0) {
                return super._encode_text(matchInfo);
              } else if (remainder.length === 2) {
                const [language, text3] = remainder;
                if (!this.supported_language_codes.includes(language)) {
                  console.warn(`Unsupported language code "${language}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`);
                }
                return (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)([language], super._encode_text(text3));
              }
            }
          }
          class Wav2Vec2CTCTokenizer extends PreTrainedTokenizer {
          }
          class BlenderbotTokenizer extends PreTrainedTokenizer {
            constructor() {
              super(...arguments);
              __publicField(this, "_default_chat_template", `{% for message in messages %}{% if message['role'] == 'user' %}{{ ' ' }}{% endif %}{{ message['content'] }}{% if not loop.last %}{{ '  ' }}{% endif %}{% endfor %}{{ eos_token }}`);
            }
          }
          class BlenderbotSmallTokenizer extends BlenderbotTokenizer {
          }
          class SpeechT5Tokenizer extends PreTrainedTokenizer {
          }
          class NougatTokenizer extends PreTrainedTokenizer {
          }
          class VitsTokenizer extends PreTrainedTokenizer {
            constructor(tokenizerJSON, tokenizerConfig) {
              super(tokenizerJSON, tokenizerConfig);
              this.decoder = new VitsDecoder({});
            }
          }
          class CohereTokenizer extends PreTrainedTokenizer {
          }
          class AutoTokenizer {
            /**
             * Instantiate one of the tokenizer classes of the library from a pretrained model.
             * 
             * The tokenizer class to instantiate is selected based on the `tokenizer_class` property of the config object
             * (either passed as an argument or loaded from `pretrained_model_name_or_path` if possible)
             * 
             * @param {string} pretrained_model_name_or_path The name or path of the pretrained model. Can be either:
             * - A string, the *model id* of a pretrained tokenizer hosted inside a model repo on huggingface.co.
             *   Valid model ids can be located at the root-level, like `bert-base-uncased`, or namespaced under a
             *   user or organization name, like `dbmdz/bert-base-german-cased`.
             * - A path to a *directory* containing tokenizer files, e.g., `./my_model_directory/`.
             * @param {PretrainedTokenizerOptions} options Additional options for loading the tokenizer.
             * 
             * @returns {Promise<PreTrainedTokenizer>} A new instance of the PreTrainedTokenizer class.
             */
            static async from_pretrained(pretrained_model_name_or_path, {
              quantized = true,
              progress_callback = null,
              config: config2 = null,
              cache_dir = null,
              local_files_only = false,
              revision = "main",
              legacy = null
            } = {}) {
              const [tokenizerJSON, tokenizerConfig] = await loadTokenizer(pretrained_model_name_or_path, {
                quantized,
                progress_callback,
                config: config2,
                cache_dir,
                local_files_only,
                revision,
                legacy
              });
              const tokenizerName = tokenizerConfig.tokenizer_class?.replace(/Fast$/, "") ?? "PreTrainedTokenizer";
              let cls = this.TOKENIZER_CLASS_MAPPING[tokenizerName];
              if (!cls) {
                console.warn(`Unknown tokenizer class "${tokenizerName}", attempting to construct from base class.`);
                cls = PreTrainedTokenizer;
              }
              return new cls(tokenizerJSON, tokenizerConfig);
            }
          }
          __publicField(AutoTokenizer, "TOKENIZER_CLASS_MAPPING", {
            T5Tokenizer,
            DistilBertTokenizer,
            CamembertTokenizer,
            DebertaTokenizer,
            DebertaV2Tokenizer,
            BertTokenizer,
            HerbertTokenizer,
            ConvBertTokenizer,
            RoFormerTokenizer,
            XLMTokenizer,
            ElectraTokenizer,
            MobileBertTokenizer,
            SqueezeBertTokenizer,
            AlbertTokenizer,
            GPT2Tokenizer,
            BartTokenizer,
            MBartTokenizer,
            MBart50Tokenizer,
            RobertaTokenizer,
            WhisperTokenizer,
            CodeGenTokenizer,
            CLIPTokenizer,
            SiglipTokenizer,
            MarianTokenizer,
            BloomTokenizer,
            NllbTokenizer,
            M2M100Tokenizer,
            LlamaTokenizer,
            CodeLlamaTokenizer,
            XLMRobertaTokenizer,
            MPNetTokenizer,
            FalconTokenizer,
            GPTNeoXTokenizer,
            EsmTokenizer,
            Wav2Vec2CTCTokenizer,
            BlenderbotTokenizer,
            BlenderbotSmallTokenizer,
            SpeechT5Tokenizer,
            NougatTokenizer,
            VitsTokenizer,
            Qwen2Tokenizer,
            GemmaTokenizer,
            Grok1Tokenizer,
            CohereTokenizer,
            // Base case:
            PreTrainedTokenizer
          });
        }
      ),
      /***/
      "./src/transformers.js": (
        /*!*****************************!*\
          !*** ./src/transformers.js ***!
          \*****************************/
        /***/
        (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "ASTFeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.ASTFeatureExtractor
            ),
            /* harmony export */
            "ASTForAudioClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ASTForAudioClassification
            ),
            /* harmony export */
            "ASTModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ASTModel
            ),
            /* harmony export */
            "ASTPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ASTPreTrainedModel
            ),
            /* harmony export */
            "AlbertForMaskedLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertForMaskedLM
            ),
            /* harmony export */
            "AlbertForQuestionAnswering": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertForQuestionAnswering
            ),
            /* harmony export */
            "AlbertForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertForSequenceClassification
            ),
            /* harmony export */
            "AlbertModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertModel
            ),
            /* harmony export */
            "AlbertPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertPreTrainedModel
            ),
            /* harmony export */
            "AlbertTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.AlbertTokenizer
            ),
            /* harmony export */
            "AudioClassificationPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.AudioClassificationPipeline
            ),
            /* harmony export */
            "AutoConfig": () => (
              /* reexport safe */
              _configs_js__WEBPACK_IMPORTED_MODULE_5__.AutoConfig
            ),
            /* harmony export */
            "AutoModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModel
            ),
            /* harmony export */
            "AutoModelForAudioClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForAudioClassification
            ),
            /* harmony export */
            "AutoModelForAudioFrameClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForAudioFrameClassification
            ),
            /* harmony export */
            "AutoModelForCTC": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForCTC
            ),
            /* harmony export */
            "AutoModelForCausalLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForCausalLM
            ),
            /* harmony export */
            "AutoModelForDepthEstimation": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForDepthEstimation
            ),
            /* harmony export */
            "AutoModelForDocumentQuestionAnswering": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForDocumentQuestionAnswering
            ),
            /* harmony export */
            "AutoModelForImageClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageClassification
            ),
            /* harmony export */
            "AutoModelForImageFeatureExtraction": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageFeatureExtraction
            ),
            /* harmony export */
            "AutoModelForImageMatting": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageMatting
            ),
            /* harmony export */
            "AutoModelForImageSegmentation": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageSegmentation
            ),
            /* harmony export */
            "AutoModelForImageToImage": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageToImage
            ),
            /* harmony export */
            "AutoModelForMaskGeneration": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForMaskGeneration
            ),
            /* harmony export */
            "AutoModelForMaskedLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForMaskedLM
            ),
            /* harmony export */
            "AutoModelForObjectDetection": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForObjectDetection
            ),
            /* harmony export */
            "AutoModelForQuestionAnswering": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForQuestionAnswering
            ),
            /* harmony export */
            "AutoModelForSemanticSegmentation": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSemanticSegmentation
            ),
            /* harmony export */
            "AutoModelForSeq2SeqLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSeq2SeqLM
            ),
            /* harmony export */
            "AutoModelForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSequenceClassification
            ),
            /* harmony export */
            "AutoModelForSpeechSeq2Seq": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSpeechSeq2Seq
            ),
            /* harmony export */
            "AutoModelForTextToSpectrogram": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForTextToSpectrogram
            ),
            /* harmony export */
            "AutoModelForTextToWaveform": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForTextToWaveform
            ),
            /* harmony export */
            "AutoModelForTokenClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForTokenClassification
            ),
            /* harmony export */
            "AutoModelForVision2Seq": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForVision2Seq
            ),
            /* harmony export */
            "AutoModelForXVector": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForXVector
            ),
            /* harmony export */
            "AutoModelForZeroShotObjectDetection": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForZeroShotObjectDetection
            ),
            /* harmony export */
            "AutoProcessor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.AutoProcessor
            ),
            /* harmony export */
            "AutoTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.AutoTokenizer
            ),
            /* harmony export */
            "AutomaticSpeechRecognitionPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.AutomaticSpeechRecognitionPipeline
            ),
            /* harmony export */
            "BartForConditionalGeneration": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BartForConditionalGeneration
            ),
            /* harmony export */
            "BartForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BartForSequenceClassification
            ),
            /* harmony export */
            "BartModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BartModel
            ),
            /* harmony export */
            "BartPretrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BartPretrainedModel
            ),
            /* harmony export */
            "BartTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BartTokenizer
            ),
            /* harmony export */
            "BaseModelOutput": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BaseModelOutput
            ),
            /* harmony export */
            "BeitFeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.BeitFeatureExtractor
            ),
            /* harmony export */
            "BeitForImageClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BeitForImageClassification
            ),
            /* harmony export */
            "BeitModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BeitModel
            ),
            /* harmony export */
            "BeitPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BeitPreTrainedModel
            ),
            /* harmony export */
            "BertForMaskedLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BertForMaskedLM
            ),
            /* harmony export */
            "BertForQuestionAnswering": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BertForQuestionAnswering
            ),
            /* harmony export */
            "BertForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BertForSequenceClassification
            ),
            /* harmony export */
            "BertForTokenClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BertForTokenClassification
            ),
            /* harmony export */
            "BertModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BertModel
            ),
            /* harmony export */
            "BertPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BertPreTrainedModel
            ),
            /* harmony export */
            "BertTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BertTokenizer
            ),
            /* harmony export */
            "BitImageProcessor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.BitImageProcessor
            ),
            /* harmony export */
            "BlenderbotForConditionalGeneration": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotForConditionalGeneration
            ),
            /* harmony export */
            "BlenderbotModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotModel
            ),
            /* harmony export */
            "BlenderbotPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotPreTrainedModel
            ),
            /* harmony export */
            "BlenderbotSmallForConditionalGeneration": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotSmallForConditionalGeneration
            ),
            /* harmony export */
            "BlenderbotSmallModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotSmallModel
            ),
            /* harmony export */
            "BlenderbotSmallPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotSmallPreTrainedModel
            ),
            /* harmony export */
            "BlenderbotSmallTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BlenderbotSmallTokenizer
            ),
            /* harmony export */
            "BlenderbotTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BlenderbotTokenizer
            ),
            /* harmony export */
            "BloomForCausalLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BloomForCausalLM
            ),
            /* harmony export */
            "BloomModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BloomModel
            ),
            /* harmony export */
            "BloomPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.BloomPreTrainedModel
            ),
            /* harmony export */
            "BloomTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BloomTokenizer
            ),
            /* harmony export */
            "CLIPFeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.CLIPFeatureExtractor
            ),
            /* harmony export */
            "CLIPModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPModel
            ),
            /* harmony export */
            "CLIPPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPPreTrainedModel
            ),
            /* harmony export */
            "CLIPSegForImageSegmentation": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPSegForImageSegmentation
            ),
            /* harmony export */
            "CLIPSegModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPSegModel
            ),
            /* harmony export */
            "CLIPSegPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPSegPreTrainedModel
            ),
            /* harmony export */
            "CLIPTextModelWithProjection": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPTextModelWithProjection
            ),
            /* harmony export */
            "CLIPTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CLIPTokenizer
            ),
            /* harmony export */
            "CLIPVisionModelWithProjection": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPVisionModelWithProjection
            ),
            /* harmony export */
            "CamembertForMaskedLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertForMaskedLM
            ),
            /* harmony export */
            "CamembertForQuestionAnswering": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertForQuestionAnswering
            ),
            /* harmony export */
            "CamembertForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertForSequenceClassification
            ),
            /* harmony export */
            "CamembertForTokenClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertForTokenClassification
            ),
            /* harmony export */
            "CamembertModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertModel
            ),
            /* harmony export */
            "CamembertPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertPreTrainedModel
            ),
            /* harmony export */
            "CamembertTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CamembertTokenizer
            ),
            /* harmony export */
            "CausalLMOutput": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.CausalLMOutput
            ),
            /* harmony export */
            "CausalLMOutputWithPast": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.CausalLMOutputWithPast
            ),
            /* harmony export */
            "ChineseCLIPFeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.ChineseCLIPFeatureExtractor
            ),
            /* harmony export */
            "ChineseCLIPModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ChineseCLIPModel
            ),
            /* harmony export */
            "ChineseCLIPPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ChineseCLIPPreTrainedModel
            ),
            /* harmony export */
            "ClapAudioModelWithProjection": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ClapAudioModelWithProjection
            ),
            /* harmony export */
            "ClapFeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.ClapFeatureExtractor
            ),
            /* harmony export */
            "ClapModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ClapModel
            ),
            /* harmony export */
            "ClapPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ClapPreTrainedModel
            ),
            /* harmony export */
            "ClapTextModelWithProjection": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ClapTextModelWithProjection
            ),
            /* harmony export */
            "CodeGenForCausalLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.CodeGenForCausalLM
            ),
            /* harmony export */
            "CodeGenModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.CodeGenModel
            ),
            /* harmony export */
            "CodeGenPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.CodeGenPreTrainedModel
            ),
            /* harmony export */
            "CodeGenTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CodeGenTokenizer
            ),
            /* harmony export */
            "CodeLlamaTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CodeLlamaTokenizer
            ),
            /* harmony export */
            "CohereTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CohereTokenizer
            ),
            /* harmony export */
            "ConvBertForMaskedLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertForMaskedLM
            ),
            /* harmony export */
            "ConvBertForQuestionAnswering": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertForQuestionAnswering
            ),
            /* harmony export */
            "ConvBertForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertForSequenceClassification
            ),
            /* harmony export */
            "ConvBertForTokenClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertForTokenClassification
            ),
            /* harmony export */
            "ConvBertModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertModel
            ),
            /* harmony export */
            "ConvBertPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertPreTrainedModel
            ),
            /* harmony export */
            "ConvBertTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.ConvBertTokenizer
            ),
            /* harmony export */
            "ConvNextFeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.ConvNextFeatureExtractor
            ),
            /* harmony export */
            "ConvNextForImageClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextForImageClassification
            ),
            /* harmony export */
            "ConvNextImageProcessor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.ConvNextImageProcessor
            ),
            /* harmony export */
            "ConvNextModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextModel
            ),
            /* harmony export */
            "ConvNextPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextPreTrainedModel
            ),
            /* harmony export */
            "ConvNextV2ForImageClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextV2ForImageClassification
            ),
            /* harmony export */
            "ConvNextV2Model": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextV2Model
            ),
            /* harmony export */
            "ConvNextV2PreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextV2PreTrainedModel
            ),
            /* harmony export */
            "DPTFeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.DPTFeatureExtractor
            ),
            /* harmony export */
            "DPTForDepthEstimation": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DPTForDepthEstimation
            ),
            /* harmony export */
            "DPTImageProcessor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.DPTImageProcessor
            ),
            /* harmony export */
            "DPTModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DPTModel
            ),
            /* harmony export */
            "DPTPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DPTPreTrainedModel
            ),
            /* harmony export */
            "DebertaForMaskedLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaForMaskedLM
            ),
            /* harmony export */
            "DebertaForQuestionAnswering": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaForQuestionAnswering
            ),
            /* harmony export */
            "DebertaForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaForSequenceClassification
            ),
            /* harmony export */
            "DebertaForTokenClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaForTokenClassification
            ),
            /* harmony export */
            "DebertaModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaModel
            ),
            /* harmony export */
            "DebertaPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaPreTrainedModel
            ),
            /* harmony export */
            "DebertaTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.DebertaTokenizer
            ),
            /* harmony export */
            "DebertaV2ForMaskedLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2ForMaskedLM
            ),
            /* harmony export */
            "DebertaV2ForQuestionAnswering": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2ForQuestionAnswering
            ),
            /* harmony export */
            "DebertaV2ForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2ForSequenceClassification
            ),
            /* harmony export */
            "DebertaV2ForTokenClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2ForTokenClassification
            ),
            /* harmony export */
            "DebertaV2Model": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2Model
            ),
            /* harmony export */
            "DebertaV2PreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2PreTrainedModel
            ),
            /* harmony export */
            "DebertaV2Tokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.DebertaV2Tokenizer
            ),
            /* harmony export */
            "DeiTFeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.DeiTFeatureExtractor
            ),
            /* harmony export */
            "DeiTForImageClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DeiTForImageClassification
            ),
            /* harmony export */
            "DeiTModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DeiTModel
            ),
            /* harmony export */
            "DeiTPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DeiTPreTrainedModel
            ),
            /* harmony export */
            "DepthAnythingForDepthEstimation": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DepthAnythingForDepthEstimation
            ),
            /* harmony export */
            "DepthAnythingPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DepthAnythingPreTrainedModel
            ),
            /* harmony export */
            "DepthEstimationPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.DepthEstimationPipeline
            ),
            /* harmony export */
            "DetrFeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.DetrFeatureExtractor
            ),
            /* harmony export */
            "DetrForObjectDetection": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrForObjectDetection
            ),
            /* harmony export */
            "DetrForSegmentation": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrForSegmentation
            ),
            /* harmony export */
            "DetrModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrModel
            ),
            /* harmony export */
            "DetrObjectDetectionOutput": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrObjectDetectionOutput
            ),
            /* harmony export */
            "DetrPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrPreTrainedModel
            ),
            /* harmony export */
            "DetrSegmentationOutput": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrSegmentationOutput
            ),
            /* harmony export */
            "Dinov2ForImageClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Dinov2ForImageClassification
            ),
            /* harmony export */
            "Dinov2Model": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Dinov2Model
            ),
            /* harmony export */
            "Dinov2PreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Dinov2PreTrainedModel
            ),
            /* harmony export */
            "DistilBertForMaskedLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForMaskedLM
            ),
            /* harmony export */
            "DistilBertForQuestionAnswering": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForQuestionAnswering
            ),
            /* harmony export */
            "DistilBertForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForSequenceClassification
            ),
            /* harmony export */
            "DistilBertForTokenClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForTokenClassification
            ),
            /* harmony export */
            "DistilBertModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertModel
            ),
            /* harmony export */
            "DistilBertPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertPreTrainedModel
            ),
            /* harmony export */
            "DistilBertTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.DistilBertTokenizer
            ),
            /* harmony export */
            "DocumentQuestionAnsweringPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.DocumentQuestionAnsweringPipeline
            ),
            /* harmony export */
            "DonutFeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.DonutFeatureExtractor
            ),
            /* harmony export */
            "DonutSwinModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DonutSwinModel
            ),
            /* harmony export */
            "DonutSwinPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.DonutSwinPreTrainedModel
            ),
            /* harmony export */
            "EfficientNetForImageClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.EfficientNetForImageClassification
            ),
            /* harmony export */
            "EfficientNetImageProcessor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.EfficientNetImageProcessor
            ),
            /* harmony export */
            "EfficientNetModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.EfficientNetModel
            ),
            /* harmony export */
            "EfficientNetPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.EfficientNetPreTrainedModel
            ),
            /* harmony export */
            "ElectraForMaskedLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraForMaskedLM
            ),
            /* harmony export */
            "ElectraForQuestionAnswering": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraForQuestionAnswering
            ),
            /* harmony export */
            "ElectraForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraForSequenceClassification
            ),
            /* harmony export */
            "ElectraForTokenClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraForTokenClassification
            ),
            /* harmony export */
            "ElectraModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraModel
            ),
            /* harmony export */
            "ElectraPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraPreTrainedModel
            ),
            /* harmony export */
            "ElectraTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.ElectraTokenizer
            ),
            /* harmony export */
            "EsmForMaskedLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.EsmForMaskedLM
            ),
            /* harmony export */
            "EsmForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.EsmForSequenceClassification
            ),
            /* harmony export */
            "EsmForTokenClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.EsmForTokenClassification
            ),
            /* harmony export */
            "EsmModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.EsmModel
            ),
            /* harmony export */
            "EsmPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.EsmPreTrainedModel
            ),
            /* harmony export */
            "EsmTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.EsmTokenizer
            ),
            /* harmony export */
            "FFT": () => (
              /* reexport safe */
              _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.FFT
            ),
            /* harmony export */
            "FalconForCausalLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.FalconForCausalLM
            ),
            /* harmony export */
            "FalconModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.FalconModel
            ),
            /* harmony export */
            "FalconPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.FalconPreTrainedModel
            ),
            /* harmony export */
            "FalconTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.FalconTokenizer
            ),
            /* harmony export */
            "FastViTForImageClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.FastViTForImageClassification
            ),
            /* harmony export */
            "FastViTModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.FastViTModel
            ),
            /* harmony export */
            "FastViTPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.FastViTPreTrainedModel
            ),
            /* harmony export */
            "FeatureExtractionPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.FeatureExtractionPipeline
            ),
            /* harmony export */
            "FeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.FeatureExtractor
            ),
            /* harmony export */
            "FillMaskPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.FillMaskPipeline
            ),
            /* harmony export */
            "GLPNFeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.GLPNFeatureExtractor
            ),
            /* harmony export */
            "GLPNForDepthEstimation": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.GLPNForDepthEstimation
            ),
            /* harmony export */
            "GLPNModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.GLPNModel
            ),
            /* harmony export */
            "GLPNPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.GLPNPreTrainedModel
            ),
            /* harmony export */
            "GPT2LMHeadModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.GPT2LMHeadModel
            ),
            /* harmony export */
            "GPT2Model": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.GPT2Model
            ),
            /* harmony export */
            "GPT2PreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.GPT2PreTrainedModel
            ),
            /* harmony export */
            "GPT2Tokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.GPT2Tokenizer
            ),
            /* harmony export */
            "GPTBigCodeForCausalLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTBigCodeForCausalLM
            ),
            /* harmony export */
            "GPTBigCodeModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTBigCodeModel
            ),
            /* harmony export */
            "GPTBigCodePreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTBigCodePreTrainedModel
            ),
            /* harmony export */
            "GPTJForCausalLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTJForCausalLM
            ),
            /* harmony export */
            "GPTJModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTJModel
            ),
            /* harmony export */
            "GPTJPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTJPreTrainedModel
            ),
            /* harmony export */
            "GPTNeoForCausalLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoForCausalLM
            ),
            /* harmony export */
            "GPTNeoModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoModel
            ),
            /* harmony export */
            "GPTNeoPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoPreTrainedModel
            ),
            /* harmony export */
            "GPTNeoXForCausalLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoXForCausalLM
            ),
            /* harmony export */
            "GPTNeoXModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoXModel
            ),
            /* harmony export */
            "GPTNeoXPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoXPreTrainedModel
            ),
            /* harmony export */
            "GPTNeoXTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.GPTNeoXTokenizer
            ),
            /* harmony export */
            "GemmaTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.GemmaTokenizer
            ),
            /* harmony export */
            "Grok1Tokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.Grok1Tokenizer
            ),
            /* harmony export */
            "HerbertTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.HerbertTokenizer
            ),
            /* harmony export */
            "HubertForCTC": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.HubertForCTC
            ),
            /* harmony export */
            "HubertForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.HubertForSequenceClassification
            ),
            /* harmony export */
            "HubertModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.HubertModel
            ),
            /* harmony export */
            "HubertPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.HubertPreTrainedModel
            ),
            /* harmony export */
            "ImageClassificationPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ImageClassificationPipeline
            ),
            /* harmony export */
            "ImageFeatureExtractionPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ImageFeatureExtractionPipeline
            ),
            /* harmony export */
            "ImageFeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.ImageFeatureExtractor
            ),
            /* harmony export */
            "ImageMattingOutput": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ImageMattingOutput
            ),
            /* harmony export */
            "ImageSegmentationPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ImageSegmentationPipeline
            ),
            /* harmony export */
            "ImageToImagePipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ImageToImagePipeline
            ),
            /* harmony export */
            "ImageToTextPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ImageToTextPipeline
            ),
            /* harmony export */
            "LlamaForCausalLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.LlamaForCausalLM
            ),
            /* harmony export */
            "LlamaModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.LlamaModel
            ),
            /* harmony export */
            "LlamaPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.LlamaPreTrainedModel
            ),
            /* harmony export */
            "LlamaTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.LlamaTokenizer
            ),
            /* harmony export */
            "LongT5ForConditionalGeneration": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.LongT5ForConditionalGeneration
            ),
            /* harmony export */
            "LongT5Model": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.LongT5Model
            ),
            /* harmony export */
            "LongT5PreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.LongT5PreTrainedModel
            ),
            /* harmony export */
            "M2M100ForConditionalGeneration": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.M2M100ForConditionalGeneration
            ),
            /* harmony export */
            "M2M100Model": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.M2M100Model
            ),
            /* harmony export */
            "M2M100PreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.M2M100PreTrainedModel
            ),
            /* harmony export */
            "M2M100Tokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.M2M100Tokenizer
            ),
            /* harmony export */
            "MBart50Tokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MBart50Tokenizer
            ),
            /* harmony export */
            "MBartForCausalLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MBartForCausalLM
            ),
            /* harmony export */
            "MBartForConditionalGeneration": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MBartForConditionalGeneration
            ),
            /* harmony export */
            "MBartForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MBartForSequenceClassification
            ),
            /* harmony export */
            "MBartModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MBartModel
            ),
            /* harmony export */
            "MBartPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MBartPreTrainedModel
            ),
            /* harmony export */
            "MBartTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MBartTokenizer
            ),
            /* harmony export */
            "MPNetForMaskedLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetForMaskedLM
            ),
            /* harmony export */
            "MPNetForQuestionAnswering": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetForQuestionAnswering
            ),
            /* harmony export */
            "MPNetForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetForSequenceClassification
            ),
            /* harmony export */
            "MPNetForTokenClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetForTokenClassification
            ),
            /* harmony export */
            "MPNetModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetModel
            ),
            /* harmony export */
            "MPNetPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetPreTrainedModel
            ),
            /* harmony export */
            "MPNetTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MPNetTokenizer
            ),
            /* harmony export */
            "MT5ForConditionalGeneration": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MT5ForConditionalGeneration
            ),
            /* harmony export */
            "MT5Model": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MT5Model
            ),
            /* harmony export */
            "MT5PreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MT5PreTrainedModel
            ),
            /* harmony export */
            "MarianMTModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MarianMTModel
            ),
            /* harmony export */
            "MarianModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MarianModel
            ),
            /* harmony export */
            "MarianPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MarianPreTrainedModel
            ),
            /* harmony export */
            "MarianTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MarianTokenizer
            ),
            /* harmony export */
            "MaskedLMOutput": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MaskedLMOutput
            ),
            /* harmony export */
            "MistralForCausalLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MistralForCausalLM
            ),
            /* harmony export */
            "MistralModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MistralModel
            ),
            /* harmony export */
            "MistralPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MistralPreTrainedModel
            ),
            /* harmony export */
            "MobileBertForMaskedLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertForMaskedLM
            ),
            /* harmony export */
            "MobileBertForQuestionAnswering": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertForQuestionAnswering
            ),
            /* harmony export */
            "MobileBertForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertForSequenceClassification
            ),
            /* harmony export */
            "MobileBertModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertModel
            ),
            /* harmony export */
            "MobileBertPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertPreTrainedModel
            ),
            /* harmony export */
            "MobileBertTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MobileBertTokenizer
            ),
            /* harmony export */
            "MobileViTFeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.MobileViTFeatureExtractor
            ),
            /* harmony export */
            "MobileViTForImageClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTForImageClassification
            ),
            /* harmony export */
            "MobileViTImageProcessor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.MobileViTImageProcessor
            ),
            /* harmony export */
            "MobileViTModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTModel
            ),
            /* harmony export */
            "MobileViTPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTPreTrainedModel
            ),
            /* harmony export */
            "MobileViTV2ForImageClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTV2ForImageClassification
            ),
            /* harmony export */
            "MobileViTV2Model": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTV2Model
            ),
            /* harmony export */
            "MobileViTV2PreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTV2PreTrainedModel
            ),
            /* harmony export */
            "ModelOutput": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ModelOutput
            ),
            /* harmony export */
            "MptForCausalLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MptForCausalLM
            ),
            /* harmony export */
            "MptModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MptModel
            ),
            /* harmony export */
            "MptPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.MptPreTrainedModel
            ),
            /* harmony export */
            "NllbTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.NllbTokenizer
            ),
            /* harmony export */
            "NomicBertModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.NomicBertModel
            ),
            /* harmony export */
            "NomicBertPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.NomicBertPreTrainedModel
            ),
            /* harmony export */
            "NougatImageProcessor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.NougatImageProcessor
            ),
            /* harmony export */
            "NougatTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.NougatTokenizer
            ),
            /* harmony export */
            "OPTForCausalLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.OPTForCausalLM
            ),
            /* harmony export */
            "OPTModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.OPTModel
            ),
            /* harmony export */
            "OPTPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.OPTPreTrainedModel
            ),
            /* harmony export */
            "ObjectDetectionPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ObjectDetectionPipeline
            ),
            /* harmony export */
            "OwlViTFeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.OwlViTFeatureExtractor
            ),
            /* harmony export */
            "OwlViTForObjectDetection": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.OwlViTForObjectDetection
            ),
            /* harmony export */
            "OwlViTModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.OwlViTModel
            ),
            /* harmony export */
            "OwlViTPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.OwlViTPreTrainedModel
            ),
            /* harmony export */
            "OwlViTProcessor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.OwlViTProcessor
            ),
            /* harmony export */
            "Owlv2ForObjectDetection": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Owlv2ForObjectDetection
            ),
            /* harmony export */
            "Owlv2ImageProcessor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.Owlv2ImageProcessor
            ),
            /* harmony export */
            "Owlv2Model": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Owlv2Model
            ),
            /* harmony export */
            "Owlv2PreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Owlv2PreTrainedModel
            ),
            /* harmony export */
            "PhiForCausalLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.PhiForCausalLM
            ),
            /* harmony export */
            "PhiModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.PhiModel
            ),
            /* harmony export */
            "PhiPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.PhiPreTrainedModel
            ),
            /* harmony export */
            "Pipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.Pipeline
            ),
            /* harmony export */
            "PreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.PreTrainedModel
            ),
            /* harmony export */
            "PreTrainedTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.PreTrainedTokenizer
            ),
            /* harmony export */
            "PretrainedConfig": () => (
              /* reexport safe */
              _configs_js__WEBPACK_IMPORTED_MODULE_5__.PretrainedConfig
            ),
            /* harmony export */
            "PretrainedMixin": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.PretrainedMixin
            ),
            /* harmony export */
            "Processor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.Processor
            ),
            /* harmony export */
            "QuestionAnsweringModelOutput": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.QuestionAnsweringModelOutput
            ),
            /* harmony export */
            "QuestionAnsweringPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.QuestionAnsweringPipeline
            ),
            /* harmony export */
            "Qwen2ForCausalLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Qwen2ForCausalLM
            ),
            /* harmony export */
            "Qwen2Model": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Qwen2Model
            ),
            /* harmony export */
            "Qwen2PreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Qwen2PreTrainedModel
            ),
            /* harmony export */
            "Qwen2Tokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.Qwen2Tokenizer
            ),
            /* harmony export */
            "RawImage": () => (
              /* reexport safe */
              _utils_image_js__WEBPACK_IMPORTED_MODULE_7__.RawImage
            ),
            /* harmony export */
            "ResNetForImageClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ResNetForImageClassification
            ),
            /* harmony export */
            "ResNetModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ResNetModel
            ),
            /* harmony export */
            "ResNetPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ResNetPreTrainedModel
            ),
            /* harmony export */
            "RoFormerForMaskedLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerForMaskedLM
            ),
            /* harmony export */
            "RoFormerForQuestionAnswering": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerForQuestionAnswering
            ),
            /* harmony export */
            "RoFormerForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerForSequenceClassification
            ),
            /* harmony export */
            "RoFormerForTokenClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerForTokenClassification
            ),
            /* harmony export */
            "RoFormerModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerModel
            ),
            /* harmony export */
            "RoFormerPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerPreTrainedModel
            ),
            /* harmony export */
            "RoFormerTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.RoFormerTokenizer
            ),
            /* harmony export */
            "RobertaForMaskedLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForMaskedLM
            ),
            /* harmony export */
            "RobertaForQuestionAnswering": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForQuestionAnswering
            ),
            /* harmony export */
            "RobertaForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForSequenceClassification
            ),
            /* harmony export */
            "RobertaForTokenClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForTokenClassification
            ),
            /* harmony export */
            "RobertaModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaModel
            ),
            /* harmony export */
            "RobertaPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaPreTrainedModel
            ),
            /* harmony export */
            "RobertaTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.RobertaTokenizer
            ),
            /* harmony export */
            "SamImageProcessor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.SamImageProcessor
            ),
            /* harmony export */
            "SamImageSegmentationOutput": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SamImageSegmentationOutput
            ),
            /* harmony export */
            "SamModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SamModel
            ),
            /* harmony export */
            "SamPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SamPreTrainedModel
            ),
            /* harmony export */
            "SamProcessor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.SamProcessor
            ),
            /* harmony export */
            "SeamlessM4TFeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.SeamlessM4TFeatureExtractor
            ),
            /* harmony export */
            "SegformerFeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.SegformerFeatureExtractor
            ),
            /* harmony export */
            "SegformerForImageClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SegformerForImageClassification
            ),
            /* harmony export */
            "SegformerForSemanticSegmentation": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SegformerForSemanticSegmentation
            ),
            /* harmony export */
            "SegformerModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SegformerModel
            ),
            /* harmony export */
            "SegformerPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SegformerPreTrainedModel
            ),
            /* harmony export */
            "Seq2SeqLMOutput": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Seq2SeqLMOutput
            ),
            /* harmony export */
            "SequenceClassifierOutput": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SequenceClassifierOutput
            ),
            /* harmony export */
            "SiglipImageProcessor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.SiglipImageProcessor
            ),
            /* harmony export */
            "SiglipModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SiglipModel
            ),
            /* harmony export */
            "SiglipPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SiglipPreTrainedModel
            ),
            /* harmony export */
            "SiglipTextModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SiglipTextModel
            ),
            /* harmony export */
            "SiglipTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.SiglipTokenizer
            ),
            /* harmony export */
            "SiglipVisionModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SiglipVisionModel
            ),
            /* harmony export */
            "SpeechT5FeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.SpeechT5FeatureExtractor
            ),
            /* harmony export */
            "SpeechT5ForSpeechToText": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SpeechT5ForSpeechToText
            ),
            /* harmony export */
            "SpeechT5ForTextToSpeech": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SpeechT5ForTextToSpeech
            ),
            /* harmony export */
            "SpeechT5HifiGan": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SpeechT5HifiGan
            ),
            /* harmony export */
            "SpeechT5Model": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SpeechT5Model
            ),
            /* harmony export */
            "SpeechT5PreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SpeechT5PreTrainedModel
            ),
            /* harmony export */
            "SpeechT5Processor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.SpeechT5Processor
            ),
            /* harmony export */
            "SpeechT5Tokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.SpeechT5Tokenizer
            ),
            /* harmony export */
            "SqueezeBertForMaskedLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertForMaskedLM
            ),
            /* harmony export */
            "SqueezeBertForQuestionAnswering": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertForQuestionAnswering
            ),
            /* harmony export */
            "SqueezeBertForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertForSequenceClassification
            ),
            /* harmony export */
            "SqueezeBertModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertModel
            ),
            /* harmony export */
            "SqueezeBertPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertPreTrainedModel
            ),
            /* harmony export */
            "SqueezeBertTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.SqueezeBertTokenizer
            ),
            /* harmony export */
            "StableLmForCausalLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.StableLmForCausalLM
            ),
            /* harmony export */
            "StableLmModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.StableLmModel
            ),
            /* harmony export */
            "StableLmPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.StableLmPreTrainedModel
            ),
            /* harmony export */
            "Starcoder2ForCausalLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Starcoder2ForCausalLM
            ),
            /* harmony export */
            "Starcoder2Model": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Starcoder2Model
            ),
            /* harmony export */
            "Starcoder2PreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Starcoder2PreTrainedModel
            ),
            /* harmony export */
            "SummarizationPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.SummarizationPipeline
            ),
            /* harmony export */
            "Swin2SRForImageSuperResolution": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Swin2SRForImageSuperResolution
            ),
            /* harmony export */
            "Swin2SRImageProcessor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.Swin2SRImageProcessor
            ),
            /* harmony export */
            "Swin2SRModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Swin2SRModel
            ),
            /* harmony export */
            "Swin2SRPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Swin2SRPreTrainedModel
            ),
            /* harmony export */
            "SwinForImageClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SwinForImageClassification
            ),
            /* harmony export */
            "SwinModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SwinModel
            ),
            /* harmony export */
            "SwinPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.SwinPreTrainedModel
            ),
            /* harmony export */
            "T5ForConditionalGeneration": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.T5ForConditionalGeneration
            ),
            /* harmony export */
            "T5Model": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.T5Model
            ),
            /* harmony export */
            "T5PreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.T5PreTrainedModel
            ),
            /* harmony export */
            "T5Tokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.T5Tokenizer
            ),
            /* harmony export */
            "TableTransformerForObjectDetection": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.TableTransformerForObjectDetection
            ),
            /* harmony export */
            "TableTransformerModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.TableTransformerModel
            ),
            /* harmony export */
            "TableTransformerObjectDetectionOutput": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.TableTransformerObjectDetectionOutput
            ),
            /* harmony export */
            "TableTransformerPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.TableTransformerPreTrainedModel
            ),
            /* harmony export */
            "Tensor": () => (
              /* reexport safe */
              _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.Tensor
            ),
            /* harmony export */
            "Text2TextGenerationPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.Text2TextGenerationPipeline
            ),
            /* harmony export */
            "TextClassificationPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.TextClassificationPipeline
            ),
            /* harmony export */
            "TextGenerationPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.TextGenerationPipeline
            ),
            /* harmony export */
            "TextToAudioPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.TextToAudioPipeline
            ),
            /* harmony export */
            "TokenClassificationPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.TokenClassificationPipeline
            ),
            /* harmony export */
            "TokenClassifierOutput": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.TokenClassifierOutput
            ),
            /* harmony export */
            "TokenizerModel": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.TokenizerModel
            ),
            /* harmony export */
            "TrOCRForCausalLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.TrOCRForCausalLM
            ),
            /* harmony export */
            "TrOCRPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.TrOCRPreTrainedModel
            ),
            /* harmony export */
            "TranslationPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.TranslationPipeline
            ),
            /* harmony export */
            "UniSpeechForCTC": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechForCTC
            ),
            /* harmony export */
            "UniSpeechForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechForSequenceClassification
            ),
            /* harmony export */
            "UniSpeechModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechModel
            ),
            /* harmony export */
            "UniSpeechPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechPreTrainedModel
            ),
            /* harmony export */
            "UniSpeechSatForAudioFrameClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechSatForAudioFrameClassification
            ),
            /* harmony export */
            "UniSpeechSatForCTC": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechSatForCTC
            ),
            /* harmony export */
            "UniSpeechSatForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechSatForSequenceClassification
            ),
            /* harmony export */
            "UniSpeechSatModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechSatModel
            ),
            /* harmony export */
            "UniSpeechSatPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechSatPreTrainedModel
            ),
            /* harmony export */
            "ViTFeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.ViTFeatureExtractor
            ),
            /* harmony export */
            "ViTForImageClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ViTForImageClassification
            ),
            /* harmony export */
            "ViTImageProcessor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.ViTImageProcessor
            ),
            /* harmony export */
            "ViTModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ViTModel
            ),
            /* harmony export */
            "ViTPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.ViTPreTrainedModel
            ),
            /* harmony export */
            "VisionEncoderDecoderModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.VisionEncoderDecoderModel
            ),
            /* harmony export */
            "VitMatteForImageMatting": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.VitMatteForImageMatting
            ),
            /* harmony export */
            "VitMatteImageProcessor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.VitMatteImageProcessor
            ),
            /* harmony export */
            "VitMattePreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.VitMattePreTrainedModel
            ),
            /* harmony export */
            "VitsModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.VitsModel
            ),
            /* harmony export */
            "VitsModelOutput": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.VitsModelOutput
            ),
            /* harmony export */
            "VitsPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.VitsPreTrainedModel
            ),
            /* harmony export */
            "VitsTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.VitsTokenizer
            ),
            /* harmony export */
            "Wav2Vec2BertForCTC": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2BertForCTC
            ),
            /* harmony export */
            "Wav2Vec2BertForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2BertForSequenceClassification
            ),
            /* harmony export */
            "Wav2Vec2BertModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2BertModel
            ),
            /* harmony export */
            "Wav2Vec2BertPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2BertPreTrainedModel
            ),
            /* harmony export */
            "Wav2Vec2CTCTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.Wav2Vec2CTCTokenizer
            ),
            /* harmony export */
            "Wav2Vec2FeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.Wav2Vec2FeatureExtractor
            ),
            /* harmony export */
            "Wav2Vec2ForAudioFrameClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2ForAudioFrameClassification
            ),
            /* harmony export */
            "Wav2Vec2ForCTC": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2ForCTC
            ),
            /* harmony export */
            "Wav2Vec2ForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2ForSequenceClassification
            ),
            /* harmony export */
            "Wav2Vec2Model": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2Model
            ),
            /* harmony export */
            "Wav2Vec2PreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2PreTrainedModel
            ),
            /* harmony export */
            "Wav2Vec2ProcessorWithLM": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.Wav2Vec2ProcessorWithLM
            ),
            /* harmony export */
            "WavLMForAudioFrameClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMForAudioFrameClassification
            ),
            /* harmony export */
            "WavLMForCTC": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMForCTC
            ),
            /* harmony export */
            "WavLMForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMForSequenceClassification
            ),
            /* harmony export */
            "WavLMForXVector": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMForXVector
            ),
            /* harmony export */
            "WavLMModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMModel
            ),
            /* harmony export */
            "WavLMPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMPreTrainedModel
            ),
            /* harmony export */
            "WhisperFeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.WhisperFeatureExtractor
            ),
            /* harmony export */
            "WhisperForConditionalGeneration": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.WhisperForConditionalGeneration
            ),
            /* harmony export */
            "WhisperModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.WhisperModel
            ),
            /* harmony export */
            "WhisperPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.WhisperPreTrainedModel
            ),
            /* harmony export */
            "WhisperProcessor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.WhisperProcessor
            ),
            /* harmony export */
            "WhisperTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.WhisperTokenizer
            ),
            /* harmony export */
            "XLMForQuestionAnswering": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMForQuestionAnswering
            ),
            /* harmony export */
            "XLMForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMForSequenceClassification
            ),
            /* harmony export */
            "XLMForTokenClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMForTokenClassification
            ),
            /* harmony export */
            "XLMModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMModel
            ),
            /* harmony export */
            "XLMPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMPreTrainedModel
            ),
            /* harmony export */
            "XLMRobertaForMaskedLM": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForMaskedLM
            ),
            /* harmony export */
            "XLMRobertaForQuestionAnswering": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForQuestionAnswering
            ),
            /* harmony export */
            "XLMRobertaForSequenceClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForSequenceClassification
            ),
            /* harmony export */
            "XLMRobertaForTokenClassification": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForTokenClassification
            ),
            /* harmony export */
            "XLMRobertaModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaModel
            ),
            /* harmony export */
            "XLMRobertaPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaPreTrainedModel
            ),
            /* harmony export */
            "XLMRobertaTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.XLMRobertaTokenizer
            ),
            /* harmony export */
            "XLMTokenizer": () => (
              /* reexport safe */
              _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.XLMTokenizer
            ),
            /* harmony export */
            "XLMWithLMHeadModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMWithLMHeadModel
            ),
            /* harmony export */
            "XVectorOutput": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.XVectorOutput
            ),
            /* harmony export */
            "YolosFeatureExtractor": () => (
              /* reexport safe */
              _processors_js__WEBPACK_IMPORTED_MODULE_4__.YolosFeatureExtractor
            ),
            /* harmony export */
            "YolosForObjectDetection": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.YolosForObjectDetection
            ),
            /* harmony export */
            "YolosModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.YolosModel
            ),
            /* harmony export */
            "YolosObjectDetectionOutput": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.YolosObjectDetectionOutput
            ),
            /* harmony export */
            "YolosPreTrainedModel": () => (
              /* reexport safe */
              _models_js__WEBPACK_IMPORTED_MODULE_2__.YolosPreTrainedModel
            ),
            /* harmony export */
            "ZeroShotAudioClassificationPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ZeroShotAudioClassificationPipeline
            ),
            /* harmony export */
            "ZeroShotClassificationPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ZeroShotClassificationPipeline
            ),
            /* harmony export */
            "ZeroShotImageClassificationPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ZeroShotImageClassificationPipeline
            ),
            /* harmony export */
            "ZeroShotObjectDetectionPipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ZeroShotObjectDetectionPipeline
            ),
            /* harmony export */
            "bankers_round": () => (
              /* reexport safe */
              _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.bankers_round
            ),
            /* harmony export */
            "cat": () => (
              /* reexport safe */
              _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.cat
            ),
            /* harmony export */
            "cos_sim": () => (
              /* reexport safe */
              _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.cos_sim
            ),
            /* harmony export */
            "dot": () => (
              /* reexport safe */
              _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.dot
            ),
            /* harmony export */
            "dynamicTimeWarping": () => (
              /* reexport safe */
              _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.dynamicTimeWarping
            ),
            /* harmony export */
            "env": () => (
              /* reexport safe */
              _env_js__WEBPACK_IMPORTED_MODULE_1__.env
            ),
            /* harmony export */
            "getTopItems": () => (
              /* reexport safe */
              _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.getTopItems
            ),
            /* harmony export */
            "hanning": () => (
              /* reexport safe */
              _utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.hanning
            ),
            /* harmony export */
            "interpolate": () => (
              /* reexport safe */
              _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.interpolate
            ),
            /* harmony export */
            "interpolate_data": () => (
              /* reexport safe */
              _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.interpolate_data
            ),
            /* harmony export */
            "layer_norm": () => (
              /* reexport safe */
              _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.layer_norm
            ),
            /* harmony export */
            "log_softmax": () => (
              /* reexport safe */
              _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.log_softmax
            ),
            /* harmony export */
            "magnitude": () => (
              /* reexport safe */
              _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.magnitude
            ),
            /* harmony export */
            "max": () => (
              /* reexport safe */
              _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.max
            ),
            /* harmony export */
            "mean": () => (
              /* reexport safe */
              _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.mean
            ),
            /* harmony export */
            "mean_pooling": () => (
              /* reexport safe */
              _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.mean_pooling
            ),
            /* harmony export */
            "medianFilter": () => (
              /* reexport safe */
              _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.medianFilter
            ),
            /* harmony export */
            "mel_filter_bank": () => (
              /* reexport safe */
              _utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.mel_filter_bank
            ),
            /* harmony export */
            "min": () => (
              /* reexport safe */
              _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.min
            ),
            /* harmony export */
            "ones": () => (
              /* reexport safe */
              _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.ones
            ),
            /* harmony export */
            "ones_like": () => (
              /* reexport safe */
              _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.ones_like
            ),
            /* harmony export */
            "permute": () => (
              /* reexport safe */
              _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.permute
            ),
            /* harmony export */
            "permute_data": () => (
              /* reexport safe */
              _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.permute_data
            ),
            /* harmony export */
            "pipeline": () => (
              /* reexport safe */
              _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.pipeline
            ),
            /* harmony export */
            "quantize_embeddings": () => (
              /* reexport safe */
              _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.quantize_embeddings
            ),
            /* harmony export */
            "read_audio": () => (
              /* reexport safe */
              _utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.read_audio
            ),
            /* harmony export */
            "round": () => (
              /* reexport safe */
              _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.round
            ),
            /* harmony export */
            "softmax": () => (
              /* reexport safe */
              _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.softmax
            ),
            /* harmony export */
            "spectrogram": () => (
              /* reexport safe */
              _utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.spectrogram
            ),
            /* harmony export */
            "stack": () => (
              /* reexport safe */
              _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.stack
            ),
            /* harmony export */
            "std_mean": () => (
              /* reexport safe */
              _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.std_mean
            ),
            /* harmony export */
            "window_function": () => (
              /* reexport safe */
              _utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.window_function
            )
            /* harmony export */
          });
          var _pipelines_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__3(
            /*! ./pipelines.js */
            "./src/pipelines.js"
          );
          var _env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__3(
            /*! ./env.js */
            "./src/env.js"
          );
          var _models_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__3(
            /*! ./models.js */
            "./src/models.js"
          );
          var _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__3(
            /*! ./tokenizers.js */
            "./src/tokenizers.js"
          );
          var _processors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__3(
            /*! ./processors.js */
            "./src/processors.js"
          );
          var _configs_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__3(
            /*! ./configs.js */
            "./src/configs.js"
          );
          var _utils_audio_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__3(
            /*! ./utils/audio.js */
            "./src/utils/audio.js"
          );
          var _utils_image_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__3(
            /*! ./utils/image.js */
            "./src/utils/image.js"
          );
          var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__3(
            /*! ./utils/tensor.js */
            "./src/utils/tensor.js"
          );
          var _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__3(
            /*! ./utils/maths.js */
            "./src/utils/maths.js"
          );
        }
      ),
      /***/
      "./src/utils/audio.js": (
        /*!****************************!*\
          !*** ./src/utils/audio.js ***!
          \****************************/
        /***/
        (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "hanning": () => (
              /* binding */
              hanning
            ),
            /* harmony export */
            "mel_filter_bank": () => (
              /* binding */
              mel_filter_bank
            ),
            /* harmony export */
            "read_audio": () => (
              /* binding */
              read_audio
            ),
            /* harmony export */
            "spectrogram": () => (
              /* binding */
              spectrogram
            ),
            /* harmony export */
            "window_function": () => (
              /* binding */
              window_function
            )
            /* harmony export */
          });
          var _hub_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__3(
            /*! ./hub.js */
            "./src/utils/hub.js"
          );
          var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__3(
            /*! ./maths.js */
            "./src/utils/maths.js"
          );
          var _core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__3(
            /*! ./core.js */
            "./src/utils/core.js"
          );
          async function read_audio(url, sampling_rate) {
            if (typeof AudioContext === "undefined") {
              throw Error(
                "Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing."
              );
            }
            const response = await (await (0, _hub_js__WEBPACK_IMPORTED_MODULE_0__.getFile)(url)).arrayBuffer();
            const audioCTX = new AudioContext({ sampleRate: sampling_rate });
            if (typeof sampling_rate === "undefined") {
              console.warn(`No sampling rate provided, using default of ${audioCTX.sampleRate}Hz.`);
            }
            const decoded = await audioCTX.decodeAudioData(response);
            let audio;
            if (decoded.numberOfChannels === 2) {
              const SCALING_FACTOR = Math.sqrt(2);
              const left = decoded.getChannelData(0);
              const right = decoded.getChannelData(1);
              audio = new Float32Array(left.length);
              for (let i = 0; i < decoded.length; ++i) {
                audio[i] = SCALING_FACTOR * (left[i] + right[i]) / 2;
              }
            } else {
              audio = decoded.getChannelData(0);
            }
            return audio;
          }
          function hanning(M) {
            if (M < 1) {
              return new Float64Array();
            }
            if (M === 1) {
              return new Float64Array([1]);
            }
            const denom = M - 1;
            const factor = Math.PI / denom;
            const cos_vals = new Float64Array(M);
            for (let i = 0; i < M; ++i) {
              const n = 2 * i - denom;
              cos_vals[i] = 0.5 + 0.5 * Math.cos(factor * n);
            }
            return cos_vals;
          }
          const HERTZ_TO_MEL_MAPPING = {
            "htk": (freq) => 2595 * Math.log10(1 + freq / 700),
            "kaldi": (freq) => 1127 * Math.log(1 + freq / 700),
            "slaney": (freq, min_log_hertz = 1e3, min_log_mel = 15, logstep = 27 / Math.log(6.4)) => freq >= min_log_hertz ? min_log_mel + Math.log(freq / min_log_hertz) * logstep : 3 * freq / 200
          };
          function hertz_to_mel(freq, mel_scale = "htk") {
            const fn = HERTZ_TO_MEL_MAPPING[mel_scale];
            if (!fn) {
              throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');
            }
            return typeof freq === "number" ? fn(freq) : freq.map((x) => fn(x));
          }
          const MEL_TO_HERTZ_MAPPING = {
            "htk": (mels) => 700 * (10 ** (mels / 2595) - 1),
            "kaldi": (mels) => 700 * (Math.exp(mels / 1127) - 1),
            "slaney": (mels, min_log_hertz = 1e3, min_log_mel = 15, logstep = Math.log(6.4) / 27) => mels >= min_log_mel ? min_log_hertz * Math.exp(logstep * (mels - min_log_mel)) : 200 * mels / 3
          };
          function mel_to_hertz(mels, mel_scale = "htk") {
            const fn = MEL_TO_HERTZ_MAPPING[mel_scale];
            if (!fn) {
              throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');
            }
            return typeof mels === "number" ? fn(mels) : mels.map((x) => fn(x));
          }
          function _create_triangular_filter_bank(fft_freqs, filter_freqs) {
            const filter_diff = Float64Array.from(
              { length: filter_freqs.length - 1 },
              (_, i) => filter_freqs[i + 1] - filter_freqs[i]
            );
            const slopes = Array.from({
              length: fft_freqs.length
            }, () => new Array(filter_freqs.length));
            for (let j = 0; j < fft_freqs.length; ++j) {
              const slope = slopes[j];
              for (let i = 0; i < filter_freqs.length; ++i) {
                slope[i] = filter_freqs[i] - fft_freqs[j];
              }
            }
            const numFreqs = filter_freqs.length - 2;
            const ret = Array.from({ length: numFreqs }, () => new Array(fft_freqs.length));
            for (let j = 0; j < fft_freqs.length; ++j) {
              const slope = slopes[j];
              for (let i = 0; i < numFreqs; ++i) {
                const down = -slope[i] / filter_diff[i];
                const up = slope[i + 2] / filter_diff[i + 1];
                ret[i][j] = Math.max(0, Math.min(down, up));
              }
            }
            return ret;
          }
          function linspace(start, end, num) {
            const step = (end - start) / (num - 1);
            return Float64Array.from({ length: num }, (_, i) => start + step * i);
          }
          function mel_filter_bank(num_frequency_bins, num_mel_filters, min_frequency, max_frequency, sampling_rate, norm = null, mel_scale = "htk", triangularize_in_mel_space = false) {
            if (norm !== null && norm !== "slaney") {
              throw new Error('norm must be one of null or "slaney"');
            }
            const mel_min = hertz_to_mel(min_frequency, mel_scale);
            const mel_max = hertz_to_mel(max_frequency, mel_scale);
            const mel_freqs = linspace(mel_min, mel_max, num_mel_filters + 2);
            let filter_freqs = mel_to_hertz(mel_freqs, mel_scale);
            let fft_freqs;
            if (triangularize_in_mel_space) {
              const fft_bin_width = sampling_rate / (num_frequency_bins * 2);
              fft_freqs = hertz_to_mel(Float64Array.from({ length: num_frequency_bins }, (_, i) => i * fft_bin_width), mel_scale);
              filter_freqs = mel_freqs;
            } else {
              fft_freqs = linspace(0, Math.floor(sampling_rate / 2), num_frequency_bins);
            }
            const mel_filters = _create_triangular_filter_bank(fft_freqs, filter_freqs);
            if (norm !== null && norm === "slaney") {
              for (let i = 0; i < num_mel_filters; ++i) {
                const filter = mel_filters[i];
                const enorm = 2 / (filter_freqs[i + 2] - filter_freqs[i]);
                for (let j = 0; j < num_frequency_bins; ++j) {
                  filter[j] *= enorm;
                }
              }
            }
            return mel_filters;
          }
          function padReflect(array, left, right) {
            const padded = new array.constructor(array.length + left + right);
            const w = array.length - 1;
            for (let i = 0; i < array.length; ++i) {
              padded[left + i] = array[i];
            }
            for (let i = 1; i <= left; ++i) {
              padded[left - i] = array[(0, _core_js__WEBPACK_IMPORTED_MODULE_2__.calculateReflectOffset)(i, w)];
            }
            for (let i = 1; i <= right; ++i) {
              padded[w + left + i] = array[(0, _core_js__WEBPACK_IMPORTED_MODULE_2__.calculateReflectOffset)(w - i, w)];
            }
            return padded;
          }
          function _db_conversion_helper(spectrogram2, factor, reference2, min_value, db_range) {
            if (reference2 <= 0) {
              throw new Error("reference must be greater than zero");
            }
            if (min_value <= 0) {
              throw new Error("min_value must be greater than zero");
            }
            reference2 = Math.max(min_value, reference2);
            const logReference = Math.log10(reference2);
            for (let i = 0; i < spectrogram2.length; ++i) {
              spectrogram2[i] = factor * Math.log10(Math.max(min_value, spectrogram2[i]) - logReference);
            }
            if (db_range !== null) {
              if (db_range <= 0) {
                throw new Error("db_range must be greater than zero");
              }
              const maxValue = (0, _maths_js__WEBPACK_IMPORTED_MODULE_1__.max)(spectrogram2)[0] - db_range;
              for (let i = 0; i < spectrogram2.length; ++i) {
                spectrogram2[i] = Math.max(spectrogram2[i], maxValue);
              }
            }
            return spectrogram2;
          }
          function amplitude_to_db(spectrogram2, reference2 = 1, min_value = 1e-5, db_range = null) {
            return _db_conversion_helper(spectrogram2, 20, reference2, min_value, db_range);
          }
          function power_to_db(spectrogram2, reference2 = 1, min_value = 1e-10, db_range = null) {
            return _db_conversion_helper(spectrogram2, 10, reference2, min_value, db_range);
          }
          function spectrogram(waveform, window2, frame_length, hop_length, {
            fft_length = null,
            power = 1,
            center = true,
            pad_mode = "reflect",
            onesided = true,
            preemphasis = null,
            mel_filters = null,
            mel_floor = 1e-10,
            log_mel = null,
            reference: reference2 = 1,
            min_value = 1e-10,
            db_range = null,
            remove_dc_offset = null,
            // Custom parameters for efficiency reasons
            max_num_frames = null,
            do_pad = true,
            transpose = false
          } = {}) {
            const window_length = window2.length;
            if (fft_length === null) {
              fft_length = frame_length;
            }
            if (frame_length > fft_length) {
              throw Error(`frame_length (${frame_length}) may not be larger than fft_length (${fft_length})`);
            }
            if (window_length !== frame_length) {
              throw new Error(`Length of the window (${window_length}) must equal frame_length (${frame_length})`);
            }
            if (hop_length <= 0) {
              throw new Error("hop_length must be greater than zero");
            }
            if (power === null && mel_filters !== null) {
              throw new Error(
                "You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue."
              );
            }
            if (center) {
              if (pad_mode !== "reflect") {
                throw new Error(`pad_mode="${pad_mode}" not implemented yet.`);
              }
              const half_window = Math.floor((fft_length - 1) / 2) + 1;
              waveform = padReflect(waveform, half_window, half_window);
            }
            const num_frames = Math.floor(1 + Math.floor((waveform.length - frame_length) / hop_length));
            const num_frequency_bins = onesided ? Math.floor(fft_length / 2) + 1 : fft_length;
            let d1 = num_frames;
            let d1Max = num_frames;
            if (max_num_frames !== null) {
              if (max_num_frames > num_frames) {
                if (do_pad) {
                  d1Max = max_num_frames;
                }
              } else {
                d1Max = d1 = max_num_frames;
              }
            }
            const fft = new _maths_js__WEBPACK_IMPORTED_MODULE_1__.FFT(fft_length);
            const inputBuffer = new Float64Array(fft_length);
            const outputBuffer = new Float64Array(fft.outputBufferSize);
            const magnitudes = new Array(d1);
            for (let i = 0; i < d1; ++i) {
              const offset = i * hop_length;
              for (let j = 0; j < frame_length; ++j) {
                inputBuffer[j] = waveform[offset + j];
              }
              if (remove_dc_offset) {
                let sum = 0;
                for (let j = 0; j < frame_length; ++j) {
                  sum += inputBuffer[j];
                }
                const mean = sum / frame_length;
                for (let j = 0; j < frame_length; ++j) {
                  inputBuffer[j] -= mean;
                }
              }
              if (preemphasis !== null) {
                for (let j = frame_length - 1; j >= 1; --j) {
                  inputBuffer[j] -= preemphasis * inputBuffer[j - 1];
                }
                inputBuffer[0] *= 1 - preemphasis;
              }
              for (let j = 0; j < window2.length; ++j) {
                inputBuffer[j] *= window2[j];
              }
              fft.realTransform(outputBuffer, inputBuffer);
              const row = new Array(num_frequency_bins);
              for (let j = 0; j < row.length; ++j) {
                const j2 = j << 1;
                row[j] = outputBuffer[j2] ** 2 + outputBuffer[j2 + 1] ** 2;
              }
              magnitudes[i] = row;
            }
            if (power !== null && power !== 2) {
              const pow = 2 / power;
              for (let i = 0; i < magnitudes.length; ++i) {
                const magnitude = magnitudes[i];
                for (let j = 0; j < magnitude.length; ++j) {
                  magnitude[j] **= pow;
                }
              }
            }
            const num_mel_filters = mel_filters.length;
            const mel_spec = new Float32Array(num_mel_filters * d1Max);
            const dims = transpose ? [d1Max, num_mel_filters] : [num_mel_filters, d1Max];
            for (let i = 0; i < num_mel_filters; ++i) {
              const filter = mel_filters[i];
              for (let j = 0; j < d1; ++j) {
                const magnitude = magnitudes[j];
                let sum = 0;
                for (let k = 0; k < num_frequency_bins; ++k) {
                  sum += filter[k] * magnitude[k];
                }
                mel_spec[transpose ? j * num_mel_filters + i : i * d1 + j] = Math.max(mel_floor, sum);
              }
            }
            if (power !== null && log_mel !== null) {
              const o = Math.min(mel_spec.length, d1 * num_mel_filters);
              switch (log_mel) {
                case "log":
                  for (let i = 0; i < o; ++i) {
                    mel_spec[i] = Math.log(mel_spec[i]);
                  }
                  break;
                case "log10":
                  for (let i = 0; i < o; ++i) {
                    mel_spec[i] = Math.log10(mel_spec[i]);
                  }
                  break;
                case "dB":
                  if (power === 1) {
                    amplitude_to_db(mel_spec, reference2, min_value, db_range);
                  } else if (power === 2) {
                    power_to_db(mel_spec, reference2, min_value, db_range);
                  } else {
                    throw new Error(`Cannot use log_mel option '${log_mel}' with power ${power}`);
                  }
                  break;
                default:
                  throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${log_mel}'`);
              }
            }
            return { data: mel_spec, dims };
          }
          function window_function(window_length, name2, {
            periodic = true,
            frame_length = null,
            center = true
          } = {}) {
            const length = periodic ? window_length + 1 : window_length;
            let window2;
            switch (name2) {
              case "boxcar":
                window2 = new Float64Array(length).fill(1);
                break;
              case "hann":
              case "hann_window":
                window2 = hanning(length);
                break;
              case "povey":
                window2 = hanning(length).map((x) => Math.pow(x, 0.85));
                break;
              default:
                throw new Error(`Unknown window type ${name2}.`);
            }
            if (periodic) {
              window2 = window2.subarray(0, window_length);
            }
            if (frame_length === null) {
              return window2;
            }
            if (window_length > frame_length) {
              throw new Error(`Length of the window (${window_length}) may not be larger than frame_length (${frame_length})`);
            }
            return window2;
          }
        }
      ),
      /***/
      "./src/utils/core.js": (
        /*!***************************!*\
          !*** ./src/utils/core.js ***!
          \***************************/
        /***/
        (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "Callable": () => (
              /* binding */
              Callable
            ),
            /* harmony export */
            "calculateDimensions": () => (
              /* binding */
              calculateDimensions
            ),
            /* harmony export */
            "calculateReflectOffset": () => (
              /* binding */
              calculateReflectOffset
            ),
            /* harmony export */
            "dispatchCallback": () => (
              /* binding */
              dispatchCallback
            ),
            /* harmony export */
            "escapeRegExp": () => (
              /* binding */
              escapeRegExp
            ),
            /* harmony export */
            "exists": () => (
              /* binding */
              exists
            ),
            /* harmony export */
            "isIntegralNumber": () => (
              /* binding */
              isIntegralNumber
            ),
            /* harmony export */
            "isTypedArray": () => (
              /* binding */
              isTypedArray
            ),
            /* harmony export */
            "mergeArrays": () => (
              /* binding */
              mergeArrays
            ),
            /* harmony export */
            "pop": () => (
              /* binding */
              pop
            ),
            /* harmony export */
            "product": () => (
              /* binding */
              product
            ),
            /* harmony export */
            "reverseDictionary": () => (
              /* binding */
              reverseDictionary
            )
            /* harmony export */
          });
          function dispatchCallback(progress_callback, data) {
            if (progress_callback)
              progress_callback(data);
          }
          function reverseDictionary(data) {
            return Object.fromEntries(Object.entries(data).map(([key, value]) => [value, key]));
          }
          function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          const Callable = (
            /** @type {any} */
            class {
              /**
              * Creates a new instance of the Callable class.
              */
              constructor() {
                let closure = function(...args) {
                  return closure._call(...args);
                };
                return Object.setPrototypeOf(closure, new.target.prototype);
              }
              /**
               * This method should be implemented in subclasses to provide the
               * functionality of the callable object.
               *
               * @param {any[]} args
               * @throws {Error} If the subclass does not implement the `_call` method.
               */
              _call(...args) {
                throw Error("Must implement _call method in subclass");
              }
            }
          );
          function isTypedArray(val) {
            return val?.prototype?.__proto__?.constructor?.name === "TypedArray";
          }
          function isIntegralNumber(x) {
            return Number.isInteger(x) || typeof x === "bigint";
          }
          function exists(x) {
            return x !== void 0 && x !== null;
          }
          function calculateDimensions(arr) {
            const dimensions = [];
            let current = arr;
            while (Array.isArray(current)) {
              dimensions.push(current.length);
              current = current[0];
            }
            return dimensions;
          }
          function pop(obj, key, defaultValue = void 0) {
            const value = obj[key];
            if (value !== void 0) {
              delete obj[key];
              return value;
            }
            if (defaultValue === void 0) {
              throw Error(`Key ${key} does not exist in object.`);
            }
            return defaultValue;
          }
          function mergeArrays(...arrs) {
            return Array.prototype.concat.apply([], arrs);
          }
          function product(...a) {
            return a.reduce((a2, b) => a2.flatMap((d) => b.map((e) => [d, e])));
          }
          function calculateReflectOffset(i, w) {
            return Math.abs((i + w) % (2 * w) - w);
          }
        }
      ),
      /***/
      "./src/utils/data-structures.js": (
        /*!**************************************!*\
          !*** ./src/utils/data-structures.js ***!
          \**************************************/
        /***/
        (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "CharTrie": () => (
              /* binding */
              CharTrie
            ),
            /* harmony export */
            "PriorityQueue": () => (
              /* binding */
              PriorityQueue
            ),
            /* harmony export */
            "TokenLattice": () => (
              /* binding */
              TokenLattice
            )
            /* harmony export */
          });
          class PriorityQueue {
            /**
             * Create a new PriorityQueue.
             * @param {Function} comparator Comparator function to determine priority. Defaults to a MaxHeap.
             */
            constructor(comparator = (a, b) => a > b) {
              this._heap = [];
              this._comparator = comparator;
            }
            /**
             * The size of the queue
             */
            get size() {
              return this._heap.length;
            }
            /**
             * Check if the queue is empty.
             * @returns {boolean} `true` if the queue is empty, `false` otherwise.
             */
            isEmpty() {
              return this.size === 0;
            }
            /**
             * Return the element with the highest priority in the queue.
             * @returns {any} The highest priority element in the queue.
             */
            peek() {
              return this._heap[0];
            }
            /**
             * Add one or more elements to the queue.
             * @param  {...any} values The values to push into the queue.
             * @returns {number} The new size of the queue.
             */
            push(...values) {
              return this.extend(values);
            }
            /**
             * Add multiple elements to the queue.
             * @param {any[]} values The values to push into the queue.
             * @returns {number} The new size of the queue.
             */
            extend(values) {
              for (const value of values) {
                this._heap.push(value);
                this._siftUp();
              }
              return this.size;
            }
            /**
             * Remove and return the element with the highest priority in the queue.
             * @returns {any} The element with the highest priority in the queue.
             */
            pop() {
              const poppedValue = this.peek();
              const bottom = this.size - 1;
              if (bottom > 0) {
                this._swap(0, bottom);
              }
              this._heap.pop();
              this._siftDown();
              return poppedValue;
            }
            /**
             * Replace the element with the highest priority in the queue with a new value.
             * @param {*} value The new value.
             * @returns {*} The replaced value.
             */
            replace(value) {
              const replacedValue = this.peek();
              this._heap[0] = value;
              this._siftDown();
              return replacedValue;
            }
            /**
             * Compute the index for the parent of the node at index `i`.
             * @param {number} i The index of the node to get the parent of.
             * @returns {number} The index of the parent node.
             * @private
             */
            _parent(i) {
              return (i + 1 >>> 1) - 1;
            }
            /**
             * Compute the index for the left child of the node at index `i`.
             * @param {number} i The index of the node to get the left child of.
             * @returns {number} The index of the left child.
             * @private
             */
            _left(i) {
              return (i << 1) + 1;
            }
            /**
             * Compute the index for the right child of the node at index `i`.
             * @param {number} i The index of the node to get the right child of.
             * @returns {number} The index of the right child.
             * @private
             */
            _right(i) {
              return i + 1 << 1;
            }
            /**
             * Check if the element at index `i` is greater than the element at index `j`.
             * @param {number} i The index of the first element to compare.
             * @param {number} j The index of the second element to compare.
             * @returns {boolean} `true` if the element at index `i` is greater than the element at index `j`, `false` otherwise.
             * @private
             */
            _greater(i, j) {
              return this._comparator(this._heap[i], this._heap[j]);
            }
            /**
             * Swap the elements at indices `i` and `j`.
             * @param {number} i The index of the first element to swap.
             * @param {number} j The index of the second element to swap.
             * @private
             */
            _swap(i, j) {
              const temp = this._heap[i];
              this._heap[i] = this._heap[j];
              this._heap[j] = temp;
            }
            /**
             * Maintain the heap property by updating positions in the heap,
             * starting at the last element and moving up the heap.
             * @private
             */
            _siftUp() {
              let node = this.size - 1;
              while (node > 0 && this._greater(node, this._parent(node))) {
                this._swap(node, this._parent(node));
                node = this._parent(node);
              }
            }
            /**
             * Maintain the heap property by updating positions in the heap,
             * starting at the first element and moving down the heap.
             * @private
             */
            _siftDown() {
              let node = 0;
              while (this._left(node) < this.size && this._greater(this._left(node), node) || this._right(node) < this.size && this._greater(this._right(node), node)) {
                const maxChild = this._right(node) < this.size && this._greater(this._right(node), this._left(node)) ? this._right(node) : this._left(node);
                this._swap(node, maxChild);
                node = maxChild;
              }
            }
          }
          class CharTrie {
            constructor() {
              this.root = CharTrieNode.default();
            }
            /**
             * Adds one or more `texts` to the trie.
             * @param {string[]} texts The strings to add to the trie.
             */
            extend(texts) {
              for (let text2 of texts) {
                this.push(text2);
              }
            }
            /**
             * Adds text to the trie.
             * @param {string} text The string to add to the trie.
             */
            push(text2) {
              let node = this.root;
              for (let ch of text2) {
                let child = node.children.get(ch);
                if (child === void 0) {
                  child = CharTrieNode.default();
                  node.children.set(ch, child);
                }
                node = child;
              }
              node.isLeaf = true;
            }
            /**
             * Searches the trie for all strings with a common prefix of `text`.
             * @param {string} text The common prefix to search for.
             * @yields {string} Each string in the trie that has `text` as a prefix.
             */
            *commonPrefixSearch(text2) {
              let node = this.root;
              let prefix = "";
              for (let i = 0; i < text2.length && node !== void 0; ++i) {
                const ch = text2[i];
                prefix += ch;
                node = node.children.get(ch);
                if (node !== void 0 && node.isLeaf) {
                  yield prefix;
                }
              }
            }
          }
          class CharTrieNode {
            /**
             * Create a new CharTrieNode.
             * @param {boolean} isLeaf Whether the node is a leaf node or not.
             * @param {Map<string, CharTrieNode>} children A map containing the node's children, where the key is a character and the value is a `CharTrieNode`.
             */
            constructor(isLeaf, children) {
              this.isLeaf = isLeaf;
              this.children = children;
            }
            /**
             * Returns a new `CharTrieNode` instance with default values.
             * @returns {CharTrieNode} A new `CharTrieNode` instance with `isLeaf` set to `false` and an empty `children` map.
             */
            static default() {
              return new CharTrieNode(false, /* @__PURE__ */ new Map());
            }
          }
          class TokenLattice {
            /**
             * Creates a new TokenLattice instance.
             *
             * @param {string} sentence The input sentence to be tokenized.
             * @param {number} bosTokenId The beginning-of-sequence token ID.
             * @param {number} eosTokenId The end-of-sequence token ID.
             */
            constructor(sentence, bosTokenId, eosTokenId) {
              this.sentence = sentence;
              this.len = sentence.length;
              this.bosTokenId = bosTokenId;
              this.eosTokenId = eosTokenId;
              this.nodes = [];
              this.beginNodes = Array.from({ length: this.len + 1 }, () => []);
              this.endNodes = Array.from({ length: this.len + 1 }, () => []);
              const bos = new TokenLatticeNode(this.bosTokenId, 0, 0, 0, 0);
              const eos = new TokenLatticeNode(this.eosTokenId, 1, this.len, 0, 0);
              this.nodes.push(bos.clone());
              this.nodes.push(eos.clone());
              this.beginNodes[this.len].push(eos);
              this.endNodes[0].push(bos);
            }
            /**
             * Inserts a new token node into the token lattice.
             *
             * @param {number} pos The starting position of the token.
             * @param {number} length The length of the token.
             * @param {number} score The score of the token.
             * @param {number} tokenId The token ID of the token.
             */
            insert(pos, length, score, tokenId) {
              const nodeId = this.nodes.length;
              const node = new TokenLatticeNode(tokenId, nodeId, pos, length, score);
              this.beginNodes[pos].push(node);
              this.endNodes[pos + length].push(node);
              this.nodes.push(node);
            }
            /**
             * Implements the Viterbi algorithm to compute the most likely sequence of tokens.
             *
             * @returns {TokenLatticeNode[]} The array of nodes representing the most likely sequence of tokens.
             */
            viterbi() {
              const len = this.len;
              let pos = 0;
              while (pos <= len) {
                if (this.beginNodes[pos].length == 0) {
                  return [];
                }
                for (let rnode of this.beginNodes[pos]) {
                  rnode.prev = null;
                  let bestScore = 0;
                  let bestNode = null;
                  for (let lnode of this.endNodes[pos]) {
                    const score = lnode.backtraceScore + rnode.score;
                    if (bestNode === null || score > bestScore) {
                      bestNode = lnode.clone();
                      bestScore = score;
                    }
                  }
                  if (bestNode !== null) {
                    rnode.prev = bestNode;
                    rnode.backtraceScore = bestScore;
                  } else {
                    return [];
                  }
                }
                ++pos;
              }
              const results = [];
              const root = this.beginNodes[len][0];
              const prev = root.prev;
              if (prev === null) {
                return [];
              }
              let node = prev.clone();
              while (node.prev !== null) {
                results.push(node.clone());
                const n = node.clone();
                node = n.prev.clone();
              }
              results.reverse();
              return results;
            }
            /**
             * @param {TokenLatticeNode} node
             * @returns {string} The array of nodes representing the most likely sequence of tokens.
             */
            piece(node) {
              return this.sentence.slice(node.pos, node.pos + node.length);
            }
            /**
             * @returns {Array} The array of nodes representing the most likely sequence of tokens.
             */
            tokens() {
              const nodes = this.viterbi();
              return nodes.map((x) => this.piece(x));
            }
            /**
             * @returns {Array} The array of nodes representing the most likely sequence of tokens.
             */
            tokenIds() {
              const nodes = this.viterbi();
              return nodes.map((x) => x.tokenId);
            }
          }
          class TokenLatticeNode {
            /**
             * Represents a node in a token lattice for a given sentence.
             * @param {number} tokenId The ID of the token associated with this node.
             * @param {number} nodeId The ID of this node.
             * @param {number} pos The starting position of the token in the sentence.
             * @param {number} length The length of the token.
             * @param {number} score The score associated with the token.
             */
            constructor(tokenId, nodeId, pos, length, score) {
              this.tokenId = tokenId;
              this.nodeId = nodeId;
              this.pos = pos;
              this.length = length;
              this.score = score;
              this.prev = null;
              this.backtraceScore = 0;
            }
            /**
             * Returns a clone of this node.
             * @returns {TokenLatticeNode} A clone of this node.
             */
            clone() {
              const n = new TokenLatticeNode(this.tokenId, this.nodeId, this.pos, this.length, this.score);
              n.prev = this.prev;
              n.backtraceScore = this.backtraceScore;
              return n;
            }
          }
        }
      ),
      /***/
      "./src/utils/generation.js": (
        /*!*********************************!*\
          !*** ./src/utils/generation.js ***!
          \*********************************/
        /***/
        (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "ForceTokensLogitsProcessor": () => (
              /* binding */
              ForceTokensLogitsProcessor
            ),
            /* harmony export */
            "ForcedBOSTokenLogitsProcessor": () => (
              /* binding */
              ForcedBOSTokenLogitsProcessor
            ),
            /* harmony export */
            "ForcedEOSTokenLogitsProcessor": () => (
              /* binding */
              ForcedEOSTokenLogitsProcessor
            ),
            /* harmony export */
            "GenerationConfig": () => (
              /* binding */
              GenerationConfig
            ),
            /* harmony export */
            "LogitsProcessor": () => (
              /* binding */
              LogitsProcessor
            ),
            /* harmony export */
            "LogitsProcessorList": () => (
              /* binding */
              LogitsProcessorList
            ),
            /* harmony export */
            "MinLengthLogitsProcessor": () => (
              /* binding */
              MinLengthLogitsProcessor
            ),
            /* harmony export */
            "MinNewTokensLengthLogitsProcessor": () => (
              /* binding */
              MinNewTokensLengthLogitsProcessor
            ),
            /* harmony export */
            "NoBadWordsLogitsProcessor": () => (
              /* binding */
              NoBadWordsLogitsProcessor
            ),
            /* harmony export */
            "NoRepeatNGramLogitsProcessor": () => (
              /* binding */
              NoRepeatNGramLogitsProcessor
            ),
            /* harmony export */
            "RepetitionPenaltyLogitsProcessor": () => (
              /* binding */
              RepetitionPenaltyLogitsProcessor
            ),
            /* harmony export */
            "Sampler": () => (
              /* binding */
              Sampler
            ),
            /* harmony export */
            "SuppressTokensAtBeginLogitsProcessor": () => (
              /* binding */
              SuppressTokensAtBeginLogitsProcessor
            ),
            /* harmony export */
            "WhisperTimeStampLogitsProcessor": () => (
              /* binding */
              WhisperTimeStampLogitsProcessor
            )
            /* harmony export */
          });
          var _tensor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__3(
            /*! ./tensor.js */
            "./src/utils/tensor.js"
          );
          var _core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__3(
            /*! ./core.js */
            "./src/utils/core.js"
          );
          var _maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__3(
            /*! ./maths.js */
            "./src/utils/maths.js"
          );
          class LogitsProcessorList extends _core_js__WEBPACK_IMPORTED_MODULE_1__.Callable {
            /**
             * Constructs a new instance of `LogitsProcessorList`.
             */
            constructor() {
              super();
              this.processors = [];
            }
            /**
             * Adds a new logits processor to the list.
             *
             * @param {LogitsProcessor} item The logits processor function to add.
             */
            push(item) {
              this.processors.push(item);
            }
            /**
             * Adds multiple logits processors to the list.
             *
             * @param {LogitsProcessor[]} items The logits processor functions to add.
             */
            extend(items) {
              this.processors.push(...items);
            }
            /**
             * Applies all logits processors in the list to a batch of logits, modifying them in-place.
             *
             * @param {number[]} input_ids The input IDs for the language model.
             * @param {number[][]} batchedLogits A 2D array of logits, where each row corresponds to a single
             *                                                input sequence in the batch.
             */
            _call(input_ids, batchedLogits) {
              for (let logits of batchedLogits) {
                this.processors.forEach(
                  (func) => func(input_ids, logits)
                );
              }
            }
            [Symbol.iterator]() {
              return this.processors.values();
            }
          }
          class LogitsProcessor extends _core_js__WEBPACK_IMPORTED_MODULE_1__.Callable {
            /**
             * Apply the processor to the input logits.
             *
             * @abstract
             * @param {Array} input_ids The input ids.
             * @param {Tensor} logits The logits to process.
             * @throws {Error} Throws an error if `_call` is not implemented in the subclass.
             */
            _call(input_ids, logits) {
              throw Error("`_call` should be implemented in a subclass");
            }
          }
          class ForceTokensLogitsProcessor extends LogitsProcessor {
            /**
             * Constructs a new instance of `ForceTokensLogitsProcessor`.
             * 
             * @param {Array} forced_decoder_ids The ids of tokens that should be forced.
             */
            constructor(forced_decoder_ids) {
              super();
              this.force_token_map = Object.fromEntries(forced_decoder_ids ?? []);
            }
            /**
             * Apply the processor to the input logits.
             *
             * @param {Array} input_ids The input ids.
             * @param {Tensor} logits The logits to process.
             * @returns {Tensor} The processed logits.
             */
            _call(input_ids, logits) {
              let map2 = this.force_token_map[input_ids.length];
              if ((0, _core_js__WEBPACK_IMPORTED_MODULE_1__.exists)(map2)) {
                logits.data.fill(-Infinity);
                logits.data[map2] = 0;
              }
              return logits;
            }
          }
          class ForcedBOSTokenLogitsProcessor extends LogitsProcessor {
            /**
             * Create a ForcedBOSTokenLogitsProcessor.
             * @param {number} bos_token_id The ID of the beginning-of-sequence token to be forced.
             */
            constructor(bos_token_id) {
              super();
              this.bos_token_id = bos_token_id;
            }
            /**
             * Apply the BOS token forcing to the logits.
             * @param {Array} input_ids The input IDs.
             * @param {Object} logits The logits.
             * @returns {Object} The logits with BOS token forcing.
             */
            _call(input_ids, logits) {
              if (input_ids.length === 1) {
                logits.data.fill(-Infinity);
                logits.data[this.bos_token_id] = 0;
              }
              return logits;
            }
          }
          class ForcedEOSTokenLogitsProcessor extends LogitsProcessor {
            /**
             * Create a ForcedEOSTokenLogitsProcessor.
             * @param {number} max_length Max length of the sequence.
             * @param {number|number[]} forced_eos_token_id The ID of the end-of-sequence token to be forced.
             */
            constructor(max_length, forced_eos_token_id) {
              super();
              this.max_length = max_length;
              this.forced_eos_token_id = forced_eos_token_id;
            }
            /**
             * Apply the processor to input_ids and logits.
             * 
             * @param {number[]} input_ids The input ids.
             * @param {Tensor} logits The logits tensor.
             */
            _call(input_ids, logits) {
            }
          }
          class SuppressTokensAtBeginLogitsProcessor extends LogitsProcessor {
            /**
             * Create a SuppressTokensAtBeginLogitsProcessor.
             * @param {number[]} begin_suppress_tokens The IDs of the tokens to suppress.
             * @param {number} begin_index The number of tokens to generate before suppressing tokens.
             */
            constructor(begin_suppress_tokens, begin_index) {
              super();
              this.begin_suppress_tokens = begin_suppress_tokens;
              this.begin_index = begin_index;
            }
            /**
             * Apply the BOS token forcing to the logits.
             * @param {Array} input_ids The input IDs.
             * @param {Object} logits The logits.
             * @returns {Object} The logits with BOS token forcing.
             */
            _call(input_ids, logits) {
              if (input_ids.length === this.begin_index) {
                for (let token_id of this.begin_suppress_tokens) {
                  logits.data[token_id] = -Infinity;
                }
              }
              return logits;
            }
          }
          class WhisperTimeStampLogitsProcessor extends LogitsProcessor {
            /**
             * Constructs a new WhisperTimeStampLogitsProcessor.
             * @param {Object} generate_config The config object passed to the `generate()` method of a transformer model.
             * @param {number} generate_config.eos_token_id The ID of the end-of-sequence token.
             * @param {number} generate_config.no_timestamps_token_id The ID of the token used to indicate that a token should not have a timestamp.
             * @param {number[][]} [generate_config.forced_decoder_ids] An array of two-element arrays representing decoder IDs that are forced to appear in the output. The second element of each array indicates whether the token is a timestamp.
             * @param {number} [generate_config.max_initial_timestamp_index] The maximum index at which an initial timestamp can appear.
             */
            constructor(generate_config) {
              super();
              this.eos_token_id = generate_config.eos_token_id;
              this.no_timestamps_token_id = generate_config.no_timestamps_token_id;
              this.timestamp_begin = this.no_timestamps_token_id + 1;
              this.begin_index = (generate_config.forced_decoder_ids || []).length + 2;
              if (generate_config.forced_decoder_ids.slice(-1)[0][1] === this.no_timestamps_token_id) {
                this.begin_index -= 1;
              }
              this.max_initial_timestamp_index = generate_config.max_initial_timestamp_index;
            }
            /**
             * Modify the logits to handle timestamp tokens.
             * @param {Array} input_ids The input sequence of tokens.
             * @param {Tensor} logits The logits output by the model.
             * @returns {Tensor} The modified logits.
             */
            _call(input_ids, logits) {
              const logitsData = (
                /** @type {Float32Array} */
                logits.data
              );
              logitsData[this.no_timestamps_token_id] = -Infinity;
              if (input_ids.length === this.begin_index - 1) {
                logitsData.fill(-Infinity);
                logitsData[this.timestamp_begin] = 0;
                return logits;
              }
              const seq = input_ids.slice(this.begin_index);
              const last_was_timestamp = seq.length >= 1 && seq[seq.length - 1] >= this.timestamp_begin;
              const penultimate_was_timestamp = seq.length < 2 || seq[seq.length - 2] >= this.timestamp_begin;
              if (last_was_timestamp) {
                if (penultimate_was_timestamp) {
                  logitsData.subarray(this.timestamp_begin).fill(-Infinity);
                } else {
                  logitsData.subarray(0, this.eos_token_id).fill(-Infinity);
                }
              }
              if (input_ids.length === this.begin_index && this.max_initial_timestamp_index !== null) {
                const last_allowed = this.timestamp_begin + this.max_initial_timestamp_index;
                logitsData.subarray(last_allowed + 1).fill(-Infinity);
              }
              const logprobs = (0, _maths_js__WEBPACK_IMPORTED_MODULE_2__.log_softmax)(logitsData);
              const timestamp_logprob = Math.log(logprobs.subarray(this.timestamp_begin).map(Math.exp).reduce((a, b) => a + b));
              const max_text_token_logprob = (0, _maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(logprobs.subarray(0, this.timestamp_begin))[0];
              if (timestamp_logprob > max_text_token_logprob) {
                logitsData.subarray(0, this.timestamp_begin).fill(-Infinity);
              }
              return logits;
            }
          }
          class NoRepeatNGramLogitsProcessor extends LogitsProcessor {
            /**
             * Create a NoRepeatNGramLogitsProcessor.
             * @param {number} no_repeat_ngram_size The no-repeat-ngram size. All ngrams of this size can only occur once.
             */
            constructor(no_repeat_ngram_size) {
              super();
              this.no_repeat_ngram_size = no_repeat_ngram_size;
            }
            /**
             * Generate n-grams from a sequence of token ids.
             * @param {number[]} prevInputIds List of previous input ids
             * @returns {Map<string, number[]>} Map of generated n-grams
             */
            getNgrams(prevInputIds) {
              const curLen = prevInputIds.length;
              const ngrams = [];
              for (let j = 0; j < curLen + 1 - this.no_repeat_ngram_size; ++j) {
                const ngram = [];
                for (let k = 0; k < this.no_repeat_ngram_size; ++k) {
                  ngram.push(prevInputIds[j + k]);
                }
                ngrams.push(ngram);
              }
              const generatedNgram = /* @__PURE__ */ new Map();
              for (const ngram of ngrams) {
                const prevNgram = ngram.slice(0, ngram.length - 1);
                const prevNgramKey = JSON.stringify(prevNgram);
                const prevNgramValue = generatedNgram.get(prevNgramKey) ?? [];
                prevNgramValue.push(ngram[ngram.length - 1]);
                generatedNgram.set(prevNgramKey, prevNgramValue);
              }
              return generatedNgram;
            }
            /**
             * Generate n-grams from a sequence of token ids.
             * @param {Map<string, number[]>} bannedNgrams Map of banned n-grams
             * @param {number[]} prevInputIds List of previous input ids
             * @returns {number[]} Map of generated n-grams
             */
            getGeneratedNgrams(bannedNgrams, prevInputIds) {
              const ngramIdx = prevInputIds.slice(prevInputIds.length + 1 - this.no_repeat_ngram_size, prevInputIds.length);
              const banned = bannedNgrams.get(JSON.stringify(ngramIdx)) ?? [];
              return banned;
            }
            /**
             * Calculate banned n-gram tokens
             * @param {number[]} prevInputIds List of previous input ids
             * @returns {number[]} Map of generated n-grams
             */
            calcBannedNgramTokens(prevInputIds) {
              const bannedTokens = [];
              if (prevInputIds.length + 1 < this.no_repeat_ngram_size) {
                return bannedTokens;
              } else {
                const generatedNgrams = this.getNgrams(prevInputIds);
                const bannedTokens2 = this.getGeneratedNgrams(generatedNgrams, prevInputIds);
                return bannedTokens2;
              }
            }
            /**
             * Apply the no-repeat-ngram processor to the logits.
             * @param {Array} input_ids The input IDs.
             * @param {Object} logits The logits.
             * @returns {Object} The logits with no-repeat-ngram processing.
             */
            _call(input_ids, logits) {
              const bannedTokens = this.calcBannedNgramTokens(input_ids);
              for (const token of bannedTokens) {
                logits.data[token] = -Infinity;
              }
              return logits;
            }
          }
          class RepetitionPenaltyLogitsProcessor extends LogitsProcessor {
            /**
             * Create a RepetitionPenaltyLogitsProcessor.
             * @param {number} penalty The penalty to apply for repeated tokens.
             */
            constructor(penalty) {
              super();
              this.penalty = penalty;
            }
            /**
             * Apply the repetition penalty to the logits.
             * @param {Array} input_ids The input IDs.
             * @param {Object} logits The logits.
             * @returns {Object} The logits with repetition penalty processing.
             */
            _call(input_ids, logits) {
              for (const input_id of input_ids) {
                if (logits.data[input_id] < 0) {
                  logits.data[input_id] *= this.penalty;
                } else {
                  logits.data[input_id] /= this.penalty;
                }
              }
              return logits;
            }
          }
          class MinLengthLogitsProcessor extends LogitsProcessor {
            /**
             * Create a MinLengthLogitsProcessor.
             * @param {number} min_length The minimum length below which the score of `eos_token_id` is set to negative infinity.
             * @param {number|number[]} eos_token_id The ID/IDs of the end-of-sequence token.
             */
            constructor(min_length, eos_token_id) {
              super();
              this.min_length = min_length;
              this.eos_token_id = Array.isArray(eos_token_id) ? eos_token_id : [eos_token_id];
            }
            /**
             * Apply logit processor.
             * @param {Array} input_ids The input IDs.
             * @param {Object} logits The logits.
             * @returns {Object} The processed logits.
             */
            _call(input_ids, logits) {
              if (input_ids.length < this.min_length) {
                for (const eos_token of this.eos_token_id) {
                  logits.data[eos_token] = -Infinity;
                }
              }
              return logits;
            }
          }
          class MinNewTokensLengthLogitsProcessor extends LogitsProcessor {
            /**
             * Create a MinNewTokensLengthLogitsProcessor.
             * @param {number} prompt_length_to_skip The input tokens length.
             * @param {number} min_new_tokens The minimum *new* tokens length below which the score of `eos_token_id` is set to negative infinity.
             * @param {number|number[]} eos_token_id The ID/IDs of the end-of-sequence token.
             */
            constructor(prompt_length_to_skip, min_new_tokens, eos_token_id) {
              super();
              this.prompt_length_to_skip = prompt_length_to_skip;
              this.min_new_tokens = min_new_tokens;
              this.eos_token_id = Array.isArray(eos_token_id) ? eos_token_id : [eos_token_id];
            }
            /**
             * Apply logit processor.
             * @param {Array} input_ids The input IDs.
             * @param {Object} logits The logits.
             * @returns {Object} The processed logits.
             */
            _call(input_ids, logits) {
              const new_tokens_length = input_ids.length - this.prompt_length_to_skip;
              if (new_tokens_length < this.min_new_tokens) {
                for (const eos_token of this.eos_token_id) {
                  logits.data[eos_token] = -Infinity;
                }
              }
              return logits;
            }
          }
          class NoBadWordsLogitsProcessor extends LogitsProcessor {
            /**
             * Create a `NoBadWordsLogitsProcessor`.
             * @param {number[][]} bad_words_ids List of list of token ids that are not allowed to be generated.
             * @param {number|number[]} eos_token_id The id of the *end-of-sequence* token. Optionally, use a list to set multiple *end-of-sequence* tokens.
             */
            constructor(bad_words_ids, eos_token_id) {
              super();
              this.bad_words_ids = bad_words_ids;
              this.eos_token_id = Array.isArray(eos_token_id) ? eos_token_id : [eos_token_id];
            }
            /**
             * Apply logit processor.
             * @param {Array} input_ids The input IDs.
             * @param {Object} logits The logits.
             * @returns {Object} The processed logits.
             */
            _call(input_ids, logits) {
              for (const bad_word_ids of this.bad_words_ids) {
                let mark = true;
                for (let i = 1; i <= bad_word_ids.length - 1 && bad_word_ids.length < input_ids.length; ++i) {
                  if (bad_word_ids.at(-i - 1) !== input_ids.at(-i)) {
                    mark = false;
                    break;
                  }
                }
                if (mark) {
                  logits.data[bad_word_ids.at(-1)] = -Infinity;
                }
              }
              return logits;
            }
          }
          const GenerationConfig = (
            /** @type {any} */
            class {
              /**
               * Create a new GenerationConfig object.
               * @param {GenerationConfigType} kwargs 
               */
              constructor(kwargs = {}) {
                this.max_length = kwargs.max_length ?? 20;
                this.max_new_tokens = kwargs.max_new_tokens ?? null;
                this.min_length = kwargs.min_length ?? 0;
                this.min_new_tokens = kwargs.min_new_tokens ?? null;
                this.early_stopping = kwargs.early_stopping ?? false;
                this.max_time = kwargs.max_time ?? null;
                this.do_sample = kwargs.do_sample ?? false;
                this.num_beams = kwargs.num_beams ?? 1;
                this.num_beam_groups = kwargs.num_beam_groups ?? 1;
                this.penalty_alpha = kwargs.penalty_alpha ?? null;
                this.use_cache = kwargs.use_cache ?? true;
                this.temperature = kwargs.temperature ?? 1;
                this.top_k = kwargs.top_k ?? 50;
                this.top_p = kwargs.top_p ?? 1;
                this.typical_p = kwargs.typical_p ?? 1;
                this.epsilon_cutoff = kwargs.epsilon_cutoff ?? 0;
                this.eta_cutoff = kwargs.eta_cutoff ?? 0;
                this.diversity_penalty = kwargs.diversity_penalty ?? 0;
                this.repetition_penalty = kwargs.repetition_penalty ?? 1;
                this.encoder_repetition_penalty = kwargs.encoder_repetition_penalty ?? 1;
                this.length_penalty = kwargs.length_penalty ?? 1;
                this.no_repeat_ngram_size = kwargs.no_repeat_ngram_size ?? 0;
                this.bad_words_ids = kwargs.bad_words_ids ?? null;
                this.force_words_ids = kwargs.force_words_ids ?? null;
                this.renormalize_logits = kwargs.renormalize_logits ?? false;
                this.constraints = kwargs.constraints ?? null;
                this.forced_bos_token_id = kwargs.forced_bos_token_id ?? null;
                this.forced_eos_token_id = kwargs.forced_eos_token_id ?? null;
                this.remove_invalid_values = kwargs.remove_invalid_values ?? false;
                this.exponential_decay_length_penalty = kwargs.exponential_decay_length_penalty ?? null;
                this.suppress_tokens = kwargs.suppress_tokens ?? null;
                this.begin_suppress_tokens = kwargs.begin_suppress_tokens ?? null;
                this.forced_decoder_ids = kwargs.forced_decoder_ids ?? null;
                this.num_return_sequences = kwargs.num_return_sequences ?? 1;
                this.output_attentions = kwargs.output_attentions ?? false;
                this.output_hidden_states = kwargs.output_hidden_states ?? false;
                this.output_scores = kwargs.output_scores ?? false;
                this.return_dict_in_generate = kwargs.return_dict_in_generate ?? false;
                this.pad_token_id = kwargs.pad_token_id ?? null;
                this.bos_token_id = kwargs.bos_token_id ?? null;
                this.eos_token_id = kwargs.eos_token_id ?? null;
                this.encoder_no_repeat_ngram_size = kwargs.encoder_no_repeat_ngram_size ?? 0;
                this.decoder_start_token_id = kwargs.decoder_start_token_id ?? null;
                this.generation_kwargs = kwargs.generation_kwargs ?? {};
              }
            }
          );
          class Sampler extends _core_js__WEBPACK_IMPORTED_MODULE_1__.Callable {
            /**
             * Creates a new Sampler object with the specified generation config.
             * @param {GenerationConfigType} generation_config The generation config.
             */
            constructor(generation_config) {
              super();
              this.generation_config = generation_config;
            }
            /**
             * Executes the sampler, using the specified logits.
             * @param {Tensor} logits
             * @param {number} index
             * @returns {void}
             */
            _call(logits, index = -1) {
              return this.sample(logits, index);
            }
            /**
             * Abstract method for sampling the logits.
             * @param {Tensor} logits
             * @param {number} index
             * @throws {Error}
             */
            sample(logits, index) {
              throw Error("sample should be implemented in subclasses.");
            }
            /**
             * Returns the specified logits as an array, with temperature applied.
             * @param {Tensor} logits
             * @param {number} index
             * @returns {Float32Array}
             */
            getLogits(logits, index) {
              let vocabSize = logits.dims.at(-1);
              let logs = (
                /** @type {Float32Array} */
                logits.data
              );
              if (index === -1) {
                logs = logs.slice(-vocabSize);
              } else {
                let startIndex = index * vocabSize;
                logs = logs.slice(startIndex, startIndex + vocabSize);
              }
              if (this.generation_config.temperature > 0) {
                logs = logs.map((x) => x / this.generation_config.temperature);
              }
              return logs;
            }
            /**
             * Selects an item randomly based on the specified probabilities.
             * @param {Array} probabilities An array of probabilities to use for selection.
             * @returns {number} The index of the selected item.
             */
            randomSelect(probabilities) {
              let sumProbabilities = probabilities.reduce((acc, curr) => acc + curr, 0);
              let r = Math.random() * sumProbabilities;
              for (let i = 0; i < probabilities.length; ++i) {
                r -= probabilities[i];
                if (r <= 0) {
                  return i;
                }
              }
              return 0;
            }
            /**
             * Returns a Sampler object based on the specified options.
             * @param {GenerationConfigType} generation_config An object containing options for the sampler.
             * @returns {Sampler} A Sampler object.
             */
            static getSampler(generation_config) {
              if (generation_config.do_sample) {
                return new MultinomialSampler(generation_config);
              } else if (generation_config.num_beams > 1) {
                return new BeamSearchSampler(generation_config);
              } else {
                if (generation_config.num_return_sequences > 1) {
                  throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${generation_config.num_return_sequences}.`);
                }
                return new GreedySampler(generation_config);
              }
            }
          }
          class GreedySampler extends Sampler {
            /**
             * Sample the maximum probability of a given logits tensor.
             * @param {Tensor} logits
             * @param {number} [index=-1]
             * @returns {Array} An array with a single tuple, containing the index of the maximum value and a meaningless score (since this is a greedy search).
             */
            sample(logits, index = -1) {
              let logs = this.getLogits(logits, index);
              let argmax = (0, _maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(logs)[1];
              return [
                [argmax, 0]
              ];
            }
          }
          class MultinomialSampler extends Sampler {
            /**
             * Sample from the logits.
             * @param {Tensor} logits
             * @param {number} index
             * @returns {Array}
             */
            sample(logits, index = -1) {
              let k = logits.dims.at(-1);
              if (this.generation_config.top_k > 0) {
                k = Math.min(this.generation_config.top_k, k);
              }
              const logs = this.getLogits(logits, index);
              const topLogits = (0, _maths_js__WEBPACK_IMPORTED_MODULE_2__.getTopItems)(logs, k);
              const probabilities = (0, _maths_js__WEBPACK_IMPORTED_MODULE_2__.softmax)(topLogits.map((x) => x[1]));
              return Array.from({ length: this.generation_config.num_beams }, () => {
                const sampledIndex = this.randomSelect(probabilities);
                return [
                  topLogits[sampledIndex][0],
                  // token id
                  Math.log(probabilities[sampledIndex])
                  // score
                ];
              });
            }
          }
          class BeamSearchSampler extends Sampler {
            /**
             * Sample from the logits.
             * @param {Tensor} logits
             * @param {number} index
             * @returns {Array}
             */
            sample(logits, index = -1) {
              let k = logits.dims.at(-1);
              if (this.generation_config.top_k > 0) {
                k = Math.min(this.generation_config.top_k, k);
              }
              const logs = this.getLogits(logits, index);
              const topLogits = (0, _maths_js__WEBPACK_IMPORTED_MODULE_2__.getTopItems)(logs, k);
              const probabilities = (0, _maths_js__WEBPACK_IMPORTED_MODULE_2__.softmax)(topLogits.map((x) => x[1]));
              return Array.from({ length: this.generation_config.num_beams }, (_, i) => {
                return [
                  topLogits[i][0],
                  // token id
                  Math.log(probabilities[i])
                  // score
                ];
              });
            }
          }
        }
      ),
      /***/
      "./src/utils/hub.js": (
        /*!**************************!*\
          !*** ./src/utils/hub.js ***!
          \**************************/
        /***/
        (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "getFile": () => (
              /* binding */
              getFile
            ),
            /* harmony export */
            "getModelFile": () => (
              /* binding */
              getModelFile
            ),
            /* harmony export */
            "getModelJSON": () => (
              /* binding */
              getModelJSON
            )
            /* harmony export */
          });
          var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__3(
            /*! fs */
            "?7a2c"
          );
          var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__3(
            /*! path */
            "?a42a"
          );
          var _env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__3(
            /*! ../env.js */
            "./src/env.js"
          );
          var _core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__3(
            /*! ./core.js */
            "./src/utils/core.js"
          );
          class FileResponse {
            /**
             * Creates a new `FileResponse` object.
             * @param {string|URL} filePath
             */
            constructor(filePath) {
              /**
               * Mapping from file extensions to MIME types.
               */
              __publicField(this, "_CONTENT_TYPE_MAP", {
                "txt": "text/plain",
                "html": "text/html",
                "css": "text/css",
                "js": "text/javascript",
                "json": "application/json",
                "png": "image/png",
                "jpg": "image/jpeg",
                "jpeg": "image/jpeg",
                "gif": "image/gif"
              });
              this.filePath = filePath;
              this.headers = new Headers();
              this.exists = fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(filePath);
              if (this.exists) {
                this.status = 200;
                this.statusText = "OK";
                let stats = fs__WEBPACK_IMPORTED_MODULE_0__.statSync(filePath);
                this.headers.set("content-length", stats.size.toString());
                this.updateContentType();
                let self2 = this;
                this.body = new ReadableStream({
                  start(controller) {
                    self2.arrayBuffer().then((buffer) => {
                      controller.enqueue(new Uint8Array(buffer));
                      controller.close();
                    });
                  }
                });
              } else {
                this.status = 404;
                this.statusText = "Not Found";
                this.body = null;
              }
            }
            /**
             * Updates the 'content-type' header property of the response based on the extension of
             * the file specified by the filePath property of the current object.
             * @returns {void}
             */
            updateContentType() {
              const extension = this.filePath.toString().split(".").pop().toLowerCase();
              this.headers.set("content-type", this._CONTENT_TYPE_MAP[extension] ?? "application/octet-stream");
            }
            /**
             * Clone the current FileResponse object.
             * @returns {FileResponse} A new FileResponse object with the same properties as the current object.
             */
            clone() {
              let response = new FileResponse(this.filePath);
              response.exists = this.exists;
              response.status = this.status;
              response.statusText = this.statusText;
              response.headers = new Headers(this.headers);
              return response;
            }
            /**
             * Reads the contents of the file specified by the filePath property and returns a Promise that
             * resolves with an ArrayBuffer containing the file's contents.
             * @returns {Promise<ArrayBuffer>} A Promise that resolves with an ArrayBuffer containing the file's contents.
             * @throws {Error} If the file cannot be read.
             */
            async arrayBuffer() {
              const data = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(this.filePath);
              return data.buffer;
            }
            /**
             * Reads the contents of the file specified by the filePath property and returns a Promise that
             * resolves with a Blob containing the file's contents.
             * @returns {Promise<Blob>} A Promise that resolves with a Blob containing the file's contents.
             * @throws {Error} If the file cannot be read.
             */
            async blob() {
              const data = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(this.filePath);
              return new Blob([data], { type: this.headers.get("content-type") });
            }
            /**
             * Reads the contents of the file specified by the filePath property and returns a Promise that
             * resolves with a string containing the file's contents.
             * @returns {Promise<string>} A Promise that resolves with a string containing the file's contents.
             * @throws {Error} If the file cannot be read.
             */
            async text() {
              const data = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(this.filePath, "utf8");
              return data;
            }
            /**
             * Reads the contents of the file specified by the filePath property and returns a Promise that
             * resolves with a parsed JavaScript object containing the file's contents.
             * 
             * @returns {Promise<Object>} A Promise that resolves with a parsed JavaScript object containing the file's contents.
             * @throws {Error} If the file cannot be read.
             */
            async json() {
              return JSON.parse(await this.text());
            }
          }
          function isValidUrl(string, protocols = null, validHosts = null) {
            let url;
            try {
              url = new URL(string);
            } catch (_) {
              return false;
            }
            if (protocols && !protocols.includes(url.protocol)) {
              return false;
            }
            if (validHosts && !validHosts.includes(url.hostname)) {
              return false;
            }
            return true;
          }
          async function getFile(urlOrPath) {
            if (_env_js__WEBPACK_IMPORTED_MODULE_2__.env.useFS && !isValidUrl(urlOrPath, ["http:", "https:", "blob:"])) {
              return new FileResponse(urlOrPath);
            } else if (typeof process !== "undefined" && process?.release?.name === "node") {
              const IS_CI = !!process.env?.TESTING_REMOTELY;
              const version = _env_js__WEBPACK_IMPORTED_MODULE_2__.env.version;
              const headers = new Headers();
              headers.set("User-Agent", `transformers.js/${version}; is_ci/${IS_CI};`);
              const isHFURL = isValidUrl(urlOrPath, ["http:", "https:"], ["huggingface.co", "hf.co"]);
              if (isHFURL) {
                const token = process.env?.HF_TOKEN ?? process.env?.HF_ACCESS_TOKEN;
                if (token) {
                  headers.set("Authorization", `Bearer ${token}`);
                }
              }
              return fetch(urlOrPath, { headers });
            } else {
              return fetch(urlOrPath);
            }
          }
          const ERROR_MAPPING = {
            // 4xx errors (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses)
            400: "Bad request error occurred while trying to load file",
            401: "Unauthorized access to file",
            403: "Forbidden access to file",
            404: "Could not locate file",
            408: "Request timeout error occurred while trying to load file",
            // 5xx errors (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#server_error_responses)
            500: "Internal server error error occurred while trying to load file",
            502: "Bad gateway error occurred while trying to load file",
            503: "Service unavailable error occurred while trying to load file",
            504: "Gateway timeout error occurred while trying to load file"
          };
          function handleError(status, remoteURL, fatal) {
            if (!fatal) {
              return null;
            }
            const message = ERROR_MAPPING[status] ?? `Error (${status}) occurred while trying to load file`;
            throw Error(`${message}: "${remoteURL}".`);
          }
          class FileCache {
            /**
             * Instantiate a `FileCache` object.
             * @param {string} path 
             */
            constructor(path) {
              this.path = path;
            }
            /**
             * Checks whether the given request is in the cache.
             * @param {string} request 
             * @returns {Promise<FileResponse | undefined>}
             */
            async match(request) {
              let filePath = path__WEBPACK_IMPORTED_MODULE_1__.join(this.path, request);
              let file = new FileResponse(filePath);
              if (file.exists) {
                return file;
              } else {
                return void 0;
              }
            }
            /**
             * Adds the given response to the cache.
             * @param {string} request 
             * @param {Response|FileResponse} response 
             * @returns {Promise<void>}
             */
            async put(request, response) {
              const buffer = Buffer.from(await response.arrayBuffer());
              let outputPath = path__WEBPACK_IMPORTED_MODULE_1__.join(this.path, request);
              try {
                await fs__WEBPACK_IMPORTED_MODULE_0__.promises.mkdir(path__WEBPACK_IMPORTED_MODULE_1__.dirname(outputPath), { recursive: true });
                await fs__WEBPACK_IMPORTED_MODULE_0__.promises.writeFile(outputPath, buffer);
              } catch (err) {
                console.warn("An error occurred while writing the file to cache:", err);
              }
            }
            // TODO add the rest?
            // addAll(requests: RequestInfo[]): Promise<void>;
            // delete(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<boolean>;
            // keys(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise<ReadonlyArray<Request>>;
            // match(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<Response | undefined>;
            // matchAll(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise<ReadonlyArray<Response>>;
          }
          async function tryCache(cache, ...names) {
            for (let name2 of names) {
              try {
                let result = await cache.match(name2);
                if (result)
                  return result;
              } catch (e) {
                continue;
              }
            }
            return void 0;
          }
          async function getModelFile(path_or_repo_id, filename, fatal = true, options = {}) {
            if (!_env_js__WEBPACK_IMPORTED_MODULE_2__.env.allowLocalModels) {
              if (options.local_files_only) {
                throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");
              } else if (!_env_js__WEBPACK_IMPORTED_MODULE_2__.env.allowRemoteModels) {
                throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.");
              }
            }
            (0, _core_js__WEBPACK_IMPORTED_MODULE_3__.dispatchCallback)(options.progress_callback, {
              status: "initiate",
              name: path_or_repo_id,
              file: filename
            });
            let cache;
            if (!cache && _env_js__WEBPACK_IMPORTED_MODULE_2__.env.useBrowserCache) {
              if (typeof caches === "undefined") {
                throw Error("Browser cache is not available in this environment.");
              }
              try {
                cache = await caches.open("transformers-cache");
              } catch (e) {
                console.warn("An error occurred while opening the browser cache:", e);
              }
            }
            if (!cache && _env_js__WEBPACK_IMPORTED_MODULE_2__.env.useFSCache) {
              cache = new FileCache(options.cache_dir ?? _env_js__WEBPACK_IMPORTED_MODULE_2__.env.cacheDir);
            }
            if (!cache && _env_js__WEBPACK_IMPORTED_MODULE_2__.env.useCustomCache) {
              if (!_env_js__WEBPACK_IMPORTED_MODULE_2__.env.customCache) {
                throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");
              }
              if (!_env_js__WEBPACK_IMPORTED_MODULE_2__.env.customCache.match || !_env_js__WEBPACK_IMPORTED_MODULE_2__.env.customCache.put) {
                throw new Error(
                  "`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache"
                );
              }
              cache = _env_js__WEBPACK_IMPORTED_MODULE_2__.env.customCache;
            }
            const revision = options.revision ?? "main";
            let requestURL = pathJoin(path_or_repo_id, filename);
            let localPath = pathJoin(_env_js__WEBPACK_IMPORTED_MODULE_2__.env.localModelPath, requestURL);
            let remoteURL = pathJoin(
              _env_js__WEBPACK_IMPORTED_MODULE_2__.env.remoteHost,
              _env_js__WEBPACK_IMPORTED_MODULE_2__.env.remotePathTemplate.replaceAll("{model}", path_or_repo_id).replaceAll("{revision}", encodeURIComponent(revision)),
              filename
            );
            let fsCacheKey = revision === "main" ? requestURL : pathJoin(path_or_repo_id, revision, filename);
            let cacheKey;
            let proposedCacheKey = cache instanceof FileCache ? fsCacheKey : remoteURL;
            let toCacheResponse = false;
            let response;
            if (cache) {
              response = await tryCache(cache, localPath, proposedCacheKey);
            }
            const cacheHit = response !== void 0;
            if (response === void 0) {
              if (_env_js__WEBPACK_IMPORTED_MODULE_2__.env.allowLocalModels) {
                const isURL = isValidUrl(requestURL, ["http:", "https:"]);
                if (!isURL) {
                  try {
                    response = await getFile(localPath);
                    cacheKey = localPath;
                  } catch (e) {
                    console.warn(`Unable to load from local path "${localPath}": "${e}"`);
                  }
                } else if (options.local_files_only) {
                  throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${requestURL}.`);
                } else if (!_env_js__WEBPACK_IMPORTED_MODULE_2__.env.allowRemoteModels) {
                  throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${requestURL}.`);
                }
              }
              if (response === void 0 || response.status === 404) {
                if (options.local_files_only || !_env_js__WEBPACK_IMPORTED_MODULE_2__.env.allowRemoteModels) {
                  if (fatal) {
                    throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${localPath}".`);
                  } else {
                    return null;
                  }
                }
                response = await getFile(remoteURL);
                if (response.status !== 200) {
                  return handleError(response.status, remoteURL, fatal);
                }
                cacheKey = proposedCacheKey;
              }
              toCacheResponse = cache && typeof Response !== "undefined" && response instanceof Response && response.status === 200;
            }
            (0, _core_js__WEBPACK_IMPORTED_MODULE_3__.dispatchCallback)(options.progress_callback, {
              status: "download",
              name: path_or_repo_id,
              file: filename
            });
            const progressInfo = {
              status: "progress",
              name: path_or_repo_id,
              file: filename
            };
            let buffer;
            if (!options.progress_callback) {
              buffer = new Uint8Array(await response.arrayBuffer());
            } else if (cacheHit && typeof navigator !== "undefined" && /firefox/i.test(navigator.userAgent)) {
              buffer = new Uint8Array(await response.arrayBuffer());
              (0, _core_js__WEBPACK_IMPORTED_MODULE_3__.dispatchCallback)(options.progress_callback, {
                ...progressInfo,
                progress: 100,
                loaded: buffer.length,
                total: buffer.length
              });
            } else {
              buffer = await readResponse(response, (data) => {
                (0, _core_js__WEBPACK_IMPORTED_MODULE_3__.dispatchCallback)(options.progress_callback, {
                  ...progressInfo,
                  ...data
                });
              });
            }
            if (
              // Only cache web responses
              // i.e., do not cache FileResponses (prevents duplication)
              toCacheResponse && cacheKey && // Check again whether request is in cache. If not, we add the response to the cache
              await cache.match(cacheKey) === void 0
            ) {
              await cache.put(cacheKey, new Response(buffer, {
                headers: response.headers
              })).catch((err) => {
                console.warn(`Unable to add response to browser cache: ${err}.`);
              });
            }
            (0, _core_js__WEBPACK_IMPORTED_MODULE_3__.dispatchCallback)(options.progress_callback, {
              status: "done",
              name: path_or_repo_id,
              file: filename
            });
            return buffer;
          }
          async function getModelJSON(modelPath, fileName, fatal = true, options = {}) {
            let buffer = await getModelFile(modelPath, fileName, fatal, options);
            if (buffer === null) {
              return {};
            }
            let decoder = new TextDecoder("utf-8");
            let jsonData = decoder.decode(buffer);
            return JSON.parse(jsonData);
          }
          async function readResponse(response, progress_callback) {
            const contentLength = response.headers.get("Content-Length");
            if (contentLength === null) {
              console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");
            }
            let total = parseInt(contentLength ?? "0");
            let buffer = new Uint8Array(total);
            let loaded = 0;
            const reader = response.body.getReader();
            async function read() {
              const { done, value } = await reader.read();
              if (done)
                return;
              let newLoaded = loaded + value.length;
              if (newLoaded > total) {
                total = newLoaded;
                let newBuffer = new Uint8Array(total);
                newBuffer.set(buffer);
                buffer = newBuffer;
              }
              buffer.set(value, loaded);
              loaded = newLoaded;
              const progress = loaded / total * 100;
              progress_callback({
                progress,
                loaded,
                total
              });
              return read();
            }
            await read();
            return buffer;
          }
          function pathJoin(...parts) {
            parts = parts.map((part, index) => {
              if (index) {
                part = part.replace(new RegExp("^/"), "");
              }
              if (index !== parts.length - 1) {
                part = part.replace(new RegExp("/$"), "");
              }
              return part;
            });
            return parts.join("/");
          }
        }
      ),
      /***/
      "./src/utils/image.js": (
        /*!****************************!*\
          !*** ./src/utils/image.js ***!
          \****************************/
        /***/
        (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "RawImage": () => (
              /* binding */
              RawImage
            )
            /* harmony export */
          });
          var _hub_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__3(
            /*! ./hub.js */
            "./src/utils/hub.js"
          );
          var _env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__3(
            /*! ../env.js */
            "./src/env.js"
          );
          var _tensor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__3(
            /*! ./tensor.js */
            "./src/utils/tensor.js"
          );
          var sharp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__3(
            /*! sharp */
            "?2b25"
          );
          const BROWSER_ENV = typeof self !== "undefined";
          const WEBWORKER_ENV = BROWSER_ENV && self.constructor.name === "DedicatedWorkerGlobalScope";
          let createCanvasFunction;
          let ImageDataClass;
          let loadImageFunction;
          if (BROWSER_ENV) {
            createCanvasFunction = (width, height) => {
              if (!self.OffscreenCanvas) {
                throw new Error("OffscreenCanvas not supported by this browser.");
              }
              return new self.OffscreenCanvas(width, height);
            };
            loadImageFunction = self.createImageBitmap;
            ImageDataClass = self.ImageData;
          } else if (sharp__WEBPACK_IMPORTED_MODULE_3__) {
            loadImageFunction = async (img) => {
              const metadata = await img.metadata();
              const rawChannels = metadata.channels;
              let { data, info } = await img.rotate().raw().toBuffer({ resolveWithObject: true });
              const newImage = new RawImage(new Uint8ClampedArray(data), info.width, info.height, info.channels);
              if (rawChannels !== void 0 && rawChannels !== info.channels) {
                newImage.convert(rawChannels);
              }
              return newImage;
            };
          } else {
            throw new Error("Unable to load image processing library.");
          }
          const RESAMPLING_MAPPING = {
            0: "nearest",
            1: "lanczos",
            2: "bilinear",
            3: "bicubic",
            4: "box",
            5: "hamming"
          };
          const CONTENT_TYPE_MAP = /* @__PURE__ */ new Map([
            ["png", "image/png"],
            ["jpg", "image/jpeg"],
            ["jpeg", "image/jpeg"],
            ["gif", "image/gif"]
          ]);
          class RawImage {
            /**
             * Create a new `RawImage` object.
             * @param {Uint8ClampedArray|Uint8Array} data The pixel data.
             * @param {number} width The width of the image.
             * @param {number} height The height of the image.
             * @param {1|2|3|4} channels The number of channels.
             */
            constructor(data, width, height, channels) {
              this.data = data;
              this.width = width;
              this.height = height;
              this.channels = channels;
            }
            /** 
             * Returns the size of the image (width, height).
             * @returns {[number, number]} The size of the image (width, height).
             */
            get size() {
              return [this.width, this.height];
            }
            /**
             * Helper method for reading an image from a variety of input types.
             * @param {RawImage|string|URL} input 
             * @returns The image object.
             * 
             * **Example:** Read image from a URL.
             * ```javascript
             * let image = await RawImage.read('https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/football-match.jpg');
             * // RawImage {
             * //   "data": Uint8ClampedArray [ 25, 25, 25, 19, 19, 19, ... ],
             * //   "width": 800,
             * //   "height": 533,
             * //   "channels": 3
             * // }
             * ```
             */
            static async read(input) {
              if (input instanceof RawImage) {
                return input;
              } else if (typeof input === "string" || input instanceof URL) {
                return await this.fromURL(input);
              } else {
                throw new Error(`Unsupported input type: ${typeof input}`);
              }
            }
            /**
             * Read an image from a URL or file path.
             * @param {string|URL} url The URL or file path to read the image from.
             * @returns {Promise<RawImage>} The image object.
             */
            static async fromURL(url) {
              let response = await (0, _hub_js__WEBPACK_IMPORTED_MODULE_0__.getFile)(url);
              if (response.status !== 200) {
                throw new Error(`Unable to read image from "${url}" (${response.status} ${response.statusText})`);
              }
              let blob = await response.blob();
              return this.fromBlob(blob);
            }
            /**
             * Helper method to create a new Image from a blob.
             * @param {Blob} blob The blob to read the image from.
             * @returns {Promise<RawImage>} The image object.
             */
            static async fromBlob(blob) {
              if (BROWSER_ENV) {
                let img = await loadImageFunction(blob);
                const ctx = createCanvasFunction(img.width, img.height).getContext("2d");
                ctx.drawImage(img, 0, 0);
                return new this(ctx.getImageData(0, 0, img.width, img.height).data, img.width, img.height, 4);
              } else {
                let img = sharp__WEBPACK_IMPORTED_MODULE_3__(await blob.arrayBuffer());
                return await loadImageFunction(img);
              }
            }
            /**
             * Helper method to create a new Image from a tensor
             * @param {Tensor} tensor 
             */
            static fromTensor(tensor, channel_format = "CHW") {
              if (tensor.dims.length !== 3) {
                throw new Error(`Tensor should have 3 dimensions, but has ${tensor.dims.length} dimensions.`);
              }
              if (channel_format === "CHW") {
                tensor = tensor.transpose(1, 2, 0);
              } else if (channel_format === "HWC") {
              } else {
                throw new Error(`Unsupported channel format: ${channel_format}`);
              }
              if (!(tensor.data instanceof Uint8ClampedArray || tensor.data instanceof Uint8Array)) {
                throw new Error(`Unsupported tensor type: ${tensor.type}`);
              }
              switch (tensor.dims[2]) {
                case 1:
                case 2:
                case 3:
                case 4:
                  return new RawImage(tensor.data, tensor.dims[1], tensor.dims[0], tensor.dims[2]);
                default:
                  throw new Error(`Unsupported number of channels: ${tensor.dims[2]}`);
              }
            }
            /**
             * Convert the image to grayscale format.
             * @returns {RawImage} `this` to support chaining.
             */
            grayscale() {
              if (this.channels === 1) {
                return this;
              }
              let newData = new Uint8ClampedArray(this.width * this.height * 1);
              switch (this.channels) {
                case 3:
                case 4:
                  for (let i = 0, offset = 0; i < this.data.length; i += this.channels) {
                    const red = this.data[i];
                    const green = this.data[i + 1];
                    const blue = this.data[i + 2];
                    newData[offset++] = Math.round(0.2989 * red + 0.587 * green + 0.114 * blue);
                  }
                  break;
                default:
                  throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);
              }
              return this._update(newData, this.width, this.height, 1);
            }
            /**
             * Convert the image to RGB format.
             * @returns {RawImage} `this` to support chaining.
             */
            rgb() {
              if (this.channels === 3) {
                return this;
              }
              let newData = new Uint8ClampedArray(this.width * this.height * 3);
              switch (this.channels) {
                case 1:
                  for (let i = 0, offset = 0; i < this.data.length; ++i) {
                    newData[offset++] = this.data[i];
                    newData[offset++] = this.data[i];
                    newData[offset++] = this.data[i];
                  }
                  break;
                case 4:
                  for (let i = 0, offset = 0; i < this.data.length; i += 4) {
                    newData[offset++] = this.data[i];
                    newData[offset++] = this.data[i + 1];
                    newData[offset++] = this.data[i + 2];
                  }
                  break;
                default:
                  throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);
              }
              return this._update(newData, this.width, this.height, 3);
            }
            /**
             * Convert the image to RGBA format.
             * @returns {RawImage} `this` to support chaining.
             */
            rgba() {
              if (this.channels === 4) {
                return this;
              }
              let newData = new Uint8ClampedArray(this.width * this.height * 4);
              switch (this.channels) {
                case 1:
                  for (let i = 0, offset = 0; i < this.data.length; ++i) {
                    newData[offset++] = this.data[i];
                    newData[offset++] = this.data[i];
                    newData[offset++] = this.data[i];
                    newData[offset++] = 255;
                  }
                  break;
                case 3:
                  for (let i = 0, offset = 0; i < this.data.length; i += 3) {
                    newData[offset++] = this.data[i];
                    newData[offset++] = this.data[i + 1];
                    newData[offset++] = this.data[i + 2];
                    newData[offset++] = 255;
                  }
                  break;
                default:
                  throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);
              }
              return this._update(newData, this.width, this.height, 4);
            }
            /**
             * Resize the image to the given dimensions. This method uses the canvas API to perform the resizing.
             * @param {number} width The width of the new image.
             * @param {number} height The height of the new image.
             * @param {Object} options Additional options for resizing.
             * @param {0|1|2|3|4|5|string} [options.resample] The resampling method to use.
             * @returns {Promise<RawImage>} `this` to support chaining.
             */
            async resize(width, height, {
              resample = 2
            } = {}) {
              let resampleMethod = RESAMPLING_MAPPING[resample] ?? resample;
              if (BROWSER_ENV) {
                let numChannels = this.channels;
                let canvas = this.toCanvas();
                const ctx = createCanvasFunction(width, height).getContext("2d");
                ctx.drawImage(canvas, 0, 0, width, height);
                let resizedImage = new RawImage(ctx.getImageData(0, 0, width, height).data, width, height, 4);
                return resizedImage.convert(numChannels);
              } else {
                let img = this.toSharp();
                switch (resampleMethod) {
                  case "box":
                  case "hamming":
                    if (resampleMethod === "box" || resampleMethod === "hamming") {
                      console.warn(`Resampling method ${resampleMethod} is not yet supported. Using bilinear instead.`);
                      resampleMethod = "bilinear";
                    }
                  case "nearest":
                  case "bilinear":
                  case "bicubic":
                    img = img.affine([width / this.width, 0, 0, height / this.height], {
                      interpolator: resampleMethod
                    });
                    break;
                  case "lanczos":
                    img = img.resize({
                      width,
                      height,
                      fit: "fill",
                      kernel: "lanczos3"
                      // PIL Lanczos uses a kernel size of 3 
                    });
                    break;
                  default:
                    throw new Error(`Resampling method ${resampleMethod} is not supported.`);
                }
                return await loadImageFunction(img);
              }
            }
            async pad([left, right, top, bottom]) {
              left = Math.max(left, 0);
              right = Math.max(right, 0);
              top = Math.max(top, 0);
              bottom = Math.max(bottom, 0);
              if (left === 0 && right === 0 && top === 0 && bottom === 0) {
                return this;
              }
              if (BROWSER_ENV) {
                let numChannels = this.channels;
                let canvas = this.toCanvas();
                let newWidth = this.width + left + right;
                let newHeight = this.height + top + bottom;
                const ctx = createCanvasFunction(newWidth, newHeight).getContext("2d");
                ctx.drawImage(
                  canvas,
                  0,
                  0,
                  this.width,
                  this.height,
                  left,
                  top,
                  newWidth,
                  newHeight
                );
                let paddedImage = new RawImage(
                  ctx.getImageData(0, 0, newWidth, newHeight).data,
                  newWidth,
                  newHeight,
                  4
                );
                return paddedImage.convert(numChannels);
              } else {
                let img = this.toSharp().extend({ left, right, top, bottom });
                return await loadImageFunction(img);
              }
            }
            async crop([x_min, y_min, x_max, y_max]) {
              x_min = Math.max(x_min, 0);
              y_min = Math.max(y_min, 0);
              x_max = Math.min(x_max, this.width - 1);
              y_max = Math.min(y_max, this.height - 1);
              if (x_min === 0 && y_min === 0 && x_max === this.width - 1 && y_max === this.height - 1) {
                return this;
              }
              const crop_width = x_max - x_min + 1;
              const crop_height = y_max - y_min + 1;
              if (BROWSER_ENV) {
                const numChannels = this.channels;
                const canvas = this.toCanvas();
                const ctx = createCanvasFunction(crop_width, crop_height).getContext("2d");
                ctx.drawImage(
                  canvas,
                  x_min,
                  y_min,
                  crop_width,
                  crop_height,
                  0,
                  0,
                  crop_width,
                  crop_height
                );
                const resizedImage = new RawImage(ctx.getImageData(0, 0, crop_width, crop_height).data, crop_width, crop_height, 4);
                return resizedImage.convert(numChannels);
              } else {
                const img = this.toSharp().extract({
                  left: x_min,
                  top: y_min,
                  width: crop_width,
                  height: crop_height
                });
                return await loadImageFunction(img);
              }
            }
            async center_crop(crop_width, crop_height) {
              if (this.width === crop_width && this.height === crop_height) {
                return this;
              }
              let width_offset = (this.width - crop_width) / 2;
              let height_offset = (this.height - crop_height) / 2;
              if (BROWSER_ENV) {
                let numChannels = this.channels;
                let canvas = this.toCanvas();
                const ctx = createCanvasFunction(crop_width, crop_height).getContext("2d");
                let sourceX = 0;
                let sourceY = 0;
                let destX = 0;
                let destY = 0;
                if (width_offset >= 0) {
                  sourceX = width_offset;
                } else {
                  destX = -width_offset;
                }
                if (height_offset >= 0) {
                  sourceY = height_offset;
                } else {
                  destY = -height_offset;
                }
                ctx.drawImage(
                  canvas,
                  sourceX,
                  sourceY,
                  crop_width,
                  crop_height,
                  destX,
                  destY,
                  crop_width,
                  crop_height
                );
                let resizedImage = new RawImage(ctx.getImageData(0, 0, crop_width, crop_height).data, crop_width, crop_height, 4);
                return resizedImage.convert(numChannels);
              } else {
                let img = this.toSharp();
                if (width_offset >= 0 && height_offset >= 0) {
                  img = img.extract({
                    left: Math.floor(width_offset),
                    top: Math.floor(height_offset),
                    width: crop_width,
                    height: crop_height
                  });
                } else if (width_offset <= 0 && height_offset <= 0) {
                  let top = Math.floor(-height_offset);
                  let left = Math.floor(-width_offset);
                  img = img.extend({
                    top,
                    left,
                    // Ensures the resulting image has the desired dimensions
                    right: crop_width - this.width - left,
                    bottom: crop_height - this.height - top
                  });
                } else {
                  let y_padding = [0, 0];
                  let y_extract = 0;
                  if (height_offset < 0) {
                    y_padding[0] = Math.floor(-height_offset);
                    y_padding[1] = crop_height - this.height - y_padding[0];
                  } else {
                    y_extract = Math.floor(height_offset);
                  }
                  let x_padding = [0, 0];
                  let x_extract = 0;
                  if (width_offset < 0) {
                    x_padding[0] = Math.floor(-width_offset);
                    x_padding[1] = crop_width - this.width - x_padding[0];
                  } else {
                    x_extract = Math.floor(width_offset);
                  }
                  img = img.extend({
                    top: y_padding[0],
                    bottom: y_padding[1],
                    left: x_padding[0],
                    right: x_padding[1]
                  }).extract({
                    left: x_extract,
                    top: y_extract,
                    width: crop_width,
                    height: crop_height
                  });
                }
                return await loadImageFunction(img);
              }
            }
            async toBlob(type = "image/png", quality = 1) {
              if (!BROWSER_ENV) {
                throw new Error("toBlob() is only supported in browser environments.");
              }
              const canvas = this.toCanvas();
              return await canvas.convertToBlob({ type, quality });
            }
            toTensor(channel_format = "CHW") {
              let tensor = new _tensor_js__WEBPACK_IMPORTED_MODULE_2__.Tensor(
                "uint8",
                new Uint8Array(this.data),
                [this.height, this.width, this.channels]
              );
              if (channel_format === "HWC") {
              } else if (channel_format === "CHW") {
                tensor = tensor.permute(2, 0, 1);
              } else {
                throw new Error(`Unsupported channel format: ${channel_format}`);
              }
              return tensor;
            }
            toCanvas() {
              if (!BROWSER_ENV) {
                throw new Error("toCanvas() is only supported in browser environments.");
              }
              let cloned = this.clone().rgba();
              let clonedCanvas = createCanvasFunction(cloned.width, cloned.height);
              let data = new ImageDataClass(cloned.data, cloned.width, cloned.height);
              clonedCanvas.getContext("2d").putImageData(data, 0, 0);
              return clonedCanvas;
            }
            /**
             * Helper method to update the image data.
             * @param {Uint8ClampedArray} data The new image data.
             * @param {number} width The new width of the image.
             * @param {number} height The new height of the image.
             * @param {1|2|3|4|null} [channels] The new number of channels of the image.
             * @private
             */
            _update(data, width, height, channels = null) {
              this.data = data;
              this.width = width;
              this.height = height;
              if (channels !== null) {
                this.channels = channels;
              }
              return this;
            }
            /**
             * Clone the image
             * @returns {RawImage} The cloned image
             */
            clone() {
              return new RawImage(this.data.slice(), this.width, this.height, this.channels);
            }
            /**
             * Helper method for converting image to have a certain number of channels
             * @param {number} numChannels The number of channels. Must be 1, 3, or 4.
             * @returns {RawImage} `this` to support chaining.
             */
            convert(numChannels) {
              if (this.channels === numChannels)
                return this;
              switch (numChannels) {
                case 1:
                  this.grayscale();
                  break;
                case 3:
                  this.rgb();
                  break;
                case 4:
                  this.rgba();
                  break;
                default:
                  throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);
              }
              return this;
            }
            /**
             * Save the image to the given path.
             * @param {string} path The path to save the image to.
             */
            async save(path) {
              if (BROWSER_ENV) {
                if (WEBWORKER_ENV) {
                  throw new Error("Unable to save an image from a Web Worker.");
                }
                const extension = path.split(".").pop().toLowerCase();
                const mime = CONTENT_TYPE_MAP.get(extension) ?? "image/png";
                const blob = await this.toBlob(mime);
                const dataURL = URL.createObjectURL(blob);
                const downloadLink = document.createElement("a");
                downloadLink.href = dataURL;
                downloadLink.download = path;
                downloadLink.click();
                downloadLink.remove();
              } else if (!_env_js__WEBPACK_IMPORTED_MODULE_1__.env.useFS) {
                throw new Error("Unable to save the image because filesystem is disabled in this environment.");
              } else {
                const img = this.toSharp();
                return await img.toFile(path);
              }
            }
            toSharp() {
              if (BROWSER_ENV) {
                throw new Error("toSharp() is only supported in server-side environments.");
              }
              return sharp__WEBPACK_IMPORTED_MODULE_3__(this.data, {
                raw: {
                  width: this.width,
                  height: this.height,
                  channels: this.channels
                }
              });
            }
          }
        }
      ),
      /***/
      "./src/utils/maths.js": (
        /*!****************************!*\
          !*** ./src/utils/maths.js ***!
          \****************************/
        /***/
        (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "FFT": () => (
              /* binding */
              FFT
            ),
            /* harmony export */
            "bankers_round": () => (
              /* binding */
              bankers_round
            ),
            /* harmony export */
            "cos_sim": () => (
              /* binding */
              cos_sim
            ),
            /* harmony export */
            "dot": () => (
              /* binding */
              dot4
            ),
            /* harmony export */
            "getTopItems": () => (
              /* binding */
              getTopItems
            ),
            /* harmony export */
            "interpolate_data": () => (
              /* binding */
              interpolate_data
            ),
            /* harmony export */
            "log_softmax": () => (
              /* binding */
              log_softmax
            ),
            /* harmony export */
            "magnitude": () => (
              /* binding */
              magnitude
            ),
            /* harmony export */
            "max": () => (
              /* binding */
              max
            ),
            /* harmony export */
            "medianFilter": () => (
              /* binding */
              medianFilter
            ),
            /* harmony export */
            "min": () => (
              /* binding */
              min
            ),
            /* harmony export */
            "permute_data": () => (
              /* binding */
              permute_data
            ),
            /* harmony export */
            "round": () => (
              /* binding */
              round
            ),
            /* harmony export */
            "softmax": () => (
              /* binding */
              softmax
            )
            /* harmony export */
          });
          function interpolate_data(input, [in_channels, in_height, in_width], [out_height, out_width], mode = "bilinear", align_corners = false) {
            const x_scale = out_width / in_width;
            const y_scale = out_height / in_height;
            const out_img = new input.constructor(out_height * out_width * in_channels);
            const inStride = in_height * in_width;
            const outStride = out_height * out_width;
            for (let i = 0; i < out_height; ++i) {
              for (let j = 0; j < out_width; ++j) {
                const outOffset = i * out_width + j;
                const x = (j + 0.5) / x_scale - 0.5;
                const y = (i + 0.5) / y_scale - 0.5;
                let x1 = Math.floor(x);
                let y1 = Math.floor(y);
                const x2 = Math.min(x1 + 1, in_width - 1);
                const y2 = Math.min(y1 + 1, in_height - 1);
                x1 = Math.max(x1, 0);
                y1 = Math.max(y1, 0);
                const s = x - x1;
                const t = y - y1;
                const w1 = (1 - s) * (1 - t);
                const w2 = s * (1 - t);
                const w3 = (1 - s) * t;
                const w4 = s * t;
                const yStride = y1 * in_width;
                const xStride = y2 * in_width;
                const idx1 = yStride + x1;
                const idx2 = yStride + x2;
                const idx3 = xStride + x1;
                const idx4 = xStride + x2;
                for (let k = 0; k < in_channels; ++k) {
                  const cOffset = k * inStride;
                  out_img[k * outStride + outOffset] = w1 * input[cOffset + idx1] + w2 * input[cOffset + idx2] + w3 * input[cOffset + idx3] + w4 * input[cOffset + idx4];
                }
              }
            }
            return out_img;
          }
          function permute_data(array, dims, axes) {
            const shape = new Array(axes.length);
            const stride = new Array(axes.length);
            for (let i = axes.length - 1, s = 1; i >= 0; --i) {
              stride[i] = s;
              shape[i] = dims[axes[i]];
              s *= shape[i];
            }
            const invStride = axes.map((_, i) => stride[axes.indexOf(i)]);
            const permutedData = new array.constructor(array.length);
            for (let i = 0; i < array.length; ++i) {
              let newIndex = 0;
              for (let j = dims.length - 1, k = i; j >= 0; --j) {
                newIndex += k % dims[j] * invStride[j];
                k = Math.floor(k / dims[j]);
              }
              permutedData[newIndex] = array[i];
            }
            return [permutedData, shape];
          }
          function softmax(arr) {
            const maxVal = max(arr)[0];
            const exps = arr.map((x) => Math.exp(x - maxVal));
            const sumExps = exps.reduce((acc, val) => acc + val, 0);
            const softmaxArr = exps.map((x) => x / sumExps);
            return (
              /** @type {T} */
              softmaxArr
            );
          }
          function log_softmax(arr) {
            const softmaxArr = softmax(arr);
            const logSoftmaxArr = softmaxArr.map((x) => Math.log(x));
            return (
              /** @type {T} */
              logSoftmaxArr
            );
          }
          function dot4(arr1, arr2) {
            let result = 0;
            for (let i = 0; i < arr1.length; ++i) {
              result += arr1[i] * arr2[i];
            }
            return result;
          }
          function getTopItems(items, top_k = 0) {
            items = Array.from(items).map((x, i) => [i, x]).sort((a, b) => b[1] - a[1]);
            if (top_k !== null && top_k > 0) {
              items = items.slice(0, top_k);
            }
            return items;
          }
          function cos_sim(arr1, arr2) {
            const dotProduct = dot4(arr1, arr2);
            const magnitudeA = magnitude(arr1);
            const magnitudeB = magnitude(arr2);
            const cosineSimilarity = dotProduct / (magnitudeA * magnitudeB);
            return cosineSimilarity;
          }
          function magnitude(arr) {
            return Math.sqrt(arr.reduce((acc, val) => acc + val * val, 0));
          }
          function min(arr) {
            if (arr.length === 0)
              throw Error("Array must not be empty");
            let min2 = arr[0];
            let indexOfMin = 0;
            for (let i = 1; i < arr.length; ++i) {
              if (arr[i] < min2) {
                min2 = arr[i];
                indexOfMin = i;
              }
            }
            return [min2, indexOfMin];
          }
          function max(arr) {
            if (arr.length === 0)
              throw Error("Array must not be empty");
            let max2 = arr[0];
            let indexOfMax = 0;
            for (let i = 1; i < arr.length; ++i) {
              if (arr[i] > max2) {
                max2 = arr[i];
                indexOfMax = i;
              }
            }
            return [Number(max2), indexOfMax];
          }
          function isPowerOfTwo(number) {
            return number > 0 && (number & number - 1) === 0;
          }
          class P2FFT {
            /**
             * @param {number} size The size of the input array. Must be a power of two larger than 1.
             * @throws {Error} FFT size must be a power of two larger than 1.
             */
            constructor(size) {
              this.size = size | 0;
              if (this.size <= 1 || !isPowerOfTwo(this.size))
                throw new Error("FFT size must be a power of two larger than 1");
              this._csize = size << 1;
              this.table = new Float64Array(this.size * 2);
              for (let i = 0; i < this.table.length; i += 2) {
                const angle = Math.PI * i / this.size;
                this.table[i] = Math.cos(angle);
                this.table[i + 1] = -Math.sin(angle);
              }
              let power = 0;
              for (let t = 1; this.size > t; t <<= 1)
                ++power;
              this._width = power % 2 === 0 ? power - 1 : power;
              this._bitrev = new Int32Array(1 << this._width);
              for (let j = 0; j < this._bitrev.length; ++j) {
                this._bitrev[j] = 0;
                for (let shift = 0; shift < this._width; shift += 2) {
                  const revShift = this._width - shift - 2;
                  this._bitrev[j] |= (j >>> shift & 3) << revShift;
                }
              }
            }
            /**
             * Create a complex number array with size `2 * size`
             *
             * @returns {Float64Array} A complex number array with size `2 * size`
             */
            createComplexArray() {
              return new Float64Array(this._csize);
            }
            /**
             * Converts a complex number representation stored in a Float64Array to an array of real numbers.
             * 
             * @param {Float64Array} complex The complex number representation to be converted.
             * @param {number[]} [storage] An optional array to store the result in.
             * @returns {number[]} An array of real numbers representing the input complex number representation.
             */
            fromComplexArray(complex, storage) {
              const res = storage || new Array(complex.length >>> 1);
              for (let i = 0; i < complex.length; i += 2)
                res[i >>> 1] = complex[i];
              return res;
            }
            /**
             * Convert a real-valued input array to a complex-valued output array.
             * @param {Float64Array} input The real-valued input array.
             * @param {Float64Array} [storage] Optional buffer to store the output array.
             * @returns {Float64Array} The complex-valued output array.
             */
            toComplexArray(input, storage) {
              const res = storage || this.createComplexArray();
              for (let i = 0; i < res.length; i += 2) {
                res[i] = input[i >>> 1];
                res[i + 1] = 0;
              }
              return res;
            }
            /**
             * Performs a Fast Fourier Transform (FFT) on the given input data and stores the result in the output buffer.
             * 
             * @param {Float64Array} out The output buffer to store the result.
             * @param {Float64Array} data The input data to transform.
             * 
             * @throws {Error} Input and output buffers must be different.
             * 
             * @returns {void}
             */
            transform(out, data) {
              if (out === data)
                throw new Error("Input and output buffers must be different");
              this._transform4(
                out,
                data,
                1
                /* DONE */
              );
            }
            /**
             * Performs a real-valued forward FFT on the given input buffer and stores the result in the given output buffer.
             * The input buffer must contain real values only, while the output buffer will contain complex values. The input and
             * output buffers must be different.
             *
             * @param {Float64Array} out The output buffer.
             * @param {Float64Array} data The input buffer containing real values.
             *
             * @throws {Error} If the input and output buffers are the same.
             */
            realTransform(out, data) {
              if (out === data)
                throw new Error("Input and output buffers must be different");
              this._realTransform4(
                out,
                data,
                1
                /* DONE */
              );
            }
            /**
             * Performs an inverse FFT transformation on the given `data` array, and stores the result in `out`.
             * The `out` array must be a different buffer than the `data` array. The `out` array will contain the
             * result of the transformation. The `data` array will not be modified.
             * 
             * @param {Float64Array} out The output buffer for the transformed data.
             * @param {Float64Array} data The input data to transform.
             * @throws {Error} If `out` and `data` refer to the same buffer.
             * @returns {void}
             */
            inverseTransform(out, data) {
              if (out === data)
                throw new Error("Input and output buffers must be different");
              this._transform4(
                out,
                data,
                -1
                /* DONE */
              );
              for (let i = 0; i < out.length; ++i)
                out[i] /= this.size;
            }
            /**
             * Performs a radix-4 implementation of a discrete Fourier transform on a given set of data.
             *
             * @param {Float64Array} out The output buffer for the transformed data.
             * @param {Float64Array} data The input buffer of data to be transformed.
             * @param {number} inv A scaling factor to apply to the transform.
             * @returns {void}
             */
            _transform4(out, data, inv) {
              const size = this._csize;
              const width = this._width;
              let step = 1 << width;
              let len = size / step << 1;
              let outOff;
              let t;
              const bitrev = this._bitrev;
              if (len === 4) {
                for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {
                  const off = bitrev[t];
                  this._singleTransform2(data, out, outOff, off, step);
                }
              } else {
                for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {
                  const off = bitrev[t];
                  this._singleTransform4(data, out, outOff, off, step, inv);
                }
              }
              const table2 = this.table;
              for (step >>= 2; step >= 2; step >>= 2) {
                len = size / step << 1;
                const quarterLen = len >>> 2;
                for (outOff = 0; outOff < size; outOff += len) {
                  const limit = outOff + quarterLen - 1;
                  for (let i = outOff, k = 0; i < limit; i += 2, k += step) {
                    const A = i;
                    const B = A + quarterLen;
                    const C = B + quarterLen;
                    const D = C + quarterLen;
                    const Ar = out[A];
                    const Ai = out[A + 1];
                    const Br = out[B];
                    const Bi = out[B + 1];
                    const Cr = out[C];
                    const Ci = out[C + 1];
                    const Dr = out[D];
                    const Di = out[D + 1];
                    const tableBr = table2[k];
                    const tableBi = inv * table2[k + 1];
                    const MBr = Br * tableBr - Bi * tableBi;
                    const MBi = Br * tableBi + Bi * tableBr;
                    const tableCr = table2[2 * k];
                    const tableCi = inv * table2[2 * k + 1];
                    const MCr = Cr * tableCr - Ci * tableCi;
                    const MCi = Cr * tableCi + Ci * tableCr;
                    const tableDr = table2[3 * k];
                    const tableDi = inv * table2[3 * k + 1];
                    const MDr = Dr * tableDr - Di * tableDi;
                    const MDi = Dr * tableDi + Di * tableDr;
                    const T0r = Ar + MCr;
                    const T0i = Ai + MCi;
                    const T1r = Ar - MCr;
                    const T1i = Ai - MCi;
                    const T2r = MBr + MDr;
                    const T2i = MBi + MDi;
                    const T3r = inv * (MBr - MDr);
                    const T3i = inv * (MBi - MDi);
                    out[A] = T0r + T2r;
                    out[A + 1] = T0i + T2i;
                    out[B] = T1r + T3i;
                    out[B + 1] = T1i - T3r;
                    out[C] = T0r - T2r;
                    out[C + 1] = T0i - T2i;
                    out[D] = T1r - T3i;
                    out[D + 1] = T1i + T3r;
                  }
                }
              }
            }
            /**
             * Performs a radix-2 implementation of a discrete Fourier transform on a given set of data.
             *
             * @param {Float64Array} data The input buffer of data to be transformed.
             * @param {Float64Array} out The output buffer for the transformed data.
             * @param {number} outOff The offset at which to write the output data.
             * @param {number} off The offset at which to begin reading the input data.
             * @param {number} step The step size for indexing the input data.
             * @returns {void}
             */
            _singleTransform2(data, out, outOff, off, step) {
              const evenR = data[off];
              const evenI = data[off + 1];
              const oddR = data[off + step];
              const oddI = data[off + step + 1];
              out[outOff] = evenR + oddR;
              out[outOff + 1] = evenI + oddI;
              out[outOff + 2] = evenR - oddR;
              out[outOff + 3] = evenI - oddI;
            }
            /**
             * Performs radix-4 transformation on input data of length 8
             *
             * @param {Float64Array} data Input data array of length 8
             * @param {Float64Array} out Output data array of length 8
             * @param {number} outOff Index of output array to start writing from
             * @param {number} off Index of input array to start reading from
             * @param {number} step Step size between elements in input array
             * @param {number} inv Scaling factor for inverse transform
             * 
             * @returns {void}
             */
            _singleTransform4(data, out, outOff, off, step, inv) {
              const step2 = step * 2;
              const step3 = step * 3;
              const Ar = data[off];
              const Ai = data[off + 1];
              const Br = data[off + step];
              const Bi = data[off + step + 1];
              const Cr = data[off + step2];
              const Ci = data[off + step2 + 1];
              const Dr = data[off + step3];
              const Di = data[off + step3 + 1];
              const T0r = Ar + Cr;
              const T0i = Ai + Ci;
              const T1r = Ar - Cr;
              const T1i = Ai - Ci;
              const T2r = Br + Dr;
              const T2i = Bi + Di;
              const T3r = inv * (Br - Dr);
              const T3i = inv * (Bi - Di);
              out[outOff] = T0r + T2r;
              out[outOff + 1] = T0i + T2i;
              out[outOff + 2] = T1r + T3i;
              out[outOff + 3] = T1i - T3r;
              out[outOff + 4] = T0r - T2r;
              out[outOff + 5] = T0i - T2i;
              out[outOff + 6] = T1r - T3i;
              out[outOff + 7] = T1i + T3r;
            }
            /**
             * Real input radix-4 implementation
             * @param {Float64Array} out Output array for the transformed data
             * @param {Float64Array} data Input array of real data to be transformed
             * @param {number} inv The scale factor used to normalize the inverse transform
             */
            _realTransform4(out, data, inv) {
              const size = this._csize;
              const width = this._width;
              let step = 1 << width;
              let len = size / step << 1;
              let outOff;
              let t;
              const bitrev = this._bitrev;
              if (len === 4) {
                for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {
                  const off = bitrev[t];
                  this._singleRealTransform2(data, out, outOff, off >>> 1, step >>> 1);
                }
              } else {
                for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {
                  const off = bitrev[t];
                  this._singleRealTransform4(data, out, outOff, off >>> 1, step >>> 1, inv);
                }
              }
              const table2 = this.table;
              for (step >>= 2; step >= 2; step >>= 2) {
                len = size / step << 1;
                const halfLen = len >>> 1;
                const quarterLen = halfLen >>> 1;
                const hquarterLen = quarterLen >>> 1;
                for (outOff = 0; outOff < size; outOff += len) {
                  for (let i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {
                    const A = outOff + i;
                    const B = A + quarterLen;
                    const C = B + quarterLen;
                    const D = C + quarterLen;
                    const Ar = out[A];
                    const Ai = out[A + 1];
                    const Br = out[B];
                    const Bi = out[B + 1];
                    const Cr = out[C];
                    const Ci = out[C + 1];
                    const Dr = out[D];
                    const Di = out[D + 1];
                    const MAr = Ar;
                    const MAi = Ai;
                    const tableBr = table2[k];
                    const tableBi = inv * table2[k + 1];
                    const MBr = Br * tableBr - Bi * tableBi;
                    const MBi = Br * tableBi + Bi * tableBr;
                    const tableCr = table2[2 * k];
                    const tableCi = inv * table2[2 * k + 1];
                    const MCr = Cr * tableCr - Ci * tableCi;
                    const MCi = Cr * tableCi + Ci * tableCr;
                    const tableDr = table2[3 * k];
                    const tableDi = inv * table2[3 * k + 1];
                    const MDr = Dr * tableDr - Di * tableDi;
                    const MDi = Dr * tableDi + Di * tableDr;
                    const T0r = MAr + MCr;
                    const T0i = MAi + MCi;
                    const T1r = MAr - MCr;
                    const T1i = MAi - MCi;
                    const T2r = MBr + MDr;
                    const T2i = MBi + MDi;
                    const T3r = inv * (MBr - MDr);
                    const T3i = inv * (MBi - MDi);
                    out[A] = T0r + T2r;
                    out[A + 1] = T0i + T2i;
                    out[B] = T1r + T3i;
                    out[B + 1] = T1i - T3r;
                    if (i === 0) {
                      out[C] = T0r - T2r;
                      out[C + 1] = T0i - T2i;
                      continue;
                    }
                    if (i === hquarterLen)
                      continue;
                    const SA = outOff + quarterLen - i;
                    const SB = outOff + halfLen - i;
                    out[SA] = T1r - inv * T3i;
                    out[SA + 1] = -T1i - inv * T3r;
                    out[SB] = T0r - inv * T2r;
                    out[SB + 1] = -T0i + inv * T2i;
                  }
                }
              }
              const half = size >>> 1;
              for (let i = 2; i < half; i += 2) {
                out[size - i] = out[i];
                out[size - i + 1] = -out[i + 1];
              }
            }
            /**
             * Performs a single real input radix-2 transformation on the provided data
             * 
             * @param {Float64Array} data The input data array
             * @param {Float64Array} out The output data array
             * @param {number} outOff The output offset
             * @param {number} off The input offset
             * @param {number} step The step
             * 
             * @returns {void}
             */
            _singleRealTransform2(data, out, outOff, off, step) {
              const evenR = data[off];
              const oddR = data[off + step];
              out[outOff] = evenR + oddR;
              out[outOff + 1] = 0;
              out[outOff + 2] = evenR - oddR;
              out[outOff + 3] = 0;
            }
            /**
             * Computes a single real-valued transform using radix-4 algorithm.
             * This method is only called for len=8.
             *
             * @param {Float64Array} data The input data array.
             * @param {Float64Array} out The output data array.
             * @param {number} outOff The offset into the output array.
             * @param {number} off The offset into the input array.
             * @param {number} step The step size for the input array.
             * @param {number} inv The value of inverse.
             */
            _singleRealTransform4(data, out, outOff, off, step, inv) {
              const step2 = step * 2;
              const step3 = step * 3;
              const Ar = data[off];
              const Br = data[off + step];
              const Cr = data[off + step2];
              const Dr = data[off + step3];
              const T0r = Ar + Cr;
              const T1r = Ar - Cr;
              const T2r = Br + Dr;
              const T3r = inv * (Br - Dr);
              out[outOff] = T0r + T2r;
              out[outOff + 1] = 0;
              out[outOff + 2] = T1r;
              out[outOff + 3] = -T3r;
              out[outOff + 4] = T0r - T2r;
              out[outOff + 5] = 0;
              out[outOff + 6] = T1r;
              out[outOff + 7] = T3r;
            }
          }
          class NP2FFT {
            /**
             * Constructs a new NP2FFT object.
             * @param {number} fft_length The length of the FFT
             */
            constructor(fft_length) {
              const a = 2 * (fft_length - 1);
              const b = 2 * (2 * fft_length - 1);
              const nextP2 = 2 ** Math.ceil(Math.log2(b));
              this.bufferSize = nextP2;
              this._a = a;
              const chirp = new Float64Array(b);
              const ichirp = new Float64Array(nextP2);
              this._chirpBuffer = new Float64Array(nextP2);
              this._buffer1 = new Float64Array(nextP2);
              this._buffer2 = new Float64Array(nextP2);
              this._outBuffer1 = new Float64Array(nextP2);
              this._outBuffer2 = new Float64Array(nextP2);
              const theta = -2 * Math.PI / fft_length;
              const baseR = Math.cos(theta);
              const baseI = Math.sin(theta);
              for (let i = 0; i < b >> 1; ++i) {
                const e = (i + 1 - fft_length) ** 2 / 2;
                const result_mod = Math.sqrt(baseR ** 2 + baseI ** 2) ** e;
                const result_arg = e * Math.atan2(baseI, baseR);
                const i2 = 2 * i;
                chirp[i2] = result_mod * Math.cos(result_arg);
                chirp[i2 + 1] = result_mod * Math.sin(result_arg);
                ichirp[i2] = chirp[i2];
                ichirp[i2 + 1] = -chirp[i2 + 1];
              }
              this._slicedChirpBuffer = chirp.subarray(a, b);
              this._f = new P2FFT(nextP2 >> 1);
              this._f.transform(this._chirpBuffer, ichirp);
            }
            _transform(output, input, real) {
              const ib1 = this._buffer1;
              const ib2 = this._buffer2;
              const ob2 = this._outBuffer1;
              const ob3 = this._outBuffer2;
              const cb = this._chirpBuffer;
              const sb = this._slicedChirpBuffer;
              const a = this._a;
              if (real) {
                for (let j = 0; j < sb.length; j += 2) {
                  const j2 = j + 1;
                  const j3 = j >> 1;
                  const a_real = input[j3];
                  ib1[j] = a_real * sb[j];
                  ib1[j2] = a_real * sb[j2];
                }
              } else {
                for (let j = 0; j < sb.length; j += 2) {
                  const j2 = j + 1;
                  ib1[j] = input[j] * sb[j] - input[j2] * sb[j2];
                  ib1[j2] = input[j] * sb[j2] + input[j2] * sb[j];
                }
              }
              this._f.transform(ob2, ib1);
              for (let j = 0; j < cb.length; j += 2) {
                const j2 = j + 1;
                ib2[j] = ob2[j] * cb[j] - ob2[j2] * cb[j2];
                ib2[j2] = ob2[j] * cb[j2] + ob2[j2] * cb[j];
              }
              this._f.inverseTransform(ob3, ib2);
              for (let j = 0; j < ob3.length; j += 2) {
                const a_real = ob3[j + a];
                const a_imag = ob3[j + a + 1];
                const b_real = sb[j];
                const b_imag = sb[j + 1];
                output[j] = a_real * b_real - a_imag * b_imag;
                output[j + 1] = a_real * b_imag + a_imag * b_real;
              }
            }
            transform(output, input) {
              this._transform(output, input, false);
            }
            realTransform(output, input) {
              this._transform(output, input, true);
            }
          }
          class FFT {
            constructor(fft_length) {
              this.fft_length = fft_length;
              this.isPowerOfTwo = isPowerOfTwo(fft_length);
              if (this.isPowerOfTwo) {
                this.fft = new P2FFT(fft_length);
                this.outputBufferSize = 2 * fft_length;
              } else {
                this.fft = new NP2FFT(fft_length);
                this.outputBufferSize = this.fft.bufferSize;
              }
            }
            realTransform(out, input) {
              this.fft.realTransform(out, input);
            }
            transform(out, input) {
              this.fft.transform(out, input);
            }
          }
          function medianFilter(data, windowSize) {
            if (windowSize % 2 === 0 || windowSize <= 0) {
              throw new Error("Window size must be a positive odd number");
            }
            const outputArray = new data.constructor(data.length);
            const buffer = new data.constructor(windowSize);
            const halfWindowSize = Math.floor(windowSize / 2);
            for (let i = 0; i < data.length; ++i) {
              let valuesIndex = 0;
              for (let j = -halfWindowSize; j <= halfWindowSize; ++j) {
                let index = i + j;
                if (index < 0) {
                  index = Math.abs(index);
                } else if (index >= data.length) {
                  index = 2 * (data.length - 1) - index;
                }
                buffer[valuesIndex++] = data[index];
              }
              buffer.sort();
              outputArray[i] = buffer[halfWindowSize];
            }
            return outputArray;
          }
          function round(num, decimals) {
            const pow = Math.pow(10, decimals);
            return Math.round(num * pow) / pow;
          }
          function bankers_round(x) {
            const r = Math.round(x);
            const br = Math.abs(x) % 1 === 0.5 ? r % 2 === 0 ? r : r - 1 : r;
            return br;
          }
        }
      ),
      /***/
      "./src/utils/tensor.js": (
        /*!*****************************!*\
          !*** ./src/utils/tensor.js ***!
          \*****************************/
        /***/
        (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__3) => {
          __webpack_require__3.r(__webpack_exports__2);
          __webpack_require__3.d(__webpack_exports__2, {
            /* harmony export */
            "Tensor": () => (
              /* binding */
              Tensor
            ),
            /* harmony export */
            "cat": () => (
              /* binding */
              cat
            ),
            /* harmony export */
            "dynamicTimeWarping": () => (
              /* binding */
              dynamicTimeWarping
            ),
            /* harmony export */
            "interpolate": () => (
              /* binding */
              interpolate
            ),
            /* harmony export */
            "layer_norm": () => (
              /* binding */
              layer_norm
            ),
            /* harmony export */
            "mean": () => (
              /* binding */
              mean
            ),
            /* harmony export */
            "mean_pooling": () => (
              /* binding */
              mean_pooling
            ),
            /* harmony export */
            "ones": () => (
              /* binding */
              ones
            ),
            /* harmony export */
            "ones_like": () => (
              /* binding */
              ones_like
            ),
            /* harmony export */
            "permute": () => (
              /* binding */
              permute
            ),
            /* harmony export */
            "quantize_embeddings": () => (
              /* binding */
              quantize_embeddings
            ),
            /* harmony export */
            "stack": () => (
              /* binding */
              stack
            ),
            /* harmony export */
            "std_mean": () => (
              /* binding */
              std_mean
            )
            /* harmony export */
          });
          var _backends_onnx_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__3(
            /*! ../backends/onnx.js */
            "./src/backends/onnx.js"
          );
          var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__3(
            /*! ./maths.js */
            "./src/utils/maths.js"
          );
          const DataTypeMap = Object.freeze({
            float32: Float32Array,
            float64: Float64Array,
            string: Array,
            // string[]
            int8: Int8Array,
            uint8: Uint8Array,
            int16: Int16Array,
            uint16: Uint16Array,
            int32: Int32Array,
            uint32: Uint32Array,
            int64: BigInt64Array,
            uint64: BigUint64Array,
            bool: Uint8Array
          });
          const ONNXTensor = _backends_onnx_js__WEBPACK_IMPORTED_MODULE_0__.ONNX.Tensor;
          class Tensor {
            /**
             * Create a new Tensor or copy an existing Tensor.
             * @param {[DataType, DataArray, number[]]|[import('onnxruntime-common').Tensor]} args
             */
            constructor(...args) {
              /** @type {number[]} Dimensions of the tensor. */
              __publicField(this, "dims");
              /** @type {DataType} Type of the tensor. */
              __publicField(this, "type");
              /** @type {DataArray} The data stored in the tensor. */
              __publicField(this, "data");
              /** @type {number} The number of elements in the tensor. */
              __publicField(this, "size");
              if (args[0] instanceof ONNXTensor) {
                Object.assign(this, args[0]);
              } else {
                Object.assign(this, new ONNXTensor(
                  /** @type {DataType} */
                  args[0],
                  /** @type {Exclude<import('./maths.js').AnyTypedArray, Uint8ClampedArray>} */
                  args[1],
                  args[2]
                ));
              }
              return new Proxy(this, {
                get: (obj, key) => {
                  if (typeof key === "string") {
                    let index = Number(key);
                    if (Number.isInteger(index)) {
                      return obj._getitem(index);
                    }
                  }
                  return obj[key];
                },
                set: (obj, key, value) => {
                  return obj[key] = value;
                }
              });
            }
            /**
             * Returns an iterator object for iterating over the tensor data in row-major order.
             * If the tensor has more than one dimension, the iterator will yield subarrays.
             * @returns {Iterator} An iterator object for iterating over the tensor data in row-major order.
             */
            *[Symbol.iterator]() {
              const [iterLength, ...iterDims] = this.dims;
              if (iterDims.length > 0) {
                const iterSize = iterDims.reduce((a, b) => a * b);
                for (let i = 0; i < iterLength; ++i) {
                  yield this._subarray(i, iterSize, iterDims);
                }
              } else {
                yield* this.data;
              }
            }
            /**
             * Index into a Tensor object.
             * @param {number} index The index to access.
             * @returns {Tensor} The data at the specified index.
             */
            _getitem(index) {
              const [iterLength, ...iterDims] = this.dims;
              index = safeIndex(index, iterLength);
              if (iterDims.length > 0) {
                const iterSize = iterDims.reduce((a, b) => a * b);
                return this._subarray(index, iterSize, iterDims);
              } else {
                return new Tensor(this.type, [this.data[index]], iterDims);
              }
            }
            /**
             * @param {number|bigint} item The item to search for in the tensor
             * @returns {number} The index of the first occurrence of item in the tensor data.
             */
            indexOf(item) {
              for (let index = 0; index < this.data.length; ++index) {
                if (this.data[index] == item) {
                  return index;
                }
              }
              return -1;
            }
            /**
             * @param {number} index 
             * @param {number} iterSize 
             * @param {any} iterDims 
             * @returns {Tensor}
             */
            _subarray(index, iterSize, iterDims) {
              const o1 = index * iterSize;
              const o2 = (index + 1) * iterSize;
              const data = "subarray" in this.data ? this.data.subarray(o1, o2) : this.data.slice(o1, o2);
              return new Tensor(this.type, data, iterDims);
            }
            /**
             * Returns the value of this tensor as a standard JavaScript Number. This only works
             * for tensors with one element. For other cases, see `Tensor.tolist()`.
             * @returns {number|bigint} The value of this tensor as a standard JavaScript Number.
             * @throws {Error} If the tensor has more than one element.
             */
            item() {
              if (this.data.length !== 1) {
                throw new Error(`a Tensor with ${this.data.length} elements cannot be converted to Scalar`);
              }
              return this.data[0];
            }
            /**
             * Convert tensor data to a n-dimensional JS list
             * @returns {Array}
             */
            tolist() {
              return reshape(this.data, this.dims);
            }
            /**
             * Return a new Tensor with the sigmoid function applied to each element.
             * @returns {Tensor} The tensor with the sigmoid function applied.
             */
            sigmoid() {
              return this.clone().sigmoid_();
            }
            /**
             * Applies the sigmoid function to the tensor in place.
             * @returns {Tensor} Returns `this`.
             */
            sigmoid_() {
              for (let i = 0; i < this.data.length; ++i) {
                this.data[i] = 1 / (1 + Math.exp(-this.data[i]));
              }
              return this;
            }
            /**
             * Return a new Tensor with every element multiplied by a constant.
             * @param {number} val The value to multiply by.
             * @returns {Tensor} The new tensor.
             */
            mul(val) {
              return this.clone().mul_(val);
            }
            /**
             * Multiply the tensor by a constant in place.
             * @param {number} val The value to multiply by.
             * @returns {Tensor} Returns `this`.
             */
            mul_(val) {
              for (let i = 0; i < this.data.length; ++i) {
                this.data[i] *= val;
              }
              return this;
            }
            /**
             * Return a new Tensor with every element added by a constant.
             * @param {number} val The value to add by.
             * @returns {Tensor} The new tensor.
             */
            add(val) {
              return this.clone().add_(val);
            }
            /**
             * Add the tensor by a constant in place.
             * @param {number} val The value to add by.
             * @returns {Tensor} Returns `this`.
             */
            add_(val) {
              for (let i = 0; i < this.data.length; ++i) {
                this.data[i] += val;
              }
              return this;
            }
            clone() {
              return new Tensor(this.type, this.data.slice(), this.dims.slice());
            }
            slice(...slices) {
              let newTensorDims = [];
              let newOffsets = [];
              for (let sliceIndex = 0; sliceIndex < this.dims.length; ++sliceIndex) {
                let slice = slices[sliceIndex];
                if (slice === null || slice === void 0) {
                  newOffsets.push([0, this.dims[sliceIndex]]);
                  newTensorDims.push(this.dims[sliceIndex]);
                } else if (typeof slice === "number") {
                  slice = safeIndex(slice, this.dims[sliceIndex], sliceIndex);
                  newOffsets.push([slice, slice + 1]);
                } else if (Array.isArray(slice) && slice.length === 2) {
                  if (slice[0] > slice[1]) {
                    throw new Error(`Invalid slice: ${slice}`);
                  }
                  let offsets = [
                    Math.max(slice[0], 0),
                    Math.min(slice[1], this.dims[sliceIndex])
                  ];
                  newOffsets.push(offsets);
                  newTensorDims.push(offsets[1] - offsets[0]);
                } else {
                  throw new Error(`Invalid slice: ${slice}`);
                }
              }
              let newDims = newOffsets.map(([start, end]) => end - start);
              let newBufferSize = newDims.reduce((a, b) => a * b);
              let data = new this.data.constructor(newBufferSize);
              const stride = this.stride();
              for (let i = 0; i < newBufferSize; ++i) {
                let originalIndex = 0;
                for (let j = newDims.length - 1, num = i; j >= 0; --j) {
                  const size = newDims[j];
                  originalIndex += (num % size + newOffsets[j][0]) * stride[j];
                  num = Math.floor(num / size);
                }
                data[i] = this.data[originalIndex];
              }
              return new Tensor(this.type, data, newTensorDims);
            }
            /**
             * Return a permuted version of this Tensor, according to the provided dimensions.
             * @param  {...number} dims Dimensions to permute.
             * @returns {Tensor} The permuted tensor.
             */
            permute(...dims) {
              return permute(this, dims);
            }
            // TODO: implement transpose. For now (backwards compatibility), it's just an alias for permute()
            transpose(...dims) {
              return this.permute(...dims);
            }
            // TODO add .max() and .min() methods
            /**
             * Returns the sum of each row of the input tensor in the given dimension dim.
             * 
             * @param {number} [dim=null] The dimension or dimensions to reduce. If `null`, all dimensions are reduced.
             * @param {boolean} keepdim Whether the output tensor has `dim` retained or not.
             * @returns The summed tensor
             */
            sum(dim = null, keepdim = false) {
              return this.norm(1, dim, keepdim);
            }
            /**
             * Returns the matrix norm or vector norm of a given tensor.
             * @param {number|string} [p='fro'] The order of norm
             * @param {number} [dim=null] Specifies which dimension of the tensor to calculate the norm across.
             * If dim is None, the norm will be calculated across all dimensions of input.
             * @param {boolean} [keepdim=false] Whether the output tensors have dim retained or not.
             * @returns {Tensor} The norm of the tensor.
             */
            norm(p = "fro", dim = null, keepdim = false) {
              if (p === "fro") {
                p = 2;
              } else if (typeof p === "string") {
                throw Error(`Unsupported norm: ${p}`);
              }
              if (dim === null) {
                let val = this.data.reduce((a, b) => a + b ** p, 0) ** (1 / p);
                return new Tensor(this.type, [val], []);
              }
              dim = safeIndex(dim, this.dims.length);
              const resultDims = this.dims.slice();
              resultDims[dim] = 1;
              const result = new this.data.constructor(this.data.length / this.dims[dim]);
              for (let i = 0; i < this.data.length; ++i) {
                let resultIndex = 0;
                for (let j = this.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {
                  const size = this.dims[j];
                  if (j !== dim) {
                    const index = num % size;
                    resultIndex += index * resultMultiplier;
                    resultMultiplier *= resultDims[j];
                  }
                  num = Math.floor(num / size);
                }
                result[resultIndex] += this.data[i] ** p;
              }
              if (p !== 1) {
                for (let i = 0; i < result.length; ++i) {
                  result[i] = result[i] ** (1 / p);
                }
              }
              if (!keepdim) {
                resultDims.splice(dim, 1);
              }
              return new Tensor(this.type, result, resultDims);
            }
            /**
             * Performs `L_p` normalization of inputs over specified dimension. Operates in place.
             * @param {number} [p=2] The exponent value in the norm formulation
             * @param {number} [dim=1] The dimension to reduce
             * @returns {Tensor} `this` for operation chaining.
             */
            normalize_(p = 2, dim = 1) {
              dim = safeIndex(dim, this.dims.length);
              const norm = this.norm(p, dim, true);
              for (let i = 0; i < this.data.length; ++i) {
                let resultIndex = 0;
                for (let j = this.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {
                  const size = this.dims[j];
                  if (j !== dim) {
                    const index = num % size;
                    resultIndex += index * resultMultiplier;
                    resultMultiplier *= this.dims[j];
                  }
                  num = Math.floor(num / size);
                }
                this.data[i] /= norm.data[resultIndex];
              }
              return this;
            }
            /**
             * Performs `L_p` normalization of inputs over specified dimension.
             * @param {number} [p=2] The exponent value in the norm formulation
             * @param {number} [dim=1] The dimension to reduce
             * @returns {Tensor} The normalized tensor.
             */
            normalize(p = 2, dim = 1) {
              return this.clone().normalize_(p, dim);
            }
            /**
             * Compute and return the stride of this tensor.
             * Stride is the jump necessary to go from one element to the next one in the specified dimension dim.
             * @returns {number[]} The stride of this tensor.
             */
            stride() {
              return dimsToStride(this.dims);
            }
            /**
             * Returns a tensor with all specified dimensions of input of size 1 removed.
             * 
             * NOTE: The returned tensor shares the storage with the input tensor, so changing the contents of one will change the contents of the other.
             * If you would like a copy, use `tensor.clone()` before squeezing.
             * 
             * @param {number} [dim=null] If given, the input will be squeezed only in the specified dimensions.
             * @returns The squeezed tensor
             */
            squeeze(dim = null) {
              return new Tensor(
                this.type,
                this.data,
                calc_squeeze_dims(this.dims, dim)
              );
            }
            /**
             * In-place version of @see {@link Tensor.squeeze}
             */
            squeeze_(dim = null) {
              this.dims = calc_squeeze_dims(this.dims, dim);
              return this;
            }
            /**
             * Returns a new tensor with a dimension of size one inserted at the specified position.
             * 
             * NOTE: The returned tensor shares the same underlying data with this tensor.
             * 
             * @param {number} dim The index at which to insert the singleton dimension
             * @returns The unsqueezed tensor
             */
            unsqueeze(dim = null) {
              return new Tensor(
                this.type,
                this.data,
                calc_unsqueeze_dims(this.dims, dim)
              );
            }
            /**
             * In-place version of @see {@link Tensor.unsqueeze}
             */
            unsqueeze_(dim = null) {
              this.dims = calc_unsqueeze_dims(this.dims, dim);
              return this;
            }
            /**
             * In-place version of @see {@link Tensor.flatten}
             */
            flatten_(start_dim = 0, end_dim = -1) {
              end_dim = (end_dim + this.dims.length) % this.dims.length;
              let dimsToKeepBefore = this.dims.slice(0, start_dim);
              let dimsToFlatten = this.dims.slice(start_dim, end_dim + 1);
              let dimsToKeepAfter = this.dims.slice(end_dim + 1);
              this.dims = [...dimsToKeepBefore, dimsToFlatten.reduce((a, b) => a * b, 1), ...dimsToKeepAfter];
              return this;
            }
            /**
             * Flattens input by reshaping it into a one-dimensional tensor.
             * If `start_dim` or `end_dim` are passed, only dimensions starting with `start_dim`
             * and ending with `end_dim` are flattened. The order of elements in input is unchanged.
             * @param {number} start_dim the first dim to flatten
             * @param {number} end_dim the last dim to flatten
             * @returns The flattened tensor.
             */
            flatten(start_dim = 0, end_dim = -1) {
              return this.clone().flatten_(start_dim, end_dim);
            }
            /**
             * Returns a new tensor with the same data as the `self` tensor but of a different `shape`.
             * @param  {...number} dims the desired size
             * @returns {Tensor} The tensor with the same data but different shape
             */
            view(...dims) {
              let inferredIndex = -1;
              for (let i = 0; i < dims.length; ++i) {
                if (dims[i] === -1) {
                  if (inferredIndex !== -1) {
                    throw new Error("Only one dimension can be inferred");
                  }
                  inferredIndex = i;
                }
              }
              if (inferredIndex !== -1) {
                const productOther = dims.reduce((product, curr, index) => {
                  return index !== inferredIndex ? product * curr : product;
                }, 1);
                dims[inferredIndex] = this.data.length / productOther;
              }
              return new Tensor(this.type, this.data, dims);
            }
            neg_() {
              for (let i = 0; i < this.data.length; ++i) {
                this.data[i] = -this.data[i];
              }
              return this;
            }
            neg() {
              return this.clone().neg_();
            }
            /**
             * In-place version of @see {@link Tensor.clamp}
             */
            clamp_(min, max) {
              for (let i = 0; i < this.data.length; ++i) {
                this.data[i] = Math.min(Math.max(this.data[i], min), max);
              }
              return this;
            }
            /**
             * Clamps all elements in input into the range [ min, max ]
             * @param {number} min lower-bound of the range to be clamped to
             * @param {number} max upper-bound of the range to be clamped to
             * @returns the output tensor.
             */
            clamp(min, max) {
              return this.clone().clamp_(min, max);
            }
            /**
             * In-place version of @see {@link Tensor.round}
             */
            round_() {
              for (let i = 0; i < this.data.length; ++i) {
                this.data[i] = Math.round(this.data[i]);
              }
              return this;
            }
            /**
             * Rounds elements of input to the nearest integer.
             * @returns the output tensor.
             */
            round() {
              return this.clone().round_();
            }
            /**
             * Performs Tensor dtype conversion.
             * @param {DataType} type The desired data type.
             * @returns {Tensor} The converted tensor.
             */
            to(type) {
              if (this.type === type)
                return this;
              if (!DataTypeMap.hasOwnProperty(type)) {
                throw new Error(`Unsupported type: ${type}`);
              }
              return new Tensor(type, DataTypeMap[type].from(this.data), this.dims);
            }
          }
          function reshape(data, dimensions) {
            const totalElements = data.length;
            const dimensionSize = dimensions.reduce((a, b) => a * b);
            if (totalElements !== dimensionSize) {
              throw Error(`cannot reshape array of size ${totalElements} into shape (${dimensions})`);
            }
            let reshapedArray = data;
            for (let i = dimensions.length - 1; i >= 0; i--) {
              reshapedArray = reshapedArray.reduce((acc, val) => {
                let lastArray = acc[acc.length - 1];
                if (lastArray.length < dimensions[i]) {
                  lastArray.push(val);
                } else {
                  acc.push([val]);
                }
                return acc;
              }, [[]]);
            }
            return reshapedArray[0];
          }
          function permute(tensor, axes) {
            const [permutedData, shape] = (0, _maths_js__WEBPACK_IMPORTED_MODULE_1__.permute_data)(tensor.data, tensor.dims, axes);
            return new Tensor(tensor.type, permutedData, shape);
          }
          function interpolate(input, [out_height, out_width], mode = "bilinear", align_corners = false) {
            const in_channels = input.dims.at(-3) ?? 1;
            const in_height = input.dims.at(-2);
            const in_width = input.dims.at(-1);
            let output = (0, _maths_js__WEBPACK_IMPORTED_MODULE_1__.interpolate_data)(
              /** @type {import('./maths.js').TypedArray}*/
              input.data,
              [in_channels, in_height, in_width],
              [out_height, out_width],
              mode,
              align_corners
            );
            return new Tensor(input.type, output, [in_channels, out_height, out_width]);
          }
          function mean_pooling(last_hidden_state, attention_mask) {
            let shape = [last_hidden_state.dims[0], last_hidden_state.dims[2]];
            let returnedData = new last_hidden_state.data.constructor(shape[0] * shape[1]);
            let [batchSize, seqLength, embedDim] = last_hidden_state.dims;
            let outIndex = 0;
            for (let i = 0; i < batchSize; ++i) {
              let offset = i * embedDim * seqLength;
              for (let k = 0; k < embedDim; ++k) {
                let sum = 0;
                let count = 0;
                let attnMaskOffset = i * seqLength;
                let offset2 = offset + k;
                for (let j = 0; j < seqLength; ++j) {
                  let attn = Number(attention_mask.data[attnMaskOffset + j]);
                  count += attn;
                  sum += last_hidden_state.data[offset2 + j * embedDim] * attn;
                }
                let avg = sum / count;
                returnedData[outIndex++] = avg;
              }
            }
            return new Tensor(
              last_hidden_state.type,
              returnedData,
              shape
            );
          }
          function layer_norm(input, normalized_shape, {
            eps = 1e-5
          } = {}) {
            if (input.dims.length !== 2) {
              throw new Error("`layer_norm` currently only supports 2D input.");
            }
            const [batchSize, featureDim] = input.dims;
            if (normalized_shape.length !== 1 && normalized_shape[0] !== featureDim) {
              throw new Error("`normalized_shape` must be a 1D array with shape `[input.dims[1]]`.");
            }
            const [std, mean2] = std_mean(input, 1, 0, true);
            const returnedData = new input.data.constructor(input.data.length);
            for (let i = 0; i < batchSize; ++i) {
              const offset = i * featureDim;
              for (let j = 0; j < featureDim; ++j) {
                const offset2 = offset + j;
                returnedData[offset2] = (input.data[offset2] - mean2.data[i]) / (std.data[i] + eps);
              }
            }
            return new Tensor(input.type, returnedData, input.dims);
          }
          function calc_squeeze_dims(dims, dim) {
            dims = dims.slice();
            if (dim === null) {
              dims = dims.filter((d) => d !== 1);
            } else if (typeof dim === "number") {
              if (dims[dim] === 1) {
                dims.splice(dim, 1);
              }
            } else if (Array.isArray(dim)) {
              dims = dims.filter((x, i) => {
                return x !== 1 || !dim.includes(i);
              });
            }
            return dims;
          }
          function calc_unsqueeze_dims(dims, dim) {
            dim = safeIndex(dim, dims.length + 1);
            dims = dims.slice();
            dims.splice(dim, 0, 1);
            return dims;
          }
          function safeIndex(index, size, dimension = null) {
            if (index < -size || index >= size) {
              throw new Error(`IndexError: index ${index} is out of bounds for dimension${dimension === null ? "" : " " + dimension} with size ${size}`);
            }
            if (index < 0) {
              index = (index % size + size) % size;
            }
            return index;
          }
          function cat(tensors, dim = 0) {
            dim = safeIndex(dim, tensors[0].dims.length);
            const resultDims = tensors[0].dims.slice();
            resultDims[dim] = tensors.reduce((a, b) => a + b.dims[dim], 0);
            const resultSize = resultDims.reduce((a, b) => a * b, 1);
            const result = new tensors[0].data.constructor(resultSize);
            const resultType = tensors[0].type;
            if (dim === 0) {
              let offset = 0;
              for (let t of tensors) {
                result.set(t.data, offset);
                offset += t.data.length;
              }
            } else {
              let currentDim = 0;
              for (let t = 0; t < tensors.length; ++t) {
                let tensor = tensors[t];
                for (let i = 0; i < tensor.data.length; ++i) {
                  let resultIndex = 0;
                  for (let j = tensor.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {
                    const size = tensor.dims[j];
                    let index = num % size;
                    if (j === dim) {
                      index += currentDim;
                    }
                    resultIndex += index * resultMultiplier;
                    resultMultiplier *= resultDims[j];
                    num = Math.floor(num / size);
                  }
                  result[resultIndex] = tensor.data[i];
                }
                currentDim += tensor.dims[dim];
              }
            }
            return new Tensor(resultType, result, resultDims);
          }
          function stack(tensors, dim = 0) {
            return cat(tensors.map((t) => t.unsqueeze(dim)), dim);
          }
          function std_mean(input, dim = null, correction = 1, keepdim = false) {
            if (dim === null) {
              const sum = input.data.reduce((a, b) => a + b, 0);
              const mean2 = sum / input.data.length;
              const std = Math.sqrt(input.data.reduce((a, b) => a + (b - mean2) ** 2, 0) / (input.data.length - correction));
              const meanTensor2 = new Tensor(input.type, [mean2], [
                /* scalar */
              ]);
              const stdTensor2 = new Tensor(input.type, [std], [
                /* scalar */
              ]);
              return [stdTensor2, meanTensor2];
            }
            dim = safeIndex(dim, input.dims.length);
            const meanTensor = mean(input, dim, keepdim);
            const resultDims = input.dims.slice();
            resultDims[dim] = 1;
            const result = new input.data.constructor(input.data.length / input.dims[dim]);
            for (let i = 0; i < input.data.length; ++i) {
              let resultIndex = 0;
              for (let j = input.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {
                const size = input.dims[j];
                if (j !== dim) {
                  const index = num % size;
                  resultIndex += index * resultMultiplier;
                  resultMultiplier *= resultDims[j];
                }
                num = Math.floor(num / size);
              }
              result[resultIndex] += (input.data[i] - meanTensor.data[resultIndex]) ** 2;
            }
            for (let i = 0; i < result.length; ++i) {
              result[i] = Math.sqrt(result[i] / (input.dims[dim] - correction));
            }
            if (!keepdim) {
              resultDims.splice(dim, 1);
            }
            const stdTensor = new Tensor(input.type, result, resultDims);
            return [stdTensor, meanTensor];
          }
          function mean(input, dim = null, keepdim = false) {
            if (dim === null) {
              let val = input.data.reduce((a, b) => a + b, 0);
              return new Tensor(input.type, [val / input.data.length], [
                /* scalar */
              ]);
            }
            dim = safeIndex(dim, input.dims.length);
            const resultDims = input.dims.slice();
            resultDims[dim] = 1;
            const result = new input.data.constructor(input.data.length / input.dims[dim]);
            for (let i = 0; i < input.data.length; ++i) {
              let resultIndex = 0;
              for (let j = input.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {
                const size = input.dims[j];
                if (j !== dim) {
                  const index = num % size;
                  resultIndex += index * resultMultiplier;
                  resultMultiplier *= resultDims[j];
                }
                num = Math.floor(num / size);
              }
              result[resultIndex] += input.data[i];
            }
            if (input.dims[dim] !== 1) {
              for (let i = 0; i < result.length; ++i) {
                result[i] = result[i] / input.dims[dim];
              }
            }
            if (!keepdim) {
              resultDims.splice(dim, 1);
            }
            return new Tensor(input.type, result, resultDims);
          }
          function dynamicTimeWarping(matrix) {
            const [output_length, input_length] = matrix.dims;
            const outputShape = [output_length + 1, input_length + 1];
            const cost = new Tensor(
              "float32",
              new Float32Array(outputShape[0] * outputShape[1]).fill(Infinity),
              outputShape
            );
            const trace = new Tensor(
              "float32",
              new Float32Array(outputShape[0] * outputShape[1]).fill(-1),
              outputShape
            );
            cost[0].data[0] = 0;
            for (let j2 = 1; j2 < input_length + 1; ++j2) {
              for (let i2 = 1; i2 < output_length + 1; ++i2) {
                const c0 = cost[i2 - 1][j2 - 1].item();
                const c1 = cost[i2 - 1][j2].item();
                const c2 = cost[i2][j2 - 1].item();
                let c, t;
                if (c0 < c1 && c0 < c2) {
                  c = c0;
                  t = 0;
                } else if (c1 < c0 && c1 < c2) {
                  c = c1;
                  t = 1;
                } else {
                  c = c2;
                  t = 2;
                }
                cost[i2].data[j2] = matrix[i2 - 1][j2 - 1].item() + c;
                trace[i2].data[j2] = t;
              }
            }
            let i = output_length;
            let j = input_length;
            trace.data.fill(2, 0, outputShape[1]);
            for (let i2 = 0; i2 < outputShape[0]; ++i2) {
              trace[i2].data[0] = 1;
            }
            let text_indices = [];
            let time_indices = [];
            while (i > 0 || j > 0) {
              text_indices.push(i - 1);
              time_indices.push(j - 1);
              const t = trace[i][j].item();
              switch (t) {
                case 0:
                  --i;
                  --j;
                  break;
                case 1:
                  --i;
                  break;
                case 2:
                  --j;
                  break;
                default:
                  throw new Error(
                    `Internal error in dynamic time warping. Unexpected trace[${i}, ${j}]. Please file a bug report.`
                  );
              }
            }
            text_indices.reverse();
            time_indices.reverse();
            return [text_indices, time_indices];
          }
          function dimsToStride(dims) {
            const stride = new Array(dims.length);
            for (let i = dims.length - 1, s2 = 1; i >= 0; --i) {
              stride[i] = s2;
              s2 *= dims[i];
            }
            return stride;
          }
          function ones(size) {
            const numElements = size.reduce((a, b) => a * b, 1);
            return new Tensor(
              "int64",
              new BigInt64Array(numElements).fill(1n),
              size
            );
          }
          function ones_like(tensor) {
            return ones(tensor.dims);
          }
          function quantize_embeddings(tensor, precision) {
            if (tensor.dims.length !== 2) {
              throw new Error("The tensor must have 2 dimensions");
            }
            if (tensor.dims.at(-1) % 8 !== 0) {
              throw new Error("The last dimension of the tensor must be a multiple of 8");
            }
            if (!["binary", "ubinary"].includes(precision)) {
              throw new Error("The precision must be either 'binary' or 'ubinary'");
            }
            const signed = precision === "binary";
            const dtype = signed ? "int8" : "uint8";
            const cls = signed ? Int8Array : Uint8Array;
            const inputData = tensor.data;
            const outputData = new cls(inputData.length / 8);
            for (let i = 0; i < inputData.length; ++i) {
              const bit = inputData[i] > 0 ? 1 : 0;
              const arrayIndex = Math.floor(i / 8);
              const bitPosition = i % 8;
              outputData[arrayIndex] |= bit << 7 - bitPosition;
              if (signed && bitPosition === 0) {
                outputData[arrayIndex] -= 128;
              }
            }
            ;
            return new Tensor(dtype, outputData, [tensor.dims[0], tensor.dims[1] / 8]);
          }
        }
      )
      /******/
    };
    __webpack_module_cache__2 = {};
    (() => {
      var getProto = Object.getPrototypeOf ? (obj) => Object.getPrototypeOf(obj) : (obj) => obj.__proto__;
      var leafPrototypes;
      __webpack_require__2.t = function(value, mode) {
        if (mode & 1)
          value = this(value);
        if (mode & 8)
          return value;
        if (typeof value === "object" && value) {
          if (mode & 4 && value.__esModule)
            return value;
          if (mode & 16 && typeof value.then === "function")
            return value;
        }
        var ns = /* @__PURE__ */ Object.create(null);
        __webpack_require__2.r(ns);
        var def = {};
        leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
        for (var current = mode & 2 && value; typeof current == "object" && !~leafPrototypes.indexOf(current); current = getProto(current)) {
          Object.getOwnPropertyNames(current).forEach((key) => def[key] = () => value[key]);
        }
        def["default"] = () => value;
        __webpack_require__2.d(ns, def);
        return ns;
      };
    })();
    (() => {
      __webpack_require__2.d = (exports, definition) => {
        for (var key in definition) {
          if (__webpack_require__2.o(definition, key) && !__webpack_require__2.o(exports, key)) {
            Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
          }
        }
      };
    })();
    (() => {
      __webpack_require__2.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
    })();
    (() => {
      __webpack_require__2.r = (exports) => {
        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
          Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
        }
        Object.defineProperty(exports, "__esModule", { value: true });
      };
    })();
    __webpack_exports__ = __webpack_require__2("./src/transformers.js");
    __webpack_exports__ASTFeatureExtractor = __webpack_exports__.ASTFeatureExtractor;
    __webpack_exports__ASTForAudioClassification = __webpack_exports__.ASTForAudioClassification;
    __webpack_exports__ASTModel = __webpack_exports__.ASTModel;
    __webpack_exports__ASTPreTrainedModel = __webpack_exports__.ASTPreTrainedModel;
    __webpack_exports__AlbertForMaskedLM = __webpack_exports__.AlbertForMaskedLM;
    __webpack_exports__AlbertForQuestionAnswering = __webpack_exports__.AlbertForQuestionAnswering;
    __webpack_exports__AlbertForSequenceClassification = __webpack_exports__.AlbertForSequenceClassification;
    __webpack_exports__AlbertModel = __webpack_exports__.AlbertModel;
    __webpack_exports__AlbertPreTrainedModel = __webpack_exports__.AlbertPreTrainedModel;
    __webpack_exports__AlbertTokenizer = __webpack_exports__.AlbertTokenizer;
    __webpack_exports__AudioClassificationPipeline = __webpack_exports__.AudioClassificationPipeline;
    __webpack_exports__AutoConfig = __webpack_exports__.AutoConfig;
    __webpack_exports__AutoModel = __webpack_exports__.AutoModel;
    __webpack_exports__AutoModelForAudioClassification = __webpack_exports__.AutoModelForAudioClassification;
    __webpack_exports__AutoModelForAudioFrameClassification = __webpack_exports__.AutoModelForAudioFrameClassification;
    __webpack_exports__AutoModelForCTC = __webpack_exports__.AutoModelForCTC;
    __webpack_exports__AutoModelForCausalLM = __webpack_exports__.AutoModelForCausalLM;
    __webpack_exports__AutoModelForDepthEstimation = __webpack_exports__.AutoModelForDepthEstimation;
    __webpack_exports__AutoModelForDocumentQuestionAnswering = __webpack_exports__.AutoModelForDocumentQuestionAnswering;
    __webpack_exports__AutoModelForImageClassification = __webpack_exports__.AutoModelForImageClassification;
    __webpack_exports__AutoModelForImageFeatureExtraction = __webpack_exports__.AutoModelForImageFeatureExtraction;
    __webpack_exports__AutoModelForImageMatting = __webpack_exports__.AutoModelForImageMatting;
    __webpack_exports__AutoModelForImageSegmentation = __webpack_exports__.AutoModelForImageSegmentation;
    __webpack_exports__AutoModelForImageToImage = __webpack_exports__.AutoModelForImageToImage;
    __webpack_exports__AutoModelForMaskGeneration = __webpack_exports__.AutoModelForMaskGeneration;
    __webpack_exports__AutoModelForMaskedLM = __webpack_exports__.AutoModelForMaskedLM;
    __webpack_exports__AutoModelForObjectDetection = __webpack_exports__.AutoModelForObjectDetection;
    __webpack_exports__AutoModelForQuestionAnswering = __webpack_exports__.AutoModelForQuestionAnswering;
    __webpack_exports__AutoModelForSemanticSegmentation = __webpack_exports__.AutoModelForSemanticSegmentation;
    __webpack_exports__AutoModelForSeq2SeqLM = __webpack_exports__.AutoModelForSeq2SeqLM;
    __webpack_exports__AutoModelForSequenceClassification = __webpack_exports__.AutoModelForSequenceClassification;
    __webpack_exports__AutoModelForSpeechSeq2Seq = __webpack_exports__.AutoModelForSpeechSeq2Seq;
    __webpack_exports__AutoModelForTextToSpectrogram = __webpack_exports__.AutoModelForTextToSpectrogram;
    __webpack_exports__AutoModelForTextToWaveform = __webpack_exports__.AutoModelForTextToWaveform;
    __webpack_exports__AutoModelForTokenClassification = __webpack_exports__.AutoModelForTokenClassification;
    __webpack_exports__AutoModelForVision2Seq = __webpack_exports__.AutoModelForVision2Seq;
    __webpack_exports__AutoModelForXVector = __webpack_exports__.AutoModelForXVector;
    __webpack_exports__AutoModelForZeroShotObjectDetection = __webpack_exports__.AutoModelForZeroShotObjectDetection;
    __webpack_exports__AutoProcessor = __webpack_exports__.AutoProcessor;
    __webpack_exports__AutoTokenizer = __webpack_exports__.AutoTokenizer;
    __webpack_exports__AutomaticSpeechRecognitionPipeline = __webpack_exports__.AutomaticSpeechRecognitionPipeline;
    __webpack_exports__BartForConditionalGeneration = __webpack_exports__.BartForConditionalGeneration;
    __webpack_exports__BartForSequenceClassification = __webpack_exports__.BartForSequenceClassification;
    __webpack_exports__BartModel = __webpack_exports__.BartModel;
    __webpack_exports__BartPretrainedModel = __webpack_exports__.BartPretrainedModel;
    __webpack_exports__BartTokenizer = __webpack_exports__.BartTokenizer;
    __webpack_exports__BaseModelOutput = __webpack_exports__.BaseModelOutput;
    __webpack_exports__BeitFeatureExtractor = __webpack_exports__.BeitFeatureExtractor;
    __webpack_exports__BeitForImageClassification = __webpack_exports__.BeitForImageClassification;
    __webpack_exports__BeitModel = __webpack_exports__.BeitModel;
    __webpack_exports__BeitPreTrainedModel = __webpack_exports__.BeitPreTrainedModel;
    __webpack_exports__BertForMaskedLM = __webpack_exports__.BertForMaskedLM;
    __webpack_exports__BertForQuestionAnswering = __webpack_exports__.BertForQuestionAnswering;
    __webpack_exports__BertForSequenceClassification = __webpack_exports__.BertForSequenceClassification;
    __webpack_exports__BertForTokenClassification = __webpack_exports__.BertForTokenClassification;
    __webpack_exports__BertModel = __webpack_exports__.BertModel;
    __webpack_exports__BertPreTrainedModel = __webpack_exports__.BertPreTrainedModel;
    __webpack_exports__BertTokenizer = __webpack_exports__.BertTokenizer;
    __webpack_exports__BitImageProcessor = __webpack_exports__.BitImageProcessor;
    __webpack_exports__BlenderbotForConditionalGeneration = __webpack_exports__.BlenderbotForConditionalGeneration;
    __webpack_exports__BlenderbotModel = __webpack_exports__.BlenderbotModel;
    __webpack_exports__BlenderbotPreTrainedModel = __webpack_exports__.BlenderbotPreTrainedModel;
    __webpack_exports__BlenderbotSmallForConditionalGeneration = __webpack_exports__.BlenderbotSmallForConditionalGeneration;
    __webpack_exports__BlenderbotSmallModel = __webpack_exports__.BlenderbotSmallModel;
    __webpack_exports__BlenderbotSmallPreTrainedModel = __webpack_exports__.BlenderbotSmallPreTrainedModel;
    __webpack_exports__BlenderbotSmallTokenizer = __webpack_exports__.BlenderbotSmallTokenizer;
    __webpack_exports__BlenderbotTokenizer = __webpack_exports__.BlenderbotTokenizer;
    __webpack_exports__BloomForCausalLM = __webpack_exports__.BloomForCausalLM;
    __webpack_exports__BloomModel = __webpack_exports__.BloomModel;
    __webpack_exports__BloomPreTrainedModel = __webpack_exports__.BloomPreTrainedModel;
    __webpack_exports__BloomTokenizer = __webpack_exports__.BloomTokenizer;
    __webpack_exports__CLIPFeatureExtractor = __webpack_exports__.CLIPFeatureExtractor;
    __webpack_exports__CLIPModel = __webpack_exports__.CLIPModel;
    __webpack_exports__CLIPPreTrainedModel = __webpack_exports__.CLIPPreTrainedModel;
    __webpack_exports__CLIPSegForImageSegmentation = __webpack_exports__.CLIPSegForImageSegmentation;
    __webpack_exports__CLIPSegModel = __webpack_exports__.CLIPSegModel;
    __webpack_exports__CLIPSegPreTrainedModel = __webpack_exports__.CLIPSegPreTrainedModel;
    __webpack_exports__CLIPTextModelWithProjection = __webpack_exports__.CLIPTextModelWithProjection;
    __webpack_exports__CLIPTokenizer = __webpack_exports__.CLIPTokenizer;
    __webpack_exports__CLIPVisionModelWithProjection = __webpack_exports__.CLIPVisionModelWithProjection;
    __webpack_exports__CamembertForMaskedLM = __webpack_exports__.CamembertForMaskedLM;
    __webpack_exports__CamembertForQuestionAnswering = __webpack_exports__.CamembertForQuestionAnswering;
    __webpack_exports__CamembertForSequenceClassification = __webpack_exports__.CamembertForSequenceClassification;
    __webpack_exports__CamembertForTokenClassification = __webpack_exports__.CamembertForTokenClassification;
    __webpack_exports__CamembertModel = __webpack_exports__.CamembertModel;
    __webpack_exports__CamembertPreTrainedModel = __webpack_exports__.CamembertPreTrainedModel;
    __webpack_exports__CamembertTokenizer = __webpack_exports__.CamembertTokenizer;
    __webpack_exports__CausalLMOutput = __webpack_exports__.CausalLMOutput;
    __webpack_exports__CausalLMOutputWithPast = __webpack_exports__.CausalLMOutputWithPast;
    __webpack_exports__ChineseCLIPFeatureExtractor = __webpack_exports__.ChineseCLIPFeatureExtractor;
    __webpack_exports__ChineseCLIPModel = __webpack_exports__.ChineseCLIPModel;
    __webpack_exports__ChineseCLIPPreTrainedModel = __webpack_exports__.ChineseCLIPPreTrainedModel;
    __webpack_exports__ClapAudioModelWithProjection = __webpack_exports__.ClapAudioModelWithProjection;
    __webpack_exports__ClapFeatureExtractor = __webpack_exports__.ClapFeatureExtractor;
    __webpack_exports__ClapModel = __webpack_exports__.ClapModel;
    __webpack_exports__ClapPreTrainedModel = __webpack_exports__.ClapPreTrainedModel;
    __webpack_exports__ClapTextModelWithProjection = __webpack_exports__.ClapTextModelWithProjection;
    __webpack_exports__CodeGenForCausalLM = __webpack_exports__.CodeGenForCausalLM;
    __webpack_exports__CodeGenModel = __webpack_exports__.CodeGenModel;
    __webpack_exports__CodeGenPreTrainedModel = __webpack_exports__.CodeGenPreTrainedModel;
    __webpack_exports__CodeGenTokenizer = __webpack_exports__.CodeGenTokenizer;
    __webpack_exports__CodeLlamaTokenizer = __webpack_exports__.CodeLlamaTokenizer;
    __webpack_exports__CohereTokenizer = __webpack_exports__.CohereTokenizer;
    __webpack_exports__ConvBertForMaskedLM = __webpack_exports__.ConvBertForMaskedLM;
    __webpack_exports__ConvBertForQuestionAnswering = __webpack_exports__.ConvBertForQuestionAnswering;
    __webpack_exports__ConvBertForSequenceClassification = __webpack_exports__.ConvBertForSequenceClassification;
    __webpack_exports__ConvBertForTokenClassification = __webpack_exports__.ConvBertForTokenClassification;
    __webpack_exports__ConvBertModel = __webpack_exports__.ConvBertModel;
    __webpack_exports__ConvBertPreTrainedModel = __webpack_exports__.ConvBertPreTrainedModel;
    __webpack_exports__ConvBertTokenizer = __webpack_exports__.ConvBertTokenizer;
    __webpack_exports__ConvNextFeatureExtractor = __webpack_exports__.ConvNextFeatureExtractor;
    __webpack_exports__ConvNextForImageClassification = __webpack_exports__.ConvNextForImageClassification;
    __webpack_exports__ConvNextImageProcessor = __webpack_exports__.ConvNextImageProcessor;
    __webpack_exports__ConvNextModel = __webpack_exports__.ConvNextModel;
    __webpack_exports__ConvNextPreTrainedModel = __webpack_exports__.ConvNextPreTrainedModel;
    __webpack_exports__ConvNextV2ForImageClassification = __webpack_exports__.ConvNextV2ForImageClassification;
    __webpack_exports__ConvNextV2Model = __webpack_exports__.ConvNextV2Model;
    __webpack_exports__ConvNextV2PreTrainedModel = __webpack_exports__.ConvNextV2PreTrainedModel;
    __webpack_exports__DPTFeatureExtractor = __webpack_exports__.DPTFeatureExtractor;
    __webpack_exports__DPTForDepthEstimation = __webpack_exports__.DPTForDepthEstimation;
    __webpack_exports__DPTImageProcessor = __webpack_exports__.DPTImageProcessor;
    __webpack_exports__DPTModel = __webpack_exports__.DPTModel;
    __webpack_exports__DPTPreTrainedModel = __webpack_exports__.DPTPreTrainedModel;
    __webpack_exports__DebertaForMaskedLM = __webpack_exports__.DebertaForMaskedLM;
    __webpack_exports__DebertaForQuestionAnswering = __webpack_exports__.DebertaForQuestionAnswering;
    __webpack_exports__DebertaForSequenceClassification = __webpack_exports__.DebertaForSequenceClassification;
    __webpack_exports__DebertaForTokenClassification = __webpack_exports__.DebertaForTokenClassification;
    __webpack_exports__DebertaModel = __webpack_exports__.DebertaModel;
    __webpack_exports__DebertaPreTrainedModel = __webpack_exports__.DebertaPreTrainedModel;
    __webpack_exports__DebertaTokenizer = __webpack_exports__.DebertaTokenizer;
    __webpack_exports__DebertaV2ForMaskedLM = __webpack_exports__.DebertaV2ForMaskedLM;
    __webpack_exports__DebertaV2ForQuestionAnswering = __webpack_exports__.DebertaV2ForQuestionAnswering;
    __webpack_exports__DebertaV2ForSequenceClassification = __webpack_exports__.DebertaV2ForSequenceClassification;
    __webpack_exports__DebertaV2ForTokenClassification = __webpack_exports__.DebertaV2ForTokenClassification;
    __webpack_exports__DebertaV2Model = __webpack_exports__.DebertaV2Model;
    __webpack_exports__DebertaV2PreTrainedModel = __webpack_exports__.DebertaV2PreTrainedModel;
    __webpack_exports__DebertaV2Tokenizer = __webpack_exports__.DebertaV2Tokenizer;
    __webpack_exports__DeiTFeatureExtractor = __webpack_exports__.DeiTFeatureExtractor;
    __webpack_exports__DeiTForImageClassification = __webpack_exports__.DeiTForImageClassification;
    __webpack_exports__DeiTModel = __webpack_exports__.DeiTModel;
    __webpack_exports__DeiTPreTrainedModel = __webpack_exports__.DeiTPreTrainedModel;
    __webpack_exports__DepthAnythingForDepthEstimation = __webpack_exports__.DepthAnythingForDepthEstimation;
    __webpack_exports__DepthAnythingPreTrainedModel = __webpack_exports__.DepthAnythingPreTrainedModel;
    __webpack_exports__DepthEstimationPipeline = __webpack_exports__.DepthEstimationPipeline;
    __webpack_exports__DetrFeatureExtractor = __webpack_exports__.DetrFeatureExtractor;
    __webpack_exports__DetrForObjectDetection = __webpack_exports__.DetrForObjectDetection;
    __webpack_exports__DetrForSegmentation = __webpack_exports__.DetrForSegmentation;
    __webpack_exports__DetrModel = __webpack_exports__.DetrModel;
    __webpack_exports__DetrObjectDetectionOutput = __webpack_exports__.DetrObjectDetectionOutput;
    __webpack_exports__DetrPreTrainedModel = __webpack_exports__.DetrPreTrainedModel;
    __webpack_exports__DetrSegmentationOutput = __webpack_exports__.DetrSegmentationOutput;
    __webpack_exports__Dinov2ForImageClassification = __webpack_exports__.Dinov2ForImageClassification;
    __webpack_exports__Dinov2Model = __webpack_exports__.Dinov2Model;
    __webpack_exports__Dinov2PreTrainedModel = __webpack_exports__.Dinov2PreTrainedModel;
    __webpack_exports__DistilBertForMaskedLM = __webpack_exports__.DistilBertForMaskedLM;
    __webpack_exports__DistilBertForQuestionAnswering = __webpack_exports__.DistilBertForQuestionAnswering;
    __webpack_exports__DistilBertForSequenceClassification = __webpack_exports__.DistilBertForSequenceClassification;
    __webpack_exports__DistilBertForTokenClassification = __webpack_exports__.DistilBertForTokenClassification;
    __webpack_exports__DistilBertModel = __webpack_exports__.DistilBertModel;
    __webpack_exports__DistilBertPreTrainedModel = __webpack_exports__.DistilBertPreTrainedModel;
    __webpack_exports__DistilBertTokenizer = __webpack_exports__.DistilBertTokenizer;
    __webpack_exports__DocumentQuestionAnsweringPipeline = __webpack_exports__.DocumentQuestionAnsweringPipeline;
    __webpack_exports__DonutFeatureExtractor = __webpack_exports__.DonutFeatureExtractor;
    __webpack_exports__DonutSwinModel = __webpack_exports__.DonutSwinModel;
    __webpack_exports__DonutSwinPreTrainedModel = __webpack_exports__.DonutSwinPreTrainedModel;
    __webpack_exports__EfficientNetForImageClassification = __webpack_exports__.EfficientNetForImageClassification;
    __webpack_exports__EfficientNetImageProcessor = __webpack_exports__.EfficientNetImageProcessor;
    __webpack_exports__EfficientNetModel = __webpack_exports__.EfficientNetModel;
    __webpack_exports__EfficientNetPreTrainedModel = __webpack_exports__.EfficientNetPreTrainedModel;
    __webpack_exports__ElectraForMaskedLM = __webpack_exports__.ElectraForMaskedLM;
    __webpack_exports__ElectraForQuestionAnswering = __webpack_exports__.ElectraForQuestionAnswering;
    __webpack_exports__ElectraForSequenceClassification = __webpack_exports__.ElectraForSequenceClassification;
    __webpack_exports__ElectraForTokenClassification = __webpack_exports__.ElectraForTokenClassification;
    __webpack_exports__ElectraModel = __webpack_exports__.ElectraModel;
    __webpack_exports__ElectraPreTrainedModel = __webpack_exports__.ElectraPreTrainedModel;
    __webpack_exports__ElectraTokenizer = __webpack_exports__.ElectraTokenizer;
    __webpack_exports__EsmForMaskedLM = __webpack_exports__.EsmForMaskedLM;
    __webpack_exports__EsmForSequenceClassification = __webpack_exports__.EsmForSequenceClassification;
    __webpack_exports__EsmForTokenClassification = __webpack_exports__.EsmForTokenClassification;
    __webpack_exports__EsmModel = __webpack_exports__.EsmModel;
    __webpack_exports__EsmPreTrainedModel = __webpack_exports__.EsmPreTrainedModel;
    __webpack_exports__EsmTokenizer = __webpack_exports__.EsmTokenizer;
    __webpack_exports__FFT = __webpack_exports__.FFT;
    __webpack_exports__FalconForCausalLM = __webpack_exports__.FalconForCausalLM;
    __webpack_exports__FalconModel = __webpack_exports__.FalconModel;
    __webpack_exports__FalconPreTrainedModel = __webpack_exports__.FalconPreTrainedModel;
    __webpack_exports__FalconTokenizer = __webpack_exports__.FalconTokenizer;
    __webpack_exports__FastViTForImageClassification = __webpack_exports__.FastViTForImageClassification;
    __webpack_exports__FastViTModel = __webpack_exports__.FastViTModel;
    __webpack_exports__FastViTPreTrainedModel = __webpack_exports__.FastViTPreTrainedModel;
    __webpack_exports__FeatureExtractionPipeline = __webpack_exports__.FeatureExtractionPipeline;
    __webpack_exports__FeatureExtractor = __webpack_exports__.FeatureExtractor;
    __webpack_exports__FillMaskPipeline = __webpack_exports__.FillMaskPipeline;
    __webpack_exports__GLPNFeatureExtractor = __webpack_exports__.GLPNFeatureExtractor;
    __webpack_exports__GLPNForDepthEstimation = __webpack_exports__.GLPNForDepthEstimation;
    __webpack_exports__GLPNModel = __webpack_exports__.GLPNModel;
    __webpack_exports__GLPNPreTrainedModel = __webpack_exports__.GLPNPreTrainedModel;
    __webpack_exports__GPT2LMHeadModel = __webpack_exports__.GPT2LMHeadModel;
    __webpack_exports__GPT2Model = __webpack_exports__.GPT2Model;
    __webpack_exports__GPT2PreTrainedModel = __webpack_exports__.GPT2PreTrainedModel;
    __webpack_exports__GPT2Tokenizer = __webpack_exports__.GPT2Tokenizer;
    __webpack_exports__GPTBigCodeForCausalLM = __webpack_exports__.GPTBigCodeForCausalLM;
    __webpack_exports__GPTBigCodeModel = __webpack_exports__.GPTBigCodeModel;
    __webpack_exports__GPTBigCodePreTrainedModel = __webpack_exports__.GPTBigCodePreTrainedModel;
    __webpack_exports__GPTJForCausalLM = __webpack_exports__.GPTJForCausalLM;
    __webpack_exports__GPTJModel = __webpack_exports__.GPTJModel;
    __webpack_exports__GPTJPreTrainedModel = __webpack_exports__.GPTJPreTrainedModel;
    __webpack_exports__GPTNeoForCausalLM = __webpack_exports__.GPTNeoForCausalLM;
    __webpack_exports__GPTNeoModel = __webpack_exports__.GPTNeoModel;
    __webpack_exports__GPTNeoPreTrainedModel = __webpack_exports__.GPTNeoPreTrainedModel;
    __webpack_exports__GPTNeoXForCausalLM = __webpack_exports__.GPTNeoXForCausalLM;
    __webpack_exports__GPTNeoXModel = __webpack_exports__.GPTNeoXModel;
    __webpack_exports__GPTNeoXPreTrainedModel = __webpack_exports__.GPTNeoXPreTrainedModel;
    __webpack_exports__GPTNeoXTokenizer = __webpack_exports__.GPTNeoXTokenizer;
    __webpack_exports__GemmaTokenizer = __webpack_exports__.GemmaTokenizer;
    __webpack_exports__Grok1Tokenizer = __webpack_exports__.Grok1Tokenizer;
    __webpack_exports__HerbertTokenizer = __webpack_exports__.HerbertTokenizer;
    __webpack_exports__HubertForCTC = __webpack_exports__.HubertForCTC;
    __webpack_exports__HubertForSequenceClassification = __webpack_exports__.HubertForSequenceClassification;
    __webpack_exports__HubertModel = __webpack_exports__.HubertModel;
    __webpack_exports__HubertPreTrainedModel = __webpack_exports__.HubertPreTrainedModel;
    __webpack_exports__ImageClassificationPipeline = __webpack_exports__.ImageClassificationPipeline;
    __webpack_exports__ImageFeatureExtractionPipeline = __webpack_exports__.ImageFeatureExtractionPipeline;
    __webpack_exports__ImageFeatureExtractor = __webpack_exports__.ImageFeatureExtractor;
    __webpack_exports__ImageMattingOutput = __webpack_exports__.ImageMattingOutput;
    __webpack_exports__ImageSegmentationPipeline = __webpack_exports__.ImageSegmentationPipeline;
    __webpack_exports__ImageToImagePipeline = __webpack_exports__.ImageToImagePipeline;
    __webpack_exports__ImageToTextPipeline = __webpack_exports__.ImageToTextPipeline;
    __webpack_exports__LlamaForCausalLM = __webpack_exports__.LlamaForCausalLM;
    __webpack_exports__LlamaModel = __webpack_exports__.LlamaModel;
    __webpack_exports__LlamaPreTrainedModel = __webpack_exports__.LlamaPreTrainedModel;
    __webpack_exports__LlamaTokenizer = __webpack_exports__.LlamaTokenizer;
    __webpack_exports__LongT5ForConditionalGeneration = __webpack_exports__.LongT5ForConditionalGeneration;
    __webpack_exports__LongT5Model = __webpack_exports__.LongT5Model;
    __webpack_exports__LongT5PreTrainedModel = __webpack_exports__.LongT5PreTrainedModel;
    __webpack_exports__M2M100ForConditionalGeneration = __webpack_exports__.M2M100ForConditionalGeneration;
    __webpack_exports__M2M100Model = __webpack_exports__.M2M100Model;
    __webpack_exports__M2M100PreTrainedModel = __webpack_exports__.M2M100PreTrainedModel;
    __webpack_exports__M2M100Tokenizer = __webpack_exports__.M2M100Tokenizer;
    __webpack_exports__MBart50Tokenizer = __webpack_exports__.MBart50Tokenizer;
    __webpack_exports__MBartForCausalLM = __webpack_exports__.MBartForCausalLM;
    __webpack_exports__MBartForConditionalGeneration = __webpack_exports__.MBartForConditionalGeneration;
    __webpack_exports__MBartForSequenceClassification = __webpack_exports__.MBartForSequenceClassification;
    __webpack_exports__MBartModel = __webpack_exports__.MBartModel;
    __webpack_exports__MBartPreTrainedModel = __webpack_exports__.MBartPreTrainedModel;
    __webpack_exports__MBartTokenizer = __webpack_exports__.MBartTokenizer;
    __webpack_exports__MPNetForMaskedLM = __webpack_exports__.MPNetForMaskedLM;
    __webpack_exports__MPNetForQuestionAnswering = __webpack_exports__.MPNetForQuestionAnswering;
    __webpack_exports__MPNetForSequenceClassification = __webpack_exports__.MPNetForSequenceClassification;
    __webpack_exports__MPNetForTokenClassification = __webpack_exports__.MPNetForTokenClassification;
    __webpack_exports__MPNetModel = __webpack_exports__.MPNetModel;
    __webpack_exports__MPNetPreTrainedModel = __webpack_exports__.MPNetPreTrainedModel;
    __webpack_exports__MPNetTokenizer = __webpack_exports__.MPNetTokenizer;
    __webpack_exports__MT5ForConditionalGeneration = __webpack_exports__.MT5ForConditionalGeneration;
    __webpack_exports__MT5Model = __webpack_exports__.MT5Model;
    __webpack_exports__MT5PreTrainedModel = __webpack_exports__.MT5PreTrainedModel;
    __webpack_exports__MarianMTModel = __webpack_exports__.MarianMTModel;
    __webpack_exports__MarianModel = __webpack_exports__.MarianModel;
    __webpack_exports__MarianPreTrainedModel = __webpack_exports__.MarianPreTrainedModel;
    __webpack_exports__MarianTokenizer = __webpack_exports__.MarianTokenizer;
    __webpack_exports__MaskedLMOutput = __webpack_exports__.MaskedLMOutput;
    __webpack_exports__MistralForCausalLM = __webpack_exports__.MistralForCausalLM;
    __webpack_exports__MistralModel = __webpack_exports__.MistralModel;
    __webpack_exports__MistralPreTrainedModel = __webpack_exports__.MistralPreTrainedModel;
    __webpack_exports__MobileBertForMaskedLM = __webpack_exports__.MobileBertForMaskedLM;
    __webpack_exports__MobileBertForQuestionAnswering = __webpack_exports__.MobileBertForQuestionAnswering;
    __webpack_exports__MobileBertForSequenceClassification = __webpack_exports__.MobileBertForSequenceClassification;
    __webpack_exports__MobileBertModel = __webpack_exports__.MobileBertModel;
    __webpack_exports__MobileBertPreTrainedModel = __webpack_exports__.MobileBertPreTrainedModel;
    __webpack_exports__MobileBertTokenizer = __webpack_exports__.MobileBertTokenizer;
    __webpack_exports__MobileViTFeatureExtractor = __webpack_exports__.MobileViTFeatureExtractor;
    __webpack_exports__MobileViTForImageClassification = __webpack_exports__.MobileViTForImageClassification;
    __webpack_exports__MobileViTImageProcessor = __webpack_exports__.MobileViTImageProcessor;
    __webpack_exports__MobileViTModel = __webpack_exports__.MobileViTModel;
    __webpack_exports__MobileViTPreTrainedModel = __webpack_exports__.MobileViTPreTrainedModel;
    __webpack_exports__MobileViTV2ForImageClassification = __webpack_exports__.MobileViTV2ForImageClassification;
    __webpack_exports__MobileViTV2Model = __webpack_exports__.MobileViTV2Model;
    __webpack_exports__MobileViTV2PreTrainedModel = __webpack_exports__.MobileViTV2PreTrainedModel;
    __webpack_exports__ModelOutput = __webpack_exports__.ModelOutput;
    __webpack_exports__MptForCausalLM = __webpack_exports__.MptForCausalLM;
    __webpack_exports__MptModel = __webpack_exports__.MptModel;
    __webpack_exports__MptPreTrainedModel = __webpack_exports__.MptPreTrainedModel;
    __webpack_exports__NllbTokenizer = __webpack_exports__.NllbTokenizer;
    __webpack_exports__NomicBertModel = __webpack_exports__.NomicBertModel;
    __webpack_exports__NomicBertPreTrainedModel = __webpack_exports__.NomicBertPreTrainedModel;
    __webpack_exports__NougatImageProcessor = __webpack_exports__.NougatImageProcessor;
    __webpack_exports__NougatTokenizer = __webpack_exports__.NougatTokenizer;
    __webpack_exports__OPTForCausalLM = __webpack_exports__.OPTForCausalLM;
    __webpack_exports__OPTModel = __webpack_exports__.OPTModel;
    __webpack_exports__OPTPreTrainedModel = __webpack_exports__.OPTPreTrainedModel;
    __webpack_exports__ObjectDetectionPipeline = __webpack_exports__.ObjectDetectionPipeline;
    __webpack_exports__OwlViTFeatureExtractor = __webpack_exports__.OwlViTFeatureExtractor;
    __webpack_exports__OwlViTForObjectDetection = __webpack_exports__.OwlViTForObjectDetection;
    __webpack_exports__OwlViTModel = __webpack_exports__.OwlViTModel;
    __webpack_exports__OwlViTPreTrainedModel = __webpack_exports__.OwlViTPreTrainedModel;
    __webpack_exports__OwlViTProcessor = __webpack_exports__.OwlViTProcessor;
    __webpack_exports__Owlv2ForObjectDetection = __webpack_exports__.Owlv2ForObjectDetection;
    __webpack_exports__Owlv2ImageProcessor = __webpack_exports__.Owlv2ImageProcessor;
    __webpack_exports__Owlv2Model = __webpack_exports__.Owlv2Model;
    __webpack_exports__Owlv2PreTrainedModel = __webpack_exports__.Owlv2PreTrainedModel;
    __webpack_exports__PhiForCausalLM = __webpack_exports__.PhiForCausalLM;
    __webpack_exports__PhiModel = __webpack_exports__.PhiModel;
    __webpack_exports__PhiPreTrainedModel = __webpack_exports__.PhiPreTrainedModel;
    __webpack_exports__Pipeline = __webpack_exports__.Pipeline;
    __webpack_exports__PreTrainedModel = __webpack_exports__.PreTrainedModel;
    __webpack_exports__PreTrainedTokenizer = __webpack_exports__.PreTrainedTokenizer;
    __webpack_exports__PretrainedConfig = __webpack_exports__.PretrainedConfig;
    __webpack_exports__PretrainedMixin = __webpack_exports__.PretrainedMixin;
    __webpack_exports__Processor = __webpack_exports__.Processor;
    __webpack_exports__QuestionAnsweringModelOutput = __webpack_exports__.QuestionAnsweringModelOutput;
    __webpack_exports__QuestionAnsweringPipeline = __webpack_exports__.QuestionAnsweringPipeline;
    __webpack_exports__Qwen2ForCausalLM = __webpack_exports__.Qwen2ForCausalLM;
    __webpack_exports__Qwen2Model = __webpack_exports__.Qwen2Model;
    __webpack_exports__Qwen2PreTrainedModel = __webpack_exports__.Qwen2PreTrainedModel;
    __webpack_exports__Qwen2Tokenizer = __webpack_exports__.Qwen2Tokenizer;
    __webpack_exports__RawImage = __webpack_exports__.RawImage;
    __webpack_exports__ResNetForImageClassification = __webpack_exports__.ResNetForImageClassification;
    __webpack_exports__ResNetModel = __webpack_exports__.ResNetModel;
    __webpack_exports__ResNetPreTrainedModel = __webpack_exports__.ResNetPreTrainedModel;
    __webpack_exports__RoFormerForMaskedLM = __webpack_exports__.RoFormerForMaskedLM;
    __webpack_exports__RoFormerForQuestionAnswering = __webpack_exports__.RoFormerForQuestionAnswering;
    __webpack_exports__RoFormerForSequenceClassification = __webpack_exports__.RoFormerForSequenceClassification;
    __webpack_exports__RoFormerForTokenClassification = __webpack_exports__.RoFormerForTokenClassification;
    __webpack_exports__RoFormerModel = __webpack_exports__.RoFormerModel;
    __webpack_exports__RoFormerPreTrainedModel = __webpack_exports__.RoFormerPreTrainedModel;
    __webpack_exports__RoFormerTokenizer = __webpack_exports__.RoFormerTokenizer;
    __webpack_exports__RobertaForMaskedLM = __webpack_exports__.RobertaForMaskedLM;
    __webpack_exports__RobertaForQuestionAnswering = __webpack_exports__.RobertaForQuestionAnswering;
    __webpack_exports__RobertaForSequenceClassification = __webpack_exports__.RobertaForSequenceClassification;
    __webpack_exports__RobertaForTokenClassification = __webpack_exports__.RobertaForTokenClassification;
    __webpack_exports__RobertaModel = __webpack_exports__.RobertaModel;
    __webpack_exports__RobertaPreTrainedModel = __webpack_exports__.RobertaPreTrainedModel;
    __webpack_exports__RobertaTokenizer = __webpack_exports__.RobertaTokenizer;
    __webpack_exports__SamImageProcessor = __webpack_exports__.SamImageProcessor;
    __webpack_exports__SamImageSegmentationOutput = __webpack_exports__.SamImageSegmentationOutput;
    __webpack_exports__SamModel = __webpack_exports__.SamModel;
    __webpack_exports__SamPreTrainedModel = __webpack_exports__.SamPreTrainedModel;
    __webpack_exports__SamProcessor = __webpack_exports__.SamProcessor;
    __webpack_exports__SeamlessM4TFeatureExtractor = __webpack_exports__.SeamlessM4TFeatureExtractor;
    __webpack_exports__SegformerFeatureExtractor = __webpack_exports__.SegformerFeatureExtractor;
    __webpack_exports__SegformerForImageClassification = __webpack_exports__.SegformerForImageClassification;
    __webpack_exports__SegformerForSemanticSegmentation = __webpack_exports__.SegformerForSemanticSegmentation;
    __webpack_exports__SegformerModel = __webpack_exports__.SegformerModel;
    __webpack_exports__SegformerPreTrainedModel = __webpack_exports__.SegformerPreTrainedModel;
    __webpack_exports__Seq2SeqLMOutput = __webpack_exports__.Seq2SeqLMOutput;
    __webpack_exports__SequenceClassifierOutput = __webpack_exports__.SequenceClassifierOutput;
    __webpack_exports__SiglipImageProcessor = __webpack_exports__.SiglipImageProcessor;
    __webpack_exports__SiglipModel = __webpack_exports__.SiglipModel;
    __webpack_exports__SiglipPreTrainedModel = __webpack_exports__.SiglipPreTrainedModel;
    __webpack_exports__SiglipTextModel = __webpack_exports__.SiglipTextModel;
    __webpack_exports__SiglipTokenizer = __webpack_exports__.SiglipTokenizer;
    __webpack_exports__SiglipVisionModel = __webpack_exports__.SiglipVisionModel;
    __webpack_exports__SpeechT5FeatureExtractor = __webpack_exports__.SpeechT5FeatureExtractor;
    __webpack_exports__SpeechT5ForSpeechToText = __webpack_exports__.SpeechT5ForSpeechToText;
    __webpack_exports__SpeechT5ForTextToSpeech = __webpack_exports__.SpeechT5ForTextToSpeech;
    __webpack_exports__SpeechT5HifiGan = __webpack_exports__.SpeechT5HifiGan;
    __webpack_exports__SpeechT5Model = __webpack_exports__.SpeechT5Model;
    __webpack_exports__SpeechT5PreTrainedModel = __webpack_exports__.SpeechT5PreTrainedModel;
    __webpack_exports__SpeechT5Processor = __webpack_exports__.SpeechT5Processor;
    __webpack_exports__SpeechT5Tokenizer = __webpack_exports__.SpeechT5Tokenizer;
    __webpack_exports__SqueezeBertForMaskedLM = __webpack_exports__.SqueezeBertForMaskedLM;
    __webpack_exports__SqueezeBertForQuestionAnswering = __webpack_exports__.SqueezeBertForQuestionAnswering;
    __webpack_exports__SqueezeBertForSequenceClassification = __webpack_exports__.SqueezeBertForSequenceClassification;
    __webpack_exports__SqueezeBertModel = __webpack_exports__.SqueezeBertModel;
    __webpack_exports__SqueezeBertPreTrainedModel = __webpack_exports__.SqueezeBertPreTrainedModel;
    __webpack_exports__SqueezeBertTokenizer = __webpack_exports__.SqueezeBertTokenizer;
    __webpack_exports__StableLmForCausalLM = __webpack_exports__.StableLmForCausalLM;
    __webpack_exports__StableLmModel = __webpack_exports__.StableLmModel;
    __webpack_exports__StableLmPreTrainedModel = __webpack_exports__.StableLmPreTrainedModel;
    __webpack_exports__Starcoder2ForCausalLM = __webpack_exports__.Starcoder2ForCausalLM;
    __webpack_exports__Starcoder2Model = __webpack_exports__.Starcoder2Model;
    __webpack_exports__Starcoder2PreTrainedModel = __webpack_exports__.Starcoder2PreTrainedModel;
    __webpack_exports__SummarizationPipeline = __webpack_exports__.SummarizationPipeline;
    __webpack_exports__Swin2SRForImageSuperResolution = __webpack_exports__.Swin2SRForImageSuperResolution;
    __webpack_exports__Swin2SRImageProcessor = __webpack_exports__.Swin2SRImageProcessor;
    __webpack_exports__Swin2SRModel = __webpack_exports__.Swin2SRModel;
    __webpack_exports__Swin2SRPreTrainedModel = __webpack_exports__.Swin2SRPreTrainedModel;
    __webpack_exports__SwinForImageClassification = __webpack_exports__.SwinForImageClassification;
    __webpack_exports__SwinModel = __webpack_exports__.SwinModel;
    __webpack_exports__SwinPreTrainedModel = __webpack_exports__.SwinPreTrainedModel;
    __webpack_exports__T5ForConditionalGeneration = __webpack_exports__.T5ForConditionalGeneration;
    __webpack_exports__T5Model = __webpack_exports__.T5Model;
    __webpack_exports__T5PreTrainedModel = __webpack_exports__.T5PreTrainedModel;
    __webpack_exports__T5Tokenizer = __webpack_exports__.T5Tokenizer;
    __webpack_exports__TableTransformerForObjectDetection = __webpack_exports__.TableTransformerForObjectDetection;
    __webpack_exports__TableTransformerModel = __webpack_exports__.TableTransformerModel;
    __webpack_exports__TableTransformerObjectDetectionOutput = __webpack_exports__.TableTransformerObjectDetectionOutput;
    __webpack_exports__TableTransformerPreTrainedModel = __webpack_exports__.TableTransformerPreTrainedModel;
    __webpack_exports__Tensor = __webpack_exports__.Tensor;
    __webpack_exports__Text2TextGenerationPipeline = __webpack_exports__.Text2TextGenerationPipeline;
    __webpack_exports__TextClassificationPipeline = __webpack_exports__.TextClassificationPipeline;
    __webpack_exports__TextGenerationPipeline = __webpack_exports__.TextGenerationPipeline;
    __webpack_exports__TextToAudioPipeline = __webpack_exports__.TextToAudioPipeline;
    __webpack_exports__TokenClassificationPipeline = __webpack_exports__.TokenClassificationPipeline;
    __webpack_exports__TokenClassifierOutput = __webpack_exports__.TokenClassifierOutput;
    __webpack_exports__TokenizerModel = __webpack_exports__.TokenizerModel;
    __webpack_exports__TrOCRForCausalLM = __webpack_exports__.TrOCRForCausalLM;
    __webpack_exports__TrOCRPreTrainedModel = __webpack_exports__.TrOCRPreTrainedModel;
    __webpack_exports__TranslationPipeline = __webpack_exports__.TranslationPipeline;
    __webpack_exports__UniSpeechForCTC = __webpack_exports__.UniSpeechForCTC;
    __webpack_exports__UniSpeechForSequenceClassification = __webpack_exports__.UniSpeechForSequenceClassification;
    __webpack_exports__UniSpeechModel = __webpack_exports__.UniSpeechModel;
    __webpack_exports__UniSpeechPreTrainedModel = __webpack_exports__.UniSpeechPreTrainedModel;
    __webpack_exports__UniSpeechSatForAudioFrameClassification = __webpack_exports__.UniSpeechSatForAudioFrameClassification;
    __webpack_exports__UniSpeechSatForCTC = __webpack_exports__.UniSpeechSatForCTC;
    __webpack_exports__UniSpeechSatForSequenceClassification = __webpack_exports__.UniSpeechSatForSequenceClassification;
    __webpack_exports__UniSpeechSatModel = __webpack_exports__.UniSpeechSatModel;
    __webpack_exports__UniSpeechSatPreTrainedModel = __webpack_exports__.UniSpeechSatPreTrainedModel;
    __webpack_exports__ViTFeatureExtractor = __webpack_exports__.ViTFeatureExtractor;
    __webpack_exports__ViTForImageClassification = __webpack_exports__.ViTForImageClassification;
    __webpack_exports__ViTImageProcessor = __webpack_exports__.ViTImageProcessor;
    __webpack_exports__ViTModel = __webpack_exports__.ViTModel;
    __webpack_exports__ViTPreTrainedModel = __webpack_exports__.ViTPreTrainedModel;
    __webpack_exports__VisionEncoderDecoderModel = __webpack_exports__.VisionEncoderDecoderModel;
    __webpack_exports__VitMatteForImageMatting = __webpack_exports__.VitMatteForImageMatting;
    __webpack_exports__VitMatteImageProcessor = __webpack_exports__.VitMatteImageProcessor;
    __webpack_exports__VitMattePreTrainedModel = __webpack_exports__.VitMattePreTrainedModel;
    __webpack_exports__VitsModel = __webpack_exports__.VitsModel;
    __webpack_exports__VitsModelOutput = __webpack_exports__.VitsModelOutput;
    __webpack_exports__VitsPreTrainedModel = __webpack_exports__.VitsPreTrainedModel;
    __webpack_exports__VitsTokenizer = __webpack_exports__.VitsTokenizer;
    __webpack_exports__Wav2Vec2BertForCTC = __webpack_exports__.Wav2Vec2BertForCTC;
    __webpack_exports__Wav2Vec2BertForSequenceClassification = __webpack_exports__.Wav2Vec2BertForSequenceClassification;
    __webpack_exports__Wav2Vec2BertModel = __webpack_exports__.Wav2Vec2BertModel;
    __webpack_exports__Wav2Vec2BertPreTrainedModel = __webpack_exports__.Wav2Vec2BertPreTrainedModel;
    __webpack_exports__Wav2Vec2CTCTokenizer = __webpack_exports__.Wav2Vec2CTCTokenizer;
    __webpack_exports__Wav2Vec2FeatureExtractor = __webpack_exports__.Wav2Vec2FeatureExtractor;
    __webpack_exports__Wav2Vec2ForAudioFrameClassification = __webpack_exports__.Wav2Vec2ForAudioFrameClassification;
    __webpack_exports__Wav2Vec2ForCTC = __webpack_exports__.Wav2Vec2ForCTC;
    __webpack_exports__Wav2Vec2ForSequenceClassification = __webpack_exports__.Wav2Vec2ForSequenceClassification;
    __webpack_exports__Wav2Vec2Model = __webpack_exports__.Wav2Vec2Model;
    __webpack_exports__Wav2Vec2PreTrainedModel = __webpack_exports__.Wav2Vec2PreTrainedModel;
    __webpack_exports__Wav2Vec2ProcessorWithLM = __webpack_exports__.Wav2Vec2ProcessorWithLM;
    __webpack_exports__WavLMForAudioFrameClassification = __webpack_exports__.WavLMForAudioFrameClassification;
    __webpack_exports__WavLMForCTC = __webpack_exports__.WavLMForCTC;
    __webpack_exports__WavLMForSequenceClassification = __webpack_exports__.WavLMForSequenceClassification;
    __webpack_exports__WavLMForXVector = __webpack_exports__.WavLMForXVector;
    __webpack_exports__WavLMModel = __webpack_exports__.WavLMModel;
    __webpack_exports__WavLMPreTrainedModel = __webpack_exports__.WavLMPreTrainedModel;
    __webpack_exports__WhisperFeatureExtractor = __webpack_exports__.WhisperFeatureExtractor;
    __webpack_exports__WhisperForConditionalGeneration = __webpack_exports__.WhisperForConditionalGeneration;
    __webpack_exports__WhisperModel = __webpack_exports__.WhisperModel;
    __webpack_exports__WhisperPreTrainedModel = __webpack_exports__.WhisperPreTrainedModel;
    __webpack_exports__WhisperProcessor = __webpack_exports__.WhisperProcessor;
    __webpack_exports__WhisperTokenizer = __webpack_exports__.WhisperTokenizer;
    __webpack_exports__XLMForQuestionAnswering = __webpack_exports__.XLMForQuestionAnswering;
    __webpack_exports__XLMForSequenceClassification = __webpack_exports__.XLMForSequenceClassification;
    __webpack_exports__XLMForTokenClassification = __webpack_exports__.XLMForTokenClassification;
    __webpack_exports__XLMModel = __webpack_exports__.XLMModel;
    __webpack_exports__XLMPreTrainedModel = __webpack_exports__.XLMPreTrainedModel;
    __webpack_exports__XLMRobertaForMaskedLM = __webpack_exports__.XLMRobertaForMaskedLM;
    __webpack_exports__XLMRobertaForQuestionAnswering = __webpack_exports__.XLMRobertaForQuestionAnswering;
    __webpack_exports__XLMRobertaForSequenceClassification = __webpack_exports__.XLMRobertaForSequenceClassification;
    __webpack_exports__XLMRobertaForTokenClassification = __webpack_exports__.XLMRobertaForTokenClassification;
    __webpack_exports__XLMRobertaModel = __webpack_exports__.XLMRobertaModel;
    __webpack_exports__XLMRobertaPreTrainedModel = __webpack_exports__.XLMRobertaPreTrainedModel;
    __webpack_exports__XLMRobertaTokenizer = __webpack_exports__.XLMRobertaTokenizer;
    __webpack_exports__XLMTokenizer = __webpack_exports__.XLMTokenizer;
    __webpack_exports__XLMWithLMHeadModel = __webpack_exports__.XLMWithLMHeadModel;
    __webpack_exports__XVectorOutput = __webpack_exports__.XVectorOutput;
    __webpack_exports__YolosFeatureExtractor = __webpack_exports__.YolosFeatureExtractor;
    __webpack_exports__YolosForObjectDetection = __webpack_exports__.YolosForObjectDetection;
    __webpack_exports__YolosModel = __webpack_exports__.YolosModel;
    __webpack_exports__YolosObjectDetectionOutput = __webpack_exports__.YolosObjectDetectionOutput;
    __webpack_exports__YolosPreTrainedModel = __webpack_exports__.YolosPreTrainedModel;
    __webpack_exports__ZeroShotAudioClassificationPipeline = __webpack_exports__.ZeroShotAudioClassificationPipeline;
    __webpack_exports__ZeroShotClassificationPipeline = __webpack_exports__.ZeroShotClassificationPipeline;
    __webpack_exports__ZeroShotImageClassificationPipeline = __webpack_exports__.ZeroShotImageClassificationPipeline;
    __webpack_exports__ZeroShotObjectDetectionPipeline = __webpack_exports__.ZeroShotObjectDetectionPipeline;
    __webpack_exports__bankers_round = __webpack_exports__.bankers_round;
    __webpack_exports__cat = __webpack_exports__.cat;
    __webpack_exports__cos_sim = __webpack_exports__.cos_sim;
    __webpack_exports__dot = __webpack_exports__.dot;
    __webpack_exports__dynamicTimeWarping = __webpack_exports__.dynamicTimeWarping;
    __webpack_exports__env = __webpack_exports__.env;
    __webpack_exports__getTopItems = __webpack_exports__.getTopItems;
    __webpack_exports__hanning = __webpack_exports__.hanning;
    __webpack_exports__interpolate = __webpack_exports__.interpolate;
    __webpack_exports__interpolate_data = __webpack_exports__.interpolate_data;
    __webpack_exports__layer_norm = __webpack_exports__.layer_norm;
    __webpack_exports__log_softmax = __webpack_exports__.log_softmax;
    __webpack_exports__magnitude = __webpack_exports__.magnitude;
    __webpack_exports__max = __webpack_exports__.max;
    __webpack_exports__mean = __webpack_exports__.mean;
    __webpack_exports__mean_pooling = __webpack_exports__.mean_pooling;
    __webpack_exports__medianFilter = __webpack_exports__.medianFilter;
    __webpack_exports__mel_filter_bank = __webpack_exports__.mel_filter_bank;
    __webpack_exports__min = __webpack_exports__.min;
    __webpack_exports__ones = __webpack_exports__.ones;
    __webpack_exports__ones_like = __webpack_exports__.ones_like;
    __webpack_exports__permute = __webpack_exports__.permute;
    __webpack_exports__permute_data = __webpack_exports__.permute_data;
    __webpack_exports__pipeline = __webpack_exports__.pipeline;
    __webpack_exports__quantize_embeddings = __webpack_exports__.quantize_embeddings;
    __webpack_exports__read_audio = __webpack_exports__.read_audio;
    __webpack_exports__round = __webpack_exports__.round;
    __webpack_exports__softmax = __webpack_exports__.softmax;
    __webpack_exports__spectrogram = __webpack_exports__.spectrogram;
    __webpack_exports__stack = __webpack_exports__.stack;
    __webpack_exports__std_mean = __webpack_exports__.std_mean;
    __webpack_exports__window_function = __webpack_exports__.window_function;
  }
});

// node_modules/jszip/dist/jszip.min.js
var require_jszip_min = __commonJS({
  "node_modules/jszip/dist/jszip.min.js"(exports, module2) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module2)
        module2.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).JSZip = e();
      }
    }(function() {
      return function s(a, o, h) {
        function u(r, e2) {
          if (!o[r]) {
            if (!a[r]) {
              var t = "function" == typeof require && require;
              if (!e2 && t)
                return t(r, true);
              if (l)
                return l(r, true);
              var n = new Error("Cannot find module '" + r + "'");
              throw n.code = "MODULE_NOT_FOUND", n;
            }
            var i = o[r] = { exports: {} };
            a[r][0].call(i.exports, function(e3) {
              var t2 = a[r][1][e3];
              return u(t2 || e3);
            }, i, i.exports, s, a, o, h);
          }
          return o[r].exports;
        }
        for (var l = "function" == typeof require && require, e = 0; e < h.length; e++)
          u(h[e]);
        return u;
      }({ 1: [function(e, t, r) {
        "use strict";
        var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r.encode = function(e2) {
          for (var t2, r2, n, i, s, a, o, h = [], u = 0, l = e2.length, f = l, c2 = "string" !== d.getTypeOf(e2); u < e2.length; )
            f = l - u, n = c2 ? (t2 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
          return h.join("");
        }, r.decode = function(e2) {
          var t2, r2, n, i, s, a, o = 0, h = 0, u = "data:";
          if (e2.substr(0, u.length) === u)
            throw new Error("Invalid base64 input, it looks like a data url.");
          var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0)
            throw new Error("Invalid base64 input, bad content length.");
          for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; )
            t2 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h++] = t2, 64 !== s && (l[h++] = r2), 64 !== a && (l[h++] = n);
          return l;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e, t, r) {
        "use strict";
        var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
        function o(e2, t2, r2, n2, i2) {
          this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
        }
        o.prototype = { getContentWorker: function() {
          var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
          return e2.on("end", function() {
            if (this.streamInfo.data_length !== t2.uncompressedSize)
              throw new Error("Bug : uncompressed data size mismatch");
          }), e2;
        }, getCompressedWorker: function() {
          return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o.createWorkerFrom = function(e2, t2, r2) {
          return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
        }, t.exports = o;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t, r) {
        "use strict";
        var n = e("./stream/GenericWorker");
        r.STORE = { magic: "\0\0", compressWorker: function() {
          return new n("STORE compression");
        }, uncompressWorker: function() {
          return new n("STORE decompression");
        } }, r.DEFLATE = e("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t, r) {
        "use strict";
        var n = e("./utils");
        var o = function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n2 = 0; n2 < 8; n2++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        }();
        t.exports = function(e2, t2) {
          return void 0 !== e2 && e2.length ? "string" !== n.getTypeOf(e2) ? function(e3, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];
            return -1 ^ e3;
          }(0 | t2, e2, e2.length, 0) : function(e3, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];
            return -1 ^ e3;
          }(0 | t2, e2, e2.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e, t, r) {
        "use strict";
        r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
      }, {}], 6: [function(e, t, r) {
        "use strict";
        var n = null;
        n = "undefined" != typeof Promise ? Promise : e("lie"), t.exports = { Promise: n };
      }, { lie: 37 }], 7: [function(e, t, r) {
        "use strict";
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
        function h(e2, t2) {
          a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};
        }
        r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e2) {
          this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
        }, h.prototype.flush = function() {
          a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
        }, h.prototype.cleanUp = function() {
          a.prototype.cleanUp.call(this), this._pako = null;
        }, h.prototype._createPako = function() {
          this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t2 = this;
          this._pako.onData = function(e2) {
            t2.push({ data: e2, meta: t2.meta });
          };
        }, r.compressWorker = function(e2) {
          return new h("Deflate", e2);
        }, r.uncompressWorker = function() {
          return new h("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t, r) {
        "use strict";
        function A(e2, t2) {
          var r2, n2 = "";
          for (r2 = 0; r2 < t2; r2++)
            n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
          return n2;
        }
        function n(e2, t2, r2, n2, i2, s2) {
          var a, o, h = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t2 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
          var S = 0;
          t2 && (S |= 8), l || !_ && !g || (S |= 2048);
          var z = 0, C = 0;
          w && (z |= 16), "UNIX" === i2 ? (C = 798, z |= function(e3, t3) {
            var r3 = e3;
            return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
          }(h.unixPermissions, w)) : (C = 20, z |= function(e3) {
            return 63 & (e3 || 0);
          }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
          var E = "";
          return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(n2, 4) + f + b + p };
        }
        var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
        function s(e2, t2, r2, n2) {
          i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        I.inherits(s, i), s.prototype.push = function(e2) {
          var t2 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
        }, s.prototype.openedSource = function(e2) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
          var t2 = this.streamFiles && !e2.file.dir;
          if (t2) {
            var r2 = n(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r2.fileRecord, meta: { percent: 0 } });
          } else
            this.accumulate = true;
        }, s.prototype.closedSource = function(e2) {
          this.accumulate = false;
          var t2 = this.streamFiles && !e2.file.dir, r2 = n(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r2.dirRecord), t2)
            this.push({ data: function(e3) {
              return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
            }(e2), meta: { percent: 100 } });
          else
            for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
              this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s.prototype.flush = function() {
          for (var e2 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++)
            this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
          var r2 = this.bytesWritten - e2, n2 = function(e3, t3, r3, n3, i2) {
            var s2 = I.transformTo("string", i2(n3));
            return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
          }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
          this.push({ data: n2, meta: { percent: 100 } });
        }, s.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s.prototype.registerPrevious = function(e2) {
          this._sources.push(e2);
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s.prototype.error = function(e2) {
          var t2 = this._sources;
          if (!i.prototype.error.call(this, e2))
            return false;
          for (var r2 = 0; r2 < t2.length; r2++)
            try {
              t2[r2].error(e2);
            } catch (e3) {
            }
          return true;
        }, s.prototype.lock = function() {
          i.prototype.lock.call(this);
          for (var e2 = this._sources, t2 = 0; t2 < e2.length; t2++)
            e2[t2].lock();
        }, t.exports = s;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t, r) {
        "use strict";
        var u = e("../compressions"), n = e("./ZipFileWorker");
        r.generateWorker = function(e2, a, t2) {
          var o = new n(a.streamFiles, t2, a.platform, a.encodeFileName), h = 0;
          try {
            e2.forEach(function(e3, t3) {
              h++;
              var r2 = function(e4, t4) {
                var r3 = e4 || t4, n3 = u[r3];
                if (!n3)
                  throw new Error(r3 + " is not a valid compression method !");
                return n3;
              }(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
              t3._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
            }), o.entriesCount = h;
          } catch (e3) {
            o.error(e3);
          }
          return o;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t, r) {
        "use strict";
        function n() {
          if (!(this instanceof n))
            return new n();
          if (arguments.length)
            throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e2 = new n();
            for (var t2 in this)
              "function" != typeof this[t2] && (e2[t2] = this[t2]);
            return e2;
          };
        }
        (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t2) {
          return new n().loadAsync(e2, t2);
        }, n.external = e("./external"), t.exports = n;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t, r) {
        "use strict";
        var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
        function f(n2) {
          return new i.Promise(function(e2, t2) {
            var r2 = n2.decompressed.getContentWorker().pipe(new a());
            r2.on("error", function(e3) {
              t2(e3);
            }).on("end", function() {
              r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
            }).resume();
          });
        }
        t.exports = function(e2, o) {
          var h = this;
          return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
            var t2 = new s(o);
            return t2.load(e3), t2;
          }).then(function(e3) {
            var t2 = [i.Promise.resolve(e3)], r2 = e3.files;
            if (o.checkCRC32)
              for (var n2 = 0; n2 < r2.length; n2++)
                t2.push(f(r2[n2]));
            return i.Promise.all(t2);
          }).then(function(e3) {
            for (var t2 = e3.shift(), r2 = t2.files, n2 = 0; n2 < r2.length; n2++) {
              var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
              h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);
            }
            return t2.zipComment.length && (h.comment = t2.zipComment), h;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("../stream/GenericWorker");
        function s(e2, t2) {
          i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t2);
        }
        n.inherits(s, i), s.prototype._bindStream = function(e2) {
          var t2 = this;
          (this._stream = e2).pause(), e2.on("data", function(e3) {
            t2.push({ data: e3, meta: { percent: 0 } });
          }).on("error", function(e3) {
            t2.isPaused ? this.generatedError = e3 : t2.error(e3);
          }).on("end", function() {
            t2.isPaused ? t2._upstreamEnded = true : t2.end();
          });
        }, s.prototype.pause = function() {
          return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t.exports = s;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t, r) {
        "use strict";
        var i = e("readable-stream").Readable;
        function n(e2, t2, r2) {
          i.call(this, t2), this._helper = e2;
          var n2 = this;
          e2.on("data", function(e3, t3) {
            n2.push(e3) || n2._helper.pause(), r2 && r2(t3);
          }).on("error", function(e3) {
            n2.emit("error", e3);
          }).on("end", function() {
            n2.push(null);
          });
        }
        e("../utils").inherits(n, i), n.prototype._read = function() {
          this._helper.resume();
        }, t.exports = n;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t, r) {
        "use strict";
        t.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e2, t2) {
          if (Buffer.from && Buffer.from !== Uint8Array.from)
            return Buffer.from(e2, t2);
          if ("number" == typeof e2)
            throw new Error('The "data" argument must not be a number');
          return new Buffer(e2, t2);
        }, allocBuffer: function(e2) {
          if (Buffer.alloc)
            return Buffer.alloc(e2);
          var t2 = new Buffer(e2);
          return t2.fill(0), t2;
        }, isBuffer: function(e2) {
          return Buffer.isBuffer(e2);
        }, isStream: function(e2) {
          return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
        } };
      }, {}], 15: [function(e, t, r) {
        "use strict";
        function s(e2, t2, r2) {
          var n2, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);
          s2.date = s2.date || new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _(e2)) && b.call(this, n2, true);
          var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
          r2 && void 0 !== r2.binary || (s2.binary = !a2), (t2 instanceof c && 0 === t2.uncompressedSize || s2.dir || !t2 || 0 === t2.length) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
          var o2 = null;
          o2 = t2 instanceof c || t2 instanceof l ? t2 : p.isNode && p.isStream(t2) ? new m(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
          var h2 = new d(e2, o2, s2);
          this.files[e2] = h2;
        }
        var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e2) {
          "/" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));
          var t2 = e2.lastIndexOf("/");
          return 0 < t2 ? e2.substring(0, t2) : "";
        }, g = function(e2) {
          return "/" !== e2.slice(-1) && (e2 += "/"), e2;
        }, b = function(e2, t2) {
          return t2 = void 0 !== t2 ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];
        };
        function h(e2) {
          return "[object RegExp]" === Object.prototype.toString.call(e2);
        }
        var n = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e2) {
          var t2, r2, n2;
          for (t2 in this.files)
            n2 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r2, n2);
        }, filter: function(r2) {
          var n2 = [];
          return this.forEach(function(e2, t2) {
            r2(e2, t2) && n2.push(t2);
          }), n2;
        }, file: function(e2, t2, r2) {
          if (1 !== arguments.length)
            return e2 = this.root + e2, s.call(this, e2, t2, r2), this;
          if (h(e2)) {
            var n2 = e2;
            return this.filter(function(e3, t3) {
              return !t3.dir && n2.test(e3);
            });
          }
          var i2 = this.files[this.root + e2];
          return i2 && !i2.dir ? i2 : null;
        }, folder: function(r2) {
          if (!r2)
            return this;
          if (h(r2))
            return this.filter(function(e3, t3) {
              return t3.dir && r2.test(e3);
            });
          var e2 = this.root + r2, t2 = b.call(this, e2), n2 = this.clone();
          return n2.root = t2.name, n2;
        }, remove: function(r2) {
          r2 = this.root + r2;
          var e2 = this.files[r2];
          if (e2 || ("/" !== r2.slice(-1) && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir)
            delete this.files[r2];
          else
            for (var t2 = this.filter(function(e3, t3) {
              return t3.name.slice(0, r2.length) === r2;
            }), n2 = 0; n2 < t2.length; n2++)
              delete this.files[t2[n2].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e2) {
          var t2, r2 = {};
          try {
            if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type)
              throw new Error("No output type specified.");
            u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
            var n2 = r2.comment || this.comment || "";
            t2 = o.generateWorker(this, r2, n2);
          } catch (e3) {
            (t2 = new l("error")).error(e3);
          }
          return new a(t2, r2.type || "string", r2.mimeType);
        }, generateAsync: function(e2, t2) {
          return this.generateInternalStream(e2).accumulate(t2);
        }, generateNodeStream: function(e2, t2) {
          return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t2);
        } };
        t.exports = n;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t, r) {
        "use strict";
        t.exports = e("stream");
      }, { stream: void 0 }], 17: [function(e, t, r) {
        "use strict";
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
          for (var t2 = 0; t2 < this.data.length; t2++)
            e2[t2] = 255 & e2[t2];
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data[this.zero + e2];
        }, i.prototype.lastIndexOfSignature = function(e2) {
          for (var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
            if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2)
              return s - this.zero;
          return -1;
        }, i.prototype.readAndCheckSignature = function(e2) {
          var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
          return t2 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
        }, i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2)
            return [];
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t, r) {
        "use strict";
        var n = e("../utils");
        function i(e2) {
          this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
        }
        i.prototype = { checkOffset: function(e2) {
          this.checkIndex(this.index + e2);
        }, checkIndex: function(e2) {
          if (this.length < this.zero + e2 || e2 < 0)
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
        }, setIndex: function(e2) {
          this.checkIndex(e2), this.index = e2;
        }, skip: function(e2) {
          this.setIndex(this.index + e2);
        }, byteAt: function() {
        }, readInt: function(e2) {
          var t2, r2 = 0;
          for (this.checkOffset(e2), t2 = this.index + e2 - 1; t2 >= this.index; t2--)
            r2 = (r2 << 8) + this.byteAt(t2);
          return this.index += e2, r2;
        }, readString: function(e2) {
          return n.transformTo("string", this.readData(e2));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e2 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
        } }, t.exports = i;
      }, { "../utils": 32 }], 19: [function(e, t, r) {
        "use strict";
        var n = e("./Uint8ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t, r) {
        "use strict";
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data.charCodeAt(this.zero + e2);
        }, i.prototype.lastIndexOfSignature = function(e2) {
          return this.data.lastIndexOf(e2) - this.zero;
        }, i.prototype.readAndCheckSignature = function(e2) {
          return e2 === this.readData(4);
        }, i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t, r) {
        "use strict";
        var n = e("./ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2)
            return new Uint8Array(0);
          var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
        t.exports = function(e2) {
          var t2 = n.getTypeOf(e2);
          return n.checkSupport(t2), "string" !== t2 || i.uint8array ? "nodebuffer" === t2 ? new o(e2) : i.uint8array ? new h(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t, r) {
        "use strict";
        r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e, t, r) {
        "use strict";
        var n = e("./GenericWorker"), i = e("../utils");
        function s(e2) {
          n.call(this, "ConvertWorker to " + e2), this.destType = e2;
        }
        i.inherits(s, n), s.prototype.processChunk = function(e2) {
          this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t, r) {
        "use strict";
        var n = e("./GenericWorker"), i = e("../crc32");
        function s() {
          n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
          this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
        }, t.exports = s;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
        }
        n.inherits(s, i), s.prototype.processChunk = function(e2) {
          if (e2) {
            var t2 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t2 + e2.data.length;
          }
          i.prototype.processChunk.call(this, e2);
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataWorker");
          var t2 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
            t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();
          }, function(e3) {
            t2.error(e3);
          });
        }
        n.inherits(s, i), s.prototype.cleanUp = function() {
          i.prototype.cleanUp.call(this), this.data = null;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
        }, s.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s.prototype._tick = function() {
          if (this.isPaused || this.isFinished)
            return false;
          var e2 = null, t2 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max)
            return this.end();
          switch (this.type) {
            case "string":
              e2 = this.data.substring(this.index, t2);
              break;
            case "uint8array":
              e2 = this.data.subarray(this.index, t2);
              break;
            case "array":
            case "nodebuffer":
              e2 = this.data.slice(this.index, t2);
          }
          return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t, r) {
        "use strict";
        function n(e2) {
          this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        n.prototype = { push: function(e2) {
          this.emit("data", e2);
        }, end: function() {
          if (this.isFinished)
            return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e2) {
            this.emit("error", e2);
          }
          return true;
        }, error: function(e2) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
        }, on: function(e2, t2) {
          return this._listeners[e2].push(t2), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e2, t2) {
          if (this._listeners[e2])
            for (var r2 = 0; r2 < this._listeners[e2].length; r2++)
              this._listeners[e2][r2].call(this, t2);
        }, pipe: function(e2) {
          return e2.registerPrevious(this);
        }, registerPrevious: function(e2) {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished)
            return false;
          var e2 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
        }, flush: function() {
        }, processChunk: function(e2) {
          this.push(e2);
        }, withStreamInfo: function(e2, t2) {
          return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e2 in this.extraStreamInfo)
            Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
        }, lock: function() {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e2 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e2 : e2;
        } }, t.exports = n;
      }, {}], 29: [function(e, t, r) {
        "use strict";
        var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
        if (n.nodestream)
          try {
            o = e("../nodejs/NodejsStreamOutputAdapter");
          } catch (e2) {
          }
        function l(e2, o2) {
          return new a.Promise(function(t2, r2) {
            var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
            e2.on("data", function(e3, t3) {
              n2.push(e3), o2 && o2(t3);
            }).on("error", function(e3) {
              n2 = [], r2(e3);
            }).on("end", function() {
              try {
                var e3 = function(e4, t3, r3) {
                  switch (e4) {
                    case "blob":
                      return h.newBlob(h.transformTo("arraybuffer", t3), r3);
                    case "base64":
                      return u.encode(t3);
                    default:
                      return h.transformTo(e4, t3);
                  }
                }(s2, function(e4, t3) {
                  var r3, n3 = 0, i3 = null, s3 = 0;
                  for (r3 = 0; r3 < t3.length; r3++)
                    s3 += t3[r3].length;
                  switch (e4) {
                    case "string":
                      return t3.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t3);
                    case "uint8array":
                      for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++)
                        i3.set(t3[r3], n3), n3 += t3[r3].length;
                      return i3;
                    case "nodebuffer":
                      return Buffer.concat(t3);
                    default:
                      throw new Error("concat : unsupported type '" + e4 + "'");
                  }
                }(i2, n2), a2);
                t2(e3);
              } catch (e4) {
                r2(e4);
              }
              n2 = [];
            }).resume();
          });
        }
        function f(e2, t2, r2) {
          var n2 = t2;
          switch (t2) {
            case "blob":
            case "arraybuffer":
              n2 = "uint8array";
              break;
            case "base64":
              n2 = "string";
          }
          try {
            this._internalType = n2, this._outputType = t2, this._mimeType = r2, h.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
          } catch (e3) {
            this._worker = new s("error"), this._worker.error(e3);
          }
        }
        f.prototype = { accumulate: function(e2) {
          return l(this, e2);
        }, on: function(e2, t2) {
          var r2 = this;
          return "data" === e2 ? this._worker.on(e2, function(e3) {
            t2.call(r2, e3.data, e3.meta);
          }) : this._worker.on(e2, function() {
            h.delay(t2, arguments, r2);
          }), this;
        }, resume: function() {
          return h.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e2) {
          if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
            throw new Error(this._outputType + " is not supported by this method");
          return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
        } }, t.exports = f;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t, r) {
        "use strict";
        if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
          r.blob = false;
        else {
          var n = new ArrayBuffer(0);
          try {
            r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
          } catch (e2) {
            try {
              var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
            } catch (e3) {
              r.blob = false;
            }
          }
        }
        try {
          r.nodestream = !!e("readable-stream").Readable;
        } catch (e2) {
          r.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e, t, s) {
        "use strict";
        for (var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)
          u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
        u[254] = u[254] = 1;
        function a() {
          n.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function l() {
          n.call(this, "utf-8 encode");
        }
        s.utf8encode = function(e2) {
          return h.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
            var t2, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
            for (i2 = 0; i2 < a2; i2++)
              55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
            for (t2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++)
              55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
            return t2;
          }(e2);
        }, s.utf8decode = function(e2) {
          return h.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
            var t2, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
            for (t2 = r2 = 0; t2 < s2; )
              if ((n2 = e3[t2++]) < 128)
                a2[r2++] = n2;
              else if (4 < (i2 = u[n2]))
                a2[r2++] = 65533, t2 += i2 - 1;
              else {
                for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t2 < s2; )
                  n2 = n2 << 6 | 63 & e3[t2++], i2--;
                1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
              }
            return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
          }(e2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2));
        }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
          var t2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2.data);
          if (this.leftOver && this.leftOver.length) {
            if (h.uint8array) {
              var r2 = t2;
              (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
            } else
              t2 = this.leftOver.concat(t2);
            this.leftOver = null;
          }
          var n2 = function(e3, t3) {
            var r3;
            for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); )
              r3--;
            return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
          }(t2), i2 = t2;
          n2 !== t2.length && (h.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
        }, a.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {
          this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
        }, s.Utf8EncodeWorker = l;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t, a) {
        "use strict";
        var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
        function n(e2) {
          return e2;
        }
        function l(e2, t2) {
          for (var r2 = 0; r2 < e2.length; ++r2)
            t2[r2] = 255 & e2.charCodeAt(r2);
          return t2;
        }
        e("setimmediate"), a.newBlob = function(t2, r2) {
          a.checkSupport("blob");
          try {
            return new Blob([t2], { type: r2 });
          } catch (e2) {
            try {
              var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n2.append(t2), n2.getBlob(r2);
            } catch (e3) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i = { stringifyByChunk: function(e2, t2, r2) {
          var n2 = [], i2 = 0, s2 = e2.length;
          if (s2 <= r2)
            return String.fromCharCode.apply(null, e2);
          for (; i2 < s2; )
            "array" === t2 || "nodebuffer" === t2 ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
          return n2.join("");
        }, stringifyByChar: function(e2) {
          for (var t2 = "", r2 = 0; r2 < e2.length; r2++)
            t2 += String.fromCharCode(e2[r2]);
          return t2;
        }, applyCanBeUsed: { uint8array: function() {
          try {
            return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
          } catch (e2) {
            return false;
          }
        }(), nodebuffer: function() {
          try {
            return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
          } catch (e2) {
            return false;
          }
        }() } };
        function s(e2) {
          var t2 = 65536, r2 = a.getTypeOf(e2), n2 = true;
          if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2)
            for (; 1 < t2; )
              try {
                return i.stringifyByChunk(e2, r2, t2);
              } catch (e3) {
                t2 = Math.floor(t2 / 2);
              }
          return i.stringifyByChar(e2);
        }
        function f(e2, t2) {
          for (var r2 = 0; r2 < e2.length; r2++)
            t2[r2] = e2[r2];
          return t2;
        }
        a.applyFromCharCode = s;
        var c = {};
        c.string = { string: n, array: function(e2) {
          return l(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.string.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return l(e2, new Uint8Array(e2.length));
        }, nodebuffer: function(e2) {
          return l(e2, r.allocBuffer(e2.length));
        } }, c.array = { string: s, array: n, arraybuffer: function(e2) {
          return new Uint8Array(e2).buffer;
        }, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.arraybuffer = { string: function(e2) {
          return s(new Uint8Array(e2));
        }, array: function(e2) {
          return f(new Uint8Array(e2), new Array(e2.byteLength));
        }, arraybuffer: n, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(new Uint8Array(e2));
        } }, c.uint8array = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return e2.buffer;
        }, uint8array: n, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.nodebuffer = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.nodebuffer.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return f(e2, new Uint8Array(e2.length));
        }, nodebuffer: n }, a.transformTo = function(e2, t2) {
          if (t2 = t2 || "", !e2)
            return t2;
          a.checkSupport(e2);
          var r2 = a.getTypeOf(t2);
          return c[r2][e2](t2);
        }, a.resolve = function(e2) {
          for (var t2 = e2.split("/"), r2 = [], n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2];
            "." === i2 || "" === i2 && 0 !== n2 && n2 !== t2.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
          }
          return r2.join("/");
        }, a.getTypeOf = function(e2) {
          return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a.checkSupport = function(e2) {
          if (!o[e2.toLowerCase()])
            throw new Error(e2 + " is not supported by this platform");
        }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
          var t2, r2, n2 = "";
          for (r2 = 0; r2 < (e2 || "").length; r2++)
            n2 += "\\x" + ((t2 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
          return n2;
        }, a.delay = function(e2, t2, r2) {
          setImmediate(function() {
            e2.apply(r2 || null, t2 || []);
          });
        }, a.inherits = function(e2, t2) {
          function r2() {
          }
          r2.prototype = t2.prototype, e2.prototype = new r2();
        }, a.extend = function() {
          var e2, t2, r2 = {};
          for (e2 = 0; e2 < arguments.length; e2++)
            for (t2 in arguments[e2])
              Object.prototype.hasOwnProperty.call(arguments[e2], t2) && void 0 === r2[t2] && (r2[t2] = arguments[e2][t2]);
          return r2;
        }, a.prepareContent = function(r2, e2, n2, i2, s2) {
          return u.Promise.resolve(e2).then(function(n3) {
            return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t2, r3) {
              var e3 = new FileReader();
              e3.onload = function(e4) {
                t2(e4.target.result);
              }, e3.onerror = function(e4) {
                r3(e4.target.error);
              }, e3.readAsArrayBuffer(n3);
            }) : n3;
          }).then(function(e3) {
            var t2 = a.getTypeOf(e3);
            return t2 ? ("arraybuffer" === t2 ? e3 = a.transformTo("uint8array", e3) : "string" === t2 && (s2 ? e3 = h.decode(e3) : n2 && true !== i2 && (e3 = function(e4) {
              return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
            }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t, r) {
        "use strict";
        var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
        function h(e2) {
          this.files = [], this.loadOptions = e2;
        }
        h.prototype = { checkSignature: function(e2) {
          if (!this.reader.readAndCheckSignature(e2)) {
            this.reader.index -= 4;
            var t2 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e2) + ")");
          }
        }, isSignature: function(e2, t2) {
          var r2 = this.reader.index;
          this.reader.setIndex(e2);
          var n2 = this.reader.readString(4) === t2;
          return this.reader.setIndex(r2), n2;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e2);
          this.zipComment = this.loadOptions.decodeFileName(r2);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e2, t2, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; )
            e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r2 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
            throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e2, t2;
          for (e2 = 0; e2 < this.files.length; e2++)
            t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
        }, readCentralDir: function() {
          var e2;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
            (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
          if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
          if (e2 < 0)
            throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e2);
          var t2 = e2;
          if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r2 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
          var n2 = t2 - r2;
          if (0 < n2)
            this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
          else if (n2 < 0)
            throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
        }, prepareReader: function(e2) {
          this.reader = n(e2);
        }, load: function(e2) {
          this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t.exports = h;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t, r) {
        "use strict";
        var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
        function l(e2, t2) {
          this.options = e2, this.loadOptions = t2;
        }
        l.prototype = { isEncrypted: function() {
          return 1 == (1 & this.bitFlag);
        }, useUTF8: function() {
          return 2048 == (2048 & this.bitFlag);
        }, readLocalPart: function(e2) {
          var t2, r2;
          if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize)
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (null === (t2 = function(e3) {
            for (var t3 in h)
              if (Object.prototype.hasOwnProperty.call(h, t3) && h[t3].magic === e3)
                return h[t3];
            return null;
          }(this.compressionMethod)))
            throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
          this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));
        }, readCentralPart: function(e2) {
          this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
          var t2 = e2.readInt(2);
          if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted())
            throw new Error("Encrypted zip are not supported");
          e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e2 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e2 = n(this.extraFields[1].value);
            this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
          }
        }, readExtraFields: function(e2) {
          var t2, r2, n2, i2 = e2.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; )
            t2 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n2 };
          e2.setIndex(i2);
        }, handleUTF8: function() {
          var e2 = u.uint8array ? "uint8array" : "array";
          if (this.useUTF8())
            this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
          else {
            var t2 = this.findExtraFieldUnicodePath();
            if (null !== t2)
              this.fileNameStr = t2;
            else {
              var r2 = s.transformTo(e2, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r2);
            }
            var n2 = this.findExtraFieldUnicodeComment();
            if (null !== n2)
              this.fileCommentStr = n2;
            else {
              var i2 = s.transformTo(e2, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i2);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e2 = this.extraFields[28789];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e2 = this.extraFields[25461];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        } }, t.exports = l;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t, r) {
        "use strict";
        function n(e2, t2, r2) {
          this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
        }
        var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
        n.prototype = { internalStream: function(e2) {
          var t2 = null, r2 = "string";
          try {
            if (!e2)
              throw new Error("No output type specified.");
            var n2 = "string" === (r2 = e2.toLowerCase()) || "text" === r2;
            "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t2 = this._decompressWorker();
            var i2 = !this._dataBinary;
            i2 && !n2 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));
          } catch (e3) {
            (t2 = new h("error")).error(e3);
          }
          return new s(t2, r2, "");
        }, async: function(e2, t2) {
          return this.internalStream(e2).accumulate(t2);
        }, nodeStream: function(e2, t2) {
          return this.internalStream(e2 || "nodebuffer").toNodejsStream(t2);
        }, _compressWorker: function(e2, t2) {
          if (this._data instanceof o && this._data.compression.magic === e2.magic)
            return this._data.getCompressedWorker();
          var r2 = this._decompressWorker();
          return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t2);
        }, _decompressWorker: function() {
          return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
        } };
        for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f = 0; f < u.length; f++)
          n.prototype[u[f]] = l;
        t.exports = n;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t) {
        (function(t2) {
          "use strict";
          var r, n, e2 = t2.MutationObserver || t2.WebKitMutationObserver;
          if (e2) {
            var i = 0, s = new e2(u), a = t2.document.createTextNode("");
            s.observe(a, { characterData: true }), r = function() {
              a.data = i = ++i % 2;
            };
          } else if (t2.setImmediate || void 0 === t2.MessageChannel)
            r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
              var e3 = t2.document.createElement("script");
              e3.onreadystatechange = function() {
                u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
              }, t2.document.documentElement.appendChild(e3);
            } : function() {
              setTimeout(u, 0);
            };
          else {
            var o = new t2.MessageChannel();
            o.port1.onmessage = u, r = function() {
              o.port2.postMessage(0);
            };
          }
          var h = [];
          function u() {
            var e3, t3;
            n = true;
            for (var r2 = h.length; r2; ) {
              for (t3 = h, h = [], e3 = -1; ++e3 < r2; )
                t3[e3]();
              r2 = h.length;
            }
            n = false;
          }
          l.exports = function(e3) {
            1 !== h.push(e3) || n || r();
          };
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 37: [function(e, t, r) {
        "use strict";
        var i = e("immediate");
        function u() {
        }
        var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
        function o(e2) {
          if ("function" != typeof e2)
            throw new TypeError("resolver must be a function");
          this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);
        }
        function h(e2, t2, r2) {
          this.promise = e2, "function" == typeof t2 && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
        }
        function f(t2, r2, n2) {
          i(function() {
            var e2;
            try {
              e2 = r2(n2);
            } catch (e3) {
              return l.reject(t2, e3);
            }
            e2 === t2 ? l.reject(t2, new TypeError("Cannot resolve promise with itself")) : l.resolve(t2, e2);
          });
        }
        function c(e2) {
          var t2 = e2 && e2.then;
          if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t2)
            return function() {
              t2.apply(e2, arguments);
            };
        }
        function d(t2, e2) {
          var r2 = false;
          function n2(e3) {
            r2 || (r2 = true, l.reject(t2, e3));
          }
          function i2(e3) {
            r2 || (r2 = true, l.resolve(t2, e3));
          }
          var s2 = p(function() {
            e2(i2, n2);
          });
          "error" === s2.status && n2(s2.value);
        }
        function p(e2, t2) {
          var r2 = {};
          try {
            r2.value = e2(t2), r2.status = "success";
          } catch (e3) {
            r2.status = "error", r2.value = e3;
          }
          return r2;
        }
        (t.exports = o).prototype.finally = function(t2) {
          if ("function" != typeof t2)
            return this;
          var r2 = this.constructor;
          return this.then(function(e2) {
            return r2.resolve(t2()).then(function() {
              return e2;
            });
          }, function(e2) {
            return r2.resolve(t2()).then(function() {
              throw e2;
            });
          });
        }, o.prototype.catch = function(e2) {
          return this.then(null, e2);
        }, o.prototype.then = function(e2, t2) {
          if ("function" != typeof e2 && this.state === a || "function" != typeof t2 && this.state === s)
            return this;
          var r2 = new this.constructor(u);
          this.state !== n ? f(r2, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h(r2, e2, t2));
          return r2;
        }, h.prototype.callFulfilled = function(e2) {
          l.resolve(this.promise, e2);
        }, h.prototype.otherCallFulfilled = function(e2) {
          f(this.promise, this.onFulfilled, e2);
        }, h.prototype.callRejected = function(e2) {
          l.reject(this.promise, e2);
        }, h.prototype.otherCallRejected = function(e2) {
          f(this.promise, this.onRejected, e2);
        }, l.resolve = function(e2, t2) {
          var r2 = p(c, t2);
          if ("error" === r2.status)
            return l.reject(e2, r2.value);
          var n2 = r2.value;
          if (n2)
            d(e2, n2);
          else {
            e2.state = a, e2.outcome = t2;
            for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; )
              e2.queue[i2].callFulfilled(t2);
          }
          return e2;
        }, l.reject = function(e2, t2) {
          e2.state = s, e2.outcome = t2;
          for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; )
            e2.queue[r2].callRejected(t2);
          return e2;
        }, o.resolve = function(e2) {
          if (e2 instanceof this)
            return e2;
          return l.resolve(new this(u), e2);
        }, o.reject = function(e2) {
          var t2 = new this(u);
          return l.reject(t2, e2);
        }, o.all = function(e2) {
          var r2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2))
            return this.reject(new TypeError("must be an array"));
          var n2 = e2.length, i2 = false;
          if (!n2)
            return this.resolve([]);
          var s2 = new Array(n2), a2 = 0, t2 = -1, o2 = new this(u);
          for (; ++t2 < n2; )
            h2(e2[t2], t2);
          return o2;
          function h2(e3, t3) {
            r2.resolve(e3).then(function(e4) {
              s2[t3] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
            }, function(e4) {
              i2 || (i2 = true, l.reject(o2, e4));
            });
          }
        }, o.race = function(e2) {
          var t2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2))
            return this.reject(new TypeError("must be an array"));
          var r2 = e2.length, n2 = false;
          if (!r2)
            return this.resolve([]);
          var i2 = -1, s2 = new this(u);
          for (; ++i2 < r2; )
            a2 = e2[i2], t2.resolve(a2).then(function(e3) {
              n2 || (n2 = true, l.resolve(s2, e3));
            }, function(e3) {
              n2 || (n2 = true, l.reject(s2, e3));
            });
          var a2;
          return s2;
        };
      }, { immediate: 36 }], 38: [function(e, t, r) {
        "use strict";
        var n = {};
        (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t, r) {
        "use strict";
        var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
        function p(e2) {
          if (!(this instanceof p))
            return new p(e2);
          this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
          var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
          if (r2 !== l)
            throw new Error(i[r2]);
          if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
            var n2;
            if (n2 = "string" == typeof t2.dictionary ? h.string2buf(t2.dictionary) : "[object ArrayBuffer]" === u.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l)
              throw new Error(i[r2]);
            this._dict_set = true;
          }
        }
        function n(e2, t2) {
          var r2 = new p(t2);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || i[r2.err];
          return r2.result;
        }
        p.prototype.push = function(e2, t2) {
          var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
          if (this.ended)
            return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, "string" == typeof e2 ? i2.input = h.string2buf(e2) : "[object ArrayBuffer]" === u.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
          do {
            if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l)
              return this.onEnd(r2), !(this.ended = true);
            0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
          } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
          return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));
        }, p.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, p.prototype.onEnd = function(e2) {
          e2 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, n(e2, t2);
        }, r.gzip = function(e2, t2) {
          return (t2 = t2 || {}).gzip = true, n(e2, t2);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t, r) {
        "use strict";
        var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
        function a(e2) {
          if (!(this instanceof a))
            return new a(e2);
          this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
          var r2 = c.inflateInit2(this.strm, t2.windowBits);
          if (r2 !== m.Z_OK)
            throw new Error(n[r2]);
          this.header = new s(), c.inflateGetHeader(this.strm, this.header);
        }
        function o(e2, t2) {
          var r2 = new a(t2);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || n[r2.err];
          return r2.result;
        }
        a.prototype.push = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
          if (this.ended)
            return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e2 ? h.input = p.binstring2buf(e2) : "[object ArrayBuffer]" === _.call(e2) ? h.input = new Uint8Array(e2) : h.input = e2, h.next_in = 0, h.avail_in = h.input.length;
          do {
            if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK)
              return this.onEnd(r2), !(this.ended = true);
            h.next_out && (0 !== h.avail_out && r2 !== m.Z_STREAM_END && (0 !== h.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);
          } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m.Z_STREAM_END);
          return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
        }, a.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, a.prototype.onEnd = function(e2) {
          e2 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, o(e2, t2);
        }, r.ungzip = o;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t, r) {
        "use strict";
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        r.assign = function(e2) {
          for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
            var r2 = t2.shift();
            if (r2) {
              if ("object" != typeof r2)
                throw new TypeError(r2 + "must be non-object");
              for (var n2 in r2)
                r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
            }
          }
          return e2;
        }, r.shrinkBuf = function(e2, t2) {
          return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
        };
        var i = { arraySet: function(e2, t2, r2, n2, i2) {
          if (t2.subarray && e2.subarray)
            e2.set(t2.subarray(r2, r2 + n2), i2);
          else
            for (var s2 = 0; s2 < n2; s2++)
              e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          var t2, r2, n2, i2, s2, a;
          for (t2 = n2 = 0, r2 = e2.length; t2 < r2; t2++)
            n2 += e2[t2].length;
          for (a = new Uint8Array(n2), t2 = i2 = 0, r2 = e2.length; t2 < r2; t2++)
            s2 = e2[t2], a.set(s2, i2), i2 += s2.length;
          return a;
        } }, s = { arraySet: function(e2, t2, r2, n2, i2) {
          for (var s2 = 0; s2 < n2; s2++)
            e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          return [].concat.apply([], e2);
        } };
        r.setTyped = function(e2) {
          e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
        }, r.setTyped(n);
      }, {}], 42: [function(e, t, r) {
        "use strict";
        var h = e("./common"), i = true, s = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e2) {
          i = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e2) {
          s = false;
        }
        for (var u = new h.Buf8(256), n = 0; n < 256; n++)
          u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
        function l(e2, t2) {
          if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i))
            return String.fromCharCode.apply(null, h.shrinkBuf(e2, t2));
          for (var r2 = "", n2 = 0; n2 < t2; n2++)
            r2 += String.fromCharCode(e2[n2]);
          return r2;
        }
        u[254] = u[254] = 1, r.string2buf = function(e2) {
          var t2, r2, n2, i2, s2, a = e2.length, o = 0;
          for (i2 = 0; i2 < a; i2++)
            55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t2 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++)
            55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
          return t2;
        }, r.buf2binstring = function(e2) {
          return l(e2, e2.length);
        }, r.binstring2buf = function(e2) {
          for (var t2 = new h.Buf8(e2.length), r2 = 0, n2 = t2.length; r2 < n2; r2++)
            t2[r2] = e2.charCodeAt(r2);
          return t2;
        }, r.buf2string = function(e2, t2) {
          var r2, n2, i2, s2, a = t2 || e2.length, o = new Array(2 * a);
          for (r2 = n2 = 0; r2 < a; )
            if ((i2 = e2[r2++]) < 128)
              o[n2++] = i2;
            else if (4 < (s2 = u[i2]))
              o[n2++] = 65533, r2 += s2 - 1;
            else {
              for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; )
                i2 = i2 << 6 | 63 & e2[r2++], s2--;
              1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
            }
          return l(o, n2);
        }, r.utf8border = function(e2, t2) {
          var r2;
          for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1; 0 <= r2 && 128 == (192 & e2[r2]); )
            r2--;
          return r2 < 0 ? t2 : 0 === r2 ? t2 : r2 + u[e2[r2]] > t2 ? r2 : t2;
        };
      }, { "./common": 41 }], 43: [function(e, t, r) {
        "use strict";
        t.exports = function(e2, t2, r2, n) {
          for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
            for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n++] | 0) | 0, --a; )
              ;
            i %= 65521, s %= 65521;
          }
          return i | s << 16 | 0;
        };
      }, {}], 44: [function(e, t, r) {
        "use strict";
        t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e, t, r) {
        "use strict";
        var o = function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n = 0; n < 8; n++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        }();
        t.exports = function(e2, t2, r2, n) {
          var i = o, s = n + r2;
          e2 ^= -1;
          for (var a = n; a < s; a++)
            e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];
          return -1 ^ e2;
        };
      }, {}], 46: [function(e, t, r) {
        "use strict";
        var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
        function R(e2, t2) {
          return e2.msg = n[t2], t2;
        }
        function T(e2) {
          return (e2 << 1) - (4 < e2 ? 9 : 0);
        }
        function D(e2) {
          for (var t2 = e2.length; 0 <= --t2; )
            e2[t2] = 0;
        }
        function F(e2) {
          var t2 = e2.state, r2 = t2.pending;
          r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (c.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));
        }
        function N(e2, t2) {
          u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F(e2.strm);
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = t2;
        }
        function P(e2, t2) {
          e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
        }
        function L(e2, t2) {
          var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h2 = e2.strstart > e2.w_size - z ? e2.strstart - (e2.w_size - z) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
          e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
          do {
            if (u2[(r2 = t2) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
              s2 += 2, r2++;
              do {
              } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
              if (n2 = S - (c2 - s2), s2 = c2 - S, a2 < n2) {
                if (e2.match_start = t2, o2 <= (a2 = n2))
                  break;
                d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
              }
            }
          } while ((t2 = f2[t2 & l2]) > h2 && 0 != --i2);
          return a2 <= e2.lookahead ? a2 : e2.lookahead;
        }
        function j(e2) {
          var t2, r2, n2, i2, s2, a2, o2, h2, u2, l2, f2 = e2.w_size;
          do {
            if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z)) {
              for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r2 = e2.hash_size; n2 = e2.head[--t2], e2.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                ;
              for (t2 = r2 = f2; n2 = e2.prev[--t2], e2.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                ;
              i2 += f2;
            }
            if (0 === e2.strm.avail_in)
              break;
            if (a2 = e2.strm, o2 = e2.window, h2 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h2), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h2) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x)
              for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); )
                ;
          } while (e2.lookahead < z && 0 !== e2.strm.avail_in);
        }
        function Z(e2, t2) {
          for (var r2, n2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2)), e2.match_length >= x)
              if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
                for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; )
                  ;
                e2.strstart++;
              } else
                e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
            else
              n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
            if (n2 && (N(e2, false), 0 === e2.strm.avail_out))
              return A;
          }
          return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function W(e2, t2) {
          for (var r2, n2, i2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
              for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; )
                ;
              if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), 0 === e2.strm.avail_out))
                return A;
            } else if (e2.match_available) {
              if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out)
                return A;
            } else
              e2.match_available = 1, e2.strstart++, e2.lookahead--;
          }
          return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function M(e2, t2, r2, n2, i2) {
          this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
        }
        function H() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function G(e2) {
          var t2;
          return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = l, u._tr_init(t2), m) : R(e2, _);
        }
        function K(e2) {
          var t2 = G(e2);
          return t2 === m && function(e3) {
            e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
          }(e2.state), t2;
        }
        function Y(e2, t2, r2, n2, i2, s2) {
          if (!e2)
            return _;
          var a2 = 1;
          if (t2 === g && (t2 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2)
            return R(e2, _);
          8 === n2 && (n2 = 9);
          var o2 = new H();
          return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K(e2);
        }
        h = [new M(0, 0, 0, 0, function(e2, t2) {
          var r2 = 65535;
          for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
            if (e2.lookahead <= 1) {
              if (j(e2), 0 === e2.lookahead && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            e2.strstart += e2.lookahead, e2.lookahead = 0;
            var n2 = e2.block_start + r2;
            if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), 0 === e2.strm.avail_out))
              return A;
            if (e2.strstart - e2.block_start >= e2.w_size - z && (N(e2, false), 0 === e2.strm.avail_out))
              return A;
          }
          return e2.insert = 0, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
        }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t2) {
          return Y(e2, t2, v, 15, 8, 0);
        }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t2) {
          return e2 && e2.state ? 2 !== e2.state.wrap ? _ : (e2.state.gzhead = t2, m) : _;
        }, r.deflate = function(e2, t2) {
          var r2, n2, i2, s2;
          if (!e2 || !e2.state || 5 < t2 || t2 < 0)
            return e2 ? R(e2, _) : _;
          if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && t2 !== f)
            return R(e2, 0 === e2.avail_out ? -5 : _);
          if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t2, n2.status === C)
            if (2 === n2.wrap)
              e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
            else {
              var a2 = v + (n2.w_bits - 8 << 4) << 8;
              a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), 0 !== n2.strstart && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;
            }
          if (69 === n2.status)
            if (n2.gzhead.extra) {
              for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
                U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
            } else
              n2.status = 73;
          if (73 === n2.status)
            if (n2.gzhead.name) {
              i2 = n2.pending;
              do {
                if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
              } while (0 !== s2);
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
            } else
              n2.status = 91;
          if (91 === n2.status)
            if (n2.gzhead.comment) {
              i2 = n2.pending;
              do {
                if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
              } while (0 !== s2);
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
            } else
              n2.status = 103;
          if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), 0 !== n2.pending) {
            if (F(e2), 0 === e2.avail_out)
              return n2.last_flush = -1, m;
          } else if (0 === e2.avail_in && T(t2) <= T(r2) && t2 !== f)
            return R(e2, -5);
          if (666 === n2.status && 0 !== e2.avail_in)
            return R(e2, -5);
          if (0 !== e2.avail_in || 0 !== n2.lookahead || t2 !== l && 666 !== n2.status) {
            var o2 = 2 === n2.strategy ? function(e3, t3) {
              for (var r3; ; ) {
                if (0 === e3.lookahead && (j(e3), 0 === e3.lookahead)) {
                  if (t3 === l)
                    return A;
                  break;
                }
                if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), 0 === e3.strm.avail_out))
                  return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            }(n2, t2) : 3 === n2.strategy ? function(e3, t3) {
              for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
                if (e3.lookahead <= S) {
                  if (j(e3), e3.lookahead <= S && t3 === l)
                    return A;
                  if (0 === e3.lookahead)
                    break;
                }
                if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                  s3 = e3.strstart + S;
                  do {
                  } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                  e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                }
                if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), 0 === e3.strm.avail_out))
                  return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            }(n2, t2) : h[n2.level].func(n2, t2);
            if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O)
              return 0 === e2.avail_out && (n2.last_flush = -1), m;
            if (o2 === I && (1 === t2 ? u._tr_align(n2) : 5 !== t2 && (u._tr_stored_block(n2, 0, 0, false), 3 === t2 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e2), 0 === e2.avail_out))
              return n2.last_flush = -1, m;
          }
          return t2 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);
        }, r.deflateEnd = function(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state.status) !== C && 69 !== t2 && 73 !== t2 && 91 !== t2 && 103 !== t2 && t2 !== E && 666 !== t2 ? R(e2, _) : (e2.state = null, t2 === E ? R(e2, -3) : m) : _;
        }, r.deflateSetDictionary = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2 = t2.length;
          if (!e2 || !e2.state)
            return _;
          if (2 === (s2 = (r2 = e2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead)
            return _;
          for (1 === s2 && (e2.adler = d(e2.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h2 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t2, j(r2); r2.lookahead >= x; ) {
            for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; )
              ;
            r2.strstart = n2, r2.lookahead = x - 1, j(r2);
          }
          return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h2, e2.avail_in = a2, r2.wrap = s2, m;
        }, r.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t, r) {
        "use strict";
        t.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e, t, r) {
        "use strict";
        t.exports = function(e2, t2) {
          var r2, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C;
          r2 = e2.state, n = e2.next_in, z = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
          e:
            do {
              p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m[d & g];
              t:
                for (; ; ) {
                  if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255))
                    C[s++] = 65535 & v;
                  else {
                    if (!(16 & y)) {
                      if (0 == (64 & y)) {
                        v = m[(65535 & v) + (d & (1 << y) - 1)];
                        continue t;
                      }
                      if (32 & y) {
                        r2.mode = 12;
                        break e;
                      }
                      e2.msg = "invalid literal/length code", r2.mode = 30;
                      break e;
                    }
                    w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _[d & b];
                    r:
                      for (; ; ) {
                        if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                          if (0 == (64 & y)) {
                            v = _[(65535 & v) + (d & (1 << y) - 1)];
                            continue r;
                          }
                          e2.msg = "invalid distance code", r2.mode = 30;
                          break e;
                        }
                        if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
                          e2.msg = "invalid distance too far back", r2.mode = 30;
                          break e;
                        }
                        if (d >>>= y, p -= y, (y = s - a) < k) {
                          if (l < (y = k - y) && r2.sane) {
                            e2.msg = "invalid distance too far back", r2.mode = 30;
                            break e;
                          }
                          if (S = c, (x = 0) === f) {
                            if (x += u - y, y < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              x = s - k, S = C;
                            }
                          } else if (f < y) {
                            if (x += u + f - y, (y -= f) < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              if (x = 0, f < w) {
                                for (w -= y = f; C[s++] = c[x++], --y; )
                                  ;
                                x = s - k, S = C;
                              }
                            }
                          } else if (x += f - y, y < w) {
                            for (w -= y; C[s++] = c[x++], --y; )
                              ;
                            x = s - k, S = C;
                          }
                          for (; 2 < w; )
                            C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                          w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                        } else {
                          for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); )
                            ;
                          w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                        }
                        break;
                      }
                  }
                  break;
                }
            } while (n < i && s < o);
          n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
        };
      }, {}], 49: [function(e, t, r) {
        "use strict";
        var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
        function L(e2) {
          return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
        }
        function s() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function a(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I.Buf32(n), t2.distcode = t2.distdyn = new I.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;
        }
        function o(e2) {
          var t2;
          return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U;
        }
        function h(e2, t2) {
          var r2, n2;
          return e2 && e2.state ? (n2 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, o(e2))) : U;
        }
        function u(e2, t2) {
          var r2, n2;
          return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h(e2, t2)) !== N && (e2.state = null), r2) : U;
        }
        var l, f, c = true;
        function j(e2) {
          if (c) {
            var t2;
            for (l = new I.Buf32(512), f = new I.Buf32(32), t2 = 0; t2 < 144; )
              e2.lens[t2++] = 8;
            for (; t2 < 256; )
              e2.lens[t2++] = 9;
            for (; t2 < 280; )
              e2.lens[t2++] = 7;
            for (; t2 < 288; )
              e2.lens[t2++] = 8;
            for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; )
              e2.lens[t2++] = 5;
            T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
          }
          e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
        }
        function Z(e2, t2, r2, n2) {
          var i2, s2 = e2.state;
          return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t2, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t2, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
        }
        r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e2) {
          return u(e2, 15);
        }, r.inflateInit2 = u, r.inflate = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in)
            return U;
          12 === (r2 = e2.state).mode && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h2, x = N;
          e:
            for (; ; )
              switch (r2.mode) {
                case P:
                  if (0 === r2.wrap) {
                    r2.mode = 13;
                    break;
                  }
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (2 & r2.wrap && 35615 === u2) {
                    E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                    break;
                  }
                  if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                    e2.msg = "incorrect header check", r2.mode = 30;
                    break;
                  }
                  if (8 != (15 & u2)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits)
                    r2.wbits = k;
                  else if (k > r2.wbits) {
                    e2.msg = "invalid window size", r2.mode = 30;
                    break;
                  }
                  r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                  break;
                case 2:
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (r2.flags = u2, 8 != (255 & r2.flags)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (57344 & r2.flags) {
                    e2.msg = "unknown header flags set", r2.mode = 30;
                    break;
                  }
                  r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
                case 3:
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
                case 4:
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
                case 5:
                  if (1024 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                  } else
                    r2.head && (r2.head.extra = null);
                  r2.mode = 6;
                case 6:
                  if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length))
                    break e;
                  r2.length = 0, r2.mode = 7;
                case 7:
                  if (2048 & r2.flags) {
                    if (0 === o2)
                      break e;
                    for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.name = null);
                  r2.length = 0, r2.mode = 8;
                case 8:
                  if (4096 & r2.flags) {
                    if (0 === o2)
                      break e;
                    for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.comment = null);
                  r2.mode = 9;
                case 9:
                  if (512 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (65535 & r2.check)) {
                      e2.msg = "header crc mismatch", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
                  break;
                case 10:
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
                case 11:
                  if (0 === r2.havedict)
                    return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                  e2.adler = r2.check = 1, r2.mode = 12;
                case 12:
                  if (5 === t2 || 6 === t2)
                    break e;
                case 13:
                  if (r2.last) {
                    u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                    break;
                  }
                  for (; l2 < 3; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                    case 0:
                      r2.mode = 14;
                      break;
                    case 1:
                      if (j(r2), r2.mode = 20, 6 !== t2)
                        break;
                      u2 >>>= 2, l2 -= 2;
                      break e;
                    case 2:
                      r2.mode = 17;
                      break;
                    case 3:
                      e2.msg = "invalid block type", r2.mode = 30;
                  }
                  u2 >>>= 2, l2 -= 2;
                  break;
                case 14:
                  for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                    e2.msg = "invalid stored block lengths", r2.mode = 30;
                    break;
                  }
                  if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === t2)
                    break e;
                case 15:
                  r2.mode = 16;
                case 16:
                  if (d = r2.length) {
                    if (o2 < d && (d = o2), h2 < d && (d = h2), 0 === d)
                      break e;
                    I.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;
                    break;
                  }
                  r2.mode = 12;
                  break;
                case 17:
                  for (; l2 < 14; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                    e2.msg = "too many length or distance symbols", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 18;
                case 18:
                  for (; r2.have < r2.ncode; ) {
                    for (; l2 < 3; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                  }
                  for (; r2.have < 19; )
                    r2.lens[A[r2.have++]] = 0;
                  if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid code lengths set", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 19;
                case 19:
                  for (; r2.have < r2.nlen + r2.ndist; ) {
                    for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (b < 16)
                      u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                    else {
                      if (16 === b) {
                        for (z = _ + 2; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        if (u2 >>>= _, l2 -= _, 0 === r2.have) {
                          e2.msg = "invalid bit length repeat", r2.mode = 30;
                          break;
                        }
                        k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                      } else if (17 === b) {
                        for (z = _ + 3; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                      } else {
                        for (z = _ + 7; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                      }
                      if (r2.have + d > r2.nlen + r2.ndist) {
                        e2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      for (; d--; )
                        r2.lens[r2.have++] = k;
                    }
                  }
                  if (30 === r2.mode)
                    break;
                  if (0 === r2.lens[256]) {
                    e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                    break;
                  }
                  if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid literal/lengths set", r2.mode = 30;
                    break;
                  }
                  if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                    e2.msg = "invalid distances set", r2.mode = 30;
                    break;
                  }
                  if (r2.mode = 20, 6 === t2)
                    break e;
                case 20:
                  r2.mode = 21;
                case 21:
                  if (6 <= o2 && 258 <= h2) {
                    e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c2), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                    break;
                  }
                  for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (g && 0 == (240 & g)) {
                    for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {
                    r2.mode = 26;
                    break;
                  }
                  if (32 & g) {
                    r2.back = -1, r2.mode = 12;
                    break;
                  }
                  if (64 & g) {
                    e2.msg = "invalid literal/length code", r2.mode = 30;
                    break;
                  }
                  r2.extra = 15 & g, r2.mode = 22;
                case 22:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  r2.was = r2.length, r2.mode = 23;
                case 23:
                  for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (0 == (240 & g)) {
                    for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                    e2.msg = "invalid distance code", r2.mode = 30;
                    break;
                  }
                  r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
                case 24:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  if (r2.offset > r2.dmax) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  r2.mode = 25;
                case 25:
                  if (0 === h2)
                    break e;
                  if (d = c2 - h2, r2.offset > d) {
                    if ((d = r2.offset - d) > r2.whave && r2.sane) {
                      e2.msg = "invalid distance too far back", r2.mode = 30;
                      break;
                    }
                    p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
                  } else
                    m = i2, p = a2 - r2.offset, d = r2.length;
                  for (h2 < d && (d = h2), h2 -= d, r2.length -= d; i2[a2++] = m[p++], --d; )
                    ;
                  0 === r2.length && (r2.mode = 21);
                  break;
                case 26:
                  if (0 === h2)
                    break e;
                  i2[a2++] = r2.length, h2--, r2.mode = 21;
                  break;
                case 27:
                  if (r2.wrap) {
                    for (; l2 < 32; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 |= n2[s2++] << l2, l2 += 8;
                    }
                    if (c2 -= h2, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                      e2.msg = "incorrect data check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 28;
                case 28:
                  if (r2.wrap && r2.flags) {
                    for (; l2 < 32; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (4294967295 & r2.total)) {
                      e2.msg = "incorrect length check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 29;
                case 29:
                  x = 1;
                  break e;
                case 30:
                  x = -3;
                  break e;
                case 31:
                  return -4;
                case 32:
                default:
                  return U;
              }
          return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t2)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t2) && x === N && (x = -5), x);
        }, r.inflateEnd = function(e2) {
          if (!e2 || !e2.state)
            return U;
          var t2 = e2.state;
          return t2.window && (t2.window = null), e2.state = null, N;
        }, r.inflateGetHeader = function(e2, t2) {
          var r2;
          return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? U : ((r2.head = t2).done = false, N) : U;
        }, r.inflateSetDictionary = function(e2, t2) {
          var r2, n2 = t2.length;
          return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, t2, n2, 0) !== r2.check ? -3 : Z(e2, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
        }, r.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t, r) {
        "use strict";
        var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t.exports = function(e2, t2, r2, n, i, s, a, o) {
          var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
          for (b = 0; b <= 15; b++)
            O[b] = 0;
          for (v = 0; v < n; v++)
            O[t2[r2 + v]]++;
          for (k = g, w = 15; 1 <= w && 0 === O[w]; w--)
            ;
          if (w < k && (k = w), 0 === w)
            return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
          for (y = 1; y < w && 0 === O[y]; y++)
            ;
          for (k < y && (k = y), b = z = 1; b <= 15; b++)
            if (z <<= 1, (z -= O[b]) < 0)
              return -1;
          if (0 < z && (0 === e2 || 1 !== w))
            return -1;
          for (B[1] = 0, b = 1; b < 15; b++)
            B[b + 1] = B[b] + O[b];
          for (v = 0; v < n; v++)
            0 !== t2[r2 + v] && (a[B[t2[r2 + v]]++] = v);
          if (d = 0 === e2 ? (A = R = a, 19) : 1 === e2 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
            return 1;
          for (; ; ) {
            for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u; )
              ;
            for (h = 1 << b - 1; E & h; )
              h >>= 1;
            if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {
              if (b === w)
                break;
              b = t2[r2 + a[v]];
            }
            if (k < b && (E & f) !== l) {
              for (0 === S && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); )
                x++, z <<= 1;
              if (C += 1 << x, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
                return 1;
              i[l = E & f] = k << 24 | x << 16 | c - s | 0;
            }
          }
          return 0 !== E && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e, t, r) {
        "use strict";
        t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e, t, r) {
        "use strict";
        var i = e("../utils/common"), o = 0, h = 1;
        function n(e2) {
          for (var t2 = e2.length; 0 <= --t2; )
            e2[t2] = 0;
        }
        var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
        n(z);
        var C = new Array(2 * f);
        n(C);
        var E = new Array(512);
        n(E);
        var A = new Array(256);
        n(A);
        var I = new Array(a);
        n(I);
        var O, B, R, T = new Array(f);
        function D(e2, t2, r2, n2, i2) {
          this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
        }
        function F(e2, t2) {
          this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
        }
        function N(e2) {
          return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
        }
        function P(e2, t2, r2) {
          e2.bi_valid > d - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t2 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
        }
        function L(e2, t2, r2) {
          P(e2, r2[2 * t2], r2[2 * t2 + 1]);
        }
        function j(e2, t2) {
          for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t2; )
            ;
          return r2 >>> 1;
        }
        function Z(e2, t2, r2) {
          var n2, i2, s2 = new Array(g + 1), a2 = 0;
          for (n2 = 1; n2 <= g; n2++)
            s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
          for (i2 = 0; i2 <= t2; i2++) {
            var o2 = e2[2 * i2 + 1];
            0 !== o2 && (e2[2 * i2] = j(s2[o2]++, o2));
          }
        }
        function W(e2) {
          var t2;
          for (t2 = 0; t2 < l; t2++)
            e2.dyn_ltree[2 * t2] = 0;
          for (t2 = 0; t2 < f; t2++)
            e2.dyn_dtree[2 * t2] = 0;
          for (t2 = 0; t2 < c; t2++)
            e2.bl_tree[2 * t2] = 0;
          e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
        }
        function M(e2) {
          8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
        }
        function H(e2, t2, r2, n2) {
          var i2 = 2 * t2, s2 = 2 * r2;
          return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t2] <= n2[r2];
        }
        function G(e2, t2, r2) {
          for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t2, n2, e2.heap[i2], e2.depth)); )
            e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
          e2.heap[r2] = n2;
        }
        function K(e2, t2, r2) {
          var n2, i2, s2, a2, o2 = 0;
          if (0 !== e2.last_lit)
            for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? L(e2, i2, t2) : (L(e2, (s2 = A[i2]) + u + 1, t2), 0 !== (a2 = w[s2]) && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), 0 !== (a2 = k[s2]) && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; )
              ;
          L(e2, m, t2);
        }
        function Y(e2, t2) {
          var r2, n2, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h2 = t2.stat_desc.elems, u2 = -1;
          for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h2; r2++)
            0 !== s2[2 * r2] ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
          for (; e2.heap_len < 2; )
            s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
          for (t2.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--)
            G(e2, s2, r2);
          for (i2 = h2; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; )
            ;
          e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
            var r3, n3, i3, s3, a3, o3, h3 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m2 = 0;
            for (s3 = 0; s3 <= g; s3++)
              e3.bl_count[s3] = 0;
            for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++)
              p2 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
            if (0 !== m2) {
              do {
                for (s3 = p2 - 1; 0 === e3.bl_count[s3]; )
                  s3--;
                e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
              } while (0 < m2);
              for (s3 = p2; 0 !== s3; s3--)
                for (n3 = e3.bl_count[s3]; 0 !== n3; )
                  u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
            }
          }(e2, t2), Z(s2, u2, e2.bl_count);
        }
        function X(e2, t2, r2) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++)
            i2 = a2, a2 = t2[2 * (n2 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
        }
        function V(e2, t2, r2) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++)
            if (i2 = a2, a2 = t2[2 * (n2 + 1) + 1], !(++o2 < h2 && i2 === a2)) {
              if (o2 < u2)
                for (; L(e2, i2, e2.bl_tree), 0 != --o2; )
                  ;
              else
                0 !== i2 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));
              s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
            }
        }
        n(T);
        var q = false;
        function J(e2, t2, r2, n2) {
          P(e2, (s << 1) + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
            M(e3), n3 && (U(e3, r3), U(e3, ~r3)), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
          }(e2, t2, r2, true);
        }
        r._tr_init = function(e2) {
          q || (function() {
            var e3, t2, r2, n2, i2, s2 = new Array(g + 1);
            for (n2 = r2 = 0; n2 < a - 1; n2++)
              for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++)
                A[r2++] = n2;
            for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++)
              for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++)
                E[i2++] = n2;
            for (i2 >>= 7; n2 < f; n2++)
              for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++)
                E[256 + i2++] = n2;
            for (t2 = 0; t2 <= g; t2++)
              s2[t2] = 0;
            for (e3 = 0; e3 <= 143; )
              z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (; e3 <= 255; )
              z[2 * e3 + 1] = 9, e3++, s2[9]++;
            for (; e3 <= 279; )
              z[2 * e3 + 1] = 7, e3++, s2[7]++;
            for (; e3 <= 287; )
              z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (Z(z, l + 1, s2), e3 = 0; e3 < f; e3++)
              C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
            O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);
          }(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);
        }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t2, r2, n2) {
          var i2, s2, a2 = 0;
          0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = function(e3) {
            var t3, r3 = 4093624447;
            for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1)
              if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3])
                return o;
            if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26])
              return h;
            for (t3 = 32; t3 < u; t3++)
              if (0 !== e3.dyn_ltree[2 * t3])
                return h;
            return o;
          }(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = function(e3) {
            var t3;
            for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t3 = c - 1; 3 <= t3 && 0 === e3.bl_tree[2 * S[t3] + 1]; t3--)
              ;
            return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
          }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t2 ? J(e2, t2, r2, n2) : 4 === e2.strategy || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K(e2, z, C)) : (P(e2, 4 + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
            var i3;
            for (P(e3, t3 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++)
              P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
            V(e3, e3.dyn_ltree, t3 - 1), V(e3, e3.dyn_dtree, r3 - 1);
          }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n2 && M(e2);
        }, r._tr_tally = function(e2, t2, r2) {
          return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t2 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
        }, r._tr_align = function(e2) {
          P(e2, 2, 3), L(e2, m, z), function(e3) {
            16 === e3.bi_valid ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
          }(e2);
        };
      }, { "../utils/common": 41 }], 53: [function(e, t, r) {
        "use strict";
        t.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e, t, r) {
        (function(e2) {
          !function(r2, n) {
            "use strict";
            if (!r2.setImmediate) {
              var i, s, t2, a, o = 1, h = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
              e3 = e3 && e3.setTimeout ? e3 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e4) {
                process.nextTick(function() {
                  c(e4);
                });
              } : function() {
                if (r2.postMessage && !r2.importScripts) {
                  var e4 = true, t3 = r2.onmessage;
                  return r2.onmessage = function() {
                    e4 = false;
                  }, r2.postMessage("", "*"), r2.onmessage = t3, e4;
                }
              }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
                r2.postMessage(a + e4, "*");
              }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e4) {
                c(e4.data);
              }, function(e4) {
                t2.port2.postMessage(e4);
              }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
                var t3 = l.createElement("script");
                t3.onreadystatechange = function() {
                  c(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
                }, s.appendChild(t3);
              }) : function(e4) {
                setTimeout(c, 0, e4);
              }, e3.setImmediate = function(e4) {
                "function" != typeof e4 && (e4 = new Function("" + e4));
                for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++)
                  t3[r3] = arguments[r3 + 1];
                var n2 = { callback: e4, args: t3 };
                return h[o] = n2, i(o), o++;
              }, e3.clearImmediate = f;
            }
            function f(e4) {
              delete h[e4];
            }
            function c(e4) {
              if (u)
                setTimeout(c, 0, e4);
              else {
                var t3 = h[e4];
                if (t3) {
                  u = true;
                  try {
                    !function(e5) {
                      var t4 = e5.callback, r3 = e5.args;
                      switch (r3.length) {
                        case 0:
                          t4();
                          break;
                        case 1:
                          t4(r3[0]);
                          break;
                        case 2:
                          t4(r3[0], r3[1]);
                          break;
                        case 3:
                          t4(r3[0], r3[1], r3[2]);
                          break;
                        default:
                          t4.apply(n, r3);
                      }
                    }(t3);
                  } finally {
                    f(e4), u = false;
                  }
                }
              }
            }
            function d(e4) {
              e4.source === r2 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));
            }
          }("undefined" == typeof self ? void 0 === e2 ? this : e2 : self);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}] }, {}, [10])(10);
    });
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => WritingDashboardPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian29 = require("obsidian");

// ui/DashboardView.ts
var import_obsidian7 = require("obsidian");
var import_client4 = __toESM(require_client());
var import_react9 = __toESM(require_react());

// ui/DashboardComponent.tsx
var import_react8 = __toESM(require_react());
var import_obsidian6 = require("obsidian");

// ui/VaultBrowser.tsx
var import_react = __toESM(require_react());
var VaultBrowser = ({ plugin, collapsed = false, onToggleCollapsed }) => {
  const [structure, setStructure] = (0, import_react.useState)([]);
  const [expandedFolders, setExpandedFolders] = (0, import_react.useState)(/* @__PURE__ */ new Set());
  (0, import_react.useEffect)(() => {
    const vaultStructure = plugin.vaultService.getVaultStructure();
    setStructure(vaultStructure);
    setExpandedFolders(/* @__PURE__ */ new Set([""]));
  }, []);
  const toggleFolder = (path) => {
    const newExpanded = new Set(expandedFolders);
    if (newExpanded.has(path)) {
      newExpanded.delete(path);
    } else {
      newExpanded.add(path);
    }
    setExpandedFolders(newExpanded);
  };
  const renderItem = (item, depth = 0) => {
    if (item.type === "folder") {
      const isExpanded = expandedFolders.has(item.path);
      const children = structure.filter(
        (s) => s.path.startsWith(item.path + "/") && s.path.split("/").length === item.path.split("/").length + 1
      );
      return /* @__PURE__ */ import_react.default.createElement("div", { key: item.path, className: "vault-item folder", style: { paddingLeft: `${depth * 20}px` } }, /* @__PURE__ */ import_react.default.createElement(
        "span",
        {
          className: "folder-toggle",
          onClick: () => toggleFolder(item.path)
        },
        isExpanded ? "\u{1F4C2}" : "\u{1F4C1}",
        " ",
        item.name
      ), isExpanded && children.map((child) => renderItem(child, depth + 1)));
    } else {
      return /* @__PURE__ */ import_react.default.createElement("div", { key: item.path, className: "vault-item file", style: { paddingLeft: `${depth * 20}px` } }, "\u{1F4C4} ", item.name);
    }
  };
  const rootItems = structure.filter((item) => !item.path.includes("/"));
  return /* @__PURE__ */ import_react.default.createElement("div", { className: "vault-browser" }, /* @__PURE__ */ import_react.default.createElement("div", { className: "vault-browser-header" }, /* @__PURE__ */ import_react.default.createElement("h3", { className: "vault-browser-title" }, collapsed ? "\u{1F4C1}" : "Vault structure"), /* @__PURE__ */ import_react.default.createElement(
    "button",
    {
      type: "button",
      className: "vault-collapse-btn",
      "aria-label": collapsed ? "Expand vault structure" : "Collapse vault structure",
      title: collapsed ? "Expand" : "Collapse",
      onClick: () => onToggleCollapsed?.(!collapsed)
    },
    collapsed ? "\xBB" : "\xAB"
  )), !collapsed && /* @__PURE__ */ import_react.default.createElement("div", { className: "vault-tree" }, rootItems.map((item) => renderItem(item))));
};

// ui/EditorPanel.tsx
var import_react2 = __toESM(require_react());

// services/TextChunker.ts
var TextChunker = class {
  /**
   * Split text into chunks of approximately the specified word count
   * Tries to break at sentence boundaries when possible
   */
  static chunkText(text2, wordsPerChunk = 500) {
    const chunks = [];
    const words = text2.trim().split(/\s+/);
    if (words.length === 0) {
      return [];
    }
    let currentChunk = [];
    let currentWordCount = 0;
    for (let i = 0; i < words.length; i++) {
      const word = words[i];
      currentChunk.push(word);
      currentWordCount++;
      if (currentWordCount >= wordsPerChunk) {
        let foundBreak = false;
        for (let j = i + 1; j < Math.min(i + 50, words.length); j++) {
          if (j > 0 && /[.!?]$/.test(words[j - 1])) {
            const chunkText = currentChunk.join(" ");
            if (chunkText.trim()) {
              chunks.push(chunkText.trim());
            }
            currentChunk = [];
            currentWordCount = 0;
            foundBreak = true;
            i = j - 1;
            break;
          }
        }
        if (!foundBreak) {
          const chunkText = currentChunk.join(" ");
          if (chunkText.trim()) {
            chunks.push(chunkText.trim());
          }
          currentChunk = [];
          currentWordCount = 0;
        }
      }
    }
    if (currentChunk.length > 0) {
      const chunkText = currentChunk.join(" ");
      if (chunkText.trim()) {
        chunks.push(chunkText.trim());
      }
    }
    return chunks;
  }
  /**
   * Get word count of text
   */
  static getWordCount(text2) {
    return text2.trim().split(/\s+/).filter((word) => word.length > 0).length;
  }
  /**
   * Split a manuscript into sections based on H1 headings (lines starting with "# ").
   * Returns an array of sections including the heading line + content.
   *
   * If no H1 headings are found, returns a single section with the whole text.
   */
  static splitByH1(text2) {
    const normalized = (text2 || "").replace(/\r\n/g, "\n");
    const lines = normalized.split("\n");
    const sections = [];
    let currentHeading = "";
    let currentLines = [];
    let seenAnyHeading = false;
    const flush = () => {
      const content = currentLines.join("\n").trimEnd();
      const heading2 = currentHeading || "";
      const fullText = (heading2 ? `${heading2}
` : "") + content;
      if (fullText.trim()) {
        sections.push({ heading: heading2, content, fullText: fullText.trim() });
      }
    };
    for (const line of lines) {
      if (line.startsWith("# ")) {
        if (seenAnyHeading) {
          flush();
        }
        seenAnyHeading = true;
        currentHeading = line.trimEnd();
        currentLines = [];
        continue;
      }
      currentLines.push(line);
    }
    if (seenAnyHeading) {
      flush();
      return sections;
    }
    const full = normalized.trim();
    return full ? [{ heading: "", content: full, fullText: full }] : [];
  }
};

// ui/EditorPanel.tsx
var EditorPanel = ({ mode, selectedText, onSelectionChange, generatedText, onGeneratedChange, onCopy }) => {
  const selectedWords = TextChunker.getWordCount(selectedText || "");
  const selectedChars = (selectedText || "").length;
  const outputWords = TextChunker.getWordCount(generatedText || "");
  const outputChars = (generatedText || "").length;
  const selectedLabel = mode === "chapter" ? "Scene summary / directions:" : mode === "micro-edit" ? "Selected passage:" : mode === "character-update" ? "Selected text (for character update):" : "Draft to check:";
  const selectedPlaceholder = mode === "chapter" ? "Write a rough summary of the scene you want (beats, directions, key dialogue notes, etc.)..." : mode === "micro-edit" ? "Paste the passage you want revised..." : mode === "character-update" ? "Paste selected text here for character extraction..." : "Paste the draft you want checked for continuity...";
  return /* @__PURE__ */ import_react2.default.createElement("div", { className: "editor-panel" }, /* @__PURE__ */ import_react2.default.createElement("div", { className: "editor-section" }, /* @__PURE__ */ import_react2.default.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "baseline", gap: 12 } }, /* @__PURE__ */ import_react2.default.createElement("label", null, selectedLabel), /* @__PURE__ */ import_react2.default.createElement("span", { className: "generation-status", style: { margin: 0 } }, selectedWords.toLocaleString(), " words / ", selectedChars.toLocaleString(), " chars")), /* @__PURE__ */ import_react2.default.createElement(
    "textarea",
    {
      value: selectedText,
      onChange: (e) => onSelectionChange(e.target.value),
      placeholder: selectedPlaceholder,
      rows: 8,
      className: "editor-textarea"
    }
  )), generatedText && /* @__PURE__ */ import_react2.default.createElement("div", { className: "editor-section" }, /* @__PURE__ */ import_react2.default.createElement("div", { className: "generated-header" }, /* @__PURE__ */ import_react2.default.createElement("div", { style: { display: "flex", flexDirection: "column" } }, /* @__PURE__ */ import_react2.default.createElement("label", null, "Generated output:"), /* @__PURE__ */ import_react2.default.createElement("span", { className: "generation-status", style: { margin: 0 } }, outputWords.toLocaleString(), " words / ", outputChars.toLocaleString(), " chars")), /* @__PURE__ */ import_react2.default.createElement("button", { onClick: onCopy, className: "copy-button" }, "Copy to clipboard")), /* @__PURE__ */ import_react2.default.createElement(
    "textarea",
    {
      value: generatedText,
      readOnly: !onGeneratedChange,
      onChange: onGeneratedChange ? (e) => onGeneratedChange(e.target.value) : void 0,
      rows: 12,
      className: "generated-textarea"
    }
  )));
};

// ui/DirectorNotes.tsx
var import_react3 = __toESM(require_react());
var DirectorNotes = ({ value, onChange, mode, onResetToDefault }) => {
  const textareaRef = (0, import_react3.useRef)(null);
  const placeholder = mode === "chapter" ? "Enter your rewrite instructions..." : mode === "micro-edit" ? `[Example: Character 1 has no knowledge of Event 1 yet, so they should not reference it here. Edit accordingly.]

More examples:
- Fix continuity (injury, timeline, locations)
- Fix POV leaks
- Match tone/voice to the surrounding context
- Tighten pacing / remove repetition
- Preserve canon; do not add new facts` : "Enter extraction instructions (optional). If empty, the default in settings is used.";
  const wordCount = TextChunker.getWordCount(value || "");
  const charCount = (value || "").length;
  return /* @__PURE__ */ import_react3.default.createElement("div", { className: "director-notes" }, /* @__PURE__ */ import_react3.default.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "baseline", gap: 12 } }, /* @__PURE__ */ import_react3.default.createElement("label", null, mode === "chapter" ? "Rewrite instructions:" : mode === "micro-edit" ? "Grievances and directives:" : "Extraction instructions:"), /* @__PURE__ */ import_react3.default.createElement("div", { style: { display: "flex", gap: 12, alignItems: "center" } }, /* @__PURE__ */ import_react3.default.createElement("span", { className: "generation-status", style: { margin: 0 } }, wordCount.toLocaleString(), " words / ", charCount.toLocaleString(), " chars"), mode === "chapter" && onResetToDefault && /* @__PURE__ */ import_react3.default.createElement(
    "button",
    {
      type: "button",
      onClick: onResetToDefault,
      className: "copy-button"
    },
    "Reset to default"
  ))), /* @__PURE__ */ import_react3.default.createElement(
    "textarea",
    {
      ref: textareaRef,
      value,
      onChange: (e) => onChange(e.target.value),
      placeholder,
      rows: 6,
      disabled: false,
      className: "director-notes-textarea"
    }
  ));
};

// ui/ModeSelector.tsx
var import_react4 = __toESM(require_react());
var ModeSelector = ({ mode, onChange }) => {
  return /* @__PURE__ */ import_react4.default.createElement("div", { className: "mode-selector" }, /* @__PURE__ */ import_react4.default.createElement("label", null, "Mode:"), /* @__PURE__ */ import_react4.default.createElement(
    "select",
    {
      value: mode,
      onChange: (e) => onChange(e.target.value),
      className: "mode-dropdown"
    },
    /* @__PURE__ */ import_react4.default.createElement("option", { value: "chapter" }, "Generate chapter"),
    /* @__PURE__ */ import_react4.default.createElement("option", { value: "micro-edit" }, "Micro edit"),
    /* @__PURE__ */ import_react4.default.createElement("option", { value: "character-update" }, "Character update"),
    /* @__PURE__ */ import_react4.default.createElement("option", { value: "continuity-check" }, "Continuity check")
  ));
};

// services/ContentHash.ts
function fnv1a32(input) {
  let hash = 2166136261;
  for (let i = 0; i < input.length; i++) {
    hash ^= input.charCodeAt(i);
    hash = hash + ((hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24)) >>> 0;
  }
  return hash.toString(16).padStart(8, "0");
}

// services/TokenEstimate.ts
function estimateTokens(text2) {
  if (!text2)
    return 0;
  return Math.ceil(text2.length / 4);
}

// ui/FolderTreePickerModal.tsx
var import_obsidian = require("obsidian");
var import_react5 = __toESM(require_react());
var import_client = __toESM(require_client());
var FolderTreePickerModal = class extends import_obsidian.Modal {
  constructor(plugin, opts) {
    super(plugin.app);
    this.reactRoot = null;
    this.plugin = plugin;
    this.onPick = opts.onPick;
    this.currentPath = opts.currentPath;
    this.title = opts.title || "Select folder";
  }
  onOpen() {
    this.titleEl.setText(this.title);
    this.contentEl.empty();
    const container = this.contentEl.createDiv();
    this.reactRoot = (0, import_client.createRoot)(container);
    this.reactRoot.render(
      import_react5.default.createElement(FolderTreePickerComponent, {
        plugin: this.plugin,
        currentPath: this.currentPath,
        onPick: (path) => {
          void this.onPick(path);
          this.close();
        },
        onClose: () => this.close()
      })
    );
  }
  onClose() {
    if (this.reactRoot) {
      this.reactRoot.unmount();
      this.reactRoot = null;
    }
    this.contentEl.empty();
  }
};
var FolderTreePickerComponent = ({
  plugin,
  currentPath,
  onPick,
  onClose
}) => {
  const [structure, setStructure] = (0, import_react5.useState)([]);
  const [expandedFolders, setExpandedFolders] = (0, import_react5.useState)(/* @__PURE__ */ new Set([""]));
  const [newFolderName, setNewFolderName] = (0, import_react5.useState)("");
  const [newFolderParent, setNewFolderParent] = (0, import_react5.useState)("");
  const [showCreateForm, setShowCreateForm] = (0, import_react5.useState)(false);
  (0, import_react5.useEffect)(() => {
    const vaultStructure = plugin.vaultService.getVaultStructure();
    const foldersOnly = vaultStructure.filter((item) => item.type === "folder");
    setStructure(foldersOnly);
    const expanded = /* @__PURE__ */ new Set([""]);
    if (currentPath) {
      const parts = currentPath.split("/");
      for (let i = 1; i < parts.length; i++) {
        expanded.add(parts.slice(0, i).join("/"));
      }
    }
    setExpandedFolders(expanded);
  }, [currentPath, plugin]);
  const toggleFolder = (path) => {
    const newExpanded = new Set(expandedFolders);
    if (newExpanded.has(path)) {
      newExpanded.delete(path);
    } else {
      newExpanded.add(path);
    }
    setExpandedFolders(newExpanded);
  };
  const handleCreateFolder = async () => {
    if (!newFolderName.trim())
      return;
    const parentPath = newFolderParent || "";
    const fullPath = parentPath ? `${parentPath}/${newFolderName.trim()}` : newFolderName.trim();
    try {
      await plugin.vaultService.createFolderIfNotExists(fullPath);
      const vaultStructure = plugin.vaultService.getVaultStructure();
      const foldersOnly = vaultStructure.filter((item) => item.type === "folder");
      setStructure(foldersOnly);
      onPick(fullPath);
    } catch (error2) {
      console.error("Failed to create folder:", error2);
      alert(`Failed to create folder: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  };
  const renderItem = (item, depth = 0) => {
    if (item.type === "folder") {
      const isExpanded = expandedFolders.has(item.path);
      const isSelected = item.path === currentPath;
      const children = structure.filter(
        (s) => s.path.startsWith(item.path + "/") && s.path.split("/").length === item.path.split("/").length + 1
      );
      return /* @__PURE__ */ import_react5.default.createElement("div", { key: item.path, style: { paddingLeft: `${depth * 20}px` } }, /* @__PURE__ */ import_react5.default.createElement(
        "div",
        {
          style: {
            display: "flex",
            alignItems: "center",
            gap: "8px",
            padding: "4px 8px",
            borderRadius: "4px",
            cursor: "pointer",
            backgroundColor: isSelected ? "var(--background-modifier-hover)" : "transparent",
            userSelect: "none"
          },
          onClick: () => onPick(item.path),
          onMouseEnter: (e) => {
            if (!isSelected)
              e.currentTarget.style.backgroundColor = "var(--background-modifier-hover)";
          },
          onMouseLeave: (e) => {
            if (!isSelected)
              e.currentTarget.style.backgroundColor = "transparent";
          }
        },
        /* @__PURE__ */ import_react5.default.createElement(
          "span",
          {
            onClick: (e) => {
              e.stopPropagation();
              toggleFolder(item.path);
            },
            style: { cursor: "pointer" }
          },
          isExpanded ? "\u{1F4C2}" : "\u{1F4C1}"
        ),
        /* @__PURE__ */ import_react5.default.createElement("span", { style: { flex: 1 } }, item.name),
        isSelected && /* @__PURE__ */ import_react5.default.createElement("span", { style: { color: "var(--text-accent)" } }, "\u2713"),
        /* @__PURE__ */ import_react5.default.createElement(
          "button",
          {
            onClick: (e) => {
              e.stopPropagation();
              setNewFolderParent(item.path);
              setShowCreateForm(true);
            },
            style: {
              padding: "2px 6px",
              fontSize: "11px",
              border: "1px solid var(--background-modifier-border)",
              borderRadius: "3px",
              background: "var(--background-secondary)",
              cursor: "pointer"
            },
            title: "Create subfolder here"
          },
          "+"
        )
      ), isExpanded && children.map((child) => renderItem(child, depth + 1)));
    }
    return null;
  };
  const rootItems = structure.filter((item) => !item.path.includes("/"));
  return /* @__PURE__ */ import_react5.default.createElement("div", { className: "folder-tree-picker", style: { padding: "12px", maxHeight: "60vh", overflowY: "auto" } }, /* @__PURE__ */ import_react5.default.createElement("div", { className: "vault-tree", style: { marginBottom: "12px" } }, rootItems.length === 0 ? /* @__PURE__ */ import_react5.default.createElement("div", { style: { padding: "12px", color: "var(--text-muted)" } }, "No folders found in vault") : rootItems.map((item) => renderItem(item))), showCreateForm && /* @__PURE__ */ import_react5.default.createElement("div", { style: {
    padding: "12px",
    border: "1px solid var(--background-modifier-border)",
    borderRadius: "4px",
    marginTop: "12px",
    backgroundColor: "var(--background-secondary)"
  } }, /* @__PURE__ */ import_react5.default.createElement("div", { style: { marginBottom: "8px", fontWeight: 600 } }, "Create new folder"), /* @__PURE__ */ import_react5.default.createElement("div", { style: { marginBottom: "8px", fontSize: "12px", color: "var(--text-muted)" } }, newFolderParent ? `Inside: ${newFolderParent}` : "At root level"), /* @__PURE__ */ import_react5.default.createElement(
    "input",
    {
      type: "text",
      value: newFolderName,
      onChange: (e) => setNewFolderName(e.target.value),
      placeholder: "Folder name",
      style: {
        width: "100%",
        padding: "6px",
        marginBottom: "8px",
        border: "1px solid var(--background-modifier-border)",
        borderRadius: "4px",
        background: "var(--background-primary)",
        color: "var(--text-normal)"
      },
      onKeyDown: (e) => {
        if (e.key === "Enter") {
          handleCreateFolder();
        } else if (e.key === "Escape") {
          setShowCreateForm(false);
          setNewFolderName("");
          setNewFolderParent("");
        }
      },
      autoFocus: true
    }
  ), /* @__PURE__ */ import_react5.default.createElement("div", { style: { display: "flex", gap: "8px", justifyContent: "flex-end" } }, /* @__PURE__ */ import_react5.default.createElement(
    "button",
    {
      onClick: () => {
        setShowCreateForm(false);
        setNewFolderName("");
        setNewFolderParent("");
      },
      style: {
        padding: "4px 12px",
        border: "1px solid var(--background-modifier-border)",
        borderRadius: "4px",
        background: "var(--background-secondary)",
        cursor: "pointer"
      }
    },
    "Cancel"
  ), /* @__PURE__ */ import_react5.default.createElement(
    "button",
    {
      onClick: handleCreateFolder,
      disabled: !newFolderName.trim(),
      style: {
        padding: "4px 12px",
        border: "none",
        borderRadius: "4px",
        background: "var(--interactive-accent)",
        color: "var(--text-on-accent)",
        cursor: newFolderName.trim() ? "pointer" : "not-allowed",
        opacity: newFolderName.trim() ? 1 : 0.5
      }
    },
    "Create"
  ))), !showCreateForm && /* @__PURE__ */ import_react5.default.createElement(
    "button",
    {
      onClick: () => {
        setNewFolderParent("");
        setShowCreateForm(true);
      },
      style: {
        width: "100%",
        padding: "8px",
        marginTop: "12px",
        border: "1px solid var(--background-modifier-border)",
        borderRadius: "4px",
        background: "var(--background-secondary)",
        cursor: "pointer",
        fontWeight: 500
      }
    },
    "+ Create new folder at root"
  ));
};

// ui/FileTreePickerModal.tsx
var import_obsidian2 = require("obsidian");
var import_react6 = __toESM(require_react());
var import_client2 = __toESM(require_client());
var FileTreePickerModal = class extends import_obsidian2.Modal {
  constructor(plugin, opts) {
    super(plugin.app);
    this.reactRoot = null;
    this.plugin = plugin;
    this.onPick = opts.onPick;
    this.currentPath = opts.currentPath;
    this.title = opts.title || "Select file";
  }
  onOpen() {
    this.titleEl.setText(this.title);
    this.contentEl.empty();
    const container = this.contentEl.createDiv();
    this.reactRoot = (0, import_client2.createRoot)(container);
    this.reactRoot.render(
      import_react6.default.createElement(FileTreePickerComponent, {
        plugin: this.plugin,
        currentPath: this.currentPath,
        onPick: (path) => {
          void this.onPick(path);
          this.close();
        },
        onClose: () => this.close()
      })
    );
  }
  onClose() {
    if (this.reactRoot) {
      this.reactRoot.unmount();
      this.reactRoot = null;
    }
    this.contentEl.empty();
  }
};
var FileTreePickerComponent = ({ plugin, currentPath, onPick, onClose }) => {
  const [structure, setStructure] = (0, import_react6.useState)([]);
  const [expandedFolders, setExpandedFolders] = (0, import_react6.useState)(/* @__PURE__ */ new Set([""]));
  (0, import_react6.useEffect)(() => {
    const vaultStructure = plugin.vaultService.getVaultStructure();
    const filtered = vaultStructure.filter(
      (item) => item.type === "folder" || item.type === "file" && item.path.endsWith(".md")
    );
    setStructure(filtered);
    const expanded = /* @__PURE__ */ new Set([""]);
    if (currentPath) {
      const parts = currentPath.split("/");
      for (let i = 1; i < parts.length; i++) {
        expanded.add(parts.slice(0, i).join("/"));
      }
    }
    setExpandedFolders(expanded);
  }, [currentPath, plugin]);
  const toggleFolder = (path) => {
    const newExpanded = new Set(expandedFolders);
    if (newExpanded.has(path)) {
      newExpanded.delete(path);
    } else {
      newExpanded.add(path);
    }
    setExpandedFolders(newExpanded);
  };
  const renderItem = (item, depth = 0) => {
    if (item.type === "folder") {
      const isExpanded = expandedFolders.has(item.path);
      const children = structure.filter(
        (s) => s.path.startsWith(item.path + "/") && s.path.split("/").length === item.path.split("/").length + 1
      );
      if (children.length === 0)
        return null;
      return /* @__PURE__ */ import_react6.default.createElement("div", { key: item.path, className: "vault-item folder", style: { paddingLeft: `${depth * 20}px` } }, /* @__PURE__ */ import_react6.default.createElement(
        "span",
        {
          className: "folder-toggle",
          onClick: () => toggleFolder(item.path),
          style: { cursor: "pointer", userSelect: "none" }
        },
        isExpanded ? "\u{1F4C2}" : "\u{1F4C1}",
        " ",
        item.name
      ), isExpanded && children.map((child) => renderItem(child, depth + 1)));
    } else {
      const isSelected = item.path === currentPath;
      return /* @__PURE__ */ import_react6.default.createElement(
        "div",
        {
          key: item.path,
          className: `vault-item file ${isSelected ? "selected" : "hoverable"}`,
          style: {
            paddingLeft: `${depth * 20}px`,
            cursor: "pointer",
            padding: "4px 8px",
            borderRadius: "4px"
          },
          onClick: () => onPick(item.path)
        },
        "\u{1F4C4} ",
        item.name,
        isSelected && /* @__PURE__ */ import_react6.default.createElement("span", { style: { marginLeft: "8px", color: "var(--text-accent)" } }, "\u2713")
      );
    }
  };
  const rootItems = structure.filter((item) => !item.path.includes("/"));
  return /* @__PURE__ */ import_react6.default.createElement("div", { className: "file-tree-picker", style: { padding: "12px", maxHeight: "60vh", overflowY: "auto" } }, /* @__PURE__ */ import_react6.default.createElement("div", { className: "vault-tree" }, rootItems.length === 0 ? /* @__PURE__ */ import_react6.default.createElement("div", { style: { padding: "12px", color: "var(--text-muted)" } }, "No markdown files found in vault") : rootItems.map((item) => renderItem(item))));
};

// services/CharacterRoster.ts
function normalizeName(name2) {
  return name2.trim().replace(/\s+/g, " ");
}
function parseCharacterRoster(text2) {
  const raw = (text2 || "").trim();
  if (!raw)
    return [];
  const entries = [];
  const lines = raw.split(/\r?\n/).map((l) => l.trim()).filter(Boolean);
  for (const line of lines) {
    const cleaned = line.replace(/^[-*]\s+/, "").replace(/^\d+[.)\]]\s+/, "").trim();
    if (!cleaned)
      continue;
    const [left, right] = cleaned.split(/\s*\|\s*/);
    const namePart = normalizeName(left || "");
    if (!namePart)
      continue;
    const entry = { name: namePart };
    if (right) {
      const m = right.match(/aliases?\s*:\s*(.+)$/i);
      if (m?.[1]) {
        const aliases = m[1].split(",").map((a) => normalizeName(a)).filter(Boolean);
        if (aliases.length)
          entry.aliases = aliases;
      }
    }
    entries.push(entry);
  }
  if (entries.length === 0 && raw.includes(",")) {
    for (const part of raw.split(",").map((p) => normalizeName(p)).filter(Boolean)) {
      entries.push({ name: part });
    }
  }
  const byLower = /* @__PURE__ */ new Map();
  for (const e of entries) {
    const key = e.name.toLowerCase();
    const existing = byLower.get(key);
    if (!existing) {
      byLower.set(key, e);
    } else {
      const merged = new Set([...existing.aliases || [], ...e.aliases || []].map((a) => a));
      existing.aliases = merged.size ? Array.from(merged) : existing.aliases;
    }
  }
  return Array.from(byLower.values());
}
function rosterToBulletList(roster) {
  if (!roster.length)
    return "[No roster]";
  return roster.map((r) => `- ${r.name}${r.aliases?.length ? ` | aliases: ${r.aliases.join(", ")}` : ""}`).join("\n");
}

// ui/ConfirmModal.ts
var import_obsidian3 = require("obsidian");
function showConfirmModal(app, opts) {
  return new Promise((resolve) => {
    let settled = false;
    const settle = (value) => {
      if (settled)
        return;
      settled = true;
      resolve(value);
    };
    const modal = new class extends import_obsidian3.Modal {
      onOpen() {
        this.titleEl.setText(opts.title);
        this.contentEl.createEl("p", { text: opts.message });
        new import_obsidian3.Setting(this.contentEl).addButton((btn) => {
          btn.setButtonText(opts.cancelText ?? "Cancel");
          btn.onClick(() => {
            settle(false);
            this.close();
          });
        }).addButton((btn) => {
          btn.setCta();
          btn.setButtonText(opts.confirmText ?? "Continue");
          btn.onClick(() => {
            settle(true);
            this.close();
          });
        });
      }
      onClose() {
        settle(false);
        this.contentEl.empty();
      }
    }(app);
    modal.open();
  });
}

// ui/PromptPreviewModal.ts
var import_obsidian4 = require("obsidian");
var PromptPreviewModal = class extends import_obsidian4.Modal {
  constructor(app, opts) {
    super(app);
    this.opts = opts;
  }
  onOpen() {
    this.titleEl.setText(this.opts.title);
    this.contentEl.empty();
    if (this.opts.stats?.length) {
      for (const s of this.opts.stats) {
        new import_obsidian4.Setting(this.contentEl).setName(s.label).setDesc(s.value);
      }
    }
    const textarea = this.contentEl.createEl("textarea");
    textarea.value = this.opts.prompt || "";
    textarea.readOnly = true;
    textarea.rows = 18;
    textarea.addClass("generated-textarea");
    new import_obsidian4.Setting(this.contentEl).addButton((btn) => {
      btn.setButtonText("Copy");
      btn.setCta();
      btn.onClick(() => {
        void navigator.clipboard.writeText(textarea.value).catch(() => {
        });
      });
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// ui/ButtonHelpModal.tsx
var import_obsidian5 = require("obsidian");
var import_react7 = __toESM(require_react());
var import_client3 = __toESM(require_client());
var WORKFLOWS = {
  "Content Generation": [
    {
      buttonLabel: "Generate chapter",
      mode: ["chapter"],
      workflow: [
        "Write your Scene Summary / Directions",
        "Set target word range (Min \u2192 Max)",
        "Optional: Review/edit Rewrite Instructions",
        'Click "Generate chapter"',
        "Review output and copy to your manuscript"
      ]
    },
    {
      buttonLabel: "Generate edit",
      mode: ["micro-edit"],
      workflow: [
        'Paste problematic passage in "Selected Text"',
        "Enter grievances/directives in the textarea",
        'Click "Generate edit"',
        "Copy the refined alternative into your manuscript"
      ]
    },
    {
      buttonLabel: "Run continuity check",
      mode: ["continuity-check"],
      workflow: [
        "Paste draft text to check (or use last generated output)",
        "Optional: Adjust focus toggles (Knowledge, Timeline, POV, Naming)",
        'Click "Run continuity check"',
        "Review violations report with suggested patches"
      ]
    }
  ],
  "Character Management": [
    {
      buttonLabel: "Update characters",
      mode: ["character-update"],
      workflow: [
        'Paste character-relevant text in "Selected Text" field',
        'Click "Update characters"',
        "Character notes are automatically updated with timestamped entries in the Characters/ folder"
      ]
    },
    {
      buttonLabel: "Select file to process",
      mode: ["character-update"],
      workflow: [
        "Click to open file tree picker",
        "Select a manuscript file for bulk character extraction",
        'Selected file will be used by "Process entire book" button'
      ]
    },
    {
      buttonLabel: "Use book main path",
      mode: ["character-update"],
      workflow: [
        "Resets the source file back to your main book file (configured in settings)",
        "Useful when you want to switch from a custom file back to the default"
      ]
    },
    {
      buttonLabel: "Process entire book",
      mode: ["character-update"],
      workflow: [
        'Optional: Select custom file with "Select file to process"',
        "Click to perform 2-pass scan (roster + per-chapter extraction)",
        "Character notes updated from entire manuscript automatically"
      ]
    },
    {
      buttonLabel: "Chunk current note",
      mode: ["character-update"],
      workflow: [
        "Select a file to process first",
        "Click to chunk it into smaller sections for processing"
      ]
    }
  ],
  "Story Bible": [
    {
      buttonLabel: "Update story bible",
      mode: ["chapter"],
      workflow: [
        "Write or generate a chapter",
        'Click "Update story bible" to extract updates from the text',
        "Review the merged output in the generated text area",
        'Use "Save merged story bible" or "Replace story bible" to save'
      ]
    },
    {
      buttonLabel: "Save merged story bible",
      mode: ["chapter"],
      workflow: [
        "After updating story bible, review the merged output",
        "Click to save as a new versioned file in Story bibles/ folder",
        'File will be named "Story bible - YYYY-MM-DD.md"'
      ]
    },
    {
      buttonLabel: "Replace story bible",
      mode: ["chapter"],
      workflow: [
        "After updating story bible, review the merged output",
        "Click to save new version and automatically update the active story bible path in settings"
      ]
    }
  ],
  "Utilities": [
    {
      buttonLabel: "Export to epub",
      workflow: [
        "Click to open export wizard",
        "Step 1: Select source (book main file or TOC note)",
        "Step 2: Enter metadata (title, author, language, subtitle)",
        "Step 3: Configure front matter (title page, copyright page, license)",
        "Step 4: Choose typography and optional font embedding",
        "Step 5: Select output folder and file name",
        "Step 6: Click export to generate EPUB, DOCX, RTF, or plain text"
      ]
    },
    {
      buttonLabel: "Preview prompt",
      workflow: [
        "Configure all inputs (scene summary, selected text, etc.)",
        "Click to preview the full prompt that will be sent to AI",
        "Review token estimates and retrieved context summary",
        "Useful for debugging or understanding what context the AI sees"
      ]
    }
  ]
};
var ButtonHelpModalComponent = ({ onClose }) => {
  const [expandedCategory, setExpandedCategory] = (0, import_react7.useState)(null);
  const toggleCategory = (category) => {
    setExpandedCategory(expandedCategory === category ? null : category);
  };
  return /* @__PURE__ */ import_react7.default.createElement("div", { style: { padding: "20px", maxHeight: "70vh", overflowY: "auto" } }, /* @__PURE__ */ import_react7.default.createElement("h2", { style: { marginTop: 0 } }, "Button Workflows"), /* @__PURE__ */ import_react7.default.createElement("p", { style: { color: "var(--text-muted)", fontSize: "14px", marginBottom: "20px" } }, "Click on a category to expand and see detailed workflows for each button."), Object.entries(WORKFLOWS).map(([category, items]) => /* @__PURE__ */ import_react7.default.createElement("div", { key: category, style: { marginBottom: "16px" } }, /* @__PURE__ */ import_react7.default.createElement(
    "button",
    {
      onClick: () => toggleCategory(category),
      style: {
        width: "100%",
        textAlign: "left",
        padding: "12px",
        background: "var(--background-secondary)",
        border: "1px solid var(--background-modifier-border)",
        borderRadius: "4px",
        cursor: "pointer",
        fontSize: "16px",
        fontWeight: 600,
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center"
      }
    },
    /* @__PURE__ */ import_react7.default.createElement("span", null, category),
    /* @__PURE__ */ import_react7.default.createElement("span", null, expandedCategory === category ? "\u2212" : "+")
  ), expandedCategory === category && /* @__PURE__ */ import_react7.default.createElement("div", { style: { marginTop: "8px", paddingLeft: "12px" } }, items.map((item, index) => /* @__PURE__ */ import_react7.default.createElement(
    "div",
    {
      key: index,
      style: {
        marginBottom: "20px",
        padding: "12px",
        background: "var(--background-primary)",
        border: "1px solid var(--background-modifier-border)",
        borderRadius: "4px"
      }
    },
    /* @__PURE__ */ import_react7.default.createElement(
      "h3",
      {
        style: {
          margin: "0 0 8px 0",
          fontSize: "14px",
          fontWeight: 600,
          color: "var(--text-accent)"
        }
      },
      item.buttonLabel
    ),
    item.mode && /* @__PURE__ */ import_react7.default.createElement(
      "div",
      {
        style: {
          fontSize: "12px",
          color: "var(--text-muted)",
          marginBottom: "8px",
          fontStyle: "italic"
        }
      },
      "Available in: ",
      item.mode.join(", "),
      " mode"
    ),
    /* @__PURE__ */ import_react7.default.createElement("ol", { style: { margin: 0, paddingLeft: "20px" } }, item.workflow.map((step, stepIndex) => /* @__PURE__ */ import_react7.default.createElement("li", { key: stepIndex, style: { marginBottom: "4px", fontSize: "13px" } }, step)))
  ))))));
};
var ButtonHelpModal = class extends import_obsidian5.Modal {
  constructor() {
    super(...arguments);
    this.reactRoot = null;
  }
  onOpen() {
    this.titleEl.setText("Button Workflows & Usage Guide");
    this.contentEl.empty();
    const container = this.contentEl.createDiv();
    this.reactRoot = (0, import_client3.createRoot)(container);
    this.reactRoot.render(import_react7.default.createElement(ButtonHelpModalComponent, { onClose: () => this.close() }));
  }
  onClose() {
    if (this.reactRoot) {
      this.reactRoot.unmount();
      this.reactRoot = null;
    }
    this.contentEl.empty();
  }
};

// ui/DashboardComponent.tsx
var DEFAULT_REWRITE_INSTRUCTIONS = "[INSTRUCTION: The Scene Summary is a rough summary OR directions. Rewrite it into a fully detailed dramatic scene. Include dialogue, sensory details, and action. Do not summarize; write the prose. Match the tone, rhythm, and pacing of the provided context.]";
var getButtonTooltip = (buttonId, mode) => {
  const workflows = {
    "export-epub": {
      "": "Workflow: 1) Click to open export wizard, 2) Select source (book main or TOC), 3) Enter metadata, 4) Configure front matter, 5) Choose typography, 6) Select output folder and export"
    },
    "preview-prompt": {
      "": "Workflow: 1) Configure all inputs (scene summary, selected text, etc.), 2) Click to preview the full prompt that will be sent to AI, 3) Review token estimates and retrieved context"
    },
    "generate-chapter": {
      "chapter": "Workflow: 1) Write Scene Summary / Directions, 2) Set target word range (Min \u2192 Max), 3) Optional: Review/edit Rewrite Instructions, 4) Click to generate, 5) Review output and copy to manuscript"
    },
    "generate-edit": {
      "micro-edit": 'Workflow: 1) Paste problematic passage in "Selected Text", 2) Enter grievances/directives, 3) Click to generate refined alternative, 4) Copy the result into your manuscript'
    },
    "run-continuity-check": {
      "continuity-check": "Workflow: 1) Paste draft text to check (or use last generated output), 2) Optional: Adjust focus toggles (Knowledge, Timeline, POV, Naming), 3) Click to run check, 4) Review violations report with suggested patches"
    },
    "update-characters": {
      "character-update": 'Workflow: 1) Paste character-relevant text in "Selected Text" field, 2) Click to automatically update character notes with timestamped entries in the Characters/ folder'
    },
    "select-file-process": {
      "character-update": 'Workflow: 1) Click to select a manuscript file for bulk character extraction, 2) Selected file will be used by "Process entire book" button'
    },
    "use-book-main-path": {
      "character-update": "Workflow: Resets the source file back to your main book file (configured in settings) for character extraction"
    },
    "process-entire-book": {
      "character-update": 'Workflow: 1) Optional: Select custom file with "Select file to process", 2) Click to perform 2-pass scan (roster + per-chapter extraction), 3) Character notes updated from entire manuscript'
    },
    "chunk-current-note": {
      "character-update": "Workflow: 1) Select a file to process, 2) Click to chunk it into smaller sections for processing"
    },
    "update-story-bible": {
      "chapter": "Workflow: 1) Write or generate a chapter, 2) Click to extract story bible updates from the text, 3) Review merged output, 4) Save as new version or replace existing story bible"
    },
    "save-merged-story-bible": {
      "chapter": "Workflow: After updating story bible, click to save merged output as a new versioned file in Story bibles/ folder"
    },
    "replace-story-bible": {
      "chapter": "Workflow: After updating story bible, click to save new version and automatically update the active story bible path in settings"
    }
  };
  const modeKey = mode || "";
  return workflows[buttonId]?.[modeKey] || workflows[buttonId]?.[""] || "";
};
var DashboardComponent = ({ plugin }) => {
  const formatUnknownForUi = (value) => {
    if (value instanceof Error)
      return value.message;
    if (typeof value === "string")
      return value;
    if (typeof value === "number" || typeof value === "boolean")
      return value.toString();
    if (typeof value === "bigint")
      return "bigint";
    if (value === null)
      return "null";
    if (value === void 0)
      return "undefined";
    try {
      return JSON.stringify(value);
    } catch {
      return "[unserializable value]";
    }
  };
  const [mode, setMode] = (0, import_react8.useState)("chapter");
  const [demoStep, setDemoStep] = (0, import_react8.useState)("off");
  const [apiKeyPresent, setApiKeyPresent] = (0, import_react8.useState)(Boolean(plugin.settings.apiKey));
  const [demoStepCompleted, setDemoStepCompleted] = (0, import_react8.useState)({
    chapter: false,
    "micro-edit": false,
    "character-update": false,
    done: false
  });
  const [isVaultPanelCollapsed, setIsVaultPanelCollapsed] = (0, import_react8.useState)(() => {
    try {
      return window.localStorage.getItem("writing-dashboard:vaultPanelCollapsed") === "1";
    } catch {
      return false;
    }
  });
  const [modeState, setModeState] = (0, import_react8.useState)(() => plugin.settings.modeState);
  const [storyBibleDelta, setStoryBibleDelta] = (0, import_react8.useState)("");
  const warmTimerRef = (0, import_react8.useRef)(null);
  const warmReqIdRef = (0, import_react8.useRef)(0);
  const modeStateSaveTimerRef = (0, import_react8.useRef)(null);
  const [minWordsInput, setMinWordsInput] = (0, import_react8.useState)(String(plugin.settings.modeState.chapter.minWords ?? 2e3));
  const [maxWordsInput, setMaxWordsInput] = (0, import_react8.useState)(String(plugin.settings.modeState.chapter.maxWords ?? 6e3));
  const [generatedText, setGeneratedText] = (0, import_react8.useState)("");
  const [isGenerating, setIsGenerating] = (0, import_react8.useState)(false);
  const [generationStage, setGenerationStage] = (0, import_react8.useState)("");
  const [error2, setError] = (0, import_react8.useState)(null);
  const [promptTokenEstimate, setPromptTokenEstimate] = (0, import_react8.useState)(null);
  const [promptCharCount, setPromptCharCount] = (0, import_react8.useState)(null);
  const [retrievedContextStats, setRetrievedContextStats] = (0, import_react8.useState)(null);
  const [indexStatusText, setIndexStatusText] = (0, import_react8.useState)(() => {
    if (!plugin.settings.retrievalEnableSemanticIndex)
      return "Semantic retrieval: Off";
    const status = plugin.embeddingsIndex?.getStatus?.();
    if (!status)
      return "Semantic retrieval: Starting\u2026";
    if (status.paused)
      return `Index: Paused (${status.indexedFiles} file(s), ${status.indexedChunks} chunk(s))`;
    if (status.queued > 0)
      return `Index: Building (${status.queued} queued, ${status.indexedChunks} chunk(s))`;
    return `Index: Up to date (${status.indexedFiles} file(s), ${status.indexedChunks} chunk(s))`;
  });
  const [bulkSourcePath, setBulkSourcePath] = (0, import_react8.useState)(
    plugin.settings.characterExtractionSourcePath
  );
  const getMainInputValue = () => {
    if (mode === "chapter")
      return modeState.chapter.sceneSummary || "";
    if (mode === "micro-edit")
      return modeState.microEdit.selectedPassage || "";
    if (mode === "character-update")
      return modeState.characterUpdate.selectedText || "";
    return modeState.continuityCheck.draftText || "";
  };
  const getNotesValue = () => {
    if (mode === "chapter")
      return modeState.chapter.rewriteInstructions || "";
    if (mode === "micro-edit")
      return modeState.microEdit.grievances || "";
    if (mode === "character-update")
      return modeState.characterUpdate.extractionInstructions || "";
    return "";
  };
  const scheduleModeStateSave = (next) => {
    if (modeStateSaveTimerRef.current)
      window.clearTimeout(modeStateSaveTimerRef.current);
    modeStateSaveTimerRef.current = window.setTimeout(() => {
      modeStateSaveTimerRef.current = null;
      plugin.settings.modeState = next;
      void plugin.saveSettings().catch(() => {
      });
    }, 350);
  };
  const updateMainInput = (value) => {
    setModeState((prev) => {
      const next = mode === "chapter" ? { ...prev, chapter: { ...prev.chapter, sceneSummary: value } } : mode === "micro-edit" ? { ...prev, microEdit: { ...prev.microEdit, selectedPassage: value } } : mode === "character-update" ? { ...prev, characterUpdate: { ...prev.characterUpdate, selectedText: value } } : { ...prev, continuityCheck: { ...prev.continuityCheck, draftText: value } };
      scheduleModeStateSave(next);
      return next;
    });
  };
  const updateNotes = (value) => {
    setModeState((prev) => {
      const next = mode === "chapter" ? { ...prev, chapter: { ...prev.chapter, rewriteInstructions: value } } : mode === "micro-edit" ? { ...prev, microEdit: { ...prev.microEdit, grievances: value } } : { ...prev, characterUpdate: { ...prev.characterUpdate, extractionInstructions: value } };
      scheduleModeStateSave(next);
      return next;
    });
  };
  const DEMO_FOLDER = "Writing dashboard demo";
  const DEMO_CHARACTER_FOLDER = `${DEMO_FOLDER}/Characters`;
  const DEMO_CHAPTER_OUTPUT = `Ava kept to the seam of shadow where the alley met the service corridor, the city\u2019s night noise dulled by concrete and distance. The corporate tower rose above her like a blackened ribcage, windows lit in irregular bands as though the building itself was breathing.

Marcus slid in beside her with the careless ease of someone who\u2019d never been caught. He smelled faintly of rain and cheap coffee. \u201CWe\u2019re late,\u201D he whispered.

\u201CWe\u2019re early,\u201D Ava corrected. She watched the security camera complete its slow pan, then pause, then pan again. The rhythm mattered. Everything did. \u201CIf we rush, we miss the blind spot.\u201D

Marcus\u2019s mouth twitched. \u201COr we miss the keycard walking right past us. I told you. We grab it off the intern. Quick, clean.\u201D

Ava flexed her gloved fingers around the thin coil of line in her pocket. She didn\u2019t look at him. \u201CAnd then what? You sprint down a hallway with a tower full of sensors tracking your heartbeat?\u201D

\u201CI\u2019ve sprinted through worse.\u201D

\u201CYou\u2019ve survived worse,\u201D Ava said, \u201Cbecause you got lucky.\u201D

The corridor door ahead had a keypad and a reader. The stolen card would open it. Her stolen card. A small rectangle of plastic that held too much: access to archives, to names, to proof. She could feel it like a phantom weight in her palm.

Footsteps approached\u2014soft, measured. Ava drew Marcus back with two fingers to his sleeve. They pressed into the alcove as a security guard passed, head tilted toward the earpiece wire threaded behind his ear.

\u201CRotation\u2019s off,\u201D Marcus breathed once the guard was gone. \u201CThey\u2019re nervous.\u201D

Ava\u2019s gaze snagged on a faint glimmer near the reader: a strip of reflective tape, almost invisible. A marker. Not theirs. She swallowed. \u201CSomeone\u2019s already here.\u201D

Marcus leaned closer. \u201COr someone was.\u201D

Ava\u2019s heart kicked once, hard. She lifted her hand to the keypad\u2014then froze. Behind the tinted glass of the corridor door, a phone screen lit for a second and went dark.

A message, no sender, no notification sound.

JUST THIS: \u201CAVA, DON\u2019T.\u201D`;
  const DEMO_MICRO_EDIT_OUTPUT = `Ava kept to the seam of shadow where the alley met the service corridor, tracking the camera\u2019s sweep like a metronome. Pan. Pause. Pan. The blind spot lived in the pause.

Marcus drifted in beside her, too relaxed for a man who should\u2019ve been afraid. \u201CWe\u2019re late,\u201D he whispered.

\u201CWe\u2019re early,\u201D Ava said. She didn\u2019t take her eyes off the lens. \u201CEarly keeps you alive.\u201D

His breath hitched into something like a laugh. \u201COr it keeps you standing here while the keycard walks away.\u201D

Ava\u2019s fingers tightened around the coil of line in her pocket. \u201CWe do this my way. Quiet. Controlled. No hero runs.\u201D

\u201CI\u2019m not a hero,\u201D Marcus murmured. \u201CI\u2019m just fast.\u201D

\u201CFast gets noticed.\u201D Ava waited for the lens to turn, then moved\u2014one step, two\u2014into the thin slice of safety.

The corridor door waited with its keypad and reader, the place her stolen card would\u2019ve belonged. A small piece of plastic that could unlock a vault of truths.

Footsteps approached. Ava snagged Marcus by his sleeve and pulled him into the alcove. A security guard passed, eyes forward, earwire gleaming.

When the sound faded, Marcus leaned in. \u201CRotation\u2019s off,\u201D he said. \u201CThey\u2019re spooked.\u201D

Ava stared at the reader and felt cold spread under her ribs. A sliver of reflective tape\u2014too neat, too deliberate\u2014clung near the sensor. Not theirs.

\u201CSomeone\u2019s already here,\u201D she whispered.

Marcus\u2019s voice dropped. \u201COr someone was.\u201D`;
  const DEMO_CONTINUITY_OUTPUT = `## Continuity report
- Severity: Medium
- Issue: Naming consistency
- Evidence (draft): "Dr. Priya Armintastani"
- Evidence (canon/context): "Priya Armintastani" (character note)
- Suggested fix: Use one canonical name consistently.

## Suggested patches (optional)
- Replace "Dr. Priya Armintastani" with "Priya Armintastani" if that matches canon.
`;
  const DEMO_CHARACTER_EXTRACTION_OUTPUT = `## Ava
- Highly cautious and methodical; tracks security camera rhythm and uses timing to avoid detection.
- Motivated by retrieving a stolen keycard tied to access, proof, and high-stakes information.
- Emotionally controlled under pressure; shows fear as tight focus rather than panic.
- Prioritizes stealth and control over speed; distrusts \u201Cluck\u201D as a strategy.

## Marcus
- Pushes for riskier, faster action; prefers direct moves over careful planning.
- Confident and calm in danger; downplays fear and frames risk as survivable.
- Tension with Ava: he challenges her caution; she asserts leadership and constraints.
`;
  const openPluginSettings = () => {
    const setting = plugin.app.setting;
    try {
      setting?.open?.();
      setting?.openTabById?.("writing-dashboard");
    } catch {
      new import_obsidian6.Notice("Open settings \u2192 writing dashboard to configure your API key.");
    }
  };
  const handlePreviewPrompt = async () => {
    if (!plugin.settings.apiKey && !isGuidedDemoActive) {
    }
    setIsGenerating(true);
    setError(null);
    setGenerationStage("Building prompt preview...");
    try {
      let prompt = "";
      let context;
      const mainInput = getMainInputValue();
      const notes = getNotesValue();
      if (mode === "chapter") {
        const retrievalQuery = plugin.queryBuilder.build({
          mode: "chapter",
          activeFilePath: plugin.lastOpenedMarkdownPath ?? plugin.settings.book2Path,
          primaryText: mainInput,
          directorNotes: notes
        });
        context = await plugin.contextAggregator.getChapterContext(retrievalQuery);
        const minCfg = modeState.chapter.minWords ?? 2e3;
        const maxCfg = modeState.chapter.maxWords ?? 6e3;
        const min = Math.max(100, Math.min(minCfg, maxCfg));
        const max = Math.max(100, Math.max(minCfg, maxCfg));
        prompt = plugin.promptEngine.buildChapterPrompt(context, notes, mainInput, min, max);
      } else if (mode === "micro-edit") {
        const retrievalQuery = plugin.queryBuilder.build({
          mode: "micro-edit",
          activeFilePath: plugin.lastOpenedMarkdownPath ?? plugin.settings.book2Path,
          primaryText: mainInput,
          directorNotes: notes
        });
        context = await plugin.contextAggregator.getMicroEditContext(mainInput, retrievalQuery);
        prompt = plugin.promptEngine.buildMicroEditPrompt(mainInput, notes, context);
      } else if (mode === "continuity-check") {
        const retrievalQuery = plugin.queryBuilder.build({
          mode: "continuity-check",
          activeFilePath: plugin.lastOpenedMarkdownPath ?? plugin.settings.book2Path,
          primaryText: mainInput,
          directorNotes: ""
        });
        context = await plugin.contextAggregator.getMicroEditContext(mainInput, retrievalQuery);
        prompt = plugin.promptEngine.buildContinuityCheckPrompt({
          draft: mainInput,
          context,
          focus: modeState.continuityCheck.focus
        });
      } else {
        const characterNotes = await plugin.contextAggregator.getCharacterNotes();
        const storyBible = await plugin.contextAggregator.readFile(plugin.settings.storyBiblePath);
        const instructions = (modeState.characterUpdate.extractionInstructions || "").trim();
        prompt = plugin.promptEngine.buildCharacterExtractionPrompt(
          mainInput,
          characterNotes,
          storyBible,
          instructions,
          ""
        );
      }
      const tokens = estimateTokens(prompt);
      new PromptPreviewModal(plugin.app, {
        title: "Prompt preview",
        prompt,
        stats: [
          { label: "Estimated tokens", value: tokens.toLocaleString() },
          { label: "Characters", value: prompt.length.toLocaleString() }
        ]
      }).open();
    } catch (err) {
      const message = formatUnknownForUi(err);
      setError(message || "Prompt preview failed");
    } finally {
      setGenerationStage("");
      setIsGenerating(false);
    }
  };
  const openPublishWizard = () => {
    try {
      plugin.showPublishWizard();
    } catch {
      new import_obsidian6.Notice("Unable to open the publishing wizard.");
    }
  };
  const isGuidedDemoActive = demoStep !== "off" && demoStep !== "done";
  const canUseAiInDemo = apiKeyPresent;
  const clampWords = (raw, fallback) => {
    const parsed = parseInt(raw, 10);
    if (!Number.isFinite(parsed))
      return fallback;
    return Math.max(100, Math.min(2e6, parsed));
  };
  const selectedText = getMainInputValue();
  const directorNotes = getNotesValue();
  const startGuidedDemo = () => {
    if (!plugin.settings.guidedDemoShownOnce) {
      plugin.settings.guidedDemoShownOnce = true;
      void plugin.saveSettings();
    }
    setError(null);
    setPromptTokenEstimate(null);
    setPromptCharCount(null);
    setGenerationStage("");
    setGeneratedText("");
    setModeState((prev) => {
      const next = {
        ...prev,
        chapter: { ...prev.chapter, minWords: 800, maxWords: 1200 }
      };
      scheduleModeStateSave(next);
      return next;
    });
    setMinWordsInput("800");
    setMaxWordsInput("1200");
    setMode("chapter");
    setModeState((prev) => {
      const next = {
        ...prev,
        chapter: {
          ...prev.chapter,
          sceneSummary: [
            "Write a tense, character-driven scene set at night in a quiet city.",
            "Include two named characters: Ava (the protagonist) and Marcus (an uneasy ally).",
            "Ava is trying to recover a stolen keycard without alerting security.",
            "Marcus pushes for a riskier plan; Ava stays cautious.",
            "End with a cliffhanger discovery (a hidden message or unexpected witness)."
          ].join("\n"),
          rewriteInstructions: DEFAULT_REWRITE_INSTRUCTIONS
        }
      };
      scheduleModeStateSave(next);
      return next;
    });
    setDemoStep("chapter");
    setDemoStepCompleted({
      chapter: false,
      "micro-edit": false,
      "character-update": false,
      done: false
    });
    new import_obsidian6.Notice(
      plugin.settings.apiKey ? "Guided demo started. This will only generate demo text." : "Guided demo started in offline mode (no API key)."
    );
  };
  (0, import_react8.useEffect)(() => {
    setMinWordsInput(String(modeState.chapter.minWords ?? 2e3));
  }, [modeState.chapter.minWords]);
  (0, import_react8.useEffect)(() => {
    setMaxWordsInput(String(modeState.chapter.maxWords ?? 6e3));
  }, [modeState.chapter.maxWords]);
  (0, import_react8.useEffect)(() => {
    const update = () => {
      try {
        if (!plugin.settings.retrievalEnableSemanticIndex) {
          setIndexStatusText("Semantic retrieval: Off");
          return;
        }
        const status = plugin.embeddingsIndex?.getStatus?.();
        if (!status) {
          setIndexStatusText("Semantic retrieval: Starting\u2026");
          return;
        }
        if (status.paused) {
          setIndexStatusText(`Index: Paused (${status.indexedFiles} file(s), ${status.indexedChunks} chunk(s))`);
          return;
        }
        if (status.queued > 0) {
          setIndexStatusText(`Index: Building (${status.queued} queued, ${status.indexedChunks} chunk(s))`);
          return;
        }
        setIndexStatusText(`Index: Up to date (${status.indexedFiles} file(s), ${status.indexedChunks} chunk(s))`);
      } catch {
        setIndexStatusText("Semantic retrieval: Unavailable");
      }
    };
    update();
    const id = window.setInterval(update, 2e3);
    return () => window.clearInterval(id);
  }, [plugin]);
  const exitGuidedDemo = () => {
    setDemoStep("off");
    setDemoStepCompleted({
      chapter: false,
      "micro-edit": false,
      "character-update": false,
      done: false
    });
    new import_obsidian6.Notice("Guided demo exited.");
  };
  const skipGuidedDemo = () => {
    plugin.settings.guidedDemoDismissed = true;
    plugin.settings.guidedDemoShownOnce = true;
    void plugin.saveSettings();
    exitGuidedDemo();
    new import_obsidian6.Notice("Guided demo skipped.");
  };
  const continueGuidedDemo = () => {
    if (demoStep === "chapter") {
      const excerpt = (generatedText || "").slice(0, 1200).trim();
      setMode("micro-edit");
      setModeState((prev) => {
        const next = {
          ...prev,
          microEdit: {
            ...prev.microEdit,
            selectedPassage: excerpt.length > 0 ? excerpt : "Paste a paragraph here, then click Generate edit."
          }
        };
        scheduleModeStateSave(next);
        return next;
      });
      setDemoStep("micro-edit");
      return;
    }
    if (demoStep === "micro-edit") {
      const excerpt = (generatedText || "").slice(0, 1500).trim();
      setMode("character-update");
      setModeState((prev) => {
        const next = {
          ...prev,
          characterUpdate: {
            ...prev.characterUpdate,
            selectedText: excerpt.length > 0 ? excerpt : "Paste character-relevant text here, then click Update characters."
          }
        };
        scheduleModeStateSave(next);
        return next;
      });
      setDemoStep("character-update");
      return;
    }
    if (demoStep === "character-update") {
      setDemoStep("done");
      setDemoStepCompleted((prev) => ({ ...prev, done: true }));
      if (!plugin.settings.guidedDemoDismissed) {
        plugin.settings.guidedDemoDismissed = true;
        plugin.settings.guidedDemoShownOnce = true;
        void plugin.saveSettings();
      }
      new import_obsidian6.Notice(`Guided demo complete. Demo notes are in "${DEMO_FOLDER}/".`);
    }
  };
  (0, import_react8.useEffect)(() => {
    if (mode !== "chapter")
      return;
    if ((modeState.chapter.rewriteInstructions || "").trim())
      return;
    setModeState((prev) => {
      const next = {
        ...prev,
        chapter: { ...prev.chapter, rewriteInstructions: DEFAULT_REWRITE_INSTRUCTIONS }
      };
      scheduleModeStateSave(next);
      return next;
    });
  }, [mode]);
  (0, import_react8.useEffect)(() => {
    const onSettingsChanged = () => {
      setApiKeyPresent(Boolean(plugin.settings.apiKey));
    };
    const onGuidedDemoStart = () => {
      startGuidedDemo();
    };
    window.addEventListener("writing-dashboard:settings-changed", onSettingsChanged);
    window.addEventListener("writing-dashboard:guided-demo-start", onGuidedDemoStart);
    if (plugin.guidedDemoStartRequested) {
      plugin.guidedDemoStartRequested = false;
      startGuidedDemo();
    } else if (!plugin.settings.guidedDemoDismissed && !plugin.settings.guidedDemoShownOnce) {
      startGuidedDemo();
    }
    return () => {
      window.removeEventListener("writing-dashboard:settings-changed", onSettingsChanged);
      window.removeEventListener("writing-dashboard:guided-demo-start", onGuidedDemoStart);
    };
  }, []);
  (0, import_react8.useEffect)(() => {
    if (mode === "character-update") {
      setBulkSourcePath(plugin.settings.characterExtractionSourcePath);
    }
  }, [mode]);
  (0, import_react8.useEffect)(() => {
    if (mode !== "continuity-check")
      return;
    if ((modeState.continuityCheck.draftText || "").trim())
      return;
    if (!generatedText.trim())
      return;
    setModeState((prev) => {
      const next = {
        ...prev,
        continuityCheck: { ...prev.continuityCheck, draftText: generatedText }
      };
      scheduleModeStateSave(next);
      return next;
    });
  }, [mode]);
  (0, import_react8.useEffect)(() => {
    try {
      window.localStorage.setItem(
        "writing-dashboard:vaultPanelCollapsed",
        isVaultPanelCollapsed ? "1" : "0"
      );
    } catch {
    }
  }, [isVaultPanelCollapsed]);
  (0, import_react8.useEffect)(() => {
    if (mode === "character-update")
      return;
    const primaryText = getMainInputValue().trim();
    const notes = getNotesValue().trim();
    if (!primaryText && !notes)
      return;
    if (warmTimerRef.current)
      window.clearTimeout(warmTimerRef.current);
    const requestId = ++warmReqIdRef.current;
    warmTimerRef.current = window.setTimeout(() => {
      const retrievalQuery = plugin.queryBuilder.build({
        mode: mode === "chapter" ? "chapter" : mode === "micro-edit" ? "micro-edit" : "continuity-check",
        activeFilePath: plugin.lastOpenedMarkdownPath ?? plugin.settings.book2Path,
        primaryText,
        directorNotes: notes
      });
      void plugin.retrievalService.search(retrievalQuery, { limit: Math.max(12, Math.min(120, plugin.settings.retrievalTopK ?? 24)) }).then((items) => {
        if (requestId !== warmReqIdRef.current)
          return;
        if (plugin.settings.retrievalEnableReranker) {
          plugin.cpuReranker.warm(retrievalQuery.text || "", items, { shortlist: 40 });
        }
      }).catch(() => {
      });
    }, 600);
    return () => {
      if (warmTimerRef.current) {
        window.clearTimeout(warmTimerRef.current);
        warmTimerRef.current = null;
      }
    };
  }, [mode, modeState]);
  const handleGenerate = async () => {
    if (!plugin.settings.apiKey && isGuidedDemoActive) {
      setIsGenerating(true);
      setError(null);
      setGenerationStage("Generating (offline demo)...");
      try {
        if (mode === "chapter") {
          setGeneratedText(DEMO_CHAPTER_OUTPUT);
          setDemoStepCompleted((prev) => ({ ...prev, chapter: true }));
        } else if (mode === "micro-edit") {
          setGeneratedText(DEMO_MICRO_EDIT_OUTPUT);
          setDemoStepCompleted((prev) => ({ ...prev, "micro-edit": true }));
        } else if (mode === "continuity-check") {
          setGeneratedText(DEMO_CONTINUITY_OUTPUT);
        } else {
        }
        setGenerationStage("");
      } finally {
        setIsGenerating(false);
      }
      return;
    }
    if (!plugin.settings.apiKey) {
      setError("Please configure your API key in settings");
      return;
    }
    setIsGenerating(true);
    setError(null);
    setGenerationStage("");
    let logPath = null;
    try {
      let prompt;
      let context;
      const mainInput = getMainInputValue();
      const notes = getNotesValue();
      if (mode === "chapter") {
        setGenerationStage("Retrieving and reranking...");
        const retrievalQuery = plugin.queryBuilder.build({
          mode: "chapter",
          activeFilePath: plugin.lastOpenedMarkdownPath ?? plugin.settings.book2Path,
          primaryText: mainInput,
          directorNotes: notes
        });
        context = await plugin.contextAggregator.getChapterContext(retrievalQuery);
        try {
          const retrievedText = (context?.smart_connections || "").toString();
          const items = (retrievedText.match(/^\[\d+\]/gm) || []).length;
          setRetrievedContextStats({ items, tokens: estimateTokens(retrievedText) });
        } catch {
          setRetrievedContextStats(null);
        }
        const minCfg = modeState.chapter.minWords ?? 2e3;
        const maxCfg = modeState.chapter.maxWords ?? 6e3;
        const min = Math.max(100, Math.min(minCfg, maxCfg));
        const max = Math.max(100, Math.max(minCfg, maxCfg));
        prompt = plugin.promptEngine.buildChapterPrompt(
          context,
          notes,
          mainInput,
          min,
          max
        );
      } else if (mode === "micro-edit") {
        setGenerationStage("Retrieving and reranking...");
        const retrievalQuery = plugin.queryBuilder.build({
          mode: "micro-edit",
          activeFilePath: plugin.lastOpenedMarkdownPath ?? plugin.settings.book2Path,
          primaryText: mainInput,
          directorNotes: notes
        });
        context = await plugin.contextAggregator.getMicroEditContext(mainInput, retrievalQuery);
        try {
          const retrievedText = (context?.smart_connections || "").toString();
          const items = (retrievedText.match(/^\[\d+\]/gm) || []).length;
          setRetrievedContextStats({ items, tokens: estimateTokens(retrievedText) });
        } catch {
          setRetrievedContextStats(null);
        }
        prompt = plugin.promptEngine.buildMicroEditPrompt(mainInput, notes, context);
      } else {
        setGenerationStage("Retrieving and reranking...");
        const retrievalQuery = plugin.queryBuilder.build({
          mode: "continuity-check",
          activeFilePath: plugin.lastOpenedMarkdownPath ?? plugin.settings.book2Path,
          primaryText: mainInput,
          directorNotes: ""
        });
        context = await plugin.contextAggregator.getMicroEditContext(mainInput, retrievalQuery);
        prompt = plugin.promptEngine.buildContinuityCheckPrompt({
          draft: mainInput,
          context,
          focus: modeState.continuityCheck.focus
        });
      }
      try {
        logPath = await plugin.generationLogService.startLog({
          mode,
          title: mode === "chapter" ? "Chapter generate" : mode === "micro-edit" ? "Micro edit" : "Continuity check",
          model: plugin.settings.model,
          provider: plugin.settings.apiProvider,
          queryText: mainInput || "",
          userInputs: {
            mainInput: mainInput || "",
            notes: notes || ""
          },
          retrievedContext: (context?.smart_connections || "").toString(),
          finalPrompt: plugin.settings.generationLogsIncludePrompt ? prompt : void 0
        });
      } catch {
      }
      const estimatedTokens = estimateTokens(prompt);
      setPromptTokenEstimate(estimatedTokens);
      setPromptCharCount(prompt.length);
      const limit = plugin.settings.contextTokenLimit ?? 128e3;
      if (estimatedTokens > limit) {
        const proceed = await showConfirmModal(plugin.app, {
          title: "Large prompt warning",
          message: `Estimated prompt size: ~${estimatedTokens.toLocaleString()} tokens (limit: ${limit.toLocaleString()}).

This may exceed your model context window and cause truncation/failure.

Continue anyway?`,
          confirmText: "Continue",
          cancelText: "Cancel"
        });
        if (!proceed) {
          setGenerationStage("");
          return;
        }
      }
      if (plugin.settings.generationMode === "multi") {
        setGenerationStage("Initializing multi-model generation...");
        const multiSettings = { ...plugin.settings, generationMode: "multi" };
        const result = await plugin.aiClient.generate(prompt, multiSettings);
        if (result.stages) {
          setGenerationStage(`Finalizing (${Object.keys(result.stages).length} stages completed)...`);
        }
        setGeneratedText(result.primary);
        void plugin.generationLogService.finishLog(logPath, { outputText: result.primary }).catch(() => {
        });
      } else {
        setGenerationStage("Generating...");
        const singleSettings = { ...plugin.settings, generationMode: "single" };
        const result = await plugin.aiClient.generate(prompt, singleSettings);
        setGeneratedText(result);
        void plugin.generationLogService.finishLog(logPath, { outputText: result }).catch(() => {
        });
      }
      if (demoStep === "chapter") {
        setDemoStepCompleted((prev) => ({ ...prev, chapter: true }));
      }
      if (demoStep === "micro-edit") {
        setDemoStepCompleted((prev) => ({ ...prev, "micro-edit": true }));
      }
      setGenerationStage("");
    } catch (err) {
      if (isGuidedDemoActive) {
        console.error("Guided demo AI generation failed; falling back to offline demo:", err);
        setError(null);
        setGenerationStage("Generating (offline demo fallback)...");
        try {
          if (mode === "chapter") {
            setGeneratedText(DEMO_CHAPTER_OUTPUT);
            setDemoStepCompleted((prev) => ({ ...prev, chapter: true }));
          } else {
            setGeneratedText(DEMO_MICRO_EDIT_OUTPUT);
            setDemoStepCompleted((prev) => ({ ...prev, "micro-edit": true }));
          }
          new import_obsidian6.Notice("AI request failed. Ran offline demo instead.");
        } finally {
          setGenerationStage("");
        }
      } else {
        const message = formatUnknownForUi(err);
        setError(message || "Generation failed");
        console.error("Generation error:", err);
        setGenerationStage("");
        void plugin.generationLogService.finishLog(logPath, { error: message }).catch(() => {
        });
      }
    } finally {
      setIsGenerating(false);
    }
  };
  const handleUpdateCharacters = async () => {
    if (!selectedText) {
      setError("Please select text to extract character information from");
      return;
    }
    if (!isGuidedDemoActive) {
      const characterFolder = plugin.settings.characterFolder || "";
      const folder = plugin.app.vault.getAbstractFileByPath(characterFolder);
      if (!characterFolder || !(folder instanceof import_obsidian6.TFolder)) {
        const modal = new FolderTreePickerModal(plugin, {
          currentPath: characterFolder || void 0,
          title: "Select or create character folder",
          onPick: async (selectedPath) => {
            plugin.settings.characterFolder = selectedPath;
            await plugin.saveSettings();
            handleUpdateCharacters();
          }
        });
        modal.open();
        return;
      }
    }
    if (!plugin.settings.apiKey && isGuidedDemoActive) {
      setIsGenerating(true);
      setError(null);
      setGenerationStage("Extracting character information (offline demo)...");
      try {
        const updates = plugin.characterExtractor.parseExtraction(DEMO_CHARACTER_EXTRACTION_OUTPUT);
        await plugin.vaultService.createFolderIfNotExists(DEMO_FOLDER);
        await plugin.vaultService.updateCharacterNotes(updates, DEMO_CHARACTER_FOLDER);
        setDemoStepCompleted((prev) => ({ ...prev, "character-update": true }));
        setGenerationStage("");
        new import_obsidian6.Notice(`Updated ${updates.length} demo character note(s)`);
      } catch (err) {
        const message = formatUnknownForUi(err);
        setError(message || "Character extraction failed");
        setGenerationStage("");
      } finally {
        setIsGenerating(false);
      }
      return;
    }
    if (!plugin.settings.apiKey) {
      setError("Please configure your API key in settings");
      return;
    }
    setIsGenerating(true);
    setError(null);
    setGenerationStage("Extracting character information...");
    try {
      const getEffectiveCharacterInstructions = (raw) => {
        const trimmed = (raw || "").trim();
        const hasLetters = /[A-Za-z]/.test(trimmed);
        if (trimmed.length < 30 || !hasLetters) {
          return (plugin.settings.defaultCharacterExtractionInstructions || "").trim();
        }
        return trimmed;
      };
      const characterNotes = await plugin.contextAggregator.getCharacterNotes();
      const storyBible = await plugin.contextAggregator.readFile(plugin.settings.storyBiblePath);
      const instructions = getEffectiveCharacterInstructions(directorNotes);
      const retrievalQuery = plugin.queryBuilder.build({
        mode: "character-update",
        activeFilePath: plugin.lastOpenedMarkdownPath ?? plugin.settings.book2Path,
        primaryText: selectedText,
        directorNotes
      });
      const retrievedItems = await plugin.retrievalService.search(retrievalQuery, {
        limit: plugin.settings.retrievalTopK ?? 24
      });
      const retrievedContext = retrievedItems.length === 0 ? "[No retrieved context]" : retrievedItems.map((it, idx) => `[${idx + 1}] ${it.path}
${it.excerpt}`.trim()).join("\n\n---\n\n");
      setRetrievedContextStats({ items: retrievedItems.length, tokens: estimateTokens(retrievedContext) });
      const prompt = plugin.promptEngine.buildCharacterExtractionPrompt(
        selectedText,
        characterNotes,
        storyBible,
        instructions,
        retrievedContext
      );
      const singleModeSettings = { ...plugin.settings, generationMode: "single" };
      let updates;
      try {
        const extractionResult = await plugin.aiClient.generate(prompt, singleModeSettings);
        updates = plugin.characterExtractor.parseExtraction(extractionResult);
      } catch (err) {
        if (!isGuidedDemoActive)
          throw err;
        console.error("Guided demo character extraction failed; falling back to offline demo:", err);
        updates = plugin.characterExtractor.parseExtraction(DEMO_CHARACTER_EXTRACTION_OUTPUT);
        new import_obsidian6.Notice("AI request failed. Used offline demo character extraction instead.");
      }
      if (isGuidedDemoActive) {
        await plugin.vaultService.createFolderIfNotExists(DEMO_FOLDER);
        await plugin.vaultService.updateCharacterNotes(updates, DEMO_CHARACTER_FOLDER);
        new import_obsidian6.Notice(`Updated ${updates.length} demo character note(s)`);
        setDemoStepCompleted((prev) => ({ ...prev, "character-update": true }));
      } else {
        await plugin.vaultService.updateCharacterNotes(updates);
        new import_obsidian6.Notice(`Updated ${updates.length} character note(s)`);
      }
      setError(null);
      setGenerationStage("");
    } catch (err) {
      const message = formatUnknownForUi(err);
      setError(message || "Character extraction failed");
      console.error("Character update error:", err);
      setGenerationStage("");
    } finally {
      setIsGenerating(false);
    }
  };
  const handleUpdateStoryBible = async () => {
    if (!selectedText.trim()) {
      setError("Please provide text to extract story bible updates from");
      return;
    }
    if (!plugin.settings.apiKey) {
      setError("Please configure your API key in settings");
      return;
    }
    setIsGenerating(true);
    setError(null);
    setGenerationStage("Updating story bible...");
    try {
      const existingBible = await plugin.vaultService.readFile(plugin.settings.storyBiblePath);
      setGenerationStage("Extracting updates...");
      const deltaPrompt = plugin.promptEngine.buildStoryBibleDeltaPrompt(selectedText);
      const singleSettings = { ...plugin.settings, generationMode: "single" };
      const delta = await plugin.aiClient.generate(deltaPrompt, singleSettings);
      setStoryBibleDelta(delta);
      setGenerationStage("Merging with story bible...");
      const mergePrompt = plugin.promptEngine.buildStoryBibleMergePrompt({
        existingStoryBible: existingBible,
        delta
      });
      const merged = await plugin.aiClient.generate(mergePrompt, singleSettings);
      setGeneratedText(merged);
      new import_obsidian6.Notice("Story bible update generated. Review and save when ready.");
    } catch (err) {
      const message = formatUnknownForUi(err);
      setError(message || "Story bible update failed");
      console.error("Story bible update error:", err);
    } finally {
      setGenerationStage("");
      setIsGenerating(false);
    }
  };
  const handleSaveStoryBibleAsNew = async () => {
    const merged = (generatedText || "").trim();
    if (!merged) {
      new import_obsidian6.Notice("Nothing to save");
      return;
    }
    const now = new Date();
    const yyyy = String(now.getFullYear());
    const mm = String(now.getMonth() + 1).padStart(2, "0");
    const dd = String(now.getDate()).padStart(2, "0");
    const path = `Story bibles/Story bible - ${yyyy}-${mm}-${dd}.md`;
    await plugin.vaultService.ensureParentFolder(path);
    await plugin.vaultService.writeFile(path, merged + "\n");
    plugin.settings.storyBiblePath = path;
    await plugin.saveSettings();
    new import_obsidian6.Notice(`Saved merged story bible to ${path}`);
  };
  const handleReplaceStoryBible = async () => {
    const merged = (generatedText || "").trim();
    if (!merged) {
      new import_obsidian6.Notice("Nothing to save");
      return;
    }
    const ok = await showConfirmModal(plugin.app, {
      title: "Replace story bible",
      message: "This will save a new versioned story bible and update the active story bible path.\n\nContinue?",
      confirmText: "Save new version",
      cancelText: "Cancel"
    });
    if (!ok)
      return;
    try {
      const existing = await plugin.vaultService.readFile(plugin.settings.storyBiblePath);
      const now2 = new Date();
      const yyyy2 = String(now2.getFullYear());
      const mm2 = String(now2.getMonth() + 1).padStart(2, "0");
      const dd2 = String(now2.getDate()).padStart(2, "0");
      const backupPath = `Story bibles/Story bible - backup ${yyyy2}-${mm2}-${dd2}.md`;
      await plugin.vaultService.ensureParentFolder(backupPath);
      await plugin.vaultService.writeFile(backupPath, existing + "\n");
    } catch {
    }
    const now = new Date();
    const yyyy = String(now.getFullYear());
    const mm = String(now.getMonth() + 1).padStart(2, "0");
    const dd = String(now.getDate()).padStart(2, "0");
    const newPath = `Story bibles/Story bible - ${yyyy}-${mm}-${dd}.md`;
    await plugin.vaultService.ensureParentFolder(newPath);
    await plugin.vaultService.writeFile(newPath, merged + "\n");
    plugin.settings.storyBiblePath = newPath;
    await plugin.saveSettings();
    new import_obsidian6.Notice("Story bible saved as new version and updated.");
  };
  const handleSelectCharacterExtractionSource = () => {
    const modal = new FileTreePickerModal(plugin, {
      currentPath: plugin.settings.characterExtractionSourcePath,
      title: "Select file to process for character extraction",
      onPick: async (filePath) => {
        plugin.settings.characterExtractionSourcePath = filePath;
        await plugin.saveSettings();
        setBulkSourcePath(filePath);
      }
    });
    modal.open();
  };
  const handleClearCharacterExtractionSource = async () => {
    delete plugin.settings.characterExtractionSourcePath;
    await plugin.saveSettings();
    setBulkSourcePath(void 0);
  };
  const handleProcessEntireBook = async () => {
    if (!plugin.settings.apiKey) {
      setError("Please configure your API key in settings");
      return;
    }
    const characterFolder = plugin.settings.characterFolder || "";
    const folder = plugin.app.vault.getAbstractFileByPath(characterFolder);
    if (!characterFolder || !(folder instanceof import_obsidian6.TFolder)) {
      const modal = new FolderTreePickerModal(plugin, {
        currentPath: characterFolder || void 0,
        title: "Select or create character folder",
        onPick: async (selectedPath) => {
          plugin.settings.characterFolder = selectedPath;
          await plugin.saveSettings();
          handleProcessEntireBook();
        }
      });
      modal.open();
      return;
    }
    setIsGenerating(true);
    setError(null);
    setGenerationStage("Loading book...");
    const sleep = (ms) => new Promise((resolve) => window.setTimeout(resolve, ms));
    const getErrorMessage = (err) => formatUnknownForUi(err);
    const withRetries = async (label, fn, maxRetries = 2) => {
      let attempt = 0;
      while (true) {
        try {
          return await fn();
        } catch (err) {
          attempt++;
          if (attempt > maxRetries)
            throw err;
          setGenerationStage(`${label} (retry ${attempt}/${maxRetries})...`);
          await sleep(600 * attempt);
        }
      }
    };
    try {
      const bookPath = plugin.settings.characterExtractionSourcePath || plugin.settings.book2Path;
      const bookText = await plugin.contextAggregator.readFile(bookPath);
      if (!bookText || bookText.trim().length === 0) {
        setError("Book file is empty or not found");
        return;
      }
      const hashNow = fnv1a32(bookText);
      const fileState = plugin.settings.fileState?.[bookPath] || {};
      const chapters = TextChunker.splitByH1(bookText);
      const totalChapters = chapters.length;
      if (totalChapters === 0) {
        setError("No content found to process.");
        return;
      }
      setGenerationStage(`Pass 1/2: Building roster from ${totalChapters} chapter(s)...`);
      const characterNotes = await plugin.contextAggregator.getCharacterNotes();
      const storyBible = await plugin.contextAggregator.readFile(plugin.settings.storyBiblePath);
      const meta = fileState.bulkProcessMeta;
      const canRetryFailures = meta && meta.hash === hashNow && typeof meta.rosterText === "string" && Array.isArray(meta.failedChapterIndices) && meta.failedChapterIndices.length > 0;
      if (fileState.lastProcessHash === hashNow && !canRetryFailures) {
        setError(null);
        setGenerationStage("");
        new import_obsidian6.Notice("Book unchanged since last processing \u2014 skipping.");
        return;
      }
      let rosterText;
      const failedChapterIndices = [];
      if (canRetryFailures) {
        rosterText = meta.rosterText;
        setGenerationStage(
          `Retrying ${meta.failedChapterIndices.length} failed chapter(s) (no restart)...`
        );
      } else {
        setGenerationStage(`Pass 1/2: Building roster from ${totalChapters} chapter(s)...`);
        const rosterEntries = [];
        for (let i = 0; i < chapters.length; i++) {
          const label = `Pass 1/2: Roster scan ${i + 1} of ${totalChapters}`;
          setGenerationStage(`${label}...`);
          const passage = chapters[i].fullText;
          const rosterPrompt = plugin.promptEngine.buildCharacterRosterPrompt(passage, storyBible);
          const singleModeSettings = { ...plugin.settings, generationMode: "single" };
          try {
            const rosterResult = await withRetries(label, async () => {
              return await plugin.aiClient.generate(rosterPrompt, singleModeSettings);
            }, 2);
            rosterEntries.push(...parseCharacterRoster(rosterResult));
          } catch (err) {
            console.error(`Roster scan failed at chapter ${i + 1}:`, err);
          }
        }
        const mergedRoster = parseCharacterRoster(rosterToBulletList(rosterEntries));
        rosterText = rosterToBulletList(mergedRoster);
        plugin.settings.fileState = plugin.settings.fileState || {};
        plugin.settings.fileState[bookPath] = {
          ...plugin.settings.fileState[bookPath] || {},
          bulkProcessMeta: {
            hash: hashNow,
            rosterText,
            failedChapterIndices: []
          }
        };
        await plugin.saveSettings();
      }
      setGenerationStage(`Pass 2/2: Extracting character updates from ${totalChapters} chapter(s)...`);
      const allUpdates = /* @__PURE__ */ new Map();
      const chapterIndicesToProcess = canRetryFailures ? meta.failedChapterIndices : chapters.map((_, idx) => idx);
      for (let k = 0; k < chapterIndicesToProcess.length; k++) {
        const i = chapterIndicesToProcess[k];
        const label = `Pass 2/2: Chapter ${i + 1} of ${totalChapters}`;
        setGenerationStage(`${label}...`);
        const passage = chapters[i].fullText;
        const prompt = plugin.promptEngine.buildCharacterExtractionPromptWithRoster({
          passage,
          roster: rosterText,
          characterNotes,
          storyBible
        });
        const singleModeSettings = { ...plugin.settings, generationMode: "single" };
        try {
          const extractionResult = await withRetries(label, async () => {
            return await plugin.aiClient.generate(prompt, singleModeSettings);
          }, 3);
          const updates = plugin.characterExtractor.parseExtraction(extractionResult, { strict: true });
          for (const update of updates) {
            const existing = allUpdates.get(update.character) ?? [];
            existing.push(update.update);
            allUpdates.set(update.character, existing);
          }
        } catch (err) {
          console.error(`${label} failed:`, err);
          failedChapterIndices.push(i);
        }
      }
      const aggregatedUpdates = Array.from(allUpdates.entries()).map(([character, updates]) => ({
        character,
        update: updates.join("\n\n---\n\n")
      }));
      setGenerationStage("Saving character updates...");
      await plugin.vaultService.updateCharacterNotes(aggregatedUpdates);
      plugin.settings.fileState = plugin.settings.fileState || {};
      plugin.settings.fileState[bookPath] = {
        ...plugin.settings.fileState[bookPath] || {},
        lastProcessHash: hashNow,
        lastProcessedAt: new Date().toISOString(),
        bulkProcessMeta: {
          hash: hashNow,
          rosterText,
          failedChapterIndices
        }
      };
      await plugin.saveSettings();
      setError(null);
      setGenerationStage("");
      if (failedChapterIndices.length > 0) {
        new import_obsidian6.Notice(
          `Processed book and updated ${aggregatedUpdates.length} character note(s). ${failedChapterIndices.length} chapter(s) failed; re-run to retry failures.`
        );
      } else {
        new import_obsidian6.Notice(`Processed book and updated ${aggregatedUpdates.length} character note(s)`);
      }
    } catch (err) {
      setError(getErrorMessage(err) || "Processing entire book failed");
      console.error("Process entire book error:", err);
      setGenerationStage("");
    } finally {
      setIsGenerating(false);
    }
  };
  const handleChunkSelectedFile = async () => {
    if (!plugin.settings.apiKey) {
      setError("Please configure your API key in settings");
      return;
    }
    setIsGenerating(true);
    setError(null);
    setGenerationStage("Chunking file...");
    try {
      const sourceFilePath = plugin.lastOpenedMarkdownPath;
      if (!sourceFilePath) {
        setError("No active note detected. Open the note you want to chunk first.");
        return;
      }
      const textToChunk = await plugin.contextAggregator.readFile(sourceFilePath);
      setGenerationStage(`Reading ${sourceFilePath}...`);
      if (!textToChunk || textToChunk.trim().length === 0) {
        setError("No text to chunk. Ensure the note has content.");
        return;
      }
      const hashNow = fnv1a32(textToChunk);
      const prevState = plugin.settings.fileState?.[sourceFilePath];
      if (prevState?.lastChunkHash === hashNow) {
        setError(null);
        setGenerationStage("");
        new import_obsidian6.Notice("Chunks are up to date \u2014 no rebuild needed.");
        return;
      }
      const wordCount = TextChunker.getWordCount(textToChunk);
      setGenerationStage(`Chunking ${wordCount} words into 500-word chunks...`);
      const result = await plugin.vaultService.chunkFile(sourceFilePath, textToChunk, 500, true);
      plugin.settings.fileState = plugin.settings.fileState || {};
      plugin.settings.fileState[sourceFilePath] = {
        ...plugin.settings.fileState[sourceFilePath] || {},
        lastChunkHash: hashNow,
        lastChunkedAt: new Date().toISOString(),
        lastChunkCount: result.totalChunks
      };
      await plugin.saveSettings();
      setError(null);
      setGenerationStage("");
      const written = result.created + result.overwritten;
      new import_obsidian6.Notice(
        `Chunks rebuilt (${result.totalChunks} total; ${written} written; ${result.deletedExtra} deleted)`
      );
    } catch (err) {
      const message = formatUnknownForUi(err);
      setError(message || "Chunking failed");
      console.error("Chunking error:", err);
      setGenerationStage("");
    } finally {
      setIsGenerating(false);
    }
  };
  const handleCopyToClipboard = async () => {
    if (generatedText) {
      try {
        await navigator.clipboard.writeText(generatedText);
        new import_obsidian6.Notice("Copied to clipboard");
      } catch (err) {
        console.error("Copy failed:", err);
        new import_obsidian6.Notice("Copy failed");
      }
    }
  };
  return /* @__PURE__ */ import_react8.default.createElement("div", { className: "writing-dashboard" }, demoStep !== "off" && /* @__PURE__ */ import_react8.default.createElement("div", { className: "demo-banner" }, /* @__PURE__ */ import_react8.default.createElement("div", { className: "demo-banner-left" }, /* @__PURE__ */ import_react8.default.createElement("strong", null, "Guided demo"), /* @__PURE__ */ import_react8.default.createElement("span", { className: "demo-banner-step" }, demoStep === "chapter" && "Step 1/3: Generate a chapter (demo text)", demoStep === "micro-edit" && "Step 2/3: Micro edit (demo text)", demoStep === "character-update" && "Step 3/3: Update characters (demo folder)", demoStep === "done" && "Complete"), !canUseAiInDemo && /* @__PURE__ */ import_react8.default.createElement("span", { className: "demo-banner-step" }, "Offline demo: uses sample outputs. Add an API key to run real generation.")), /* @__PURE__ */ import_react8.default.createElement("div", { className: "demo-banner-actions" }, /* @__PURE__ */ import_react8.default.createElement("button", { onClick: openPluginSettings, disabled: isGenerating, className: "mod-secondary" }, "Open settings"), !plugin.settings.setupCompleted && /* @__PURE__ */ import_react8.default.createElement("button", { onClick: skipGuidedDemo, disabled: isGenerating, className: "mod-secondary" }, "Skip demo"), demoStep !== "done" && /* @__PURE__ */ import_react8.default.createElement(
    "button",
    {
      onClick: continueGuidedDemo,
      disabled: isGenerating || demoStep === "chapter" && !demoStepCompleted.chapter || demoStep === "micro-edit" && !demoStepCompleted["micro-edit"] || demoStep === "character-update" && !demoStepCompleted["character-update"],
      className: "mod-cta"
    },
    "Next"
  ), demoStep === "done" && /* @__PURE__ */ import_react8.default.createElement("button", { onClick: exitGuidedDemo, disabled: isGenerating, className: "mod-cta" }, "Close demo"), /* @__PURE__ */ import_react8.default.createElement("button", { onClick: exitGuidedDemo, disabled: isGenerating, className: "mod-secondary" }, "Exit"))), !apiKeyPresent && !isGuidedDemoActive && /* @__PURE__ */ import_react8.default.createElement("div", { className: "backend-warning" }, "\u26A0\uFE0F Please configure your API key in settings \u2192 writing dashboard"), /* @__PURE__ */ import_react8.default.createElement("div", { className: "dashboard-layout" }, /* @__PURE__ */ import_react8.default.createElement("div", { className: `sidebar ${isVaultPanelCollapsed ? "collapsed" : ""}` }, /* @__PURE__ */ import_react8.default.createElement(
    VaultBrowser,
    {
      plugin,
      collapsed: isVaultPanelCollapsed,
      onToggleCollapsed: setIsVaultPanelCollapsed
    }
  )), /* @__PURE__ */ import_react8.default.createElement("div", { className: "main-workspace" }, /* @__PURE__ */ import_react8.default.createElement("div", { className: "generation-status", style: { marginBottom: "8px", fontSize: "0.9em" } }, /* @__PURE__ */ import_react8.default.createElement("span", { className: "visual-aid-text" }, "\u{1F4D6}"), " Book: ", plugin.settings.book2Path || "(not set)", (() => {
    const file = plugin.app.vault.getAbstractFileByPath(plugin.settings.book2Path);
    if (plugin.settings.book2Path && !file) {
      return /* @__PURE__ */ import_react8.default.createElement("span", { className: "visual-aid-text" }, " (file not found)");
    }
    return "";
  })()), /* @__PURE__ */ import_react8.default.createElement(
    EditorPanel,
    {
      plugin,
      mode,
      selectedText,
      onSelectionChange: updateMainInput,
      generatedText,
      onGeneratedChange: setGeneratedText,
      onCopy: handleCopyToClipboard
    }
  ), mode === "chapter" && /* @__PURE__ */ import_react8.default.createElement("div", { className: "word-count-input" }, /* @__PURE__ */ import_react8.default.createElement("label", null, "Target word range:"), /* @__PURE__ */ import_react8.default.createElement(
    "input",
    {
      type: "number",
      value: minWordsInput,
      onChange: (e) => setMinWordsInput(e.target.value),
      onBlur: () => {
        const currentMin = modeState.chapter.minWords ?? 2e3;
        const currentMax = modeState.chapter.maxWords ?? 6e3;
        const nextMin = clampWords(minWordsInput, currentMin);
        const nextMax = Math.max(nextMin, currentMax);
        setModeState((prev) => {
          const next = { ...prev, chapter: { ...prev.chapter, minWords: nextMin, maxWords: nextMax } };
          scheduleModeStateSave(next);
          return next;
        });
        setMinWordsInput(String(nextMin));
      },
      onKeyDown: (e) => {
        if (e.key === "Enter") {
          const currentMin = modeState.chapter.minWords ?? 2e3;
          const currentMax = modeState.chapter.maxWords ?? 6e3;
          const nextMin = clampWords(minWordsInput, currentMin);
          const nextMax = Math.max(nextMin, currentMax);
          setModeState((prev) => {
            const next = { ...prev, chapter: { ...prev.chapter, minWords: nextMin, maxWords: nextMax } };
            scheduleModeStateSave(next);
            return next;
          });
          setMinWordsInput(String(nextMin));
          e.currentTarget.blur();
        }
      },
      min: "100",
      max: "2000000"
    }
  ), /* @__PURE__ */ import_react8.default.createElement("span", { style: { margin: "0 8px" } }, "to"), /* @__PURE__ */ import_react8.default.createElement(
    "input",
    {
      type: "number",
      value: maxWordsInput,
      onChange: (e) => setMaxWordsInput(e.target.value),
      onBlur: () => {
        const currentMin = modeState.chapter.minWords ?? 2e3;
        const currentMax = modeState.chapter.maxWords ?? 6e3;
        const nextMax = clampWords(maxWordsInput, currentMax);
        const nextMin = Math.min(currentMin, nextMax);
        setModeState((prev) => {
          const next = { ...prev, chapter: { ...prev.chapter, minWords: nextMin, maxWords: nextMax } };
          scheduleModeStateSave(next);
          return next;
        });
        setMaxWordsInput(String(nextMax));
      },
      onKeyDown: (e) => {
        if (e.key === "Enter") {
          const currentMin = modeState.chapter.minWords ?? 2e3;
          const currentMax = modeState.chapter.maxWords ?? 6e3;
          const nextMax = clampWords(maxWordsInput, currentMax);
          const nextMin = Math.min(currentMin, nextMax);
          setModeState((prev) => {
            const next = { ...prev, chapter: { ...prev.chapter, minWords: nextMin, maxWords: nextMax } };
            scheduleModeStateSave(next);
            return next;
          });
          setMaxWordsInput(String(nextMax));
          e.currentTarget.blur();
        }
      },
      min: "100",
      max: "2000000"
    }
  )), mode === "continuity-check" && /* @__PURE__ */ import_react8.default.createElement("div", { className: "generation-status" }, /* @__PURE__ */ import_react8.default.createElement("div", { style: { marginBottom: 6 } }, "Continuity focus:"), /* @__PURE__ */ import_react8.default.createElement("label", { style: { marginRight: 12 } }, /* @__PURE__ */ import_react8.default.createElement(
    "input",
    {
      type: "checkbox",
      checked: Boolean(modeState.continuityCheck.focus.knowledge),
      onChange: (e) => setModeState((prev) => {
        const next = {
          ...prev,
          continuityCheck: {
            ...prev.continuityCheck,
            focus: { ...prev.continuityCheck.focus, knowledge: e.target.checked }
          }
        };
        scheduleModeStateSave(next);
        return next;
      })
    }
  ), "Knowledge"), /* @__PURE__ */ import_react8.default.createElement("label", { style: { marginRight: 12 } }, /* @__PURE__ */ import_react8.default.createElement(
    "input",
    {
      type: "checkbox",
      checked: Boolean(modeState.continuityCheck.focus.timeline),
      onChange: (e) => setModeState((prev) => {
        const next = {
          ...prev,
          continuityCheck: {
            ...prev.continuityCheck,
            focus: { ...prev.continuityCheck.focus, timeline: e.target.checked }
          }
        };
        scheduleModeStateSave(next);
        return next;
      })
    }
  ), "Timeline"), /* @__PURE__ */ import_react8.default.createElement("label", { style: { marginRight: 12 } }, /* @__PURE__ */ import_react8.default.createElement(
    "input",
    {
      type: "checkbox",
      checked: Boolean(modeState.continuityCheck.focus.pov),
      onChange: (e) => setModeState((prev) => {
        const next = {
          ...prev,
          continuityCheck: {
            ...prev.continuityCheck,
            focus: { ...prev.continuityCheck.focus, pov: e.target.checked }
          }
        };
        scheduleModeStateSave(next);
        return next;
      })
    }
  ), "POV"), /* @__PURE__ */ import_react8.default.createElement("label", null, /* @__PURE__ */ import_react8.default.createElement(
    "input",
    {
      type: "checkbox",
      checked: Boolean(modeState.continuityCheck.focus.naming),
      onChange: (e) => setModeState((prev) => {
        const next = {
          ...prev,
          continuityCheck: {
            ...prev.continuityCheck,
            focus: { ...prev.continuityCheck.focus, naming: e.target.checked }
          }
        };
        scheduleModeStateSave(next);
        return next;
      })
    }
  ), "Naming")), mode !== "continuity-check" && /* @__PURE__ */ import_react8.default.createElement(
    DirectorNotes,
    {
      value: directorNotes,
      onChange: updateNotes,
      mode,
      onResetToDefault: mode === "chapter" ? () => updateNotes(DEFAULT_REWRITE_INSTRUCTIONS) : void 0
    }
  ), promptTokenEstimate !== null && /* @__PURE__ */ import_react8.default.createElement("div", { className: "generation-status" }, /* @__PURE__ */ import_react8.default.createElement("span", { className: "visual-aid-text" }, "Estimated prompt size:"), " ~", promptTokenEstimate.toLocaleString(), " tokens", promptCharCount !== null ? ` (${promptCharCount.toLocaleString()} chars)` : "", plugin.settings.contextTokenLimit && promptTokenEstimate > plugin.settings.contextTokenLimit ? /* @__PURE__ */ import_react8.default.createElement("span", { className: "visual-aid-text" }, " \u2014 exceeds warning limit (", plugin.settings.contextTokenLimit.toLocaleString(), ")") : ""), /* @__PURE__ */ import_react8.default.createElement("div", { className: "generation-status" }, /* @__PURE__ */ import_react8.default.createElement("span", { className: "visual-aid-text" }, indexStatusText)), retrievedContextStats && /* @__PURE__ */ import_react8.default.createElement("div", { className: "generation-status" }, /* @__PURE__ */ import_react8.default.createElement("span", { className: "visual-aid-text" }, "Retrieved context:"), " ", retrievedContextStats.items.toLocaleString(), " item(s) (~", retrievedContextStats.tokens.toLocaleString(), " tokens)"), error2 && /* @__PURE__ */ import_react8.default.createElement("div", { className: "error-message" }, "\u274C ", error2), isGenerating && generationStage && /* @__PURE__ */ import_react8.default.createElement("div", { className: "generation-status" }, /* @__PURE__ */ import_react8.default.createElement("span", { className: "visual-aid-text" }, "\u23F3"), " ", generationStage), mode === "character-update" && /* @__PURE__ */ import_react8.default.createElement("div", { className: "generation-status" }, /* @__PURE__ */ import_react8.default.createElement("span", { className: "visual-aid-text" }, "Bulk source:"), " ", bulkSourcePath || plugin.settings.book2Path, bulkSourcePath ? /* @__PURE__ */ import_react8.default.createElement("span", { className: "visual-aid-text" }, " (custom)") : /* @__PURE__ */ import_react8.default.createElement("span", { className: "visual-aid-text" }, " (book main path)")), /* @__PURE__ */ import_react8.default.createElement("div", { className: "controls" }, /* @__PURE__ */ import_react8.default.createElement("div", { className: "button-group utility-buttons" }, /* @__PURE__ */ import_react8.default.createElement("div", { className: "button-group-header" }, /* @__PURE__ */ import_react8.default.createElement("h3", null, "Utilities"), /* @__PURE__ */ import_react8.default.createElement(
    "button",
    {
      onClick: () => {
        const modal = new ButtonHelpModal(plugin.app);
        modal.open();
      },
      className: "help-button update-characters-button",
      title: "View button workflows and usage guide"
    },
    "?"
  )), /* @__PURE__ */ import_react8.default.createElement("div", { className: "button-group-buttons" }, /* @__PURE__ */ import_react8.default.createElement(
    "button",
    {
      onClick: openPublishWizard,
      disabled: isGenerating,
      className: "update-characters-button",
      title: getButtonTooltip("export-epub")
    },
    "Export to epub"
  ), /* @__PURE__ */ import_react8.default.createElement(
    "button",
    {
      onClick: handlePreviewPrompt,
      disabled: isGenerating,
      className: "update-characters-button",
      title: getButtonTooltip("preview-prompt")
    },
    "Preview prompt"
  ))), mode !== "character-update" && /* @__PURE__ */ import_react8.default.createElement("div", { className: "button-group generation-buttons" }, /* @__PURE__ */ import_react8.default.createElement("h3", null, "Content Generation"), /* @__PURE__ */ import_react8.default.createElement("div", { className: "button-group-buttons" }, /* @__PURE__ */ import_react8.default.createElement(
    "button",
    {
      onClick: handleGenerate,
      disabled: isGenerating || !apiKeyPresent && !isGuidedDemoActive,
      className: "generate-button",
      title: mode === "chapter" ? getButtonTooltip("generate-chapter", mode) : mode === "micro-edit" ? getButtonTooltip("generate-edit", mode) : getButtonTooltip("run-continuity-check", mode)
    },
    isGenerating ? "Generating..." : mode === "chapter" ? "Generate chapter" : mode === "micro-edit" ? "Generate edit" : "Run continuity check"
  ))), mode === "character-update" && /* @__PURE__ */ import_react8.default.createElement("div", { className: "button-group character-buttons" }, /* @__PURE__ */ import_react8.default.createElement("h3", null, "Character Management"), /* @__PURE__ */ import_react8.default.createElement("div", { className: "button-group-buttons" }, /* @__PURE__ */ import_react8.default.createElement(
    "button",
    {
      onClick: handleUpdateCharacters,
      disabled: isGenerating || !selectedText || !apiKeyPresent && !isGuidedDemoActive,
      className: "update-characters-button",
      title: getButtonTooltip("update-characters", mode)
    },
    "Update characters"
  ), /* @__PURE__ */ import_react8.default.createElement(
    "button",
    {
      onClick: handleSelectCharacterExtractionSource,
      disabled: isGenerating,
      className: "update-characters-button",
      title: getButtonTooltip("select-file-process", mode)
    },
    "Select file to process"
  ), /* @__PURE__ */ import_react8.default.createElement(
    "button",
    {
      onClick: handleClearCharacterExtractionSource,
      disabled: isGenerating || !plugin.settings.characterExtractionSourcePath,
      className: "update-characters-button",
      title: getButtonTooltip("use-book-main-path", mode)
    },
    "Use book main path"
  ), /* @__PURE__ */ import_react8.default.createElement(
    "button",
    {
      onClick: handleProcessEntireBook,
      disabled: isGenerating || !apiKeyPresent,
      className: "update-characters-button",
      title: getButtonTooltip("process-entire-book", mode)
    },
    "Process entire book"
  ), /* @__PURE__ */ import_react8.default.createElement(
    "button",
    {
      onClick: handleChunkSelectedFile,
      disabled: isGenerating || !apiKeyPresent,
      className: "update-characters-button",
      title: getButtonTooltip("chunk-current-note", mode)
    },
    "Chunk current note"
  ))), mode === "chapter" && /* @__PURE__ */ import_react8.default.createElement("div", { className: "button-group story-bible-buttons" }, /* @__PURE__ */ import_react8.default.createElement("h3", null, "Story Bible"), /* @__PURE__ */ import_react8.default.createElement("div", { className: "button-group-buttons" }, /* @__PURE__ */ import_react8.default.createElement(
    "button",
    {
      onClick: handleUpdateStoryBible,
      disabled: isGenerating || !apiKeyPresent,
      className: "update-characters-button",
      title: getButtonTooltip("update-story-bible", mode)
    },
    "Update story bible"
  )))), mode === "chapter" && (generatedText || storyBibleDelta) && /* @__PURE__ */ import_react8.default.createElement("div", { className: "generation-status", style: { marginTop: 8 } }, /* @__PURE__ */ import_react8.default.createElement(
    "button",
    {
      onClick: handleSaveStoryBibleAsNew,
      disabled: isGenerating || !generatedText,
      title: getButtonTooltip("save-merged-story-bible", mode)
    },
    "Save merged story bible"
  ), /* @__PURE__ */ import_react8.default.createElement(
    "button",
    {
      onClick: handleReplaceStoryBible,
      disabled: isGenerating || !generatedText,
      style: { marginLeft: 8 },
      title: getButtonTooltip("replace-story-bible", mode)
    },
    "Replace story bible"
  )), /* @__PURE__ */ import_react8.default.createElement(ModeSelector, { mode, onChange: setMode }))));
};

// ui/DashboardView.ts
var VIEW_TYPE_DASHBOARD = "writing-dashboard";
var DashboardView = class extends import_obsidian7.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.reactRoot = null;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_DASHBOARD;
  }
  getDisplayText() {
    return "Writing dashboard";
  }
  getIcon() {
    return "book-open";
  }
  onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    const reactContainer = container.createDiv();
    this.reactRoot = (0, import_client4.createRoot)(reactContainer);
    this.reactRoot.render(
      import_react9.default.createElement(DashboardComponent, { plugin: this.plugin })
    );
    return Promise.resolve();
  }
  onClose() {
    if (this.reactRoot) {
      this.reactRoot.unmount();
      this.reactRoot = null;
    }
    return Promise.resolve();
  }
};

// ui/SettingsTab.ts
var import_obsidian11 = require("obsidian");

// ui/SetupWizard.tsx
var import_react10 = __toESM(require_react());
var import_client5 = __toESM(require_client());
var import_obsidian8 = require("obsidian");
function getSetupItems(plugin) {
  const bookPath = plugin.settings.book2Path || "Book-Main.md";
  return [
    {
      type: "file",
      path: bookPath,
      description: "Your active manuscript file where new chapters are written",
      content: `# Book - Main

Your active manuscript goes here.

## Chapters

[Start writing...]`,
      defaultChecked: true
    },
    {
      type: "file",
      path: plugin.settings.storyBiblePath || "Book - Story Bible.md",
      description: "World building, rules, canon, and story elements",
      content: `# Story Bible

## World Building
[Your world rules, magic systems, etc.]

## Characters
[Main character overviews]

## Plot Points
[Key plot elements]

## Themes
[Themes and motifs]`,
      defaultChecked: true
    },
    {
      type: "folder",
      path: plugin.settings.characterFolder || "Characters",
      description: "Folder for character notes (auto-updated by Character Update mode)",
      defaultChecked: true
    },
    {
      type: "folder",
      path: "Book 1 - Chunked",
      description: "Chunked version of Book 1 (500-word sections) for Smart Connections. Only needed when starting Book 2.",
      defaultChecked: false
    }
  ];
}
var SetupWizardModal = class extends import_obsidian8.Modal {
  constructor(plugin) {
    super(plugin.app);
    this.reactRoot = null;
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const reactContainer = contentEl.createDiv();
    this.reactRoot = (0, import_client5.createRoot)(reactContainer);
    this.reactRoot.render(
      import_react10.default.createElement(SetupWizardComponent, {
        plugin: this.plugin,
        onClose: () => this.close()
      })
    );
  }
  onClose() {
    if (this.reactRoot) {
      this.reactRoot.unmount();
      this.reactRoot = null;
    }
  }
};
var SetupWizardComponent = ({ plugin, onClose }) => {
  const [items, setItems] = (0, import_react10.useState)([]);
  const [isCreating, setIsCreating] = (0, import_react10.useState)(false);
  const [result, setResult] = (0, import_react10.useState)(null);
  (0, import_react10.useEffect)(() => {
    const checkItems = () => {
      const checkedItems = getSetupItems(plugin).map((item) => {
        const file = plugin.app.vault.getAbstractFileByPath(item.path);
        const exists = file !== null;
        return {
          ...item,
          checked: item.defaultChecked && !exists,
          exists
        };
      });
      setItems(checkedItems);
    };
    checkItems();
  }, [plugin]);
  const handleToggle = (index) => {
    const newItems = [...items];
    if (!newItems[index].exists) {
      newItems[index].checked = !newItems[index].checked;
      setItems(newItems);
    }
  };
  const handleCreate = async () => {
    setIsCreating(true);
    try {
      const selectedItems = items.filter((item) => item.checked && !item.exists);
      const structureItems = selectedItems.map((item) => ({
        type: item.type,
        path: item.path,
        content: item.content
      }));
      const characterFolder = plugin.settings.characterFolder || "Characters";
      const needsCharacterTemplate = selectedItems.some((item) => item.path === characterFolder);
      const result2 = await plugin.vaultService.setupDefaultStructure(structureItems);
      if (needsCharacterTemplate && result2.created.includes(characterFolder)) {
        try {
          await plugin.vaultService.createFileIfNotExists(
            `${characterFolder}/Character Template.md`,
            `# Character Name

## Basic Info
- **Role**: 
- **Age**: 
- **Appearance**: 

## Voice & Tone
[Examples of their dialogue/voice]

## Traits
- [Trait]: [Evidence]

## Relationships
- **OtherCharacter**: [Relationship description]

## Arc Progression
[Character development notes]

## Notes
[Additional information]`
          );
          if (!result2.created.includes(`${characterFolder}/Character Template.md`)) {
            result2.created.push(`${characterFolder}/Character Template.md`);
          }
        } catch (error2) {
          console.error("Error creating character template:", error2);
        }
      }
      setResult(result2);
      plugin.settings.setupCompleted = true;
      await plugin.saveSettings();
    } catch (error2) {
      console.error("Setup error:", error2);
      const message = error2 instanceof Error ? error2.message : (() => {
        try {
          return JSON.stringify(error2);
        } catch {
          return "[unserializable error]";
        }
      })();
      new import_obsidian8.Notice(`Error creating files: ${message}`);
    } finally {
      setIsCreating(false);
    }
  };
  const handleDontShowAgain = async () => {
    try {
      plugin.settings.setupCompleted = true;
      await plugin.saveSettings();
    } finally {
      onClose();
    }
  };
  const handleRunGuidedDemo = async () => {
    try {
      plugin.settings.setupCompleted = true;
      await plugin.saveSettings();
    } finally {
      onClose();
      plugin.requestGuidedDemoStart();
    }
  };
  if (result) {
    return /* @__PURE__ */ import_react10.default.createElement("div", { className: "setup-wizard" }, /* @__PURE__ */ import_react10.default.createElement("h2", null, "Setup complete!"), result.created.length > 0 && /* @__PURE__ */ import_react10.default.createElement("div", { className: "setup-success" }, /* @__PURE__ */ import_react10.default.createElement("p", null, /* @__PURE__ */ import_react10.default.createElement("strong", null, "Created:")), /* @__PURE__ */ import_react10.default.createElement("ul", null, result.created.map((path) => /* @__PURE__ */ import_react10.default.createElement("li", { key: path }, path)))), result.skipped.length > 0 && /* @__PURE__ */ import_react10.default.createElement("div", { className: "setup-skipped" }, /* @__PURE__ */ import_react10.default.createElement("p", null, /* @__PURE__ */ import_react10.default.createElement("strong", null, "Skipped (already exist):")), /* @__PURE__ */ import_react10.default.createElement("ul", null, result.skipped.map((path) => /* @__PURE__ */ import_react10.default.createElement("li", { key: path }, path)))), /* @__PURE__ */ import_react10.default.createElement("div", { className: "setup-actions" }, /* @__PURE__ */ import_react10.default.createElement("button", { onClick: handleRunGuidedDemo, className: "mod-cta" }, "Run guided demo"), /* @__PURE__ */ import_react10.default.createElement("button", { onClick: onClose, className: "mod-secondary" }, "Close")));
  }
  return /* @__PURE__ */ import_react10.default.createElement("div", { className: "setup-wizard" }, /* @__PURE__ */ import_react10.default.createElement("h2", null, "Welcome to writing dashboard"), /* @__PURE__ */ import_react10.default.createElement("p", null, "Set up your writing workspace by selecting which files and folders to create:"), /* @__PURE__ */ import_react10.default.createElement("div", { className: "setup-items" }, items.map((item, index) => /* @__PURE__ */ import_react10.default.createElement("div", { key: item.path, className: "setup-item" }, /* @__PURE__ */ import_react10.default.createElement("label", { className: item.exists ? "disabled" : "" }, /* @__PURE__ */ import_react10.default.createElement(
    "input",
    {
      type: "checkbox",
      checked: item.checked,
      disabled: item.exists || isCreating,
      onChange: () => handleToggle(index)
    }
  ), /* @__PURE__ */ import_react10.default.createElement("div", { className: "setup-item-content" }, /* @__PURE__ */ import_react10.default.createElement("div", { className: "setup-item-header" }, /* @__PURE__ */ import_react10.default.createElement("strong", null, item.path), item.exists && /* @__PURE__ */ import_react10.default.createElement("span", { className: "exists-badge" }, "\u2713 Already exists")), /* @__PURE__ */ import_react10.default.createElement("div", { className: "setup-item-description" }, item.description), item.type === "file" && !item.exists && /* @__PURE__ */ import_react10.default.createElement("div", { style: { marginTop: "8px" } }, /* @__PURE__ */ import_react10.default.createElement(
    "button",
    {
      onClick: () => {
        const modal = new FileTreePickerModal(plugin, {
          title: `Select ${item.path}`,
          currentPath: item.path,
          onPick: async (filePath) => {
            const newItems = [...items];
            newItems[index].path = filePath;
            setItems(newItems);
          }
        });
        modal.open();
      },
      className: "mod-secondary",
      style: { fontSize: "11px", marginTop: "4px" },
      disabled: isCreating
    },
    "Browse existing file"
  ))))))), /* @__PURE__ */ import_react10.default.createElement("div", { className: "setup-actions" }, /* @__PURE__ */ import_react10.default.createElement("button", { onClick: onClose, disabled: isCreating, className: "mod-secondary" }, "Cancel"), /* @__PURE__ */ import_react10.default.createElement("button", { onClick: handleDontShowAgain, disabled: isCreating, className: "mod-secondary" }, "Don't show again"), /* @__PURE__ */ import_react10.default.createElement("button", { onClick: handleRunGuidedDemo, disabled: isCreating, className: "mod-secondary" }, "Run guided demo"), /* @__PURE__ */ import_react10.default.createElement(
    "button",
    {
      onClick: handleCreate,
      disabled: isCreating || items.filter((item) => item.checked && !item.exists).length === 0,
      className: "mod-cta"
    },
    isCreating ? "Creating..." : "Create Selected"
  )));
};

// ui/FilePickerModal.ts
var import_obsidian9 = require("obsidian");
var FilePickerModal = class extends import_obsidian9.FuzzySuggestModal {
  constructor(opts) {
    super(opts.app);
    this.files = opts.files;
    this.placeholderText = opts.placeholder;
    this.onPick = opts.onPick;
    this.setPlaceholder(this.placeholderText);
  }
  getItems() {
    return this.files.slice().sort((a, b) => {
      const aScore = (a.stat?.mtime || 0) + (a.stat?.size || 0);
      const bScore = (b.stat?.mtime || 0) + (b.stat?.size || 0);
      return bScore - aScore;
    });
  }
  getItemText(item) {
    return item.path;
  }
  onChooseItem(item) {
    void this.onPick(item);
  }
};

// services/StressTestService.ts
var import_obsidian10 = require("obsidian");
var StressTestService = class {
  constructor(plugin) {
    this.log = [];
    this.testFolder = "StressTest-Temp";
    this.testFiles = [];
    this.testFolders = [];
    this.startTime = 0;
    this.plugin = plugin;
  }
  async runFullStressTest() {
    this.log = [];
    this.startTime = Date.now();
    this.logEntry("=== WRITING DASHBOARD STRESS TEST ===");
    this.logEntry(`Started: ${new Date().toISOString()}`);
    this.logEntry(`Vault: ${this.plugin.app.vault.getName()}`);
    this.logEntry("");
    this.logEntry("=== PLUGIN CONFIGURATION ===");
    this.logEntry(`API Key: ${this.plugin.settings.apiKey ? "\u2713 Configured" : "\u2717 Missing"}`);
    this.logEntry(`API Provider: ${this.plugin.settings.apiProvider || "Not set"}`);
    this.logEntry(`Model: ${this.plugin.settings.model || "Not set"}`);
    this.logEntry(`Generation Mode: ${this.plugin.settings.generationMode || "single"}`);
    this.logEntry(`Book Main Path: ${this.plugin.settings.book2Path || "Not configured"}`);
    this.logEntry(`Story Bible Path: ${this.plugin.settings.storyBiblePath || "Not configured"}`);
    this.logEntry(`Character Folder: ${this.plugin.settings.characterFolder || "Not configured (will use default: Characters)"}`);
    this.logEntry(`Semantic Retrieval: ${this.plugin.settings.retrievalEnableSemanticIndex ? "Enabled" : "Disabled"}`);
    this.logEntry(`Embedding Backend: ${this.plugin.settings.retrievalEmbeddingBackend || "hash"}`);
    this.logEntry(`BM25 Retrieval: ${this.plugin.settings.retrievalEnableBm25 ? "Enabled" : "Disabled"}`);
    this.logEntry(`Index Paused: ${this.plugin.settings.retrievalIndexPaused ? "Yes" : "No"}`);
    this.logEntry(`Retrieval Top K: ${this.plugin.settings.retrievalTopK || 24}`);
    this.logEntry(`External Embeddings: ${this.plugin.settings.externalEmbeddingsEnabled ? "Enabled" : "Disabled"}`);
    this.logEntry(`Smart Connections Template: ${this.plugin.settings.smartConnectionsTemplatePath || "Not configured"}`);
    this.logEntry(`Smart Connections Cache: ${this.plugin.settings.smartConnectionsCacheEnabled ? "Enabled" : "Disabled"}`);
    this.logEntry("");
    try {
      await this.phase1_Setup();
      await this.phase2_Indexing();
      await this.phase3_FileOperations();
      if (this.plugin.settings.apiKey) {
        await this.phase4_WritingModes();
      } else {
        this.logEntry("Phase 4: Skipped (no API key configured)");
      }
      await this.phase5_Retrieval();
      await this.phase5_5_SmartConnectionsTemplate();
      if (this.plugin.settings.apiKey) {
        await this.phase7_CharacterOperations();
      } else {
        this.logEntry("Phase 7: Skipped (no API key configured)");
      }
    } catch (error2) {
      this.logEntry(`=== FATAL ERROR IN STRESS TEST ===`);
      this.logEntry(`  WHERE: runFullStressTest (top-level catch)`);
      this.logEntry(`  WHAT: ${error2 instanceof Error ? error2.message : String(error2)}`);
      this.logEntry(`  TYPE: ${error2 instanceof Error ? error2.constructor.name : typeof error2}`);
      if (error2 instanceof Error && error2.stack) {
        this.logEntry(`  STACK (first 10 lines):`);
        error2.stack.split("\n").slice(0, 10).forEach((line) => {
          this.logEntry(`    ${line.trim()}`);
        });
      }
      if (error2 instanceof Error && "cause" in error2) {
        this.logEntry(`  CAUSE: ${error2.cause}`);
      }
      this.logEntry(`=== END FATAL ERROR ===`);
    } finally {
      await this.phase6_Cleanup();
    }
    const duration = ((Date.now() - this.startTime) / 1e3).toFixed(2);
    this.logEntry("");
    this.logEntry("=== STRESS TEST SUMMARY ===");
    this.logEntry(`Total Duration: ${duration} seconds`);
    this.logEntry(`Ended: ${new Date().toISOString()}`);
    this.logEntry("");
    this.logEntry("=== FUNCTIONAL OPERATIONS TESTED ===");
    this.logEntry("\u2713 Phase 1: Setup (folder/file creation)");
    this.logEntry("\u2713 Phase 2: Indexing (semantic index, BM25, chunking)");
    this.logEntry("\u2713 Phase 3: File Operations (read/write/folder management)");
    if (this.plugin.settings.apiKey) {
      this.logEntry("\u2713 Phase 4: Writing Modes (chapter generation, micro-edit, continuity check)");
      this.logEntry("\u2713 Phase 7: Character Operations (extraction, note updates)");
    } else {
      this.logEntry("\u25CB Phase 4: Writing Modes (skipped - no API key)");
      this.logEntry("\u25CB Phase 7: Character Operations (skipped - no API key)");
    }
    this.logEntry("\u2713 Phase 5: Retrieval Tests (hash, BM25, semantic search)");
    this.logEntry("\u2713 Phase 5.5: Smart Connections Template (execution, parsing, intersection)");
    this.logEntry("\u2713 Phase 6: Cleanup (test file/folder removal)");
    this.logEntry("");
    this.logEntry("=== KEY METRICS ===");
    this.logEntry(`Semantic Retrieval: ${this.plugin.settings.retrievalEnableSemanticIndex ? "Enabled" : "Disabled"}`);
    this.logEntry(`BM25 Retrieval: ${this.plugin.settings.retrievalEnableBm25 ? "Enabled" : "Disabled"}`);
    this.logEntry(`External Embeddings: ${this.plugin.settings.externalEmbeddingsEnabled ? "Enabled" : "Disabled"}`);
    this.logEntry(`Smart Connections Template: ${this.plugin.settings.smartConnectionsTemplatePath ? "Configured" : "Not configured"}`);
    this.logEntry(`Smart Connections Cache: ${this.plugin.settings.smartConnectionsCacheEnabled ? "Enabled" : "Disabled"}`);
    this.logEntry("");
    this.logEntry("=== STRESS TEST COMPLETED ===");
    return this.log.join("\n");
  }
  logEntry(message) {
    const timestamp = new Date().toISOString();
    const entry = `[${timestamp}] ${message}`;
    this.log.push(entry);
    console.log(`[StressTest] ${message}`);
  }
  async phase1_Setup() {
    this.logEntry("--- Phase 1: Setup ---");
    const phaseStart = Date.now();
    try {
      await this.plugin.vaultService.createFolderIfNotExists(this.testFolder);
      this.testFolders.push(this.testFolder);
      this.logEntry(`\u2713 Created test folder: ${this.testFolder}`);
      const testFiles = [
        { name: "test-chapter-1.md", content: this.generateTestChapter(1) },
        { name: "test-chapter-2.md", content: this.generateTestChapter(2) },
        { name: "test-character-scene.md", content: this.generateCharacterScene() },
        { name: "test-short.md", content: "This is a short test file with minimal content." },
        { name: "test-long.md", content: this.generateLongContent() }
      ];
      for (const testFile of testFiles) {
        const path = `${this.testFolder}/${testFile.name}`;
        await this.plugin.vaultService.writeFile(path, testFile.content);
        this.testFiles.push(path);
        this.logEntry(`\u2713 Created test file: ${testFile.name} (${testFile.content.split(/\s+/).length} words)`);
      }
      const phaseDuration = ((Date.now() - phaseStart) / 1e3).toFixed(2);
      this.logEntry(`Phase 1 completed in ${phaseDuration}s`);
      this.logEntry("");
    } catch (error2) {
      this.logEntry(`\u2717 Phase 1 failed`);
      this.logEntry(`  WHERE: phase1_Setup`);
      this.logEntry(`  CONTEXT: Test folder: ${this.testFolder}`);
      this.logEntry(`  WHAT: ${error2 instanceof Error ? error2.message : String(error2)}`);
      this.logEntry(`  TYPE: ${error2 instanceof Error ? error2.constructor.name : typeof error2}`);
      if (error2 instanceof Error && error2.stack) {
        this.logEntry(`  STACK (first 5 lines):`);
        error2.stack.split("\n").slice(0, 5).forEach((line) => {
          this.logEntry(`    ${line.trim()}`);
        });
      }
      if (error2 instanceof Error && "cause" in error2) {
        this.logEntry(`  CAUSE: ${error2.cause}`);
      }
      throw error2;
    }
  }
  async phase2_Indexing() {
    this.logEntry("--- Phase 2: Indexing Tests ---");
    const phaseStart = Date.now();
    try {
      this.logEntry("=== Indexing Configuration ===");
      this.logEntry(`Semantic retrieval enabled: ${this.plugin.settings.retrievalEnableSemanticIndex}`);
      this.logEntry(`Embedding backend: ${this.plugin.settings.retrievalEmbeddingBackend || "hash"}`);
      this.logEntry(`Index paused: ${this.plugin.settings.retrievalIndexPaused}`);
      this.logEntry(`Chunk size: ${this.plugin.settings.retrievalChunkWords || 500} words`);
      this.logEntry(`Chunk overlap: ${this.plugin.settings.retrievalChunkOverlapWords || 100} words`);
      this.logEntry(`Chunk heading level: ${this.plugin.settings.retrievalChunkHeadingLevel || "h1"}`);
      this.logEntry("");
      const statusBefore = this.plugin.embeddingsIndex?.getStatus?.();
      this.logEntry(`Index status before: ${statusBefore ? `${statusBefore.indexedFiles} files, ${statusBefore.indexedChunks} chunks, ${statusBefore.queued} queued` : "N/A"}`);
      const allFiles = this.plugin.vaultService.getIncludedMarkdownFiles();
      this.logEntry(`Total markdown files in vault: ${allFiles.length}`);
      const testFileCount = allFiles.filter((f) => f.path.startsWith(this.testFolder)).length;
      this.logEntry(`Test files created: ${testFileCount}`);
      const excludedTestFiles = [];
      for (const file of allFiles) {
        if (this.plugin.vaultService.isExcludedPath(file.path)) {
          excludedTestFiles.push(file.path);
        }
      }
      if (excludedTestFiles.length > 0) {
        this.logEntry(`\u26A0 WARNING: ${excludedTestFiles.length} files are excluded from indexing:`);
        excludedTestFiles.slice(0, 10).forEach((path) => {
          this.logEntry(`  - ${path}`);
        });
        if (excludedTestFiles.length > 10) {
          this.logEntry(`  ... and ${excludedTestFiles.length - 10} more`);
        }
      }
      const profiles = this.plugin.settings.retrievalProfiles || [];
      const activeProfile = profiles.find((p) => p.id === this.plugin.settings.retrievalActiveProfileId);
      this.logEntry(`Active retrieval profile: ${activeProfile?.name || "N/A"} (${activeProfile?.id || "N/A"})`);
      this.logEntry(`Included folders: ${activeProfile?.includedFolders?.length || 0} (empty = whole vault)`);
      if (activeProfile?.includedFolders && activeProfile.includedFolders.length > 0) {
        activeProfile.includedFolders.forEach((folder) => {
          this.logEntry(`  - ${folder}`);
        });
      }
      this.logEntry(`Excluded folders: ${this.plugin.settings.retrievalExcludedFolders?.length || 0}`);
      if (this.plugin.settings.retrievalExcludedFolders && this.plugin.settings.retrievalExcludedFolders.length > 0) {
        this.plugin.settings.retrievalExcludedFolders.forEach((folder) => {
          this.logEntry(`  - ${folder}`);
        });
      }
      if (this.plugin.settings.retrievalEnableSemanticIndex && !this.plugin.settings.retrievalIndexPaused) {
        this.logEntry("Triggering full index rescan...");
        this.logEntry(`Embedding backend: ${this.plugin.settings.retrievalEmbeddingBackend || "hash"}`);
        this.plugin.embeddingsIndex.enqueueFullRescan();
        this.plugin.bm25Index.enqueueFullRescan();
        for (let i = 0; i < 10; i++) {
          await new Promise((resolve) => setTimeout(resolve, 1e3));
          const status = this.plugin.embeddingsIndex?.getStatus?.();
          if (status) {
            this.logEntry(`Index status after ${i + 1}s: ${status.indexedFiles} files, ${status.indexedChunks} chunks, ${status.queued} queued`);
            if (status.queued === 0 && status.indexedFiles === 0 && allFiles.length > 0 && i >= 3) {
              this.logEntry(`  \u26A0 Queue empty but no files indexed - check browser console for worker logs`);
              break;
            }
            if (status.indexedFiles > 0 || status.queued === 0) {
              break;
            }
          }
        }
        const statusFinal = this.plugin.embeddingsIndex?.getStatus?.();
        this.logEntry(`Final index status: ${statusFinal ? `${statusFinal.indexedFiles} files, ${statusFinal.indexedChunks} chunks, ${statusFinal.queued} queued` : "N/A"}`);
        const indexedPaths = this.plugin.embeddingsIndex?.getIndexedPaths?.() || [];
        const allChunks = this.plugin.embeddingsIndex?.getAllChunks?.() || [];
        this.logEntry(`Actual indexed paths (getIndexedPaths): ${indexedPaths.length}`);
        this.logEntry(`Actual chunks (getAllChunks): ${allChunks.length}`);
        if (indexedPaths.length > 0) {
          this.logEntry(`Indexed files:`);
          indexedPaths.slice(0, 10).forEach((path) => {
            this.logEntry(`  - ${path}`);
          });
          if (indexedPaths.length > 10) {
            this.logEntry(`  ... and ${indexedPaths.length - 10} more`);
          }
        }
        const bm25Status = this.plugin.bm25Index?.getStatus?.();
        if (bm25Status) {
          this.logEntry(`BM25 index status: ${bm25Status.indexedFiles} files, ${bm25Status.indexedChunks} chunks, ${bm25Status.queued} queued`);
        }
        if (statusFinal) {
          if (statusFinal.queued > 0) {
            this.logEntry(`\u26A0 WARNING: ${statusFinal.queued} files still queued - indexing may be slow or stuck`);
          }
          if (statusFinal.indexedFiles === 0 && allFiles.length > 0) {
            this.logEntry(`\u26A0 ERROR: Status shows 0 files but getIndexedPaths() shows ${indexedPaths.length} files`);
            this.logEntry(`  - This suggests a bug in status reporting OR chunks are being created then removed`);
            this.logEntry(`  - Index paused: ${statusFinal.paused}`);
            this.logEntry(`  - Semantic retrieval enabled: ${this.plugin.settings.retrievalEnableSemanticIndex}`);
            this.logEntry(`  - Embedding backend: ${this.plugin.settings.retrievalEmbeddingBackend || "minilm"}`);
            this.logEntry(`  - Check browser console (F12) for detailed worker logs`);
            if (indexedPaths.length === 0 && allChunks.length === 0) {
              this.logEntry(`  - CONFIRMED: No chunks exist in memory - embedding generation likely failing`);
              const embeddingErrors = this.plugin.embeddingsIndex?.getRecentErrors?.(20) || [];
              const embeddingErrorSummary = this.plugin.embeddingsIndex?.getErrorSummary?.();
              const model = this.plugin.embeddingsIndex?.model;
              const modelErrors = model?.getRecentErrors?.(20) || [];
              const lastLoadError = model?.getLastLoadError?.();
              const loadAttempts = model?.getLoadAttempts?.() || 0;
              this.logEntry(`  === EMBEDDING ERROR DIAGNOSTICS ===`);
              this.logEntry(`  Model load attempts: ${loadAttempts}`);
              if (lastLoadError) {
                this.logEntry(`  Last model load error:`);
                this.logEntry(`    Location: ${lastLoadError.location}`);
                this.logEntry(`    Context: ${lastLoadError.context}`);
                this.logEntry(`    Message: ${lastLoadError.message}`);
                this.logEntry(`    Error Type: ${lastLoadError.errorType || "Unknown"}`);
                if (lastLoadError.stack) {
                  this.logEntry(`    Stack (first 5 lines):`);
                  lastLoadError.stack.split("\n").slice(0, 5).forEach((line) => {
                    this.logEntry(`      ${line.trim()}`);
                  });
                }
              }
              if (modelErrors.length > 0) {
                this.logEntry(`  Model errors (${modelErrors.length} total):`);
                modelErrors.slice(-10).forEach((err, idx) => {
                  this.logEntry(`    [${idx + 1}] ${err.timestamp} - ${err.location}: ${err.message}`);
                  this.logEntry(`        Context: ${err.context}`);
                  if (err.stack) {
                    const stackLines = err.stack.split("\n").slice(0, 2);
                    this.logEntry(`        Stack: ${stackLines.join(" | ")}`);
                  }
                });
              }
              if (embeddingErrorSummary) {
                this.logEntry(`  Embedding index errors:`);
                this.logEntry(`    Total errors: ${embeddingErrorSummary.total}`);
                if (Object.keys(embeddingErrorSummary.byLocation).length > 0) {
                  this.logEntry(`    Errors by location:`);
                  Object.entries(embeddingErrorSummary.byLocation).forEach(([loc, count]) => {
                    this.logEntry(`      ${loc}: ${count}`);
                  });
                }
              }
              if (embeddingErrors.length > 0) {
                this.logEntry(`  Recent embedding errors (${embeddingErrors.length}):`);
                embeddingErrors.slice(-10).forEach((err, idx) => {
                  this.logEntry(`    [${idx + 1}] ${err.timestamp}`);
                  this.logEntry(`        WHERE: ${err.location}`);
                  this.logEntry(`        CONTEXT: ${err.context}`);
                  this.logEntry(`        WHAT: ${err.message}`);
                  this.logEntry(`        TYPE: ${err.errorType || "Unknown"}`);
                  if (err.stack) {
                    this.logEntry(`        STACK (first 3 lines):`);
                    err.stack.split("\n").slice(0, 3).forEach((line) => {
                      this.logEntry(`          ${line.trim()}`);
                    });
                  }
                });
              }
              if (embeddingErrors.length === 0 && modelErrors.length === 0 && !lastLoadError) {
                this.logEntry(`  \u26A0 No errors captured - this suggests:`);
                this.logEntry(`    * Worker may not be running`);
                this.logEntry(`    * Files may be excluded from indexing`);
                this.logEntry(`    * Queue may be emptying before processing`);
                this.logEntry(`    * Errors may be occurring but not being caught`);
              }
              const envSnapshot = model?.getEnvSnapshot?.();
              if (envSnapshot) {
                this.logEntry(`  === TRANSFORMERS ENV SNAPSHOT ===`);
                this.logEntry(`    Where: ${envSnapshot.where}`);
                this.logEntry(`    Timestamp: ${envSnapshot.timestamp}`);
                this.logEntry(`    Mod keys (first 20): ${JSON.stringify(envSnapshot.modKeys)}`);
                this.logEntry(`    Has default: ${envSnapshot.hasDefault}`);
                this.logEntry(`    Has pipeline: ${envSnapshot.hasPipeline}`);
                this.logEntry(`    Env keys (first 20): ${JSON.stringify(envSnapshot.envKeys)}`);
                this.logEntry(`    Env has useWasm: ${envSnapshot.envHasUseWasm}`);
                this.logEntry(`    Env has backends: ${envSnapshot.envHasBackends}`);
                this.logEntry(`    Backend keys (first 20): ${JSON.stringify(envSnapshot.backendKeys)}`);
                this.logEntry(`    ONNX has wasm: ${envSnapshot.onnxHasWasm}`);
                this.logEntry(`    ONNX wasm keys (first 20): ${JSON.stringify(envSnapshot.onnxWasmKeys)}`);
                this.logEntry(`    ONNX wasmPaths: ${JSON.stringify(envSnapshot.onnxWasmPaths)}`);
                this.logEntry(`  === END TRANSFORMERS ENV SNAPSHOT ===`);
              } else {
                this.logEntry(`  \u26A0 Transformers env snapshot: [none captured]`);
              }
              this.logEntry(`  === END ERROR DIAGNOSTICS ===`);
            } else if (indexedPaths.length > 0 || allChunks.length > 0) {
              this.logEntry(`  - CONFIRMED: Chunks DO exist but status is wrong - bug in getStatus()`);
            }
          }
        }
      } else {
        this.logEntry("\u26A0 Indexing is disabled or paused");
        this.logEntry(`  - Semantic retrieval enabled: ${this.plugin.settings.retrievalEnableSemanticIndex}`);
        this.logEntry(`  - Index paused: ${this.plugin.settings.retrievalIndexPaused}`);
      }
      const phaseDuration = ((Date.now() - phaseStart) / 1e3).toFixed(2);
      this.logEntry(`Phase 2 completed in ${phaseDuration}s`);
      this.logEntry("");
    } catch (error2) {
      this.logEntry(`\u2717 Phase 2 failed`);
      this.logEntry(`  WHERE: phase2_Indexing`);
      this.logEntry(`  WHAT: ${error2 instanceof Error ? error2.message : String(error2)}`);
      this.logEntry(`  TYPE: ${error2 instanceof Error ? error2.constructor.name : typeof error2}`);
      if (error2 instanceof Error && error2.stack) {
        this.logEntry(`  STACK (first 5 lines):`);
        error2.stack.split("\n").slice(0, 5).forEach((line) => {
          this.logEntry(`    ${line.trim()}`);
        });
      }
      if (error2 instanceof Error && "cause" in error2) {
        this.logEntry(`  CAUSE: ${error2.cause}`);
      }
    }
  }
  async phase3_FileOperations() {
    this.logEntry("--- Phase 3: File Operations ---");
    const phaseStart = Date.now();
    try {
      if (this.testFiles.length > 0) {
        const testPath = this.testFiles[0];
        const content = await this.plugin.vaultService.readFile(testPath);
        this.logEntry(`\u2713 Read file: ${testPath} (${content.length} chars)`);
      }
      const writeTestPath = `${this.testFolder}/write-test.md`;
      const writeContent = "This is a write test file.";
      await this.plugin.vaultService.writeFile(writeTestPath, writeContent);
      this.testFiles.push(writeTestPath);
      this.logEntry(`\u2713 Write file: ${writeTestPath}`);
      const testSubFolder = `${this.testFolder}/subfolder`;
      await this.plugin.vaultService.createFolderIfNotExists(testSubFolder);
      this.testFolders.push(testSubFolder);
      this.logEntry(`\u2713 Create folder: ${testSubFolder}`);
      const structure = this.plugin.vaultService.getVaultStructure();
      this.logEntry(`\u2713 Vault structure: ${structure.length} items total`);
      const phaseDuration = ((Date.now() - phaseStart) / 1e3).toFixed(2);
      this.logEntry(`Phase 3 completed in ${phaseDuration}s`);
      this.logEntry("");
    } catch (error2) {
      this.logEntry(`\u2717 Phase 3 failed`);
      this.logEntry(`  WHERE: phase3_FileOperations`);
      this.logEntry(`  WHAT: ${error2 instanceof Error ? error2.message : String(error2)}`);
      this.logEntry(`  TYPE: ${error2 instanceof Error ? error2.constructor.name : typeof error2}`);
      if (error2 instanceof Error && error2.stack) {
        this.logEntry(`  STACK (first 5 lines):`);
        error2.stack.split("\n").slice(0, 5).forEach((line) => {
          this.logEntry(`    ${line.trim()}`);
        });
      }
      if (error2 instanceof Error && "cause" in error2) {
        this.logEntry(`  CAUSE: ${error2.cause}`);
      }
    }
  }
  async phase4_WritingModes() {
    this.logEntry("--- Phase 4: Writing Mode Tests ---");
    const phaseStart = Date.now();
    try {
      if (!this.plugin.queryBuilder) {
        this.logEntry("\u26A0 QueryBuilder not available - skipping writing mode tests");
        return;
      }
      this.logEntry("");
      this.logEntry("=== Test 1: Chapter Generation ===");
      try {
        this.logEntry("Building context for chapter generation...");
        const contextStart = Date.now();
        const chapterQuery = this.plugin.queryBuilder.build({
          mode: "chapter",
          activeFilePath: this.plugin.settings.book2Path,
          primaryText: "A test scene where the protagonist discovers a hidden door in an ancient library.",
          directorNotes: "Write in third person, maintain a suspenseful and mysterious tone. Include sensory details."
        });
        const chapterContext = await this.plugin.contextAggregator.getChapterContext(chapterQuery);
        const contextDuration = ((Date.now() - contextStart) / 1e3).toFixed(2);
        this.logEntry(`\u2713 Context aggregated in ${contextDuration}s: ${Object.keys(chapterContext).length} context sections`);
        if (chapterContext.smart_connections) {
          const scWords = chapterContext.smart_connections.split(/\s+/).length;
          const scChars = chapterContext.smart_connections.length;
          this.logEntry(`  Smart Connections context: ${scWords} words, ${scChars} chars`);
        }
        if (chapterContext.story_bible) {
          const sbWords = chapterContext.story_bible.split(/\s+/).length;
          this.logEntry(`  Story Bible: ${sbWords} words`);
        }
        if (chapterContext.sliding_window) {
          const swWords = chapterContext.sliding_window.split(/\s+/).length;
          this.logEntry(`  Sliding Window: ${swWords} words`);
        }
        this.logEntry("Building chapter generation prompt...");
        const chapterPrompt = this.plugin.promptEngine.buildChapterPrompt(
          chapterContext,
          "[INSTRUCTION: Rewrite the scene summary into fully detailed dramatic prose. Include dialogue, sensory details, and action.]",
          "A test scene where the protagonist discovers a hidden door in an ancient library.",
          500,
          1e3
        );
        this.logEntry(`\u2713 Prompt built: ${chapterPrompt.length} chars (~${Math.round(chapterPrompt.length / 4)} tokens)`);
        this.logEntry("Calling AI for chapter generation...");
        const chapterStart = Date.now();
        const chapterResult = await this.plugin.aiClient.generate(
          chapterPrompt,
          { ...this.plugin.settings, generationMode: "single" }
        );
        const chapterDuration = ((Date.now() - chapterStart) / 1e3).toFixed(2);
        const chapterText = typeof chapterResult === "string" ? chapterResult : chapterResult.primary;
        const wordCount = chapterText.split(/\s+/).length;
        this.logEntry(`\u2713 Chapter generated in ${chapterDuration}s: ${chapterText.length} chars, ${wordCount} words`);
        this.logEntry(`  Preview: ${chapterText.substring(0, 150).replace(/\n/g, " ")}...`);
      } catch (error2) {
        this.logEntry(`\u2717 Chapter generation failed`);
        this.logEntry(`  WHERE: phase4_WritingModes - Chapter Generation`);
        this.logEntry(`  CONTEXT: API Provider: ${this.plugin.settings.apiProvider}, Model: ${this.plugin.settings.model}`);
        this.logEntry(`  WHAT: ${error2 instanceof Error ? error2.message : String(error2)}`);
        this.logEntry(`  TYPE: ${error2 instanceof Error ? error2.constructor.name : typeof error2}`);
        if (error2 instanceof Error && error2.stack) {
          this.logEntry(`  STACK (first 5 lines):`);
          error2.stack.split("\n").slice(0, 5).forEach((line) => {
            this.logEntry(`    ${line.trim()}`);
          });
        }
        if (error2 instanceof Error && "cause" in error2) {
          this.logEntry(`  CAUSE: ${error2.cause}`);
        }
      }
      this.logEntry("");
      this.logEntry("=== Test 2: Micro-Edit ===");
      const testPassage = "The protagonist walked through the door. They were nervous. The room was dark.";
      try {
        this.logEntry(`Selected passage: "${testPassage}"`);
        this.logEntry("Building context for micro-edit...");
        const contextStart = Date.now();
        const microEditQuery = this.plugin.queryBuilder.build({
          mode: "micro-edit",
          activeFilePath: this.plugin.settings.book2Path,
          primaryText: testPassage,
          directorNotes: "Make the prose more vivid and engaging. Add sensory details and improve the pacing."
        });
        const microEditContext = await this.plugin.contextAggregator.getMicroEditContext(testPassage, microEditQuery);
        const contextDuration = ((Date.now() - contextStart) / 1e3).toFixed(2);
        this.logEntry(`\u2713 Context aggregated in ${contextDuration}s: ${Object.keys(microEditContext).length} context sections`);
        if (microEditContext.surrounding_before) {
          this.logEntry(`  Surrounding before: ${microEditContext.surrounding_before.split(/\s+/).length} words`);
        }
        if (microEditContext.surrounding_after) {
          this.logEntry(`  Surrounding after: ${microEditContext.surrounding_after.split(/\s+/).length} words`);
        }
        this.logEntry("Building micro-edit prompt...");
        const microEditPrompt = this.plugin.promptEngine.buildMicroEditPrompt(
          testPassage,
          "Make the prose more vivid and engaging. Add sensory details and improve the pacing.",
          microEditContext
        );
        this.logEntry(`\u2713 Prompt built: ${microEditPrompt.length} chars (~${Math.round(microEditPrompt.length / 4)} tokens)`);
        this.logEntry("Calling AI for micro-edit...");
        const microEditStart = Date.now();
        const microEditResult = await this.plugin.aiClient.generate(
          microEditPrompt,
          { ...this.plugin.settings, generationMode: "single" }
        );
        const microEditDuration = ((Date.now() - microEditStart) / 1e3).toFixed(2);
        const microEditText = typeof microEditResult === "string" ? microEditResult : microEditResult.primary;
        const microEditWordCount = microEditText.split(/\s+/).length;
        this.logEntry(`\u2713 Micro-edit generated in ${microEditDuration}s: ${microEditText.length} chars, ${microEditWordCount} words`);
        this.logEntry(`  Original: "${testPassage}"`);
        this.logEntry(`  Edited: "${microEditText.substring(0, 150).replace(/\n/g, " ")}..."`);
      } catch (error2) {
        this.logEntry(`\u2717 Micro-edit failed`);
        this.logEntry(`  WHERE: phase4_WritingModes - Micro-Edit`);
        this.logEntry(`  CONTEXT: Selected passage: "${testPassage.substring(0, 50)}...", API Provider: ${this.plugin.settings.apiProvider}`);
        this.logEntry(`  WHAT: ${error2 instanceof Error ? error2.message : String(error2)}`);
        this.logEntry(`  TYPE: ${error2 instanceof Error ? error2.constructor.name : typeof error2}`);
        if (error2 instanceof Error && error2.stack) {
          this.logEntry(`  STACK (first 5 lines):`);
          error2.stack.split("\n").slice(0, 5).forEach((line) => {
            this.logEntry(`    ${line.trim()}`);
          });
        }
        if (error2 instanceof Error && "cause" in error2) {
          this.logEntry(`  CAUSE: ${error2.cause}`);
        }
      }
      this.logEntry("");
      this.logEntry("=== Test 3: Continuity Check ===");
      const testDraft = "The protagonist entered the library. They found a book about ancient magic. The book was written in an unknown language.";
      try {
        this.logEntry(`Test draft: "${testDraft}"`);
        this.logEntry("Building context for continuity check...");
        const continuityQuery = this.plugin.queryBuilder.build({
          mode: "continuity-check",
          activeFilePath: this.plugin.settings.book2Path,
          primaryText: testDraft,
          directorNotes: ""
        });
        const continuityContext = await this.plugin.contextAggregator.getMicroEditContext(testDraft, continuityQuery);
        this.logEntry(`\u2713 Context aggregated: ${Object.keys(continuityContext).length} context sections`);
        this.logEntry("Building continuity check prompt...");
        const continuityPrompt = this.plugin.promptEngine.buildContinuityCheckPrompt({
          draft: testDraft,
          context: continuityContext,
          focus: {
            knowledge: true,
            timeline: true,
            pov: true,
            naming: true
          }
        });
        this.logEntry(`\u2713 Prompt built: ${continuityPrompt.length} chars (~${Math.round(continuityPrompt.length / 4)} tokens)`);
        this.logEntry("Calling AI for continuity check...");
        const continuityStart = Date.now();
        const continuityResult = await this.plugin.aiClient.generate(
          continuityPrompt,
          { ...this.plugin.settings, generationMode: "single" }
        );
        const continuityDuration = ((Date.now() - continuityStart) / 1e3).toFixed(2);
        const continuityText = typeof continuityResult === "string" ? continuityResult : continuityResult.primary;
        this.logEntry(`\u2713 Continuity check completed in ${continuityDuration}s: ${continuityText.length} chars`);
        this.logEntry(`  Result preview: ${continuityText.substring(0, 200).replace(/\n/g, " ")}...`);
      } catch (error2) {
        this.logEntry(`\u2717 Continuity check failed`);
        this.logEntry(`  WHERE: phase4_WritingModes - Continuity Check`);
        this.logEntry(`  CONTEXT: Test draft: "${testDraft.substring(0, 50)}...", API Provider: ${this.plugin.settings.apiProvider}`);
        this.logEntry(`  WHAT: ${error2 instanceof Error ? error2.message : String(error2)}`);
        this.logEntry(`  TYPE: ${error2 instanceof Error ? error2.constructor.name : typeof error2}`);
        if (error2 instanceof Error && error2.stack) {
          this.logEntry(`  STACK (first 5 lines):`);
          error2.stack.split("\n").slice(0, 5).forEach((line) => {
            this.logEntry(`    ${line.trim()}`);
          });
        }
        if (error2 instanceof Error && "cause" in error2) {
          this.logEntry(`  CAUSE: ${error2.cause}`);
        }
      }
      const phaseDuration = ((Date.now() - phaseStart) / 1e3).toFixed(2);
      this.logEntry("");
      this.logEntry(`Phase 4 completed in ${phaseDuration}s`);
      this.logEntry("");
    } catch (error2) {
      this.logEntry(`\u2717 Phase 4 failed`);
      this.logEntry(`  WHERE: phase4_WritingModes`);
      this.logEntry(`  WHAT: ${error2 instanceof Error ? error2.message : String(error2)}`);
      this.logEntry(`  TYPE: ${error2 instanceof Error ? error2.constructor.name : typeof error2}`);
      if (error2 instanceof Error && error2.stack) {
        this.logEntry(`  STACK (first 5 lines):`);
        error2.stack.split("\n").slice(0, 5).forEach((line) => {
          this.logEntry(`    ${line.trim()}`);
        });
      }
      if (error2 instanceof Error && "cause" in error2) {
        this.logEntry(`  CAUSE: ${error2.cause}`);
      }
    }
  }
  async phase5_Retrieval() {
    this.logEntry("--- Phase 5: Retrieval Tests ---");
    const phaseStart = Date.now();
    try {
      if (!this.plugin.settings.retrievalEnableSemanticIndex) {
        this.logEntry("\u26A0 Semantic retrieval disabled - skipping retrieval tests");
        return;
      }
      if (!this.plugin.queryBuilder || !this.plugin.retrievalService) {
        this.logEntry("\u26A0 Retrieval services not available - skipping retrieval tests");
        return;
      }
      this.logEntry("Testing retrieval query...");
      const query = this.plugin.queryBuilder.build({
        mode: "chapter",
        activeFilePath: this.plugin.settings.book2Path,
        primaryText: "test query text about characters and plot",
        directorNotes: ""
      });
      const retrievalStart = Date.now();
      const results = await this.plugin.retrievalService.search(query, { limit: 10 });
      const retrievalDuration = ((Date.now() - retrievalStart) / 1e3).toFixed(2);
      this.logEntry(`\u2713 Retrieval query completed in ${retrievalDuration}s: ${results.length} results`);
      if (results.length > 0) {
        results.slice(0, 5).forEach((result, idx) => {
          this.logEntry(`  Result ${idx + 1}: ${result.path}`);
          this.logEntry(`    Score: ${result.score.toFixed(3)} | Source: ${result.source} | Excerpt: ${result.excerpt.length} chars`);
        });
        const sourceCounts = {};
        results.forEach((r) => {
          sourceCounts[r.source] = (sourceCounts[r.source] || 0) + 1;
        });
        this.logEntry(`  Result sources: ${Object.entries(sourceCounts).map(([src, count]) => `${src}: ${count}`).join(", ")}`);
      } else {
        this.logEntry(`\u26A0 No retrieval results - index may be empty or query too specific`);
      }
      this.logEntry("");
      this.logEntry("Testing retrieval with limit 50...");
      const largeQueryStart = Date.now();
      const largeResults = await this.plugin.retrievalService.search(query, { limit: 50 });
      const largeQueryDuration = ((Date.now() - largeQueryStart) / 1e3).toFixed(2);
      this.logEntry(`\u2713 Large retrieval query completed in ${largeQueryDuration}s: ${largeResults.length} results`);
      const phaseDuration = ((Date.now() - phaseStart) / 1e3).toFixed(2);
      this.logEntry(`Phase 5 completed in ${phaseDuration}s`);
      this.logEntry("");
    } catch (error2) {
      this.logEntry(`\u2717 Phase 5 failed`);
      this.logEntry(`  WHERE: phase5_Retrieval`);
      this.logEntry(`  CONTEXT: Semantic retrieval: ${this.plugin.settings.retrievalEnableSemanticIndex}, BM25: ${this.plugin.settings.retrievalEnableBm25}`);
      this.logEntry(`  WHAT: ${error2 instanceof Error ? error2.message : String(error2)}`);
      this.logEntry(`  TYPE: ${error2 instanceof Error ? error2.constructor.name : typeof error2}`);
      if (error2 instanceof Error && error2.stack) {
        this.logEntry(`  STACK (first 5 lines):`);
        error2.stack.split("\n").slice(0, 5).forEach((line) => {
          this.logEntry(`    ${line.trim()}`);
        });
      }
      if (error2 instanceof Error && "cause" in error2) {
        this.logEntry(`  CAUSE: ${error2.cause}`);
      }
    }
  }
  async phase5_5_SmartConnectionsTemplate() {
    this.logEntry("--- Phase 5.5: Smart Connections Template Tests ---");
    const phaseStart = Date.now();
    try {
      this.logEntry("");
      this.logEntry("=== Test 1: Template Configuration ===");
      if (this.plugin.settings.smartConnectionsTemplatePath) {
        this.logEntry(`\u2713 Template path configured: ${this.plugin.settings.smartConnectionsTemplatePath}`);
        const templateFile = this.plugin.app.vault.getAbstractFileByPath(this.plugin.settings.smartConnectionsTemplatePath);
        if (templateFile && templateFile instanceof import_obsidian10.TFile) {
          this.logEntry(`\u2713 Template file exists: ${templateFile.path}`);
          const templateContent = await this.plugin.app.vault.read(templateFile);
          this.logEntry(`  Template size: ${templateContent.length} chars`);
          const hasScSyntax = templateContent.includes("{{smart-connections:similar:");
          if (hasScSyntax) {
            this.logEntry(`\u2713 Template contains Smart Connections syntax`);
            const match2 = templateContent.match(/{{smart-connections:similar:(\d+)}}/);
            if (match2) {
              this.logEntry(`  Requested similar items: ${match2[1]}`);
            }
          } else {
            this.logEntry(`\u26A0 Template does not contain {{smart-connections:similar:#}} syntax`);
          }
        } else {
          this.logEntry(`\u2717 Template file not found: ${this.plugin.settings.smartConnectionsTemplatePath}`);
        }
      } else {
        this.logEntry("\u26A0 Smart Connections template not configured");
        this.logEntry("  Template-based retrieval will be skipped");
      }
      if (this.plugin.settings.smartConnectionsTemplatePath) {
        this.logEntry("");
        this.logEntry("=== Test 2: Template Execution ===");
        try {
          const activeFile = this.plugin.app.workspace.getActiveFile();
          this.logEntry(`Active file: ${activeFile?.path || "None (using null context)"}`);
          const templateStart = Date.now();
          const templateOutput = await this.plugin.contextAggregator.templateExecutor.executeTemplate(
            this.plugin.settings.smartConnectionsTemplatePath,
            activeFile
          );
          const templateDuration = ((Date.now() - templateStart) / 1e3).toFixed(2);
          this.logEntry(`\u2713 Template executed in ${templateDuration}s`);
          this.logEntry(`  Output length: ${templateOutput.length} chars`);
          if (templateOutput.length > 0) {
            const preview = templateOutput.substring(0, 200).replace(/\n/g, " ");
            this.logEntry(`  Preview: ${preview}...`);
          } else {
            this.logEntry(`  \u26A0 Template output is empty`);
          }
        } catch (error2) {
          this.logEntry(`\u2717 Template execution failed`);
          this.logEntry(`  WHERE: phase5_5_SmartConnectionsTemplate - Template Execution`);
          this.logEntry(`  WHAT: ${error2 instanceof Error ? error2.message : String(error2)}`);
          this.logEntry(`  TYPE: ${error2 instanceof Error ? error2.constructor.name : typeof error2}`);
          if (error2 instanceof Error && error2.stack) {
            this.logEntry(`  STACK (first 5 lines):`);
            error2.stack.split("\n").slice(0, 5).forEach((line) => {
              this.logEntry(`    ${line.trim()}`);
            });
          }
        }
      }
      if (this.plugin.settings.smartConnectionsTemplatePath) {
        this.logEntry("");
        this.logEntry("=== Test 3: Path Parsing ===");
        try {
          const activeFile = this.plugin.app.workspace.getActiveFile();
          const templateOutput = await this.plugin.contextAggregator.templateExecutor.executeTemplate(
            this.plugin.settings.smartConnectionsTemplatePath,
            activeFile
          );
          const parseStart = Date.now();
          const paths = this.plugin.contextAggregator.templateExecutor.parseTemplateOutput(templateOutput);
          const parseDuration = ((Date.now() - parseStart) * 1e3).toFixed(2);
          this.logEntry(`\u2713 Path parsing completed in ${parseDuration}ms`);
          this.logEntry(`  Parsed ${paths.length} file paths from template output`);
          if (paths.length > 0) {
            this.logEntry(`  Sample paths (first 10):`);
            paths.slice(0, 10).forEach((path, idx) => {
              const file = this.plugin.app.vault.getAbstractFileByPath(path);
              const exists = file instanceof import_obsidian10.TFile ? "\u2713" : "\u2717";
              this.logEntry(`    ${idx + 1}. ${exists} ${path}`);
            });
            if (paths.length > 10) {
              this.logEntry(`    ... and ${paths.length - 10} more`);
            }
            const existingPaths = paths.filter((p) => {
              const file = this.plugin.app.vault.getAbstractFileByPath(p);
              return file instanceof import_obsidian10.TFile;
            });
            this.logEntry(`  Valid paths: ${existingPaths.length}/${paths.length}`);
          } else {
            this.logEntry(`  \u26A0 No paths extracted - template may not contain links or syntax may be incorrect`);
          }
        } catch (error2) {
          this.logEntry(`\u2717 Path parsing failed`);
          this.logEntry(`  WHERE: phase5_5_SmartConnectionsTemplate - Path Parsing`);
          this.logEntry(`  WHAT: ${error2 instanceof Error ? error2.message : String(error2)}`);
        }
      }
      if (this.plugin.settings.smartConnectionsTemplatePath) {
        this.logEntry("");
        this.logEntry("=== Test 4: Intersection Logic ===");
        try {
          const activeFile = this.plugin.app.workspace.getActiveFile();
          const templateOutput = await this.plugin.contextAggregator.templateExecutor.executeTemplate(
            this.plugin.settings.smartConnectionsTemplatePath,
            activeFile
          );
          const scTemplatePaths = this.plugin.contextAggregator.templateExecutor.parseTemplateOutput(templateOutput);
          if (scTemplatePaths.length > 0) {
            this.logEntry(`Template paths: ${scTemplatePaths.length}`);
            const query = this.plugin.queryBuilder.build({
              mode: "chapter",
              activeFilePath: this.plugin.settings.book2Path,
              primaryText: "test query for intersection testing",
              directorNotes: ""
            });
            this.logEntry("Getting hash-based retrieval results (wide net)...");
            const hashStart = Date.now();
            const hashResults = await this.plugin.retrievalService.search(query, { limit: 500 });
            const hashDuration = ((Date.now() - hashStart) / 1e3).toFixed(2);
            this.logEntry(`\u2713 Hash retrieval completed in ${hashDuration}s: ${hashResults.length} results`);
            this.logEntry("Getting intersection results (with SC template paths)...");
            const intersectionStart = Date.now();
            const intersectionResults = await this.plugin.retrievalService.search(query, { limit: 64 }, scTemplatePaths);
            const intersectionDuration = ((Date.now() - intersectionStart) / 1e3).toFixed(2);
            this.logEntry(`\u2713 Intersection retrieval completed in ${intersectionDuration}s: ${intersectionResults.length} results`);
            const scPathSet = new Set(scTemplatePaths);
            const hashPathSet = new Set(hashResults.map((r) => r.path));
            const intersectionPaths = hashResults.filter((r) => scPathSet.has(r.path)).map((r) => r.path);
            this.logEntry(`  Hash results: ${hashResults.length}`);
            this.logEntry(`  SC template paths: ${scTemplatePaths.length}`);
            this.logEntry(`  Intersection matches: ${intersectionPaths.length}`);
            this.logEntry(`  Intersection rate: ${hashResults.length > 0 ? (intersectionPaths.length / hashResults.length * 100).toFixed(1) : 0}%`);
            if (intersectionResults.length > 0) {
              this.logEntry(`  Top intersection results (first 5):`);
              intersectionResults.slice(0, 5).forEach((result, idx) => {
                const isIntersection = scPathSet.has(result.path);
                this.logEntry(`    ${idx + 1}. ${isIntersection ? "\u2713" : "\u25CB"} ${result.path} (score: ${result.score.toFixed(3)})`);
              });
            }
          } else {
            this.logEntry(`\u26A0 No template paths available - skipping intersection test`);
          }
        } catch (error2) {
          this.logEntry(`\u2717 Intersection test failed`);
          this.logEntry(`  WHERE: phase5_5_SmartConnectionsTemplate - Intersection Logic`);
          this.logEntry(`  WHAT: ${error2 instanceof Error ? error2.message : String(error2)}`);
          if (error2 instanceof Error && error2.stack) {
            this.logEntry(`  STACK (first 3 lines):`);
            error2.stack.split("\n").slice(0, 3).forEach((line) => {
              this.logEntry(`    ${line.trim()}`);
            });
          }
        }
      }
      if (this.plugin.settings.smartConnectionsCacheEnabled) {
        this.logEntry("");
        this.logEntry("=== Test 5: Smart Connections Cache Status ===");
        try {
          const scProvider = this.plugin.smartConnectionsProvider;
          if (scProvider && "getCacheStatus" in scProvider) {
            const cacheStatus = scProvider.getCacheStatus();
            if (cacheStatus) {
              this.logEntry(`  Cache exists: ${cacheStatus.exists ? "Yes" : "No"}`);
              this.logEntry(`  Cache enabled: ${cacheStatus.enabled ? "Yes" : "No"}`);
              this.logEntry(`  Cache count: ${cacheStatus.count || 0}`);
              this.logEntry(`  Cache age: ${cacheStatus.age || "unknown"}`);
              this.logEntry(`  Cache method: ${cacheStatus.method || "unknown"}`);
              if (cacheStatus.sourceNote) {
                this.logEntry(`  Source note: ${cacheStatus.sourceNote}`);
              }
            } else {
              this.logEntry(`  \u26A0 Cache status unavailable`);
            }
          } else {
            this.logEntry(`  \u26A0 Smart Connections provider not available`);
          }
        } catch (error2) {
          this.logEntry(`  \u26A0 Cache status check failed: ${error2 instanceof Error ? error2.message : String(error2)}`);
        }
      }
      const phaseDuration = ((Date.now() - phaseStart) / 1e3).toFixed(2);
      this.logEntry("");
      this.logEntry(`Phase 5.5 completed in ${phaseDuration}s`);
      this.logEntry("");
    } catch (error2) {
      this.logEntry(`\u2717 Phase 5.5 failed`);
      this.logEntry(`  WHERE: phase5_5_SmartConnectionsTemplate`);
      this.logEntry(`  WHAT: ${error2 instanceof Error ? error2.message : String(error2)}`);
      this.logEntry(`  TYPE: ${error2 instanceof Error ? error2.constructor.name : typeof error2}`);
      if (error2 instanceof Error && error2.stack) {
        this.logEntry(`  STACK (first 5 lines):`);
        error2.stack.split("\n").slice(0, 5).forEach((line) => {
          this.logEntry(`    ${line.trim()}`);
        });
      }
    }
  }
  async phase7_CharacterOperations() {
    this.logEntry("--- Phase 7: Character Operations ---");
    const phaseStart = Date.now();
    let characterFolder = this.plugin.settings.characterFolder;
    if (!characterFolder) {
      characterFolder = "Characters";
    }
    try {
      if (!characterFolder || characterFolder === "Characters" && !this.plugin.settings.characterFolder) {
        this.logEntry(`\u26A0 Character folder not configured, using default: ${characterFolder}`);
        this.logEntry(`  Note: This is a test-only folder. Configure in settings for production use.`);
      } else {
        this.logEntry(`Using configured character folder: ${characterFolder}`);
      }
      const folderCreated = await this.plugin.vaultService.createFolderIfNotExists(characterFolder);
      if (folderCreated) {
        this.logEntry(`\u2713 Created character folder: ${characterFolder}`);
      } else {
        this.logEntry(`\u2713 Character folder already exists: ${characterFolder}`);
      }
      this.logEntry("");
      this.logEntry("=== Test 1: Character Extraction (Selected Text) ===");
      const characterTestText = this.generateCharacterScene();
      try {
        this.logEntry(`Test text: ${characterTestText.split(/\s+/).length} words`);
        this.logEntry(`  Preview: ${characterTestText.substring(0, 100)}...`);
        this.logEntry("Building character extraction prompt...");
        const characterNotes = await this.plugin.contextAggregator.getCharacterNotes();
        const storyBible = await this.plugin.contextAggregator.readFile(this.plugin.settings.storyBiblePath);
        const characterQuery = this.plugin.queryBuilder.build({
          mode: "character-update",
          activeFilePath: this.plugin.settings.book2Path,
          primaryText: characterTestText,
          directorNotes: ""
        });
        const retrievedItems = await this.plugin.retrievalService.search(characterQuery, {
          limit: this.plugin.settings.retrievalTopK ?? 24
        });
        const retrievedContext = retrievedItems.length === 0 ? "[No retrieved context]" : retrievedItems.map((it, idx) => `[${idx + 1}] ${it.path}
${it.excerpt}`.trim()).join("\n\n---\n\n");
        const extractionPrompt = this.plugin.promptEngine.buildCharacterExtractionPrompt(
          characterTestText,
          characterNotes,
          storyBible,
          this.plugin.settings.defaultCharacterExtractionInstructions || "Extract character information from the provided text.",
          retrievedContext
        );
        this.logEntry(`\u2713 Prompt built: ${extractionPrompt.length} chars (~${Math.round(extractionPrompt.length / 4)} tokens)`);
        this.logEntry(`  Retrieved context: ${retrievedItems.length} items`);
        this.logEntry("Calling AI for character extraction...");
        const extractionStart = Date.now();
        const extractionResult = await this.plugin.aiClient.generate(
          extractionPrompt,
          { ...this.plugin.settings, generationMode: "single" }
        );
        const extractionDuration = ((Date.now() - extractionStart) / 1e3).toFixed(2);
        const extractionText = typeof extractionResult === "string" ? extractionResult : extractionResult.primary;
        this.logEntry(`\u2713 Extraction completed in ${extractionDuration}s: ${extractionText.length} chars`);
        this.logEntry(`  Result preview: ${extractionText.substring(0, 200).replace(/\n/g, " ")}...`);
        this.logEntry("Parsing character extraction results...");
        const updates = this.plugin.characterExtractor.parseExtraction(extractionText);
        this.logEntry(`\u2713 Parsed ${updates.length} character update(s)`);
        updates.forEach((update, idx) => {
          this.logEntry(`  Update ${idx + 1}: ${update.character} (${update.update.split(/\s+/).length} words)`);
        });
        if (updates.length > 0) {
          this.logEntry("Updating character notes...");
          await this.plugin.vaultService.updateCharacterNotes(updates, characterFolder);
          this.logEntry(`\u2713 Updated ${updates.length} character note(s) in ${characterFolder}`);
          for (const update of updates) {
            const characterPath = `${characterFolder}/${update.character}.md`;
            const file = this.plugin.app.vault.getAbstractFileByPath(characterPath);
            if (file instanceof import_obsidian10.TFile) {
              const content = await this.plugin.vaultService.readFile(characterPath);
              this.logEntry(`  \u2713 Verified: ${characterPath} (${content.length} chars)`);
              const preview = content.substring(0, 150).replace(/\n/g, " ");
              this.logEntry(`    Preview: ${preview}...`);
            } else {
              this.logEntry(`  \u2717 Character note not found: ${characterPath}`);
            }
          }
        } else {
          this.logEntry("\u26A0 No character updates parsed from extraction result");
          this.logEntry(`  Extraction text length: ${extractionText.length} chars`);
          this.logEntry(`  Extraction preview: ${extractionText.substring(0, 300)}...`);
        }
      } catch (error2) {
        this.logEntry(`\u2717 Character extraction failed`);
        this.logEntry(`  WHERE: phase7_CharacterOperations - Character Extraction`);
        this.logEntry(`  CONTEXT: Character folder: ${characterFolder}, Test text: ${characterTestText.split(/\s+/).length} words, API Provider: ${this.plugin.settings.apiProvider}`);
        this.logEntry(`  WHAT: ${error2 instanceof Error ? error2.message : String(error2)}`);
        this.logEntry(`  TYPE: ${error2 instanceof Error ? error2.constructor.name : typeof error2}`);
        if (error2 instanceof Error && error2.stack) {
          this.logEntry(`  STACK (first 5 lines):`);
          error2.stack.split("\n").slice(0, 5).forEach((line) => {
            this.logEntry(`    ${line.trim()}`);
          });
        }
        if (error2 instanceof Error && "cause" in error2) {
          this.logEntry(`  CAUSE: ${error2.cause}`);
        }
      }
      const phaseDuration = ((Date.now() - phaseStart) / 1e3).toFixed(2);
      this.logEntry("");
      this.logEntry(`Phase 7 completed in ${phaseDuration}s`);
      this.logEntry("");
    } catch (error2) {
      this.logEntry(`\u2717 Phase 7 failed`);
      this.logEntry(`  WHERE: phase7_CharacterOperations`);
      this.logEntry(`  CONTEXT: Character folder: ${characterFolder || "Not configured"}`);
      this.logEntry(`  WHAT: ${error2 instanceof Error ? error2.message : String(error2)}`);
      this.logEntry(`  TYPE: ${error2 instanceof Error ? error2.constructor.name : typeof error2}`);
      if (error2 instanceof Error && error2.stack) {
        this.logEntry(`  STACK (first 5 lines):`);
        error2.stack.split("\n").slice(0, 5).forEach((line) => {
          this.logEntry(`    ${line.trim()}`);
        });
      }
      if (error2 instanceof Error && "cause" in error2) {
        this.logEntry(`  CAUSE: ${error2.cause}`);
      }
    }
  }
  async phase6_Cleanup() {
    this.logEntry("--- Phase 6: Cleanup ---");
    const phaseStart = Date.now();
    try {
      for (const filePath of this.testFiles) {
        try {
          const file = this.plugin.app.vault.getAbstractFileByPath(filePath);
          if (file instanceof import_obsidian10.TFile) {
            await this.plugin.app.vault.delete(file);
            this.logEntry(`\u2713 Deleted: ${filePath}`);
          }
        } catch (error2) {
          this.logEntry(`\u26A0 Failed to delete ${filePath}: ${error2 instanceof Error ? error2.message : String(error2)}`);
        }
      }
      for (const folderPath of this.testFolders.reverse()) {
        try {
          const folder = this.plugin.app.vault.getAbstractFileByPath(folderPath);
          if (folder instanceof import_obsidian10.TFolder) {
            if (folder.children.length === 0) {
              await this.plugin.app.vault.delete(folder);
              this.logEntry(`\u2713 Deleted folder: ${folderPath}`);
            } else {
              this.logEntry(`\u26A0 Folder not empty, skipping: ${folderPath}`);
            }
          }
        } catch (error2) {
          this.logEntry(`\u26A0 Failed to delete folder ${folderPath}: ${error2 instanceof Error ? error2.message : String(error2)}`);
        }
      }
      for (const filePath of this.testFiles) {
        this.plugin.embeddingsIndex?.queueRemoveFile(filePath);
        this.plugin.bm25Index?.queueRemoveFile(filePath);
      }
      const phaseDuration = ((Date.now() - phaseStart) / 1e3).toFixed(2);
      this.logEntry(`Phase 6 completed in ${phaseDuration}s`);
      this.logEntry("");
    } catch (error2) {
      this.logEntry(`\u2717 Phase 6 failed: ${error2 instanceof Error ? error2.message : String(error2)}`);
    }
  }
  generateTestChapter(num) {
    return `# Chapter ${num}

This is a test chapter for stress testing the Writing Dashboard plugin.

## Scene 1

The protagonist walked through the ancient forest, feeling the weight of their mission. Trees towered overhead, their branches creating a canopy that filtered the sunlight into dappled patterns on the forest floor.

## Scene 2

A sound in the distance caught their attention. Something was moving through the underbrush, something large. The protagonist paused, hand moving to their weapon.

## Scene 3

The creature emerged from the shadows - a massive wolf with intelligent eyes. It studied the protagonist for a moment, then turned and disappeared back into the forest, leaving only the memory of its presence.

The protagonist continued on their journey, now more aware of the dangers that lurked in this place.
`;
  }
  generateCharacterScene() {
    return `# Character Test Scene

This scene involves multiple characters for testing character extraction.

Ava stood at the edge of the cliff, looking down at the city below. Marcus joined her, his expression grim.

"We need to move quickly," Marcus said. "They know we're here."

Ava nodded, her mind racing through the possibilities. The mission had become more complicated than expected.

"Can we trust them?" she asked.

Marcus hesitated before answering. "We don't have a choice."

Together, they began their descent into the city, each step bringing them closer to their goal - and to danger.
`;
  }
  generateLongContent() {
    const paragraphs = [
      "This is a long test document designed to test chunking and indexing.",
      "It contains multiple paragraphs that should be split into chunks.",
      "Each paragraph adds to the word count to ensure proper chunking behavior.",
      "The content is intentionally repetitive to test the indexing system.",
      "This helps verify that large files are properly processed.",
      "Chunking should break this into manageable pieces.",
      "Each chunk should be around 500 words by default.",
      "This document should create multiple chunks when indexed.",
      "Testing the chunking algorithm is important for retrieval quality.",
      "Proper chunking ensures relevant context is found during searches."
    ];
    let content = "# Long Test Document\n\n";
    for (let i = 0; i < 20; i++) {
      content += paragraphs.join("\n\n") + "\n\n";
    }
    return content;
  }
};

// ui/SettingsTab.ts
var OPENAI_MODELS = [
  { value: "gpt-5.2-pro", label: "GPT-5.2 Pro" },
  { value: "gpt-5.2-thinking", label: "GPT-5.2 Thinking" },
  { value: "gpt-5.2-instant", label: "GPT-5.2 Instant" },
  { value: "gpt-4o", label: "GPT-4o" },
  { value: "gpt-4o-mini", label: "GPT-4o Mini" },
  { value: "gpt-4-turbo", label: "GPT-4 Turbo" },
  { value: "gpt-4", label: "GPT-4" },
  { value: "gpt-3.5-turbo", label: "GPT-3.5 Turbo" }
];
var ANTHROPIC_MODELS = [
  { value: "claude-4-5-opus", label: "Claude 4.5 Opus" },
  { value: "claude-4-5-sonnet", label: "Claude 4.5 Sonnet" },
  { value: "claude-4-5-haiku", label: "Claude 4.5 Haiku" },
  { value: "claude-3-5-sonnet", label: "Claude 3.5 Sonnet" },
  { value: "claude-3-opus", label: "Claude 3 Opus" },
  { value: "claude-3-sonnet", label: "Claude 3 Sonnet" },
  { value: "claude-3-haiku", label: "Claude 3 Haiku" }
];
var GEMINI_MODELS = [
  { value: "gemini-3-pro-preview", label: "Gemini 3.0 Pro (Preview)" },
  { value: "gemini-3-flash-preview", label: "Gemini 3.0 Flash (Preview)" },
  { value: "gemini-2.5-pro", label: "Gemini 2.5 Pro" },
  { value: "gemini-2.5-flash", label: "Gemini 2.5 Flash" },
  { value: "gemini-2.5-flash-lite", label: "Gemini 2.5 Flash Lite" },
  { value: "gemini-2.0-flash-exp", label: "Gemini 2.0 Flash Experimental" },
  { value: "gemini-1.5-pro", label: "Gemini 1.5 Pro" },
  { value: "gemini-1.5-flash", label: "Gemini 1.5 Flash" },
  { value: "gemini-pro", label: "Gemini Pro" }
];
var OPENROUTER_MODELS = [
  { value: "openai/gpt-5.2-pro", label: "OpenAI GPT-5.2 Pro" },
  { value: "openai/gpt-5.2-thinking", label: "OpenAI GPT-5.2 Thinking" },
  { value: "openai/gpt-5.2-instant", label: "OpenAI GPT-5.2 Instant" },
  { value: "openai/gpt-4o", label: "OpenAI GPT-4o" },
  { value: "openai/gpt-4o-mini", label: "OpenAI GPT-4o Mini" },
  { value: "openai/gpt-4-turbo", label: "OpenAI GPT-4 Turbo" },
  { value: "openai/gpt-4", label: "OpenAI GPT-4" },
  { value: "openai/gpt-3.5-turbo", label: "OpenAI GPT-3.5 Turbo" },
  { value: "anthropic/claude-4-5-opus", label: "Anthropic Claude 4.5 Opus" },
  { value: "anthropic/claude-4-5-sonnet", label: "Anthropic Claude 4.5 Sonnet" },
  { value: "anthropic/claude-4-5-haiku", label: "Anthropic Claude 4.5 Haiku" },
  { value: "anthropic/claude-3-5-sonnet", label: "Anthropic Claude 3.5 Sonnet" },
  { value: "anthropic/claude-3-opus", label: "Anthropic Claude 3 Opus" },
  { value: "anthropic/claude-3-sonnet", label: "Anthropic Claude 3 Sonnet" },
  { value: "anthropic/claude-3-haiku", label: "Anthropic Claude 3 Haiku" },
  { value: "google/gemini-3-pro-preview", label: "Google Gemini 3.0 Pro (Preview)" },
  { value: "google/gemini-3-flash-preview", label: "Google Gemini 3.0 Flash (Preview)" },
  { value: "google/gemini-2.5-pro", label: "Google Gemini 2.5 Pro" },
  { value: "google/gemini-2.5-flash", label: "Google Gemini 2.5 Flash" },
  { value: "google/gemini-2.5-flash-lite", label: "Google Gemini 2.5 Flash Lite" },
  { value: "google/gemini-2.0-flash-exp", label: "Google Gemini 2.0 Flash Experimental" },
  { value: "google/gemini-1.5-pro", label: "Google Gemini 1.5 Pro" },
  { value: "google/gemini-1.5-flash", label: "Google Gemini 1.5 Flash" },
  { value: "google/gemini-pro", label: "Google Gemini Pro" }
];
function getModelsForProvider(provider) {
  switch (provider) {
    case "openai":
      return OPENAI_MODELS;
    case "anthropic":
      return ANTHROPIC_MODELS;
    case "gemini":
      return GEMINI_MODELS;
    case "openrouter":
      return OPENROUTER_MODELS;
    default:
      return [];
  }
}
var SettingsTab = class extends import_obsidian11.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    const refreshIfVisible = () => {
      try {
        if (this.containerEl?.isConnected)
          this.display();
      } catch {
      }
    };
    this.plugin.registerEvent(this.app.vault.on("create", refreshIfVisible));
    this.plugin.registerEvent(this.app.vault.on("delete", refreshIfVisible));
    this.plugin.registerEvent(
      this.app.vault.on("rename", () => {
        refreshIfVisible();
      })
    );
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian11.Setting(containerEl).setName("Configuration").setHeading();
    new import_obsidian11.Setting(containerEl).setName("API key").setDesc("Your AI API key (stored securely)").addText((text2) => text2.setPlaceholder("Enter API key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian11.Setting(containerEl).setName("Generation mode").setDesc("Single mode: fast, single model. Multi mode: higher quality with multiple models.").addDropdown((dropdown) => dropdown.addOption("single", "Single mode").addOption("multi", "Multi mode").setValue(this.plugin.settings.generationMode).onChange(async (value) => {
      this.plugin.settings.generationMode = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    new import_obsidian11.Setting(containerEl).setName("API provider").setDesc("Choose your AI provider. Openrouter is recommended for multi mode.").addDropdown((dropdown) => dropdown.addOption("openrouter", "Openrouter (recommended)").addOption("openai", "Openai").addOption("anthropic", "Anthropic").addOption("gemini", "Gemini").setValue(this.plugin.settings.apiProvider).onChange(async (value) => {
      this.plugin.settings.apiProvider = value;
      const models = getModelsForProvider(value);
      const currentModel = this.plugin.settings.model;
      if (!models.some((m) => m.value === currentModel)) {
        this.plugin.settings.model = models[0].value;
      }
      await this.plugin.saveSettings();
      this.display();
    }));
    new import_obsidian11.Setting(containerEl).setName("Model").setDesc("AI model to use").addDropdown((dropdown) => {
      const models = getModelsForProvider(this.plugin.settings.apiProvider);
      models.forEach((model) => {
        dropdown.addOption(model.value, model.label);
      });
      dropdown.setValue(this.plugin.settings.model || models[0].value);
      dropdown.onChange(async (value) => {
        this.plugin.settings.model = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian11.Setting(containerEl).setName("Retrieval").setHeading();
    const profiles = Array.isArray(this.plugin.settings.retrievalProfiles) ? this.plugin.settings.retrievalProfiles : [];
    const activeProfileId = this.plugin.settings.retrievalActiveProfileId;
    new import_obsidian11.Setting(containerEl).setName("Retrieval profile").setDesc("Controls which folders are included for retrieval and indexing. Use this to avoid pulling irrelevant vault content.").addDropdown((dropdown) => {
      for (const p of profiles)
        dropdown.addOption(p.id, p.name);
      dropdown.setValue(activeProfileId || (profiles[0]?.id ?? "story"));
      dropdown.onChange(async (value) => {
        this.plugin.settings.retrievalActiveProfileId = value;
        await this.plugin.saveSettings();
        this.plugin.embeddingsIndex.queueRecheckAllIndexed();
        this.plugin.bm25Index.queueRecheckAllIndexed();
        this.plugin.embeddingsIndex.enqueueFullRescan();
        this.plugin.bm25Index.enqueueFullRescan();
        this.display();
      });
    });
    const activeProfile = profiles.find((p) => p.id === activeProfileId) ?? profiles[0];
    if (activeProfile) {
      new import_obsidian11.Setting(containerEl).setName("Profile name").setDesc("Rename the active profile.").addText(
        (text2) => text2.setValue(activeProfile.name).onChange(async (value) => {
          const nextName = value.trim() || activeProfile.name;
          activeProfile.name = nextName;
          this.plugin.settings.retrievalProfiles = profiles;
          await this.plugin.saveSettings();
        })
      );
      let newProfileName = "";
      new import_obsidian11.Setting(containerEl).setName("Create profile").setDesc("Create a new retrieval profile.").addText(
        (text2) => text2.setPlaceholder("New profile name").onChange((value) => {
          newProfileName = value;
        })
      ).addButton(
        (btn) => btn.setButtonText("Create").setCta().onClick(async () => {
          const name2 = (newProfileName || "").trim();
          if (!name2)
            return;
          const id = `custom-${Date.now()}`;
          this.plugin.settings.retrievalProfiles = [...profiles, { id, name: name2, includedFolders: [] }];
          this.plugin.settings.retrievalActiveProfileId = id;
          await this.plugin.saveSettings();
          this.display();
        })
      );
      if (!["story", "research", "manuscript"].includes(activeProfile.id)) {
        new import_obsidian11.Setting(containerEl).setName("Delete profile").setDesc("Deletes the active profile.").addButton(
          (btn) => btn.setButtonText("Delete").onClick(async () => {
            this.plugin.settings.retrievalProfiles = profiles.filter((p) => p.id !== activeProfile.id);
            this.plugin.settings.retrievalActiveProfileId = this.plugin.settings.retrievalProfiles[0]?.id || "story";
            await this.plugin.saveSettings();
            this.plugin.embeddingsIndex.enqueueFullRescan();
            this.plugin.bm25Index.enqueueFullRescan();
            this.display();
          })
        );
      }
      const folderRoster = this.plugin.vaultService.getAllFolderPaths();
      const configDir2 = this.plugin.app.vault.configDir.replace(/\\/g, "/").replace(/\/+$/, "");
      const logsFolder = (this.plugin.settings.generationLogsFolder || "").replace(/\\/g, "/").replace(/\/+$/, "");
      const includes = new Set((activeProfile.includedFolders || []).map((p) => p.replace(/\\/g, "/")));
      const profileContainer = containerEl.createDiv({ cls: "writing-dashboard-exclusions" });
      new import_obsidian11.Setting(profileContainer).setName("Included folders").setDesc("Only these folders are searched and indexed. Leave empty to include the whole vault (minus exclusions).");
      for (const folder of folderRoster) {
        const normalized = folder.replace(/\\/g, "/");
        const isProtected = normalized === configDir2 || normalized.startsWith(`${configDir2}/`) || logsFolder && (normalized === logsFolder || normalized.startsWith(`${logsFolder}/`));
        const isChecked = includes.has(normalized);
        new import_obsidian11.Setting(profileContainer).setName(normalized).addToggle(
          (toggle) => toggle.setValue(isChecked).setDisabled(isProtected).onChange(async (value) => {
            const next = new Set((activeProfile.includedFolders || []).map((p) => p.replace(/\\/g, "/")));
            if (value)
              next.add(normalized);
            else
              next.delete(normalized);
            activeProfile.includedFolders = Array.from(next).sort((a, b) => a.localeCompare(b));
            this.plugin.settings.retrievalProfiles = profiles;
            await this.plugin.saveSettings();
            this.plugin.embeddingsIndex.queueRecheckAllIndexed();
            this.plugin.bm25Index.queueRecheckAllIndexed();
            this.plugin.embeddingsIndex.enqueueFullRescan();
            this.plugin.bm25Index.enqueueFullRescan();
          })
        );
      }
    }
    new import_obsidian11.Setting(containerEl).setName("Enable bm25 retrieval").setDesc("Use a search-engine style relevance ranking (BM25). Recommended for names, places, and exact terms.").addToggle(
      (toggle) => toggle.setValue(Boolean(this.plugin.settings.retrievalEnableBm25)).onChange(async (value) => {
        this.plugin.settings.retrievalEnableBm25 = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Enable semantic retrieval").setDesc("Build a local index to retrieve relevant notes from the vault. If disabled, retrieval uses heuristic matching only.").addToggle(
      (toggle) => toggle.setValue(Boolean(this.plugin.settings.retrievalEnableSemanticIndex)).onChange(async (value) => {
        this.plugin.settings.retrievalEnableSemanticIndex = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Semantic backend").setDesc("Choose which local semantic retrieval method to use. Hash is fast and reliable.").addDropdown((dropdown) => {
      dropdown.addOption("hash", "Hash (fast, reliable - recommended)");
      dropdown.setValue(this.plugin.settings.retrievalEmbeddingBackend ?? "hash");
      dropdown.onChange(async (value) => {
        this.plugin.settings.retrievalEmbeddingBackend = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian11.Setting(containerEl).setName("Enable reranking (experimental)").setDesc("Use a local CPU reranker to improve the ordering of retrieved snippets. Experimental feature - may fail if model files cannot be downloaded. If disabled, retrieval will work without reranking.").addToggle(
      (toggle) => toggle.setValue(Boolean(this.plugin.settings.retrievalEnableReranker)).onChange(async (value) => {
        this.plugin.settings.retrievalEnableReranker = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Retrieved items (limit)").setDesc("Maximum number of retrieved snippets to include in prompts.").addText(
      (text2) => text2.setPlaceholder("24").setValue(String(this.plugin.settings.retrievalTopK ?? 24)).onChange(async (value) => {
        const parsed = parseInt(value, 10);
        if (Number.isFinite(parsed)) {
          this.plugin.settings.retrievalTopK = Math.max(1, Math.min(100, parsed));
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Enable external embeddings").setDesc("\u26A0\uFE0F WARNING: Enabling this will make API calls during retrieval. Keep disabled to use only local hash/BM25 search (recommended).").addToggle((toggle) => {
      toggle.setValue(Boolean(this.plugin.settings.externalEmbeddingsEnabled ?? false));
      toggle.onChange(async (value) => {
        this.plugin.settings.externalEmbeddingsEnabled = value;
        await this.plugin.saveSettings();
        this.plugin.recreateRetrievalService();
        this.display();
      });
    });
    if (this.plugin.settings.externalEmbeddingsEnabled) {
      new import_obsidian11.Setting(containerEl).setName("External embedding provider").setDesc("Choose which external embedding API to use. If configured, external embeddings will be used automatically instead of local hash embeddings.").addDropdown((dropdown) => {
        dropdown.addOption("openai", "OpenAI");
        dropdown.addOption("cohere", "Cohere");
        dropdown.addOption("google", "Google (Gemini)");
        dropdown.addOption("custom", "Custom");
        dropdown.setValue(this.plugin.settings.externalEmbeddingProvider ?? "openai");
        dropdown.onChange(async (value) => {
          this.plugin.settings.externalEmbeddingProvider = value;
          if (value === "openai") {
            this.plugin.settings.externalEmbeddingModel = "text-embedding-3-small";
          } else if (value === "cohere") {
            this.plugin.settings.externalEmbeddingModel = "embed-english-v3.0";
          } else if (value === "google") {
            this.plugin.settings.externalEmbeddingModel = "gemini-embedding-001";
          } else {
            this.plugin.settings.externalEmbeddingModel = "";
          }
          await this.plugin.saveSettings();
          this.plugin.recreateRetrievalService();
          this.display();
        });
      });
      new import_obsidian11.Setting(containerEl).setName("External embedding API key").setDesc("Your API key for the external embedding provider.").addText((text2) => {
        text2.setPlaceholder("Enter API key").setValue(this.plugin.settings.externalEmbeddingApiKey ?? "");
        text2.inputEl.type = "password";
        text2.onChange(async (value) => {
          this.plugin.settings.externalEmbeddingApiKey = value;
          await this.plugin.saveSettings();
          this.plugin.recreateRetrievalService();
        });
      });
      const provider = this.plugin.settings.externalEmbeddingProvider ?? "openai";
      const defaultModel = provider === "openai" ? "text-embedding-3-small" : provider === "cohere" ? "embed-english-v3.0" : provider === "google" ? "gemini-embedding-001" : "";
      new import_obsidian11.Setting(containerEl).setName("External embedding model").setDesc(`Model name for ${provider} (e.g., ${defaultModel}).`).addText(
        (text2) => text2.setPlaceholder(defaultModel).setValue(this.plugin.settings.externalEmbeddingModel ?? defaultModel).onChange(async (value) => {
          this.plugin.settings.externalEmbeddingModel = value;
          await this.plugin.saveSettings();
        })
      );
      if (provider === "google") {
        new import_obsidian11.Setting(containerEl).setName("Use batch embeddings (Google Gemini)").setDesc("Use batch endpoint for more efficient embedding of multiple queries.").addToggle(
          (toggle) => toggle.setValue(Boolean(this.plugin.settings.externalEmbeddingUseBatch)).onChange(async (value) => {
            this.plugin.settings.externalEmbeddingUseBatch = value;
            await this.plugin.saveSettings();
          })
        );
      }
      if (provider === "custom") {
        new import_obsidian11.Setting(containerEl).setName("Custom API URL").setDesc("Endpoint URL for your custom embedding API.").addText(
          (text2) => text2.setPlaceholder("https://api.example.com/embeddings").setValue(this.plugin.settings.externalEmbeddingApiUrl ?? "").onChange(async (value) => {
            this.plugin.settings.externalEmbeddingApiUrl = value;
            await this.plugin.saveSettings();
          })
        );
      }
      new import_obsidian11.Setting(containerEl).setName("Test connection").setDesc("Test the external embedding API connection.").addButton(
        (btn) => btn.setButtonText("Test").onClick(async () => {
          btn.setDisabled(true);
          btn.setButtonText("Testing...");
          try {
            const testQuery = "test";
            const response = await fetch(
              provider === "openai" ? "https://api.openai.com/v1/embeddings" : provider === "cohere" ? "https://api.cohere.ai/v1/embed" : provider === "google" ? `https://generativelanguage.googleapis.com/v1beta/models/${this.plugin.settings.externalEmbeddingModel || "gemini-embedding-001"}:embedContent?key=${this.plugin.settings.externalEmbeddingApiKey}` : this.plugin.settings.externalEmbeddingApiUrl || "",
              {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  ...provider !== "google" && provider !== "custom" ? { Authorization: `Bearer ${this.plugin.settings.externalEmbeddingApiKey}` } : {}
                },
                body: JSON.stringify(
                  provider === "openai" ? { model: this.plugin.settings.externalEmbeddingModel || "text-embedding-3-small", input: testQuery } : provider === "cohere" ? { model: this.plugin.settings.externalEmbeddingModel || "embed-english-v3.0", texts: [testQuery] } : provider === "google" ? { content: { parts: [{ text: testQuery }] } } : { text: testQuery }
                )
              }
            );
            if (response.ok) {
              new import_obsidian11.Notice("External embedding API connection successful!", 3e3);
            } else {
              const error2 = await response.text();
              new import_obsidian11.Notice(`External embedding API test failed: ${response.status} ${error2}`, 5e3);
            }
          } catch (error2) {
            new import_obsidian11.Notice(`External embedding API test failed: ${error2 instanceof Error ? error2.message : String(error2)}`, 5e3);
          } finally {
            btn.setDisabled(false);
            btn.setButtonText("Test");
          }
        })
      );
    }
    new import_obsidian11.Setting(containerEl).setName("Index chunk size (words)").setDesc("Controls how your notes are chunked for semantic retrieval. Larger chunks add more context but may reduce precision.").addText(
      (text2) => text2.setPlaceholder("500").setValue(String(this.plugin.settings.retrievalChunkWords ?? 500)).onChange(async (value) => {
        const parsed = parseInt(value, 10);
        if (Number.isFinite(parsed)) {
          this.plugin.settings.retrievalChunkWords = Math.max(200, Math.min(2e3, parsed));
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Index chunk overlap (words)").setDesc("Overlap helps preserve continuity between chunks.").addText(
      (text2) => text2.setPlaceholder("100").setValue(String(this.plugin.settings.retrievalChunkOverlapWords ?? 100)).onChange(async (value) => {
        const parsed = parseInt(value, 10);
        if (Number.isFinite(parsed)) {
          this.plugin.settings.retrievalChunkOverlapWords = Math.max(0, Math.min(500, parsed));
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Indexing heading level").setDesc("Preferred heading level used to split notes into coherent chunks for retrieval indexing. Falls back to word-window chunking if headings are missing.").addDropdown((dropdown) => {
      dropdown.addOption("h1", "H1 (#)");
      dropdown.addOption("h2", "H2 (##)");
      dropdown.addOption("h3", "H3 (###)");
      dropdown.addOption("none", "None (word chunks only)");
      dropdown.setValue(this.plugin.settings.retrievalChunkHeadingLevel ?? "h1");
      dropdown.onChange(async (value) => {
        this.plugin.settings.retrievalChunkHeadingLevel = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian11.Setting(containerEl).setName("Pause indexing").setDesc("Pauses background indexing for semantic retrieval.").addToggle(
      (toggle) => toggle.setValue(Boolean(this.plugin.settings.retrievalIndexPaused)).onChange(async (value) => {
        this.plugin.settings.retrievalIndexPaused = value;
        await this.plugin.saveSettings();
      })
    );
    const excluded = new Set((this.plugin.settings.retrievalExcludedFolders || []).map((p) => p.replace(/\\/g, "/")));
    const folders = this.plugin.vaultService.getAllFolderPaths();
    const exclusionsContainer = containerEl.createDiv({ cls: "writing-dashboard-exclusions" });
    new import_obsidian11.Setting(exclusionsContainer).setName("Exclude from retrieval").setDesc("Choose folders to exclude from retrieval and indexing. Obsidian configuration is always excluded.");
    const configDir = this.app.vault.configDir.replace(/\\/g, "/");
    new import_obsidian11.Setting(exclusionsContainer).setName(configDir).setDesc("Always excluded.").addToggle((toggle) => toggle.setValue(true).setDisabled(true));
    for (const folder of folders) {
      const normalized = folder.replace(/\\/g, "/");
      const isChecked = excluded.has(normalized);
      new import_obsidian11.Setting(exclusionsContainer).setName(normalized).addToggle(
        (toggle) => toggle.setValue(isChecked).onChange(async (value) => {
          const next = new Set(
            (this.plugin.settings.retrievalExcludedFolders || []).map((p) => p.replace(/\\/g, "/"))
          );
          if (value)
            next.add(normalized);
          else
            next.delete(normalized);
          this.plugin.settings.retrievalExcludedFolders = Array.from(next).sort((a, b) => a.localeCompare(b));
          await this.plugin.saveSettings();
        })
      );
    }
    const existingSet = new Set(folders.map((f) => f.replace(/\\/g, "/")));
    const missing = Array.from(excluded).filter((p) => p && !existingSet.has(p));
    if (missing.length > 0) {
      new import_obsidian11.Setting(exclusionsContainer).setName("Missing excluded folders").setHeading();
      for (const missingPath of missing.sort((a, b) => a.localeCompare(b))) {
        new import_obsidian11.Setting(exclusionsContainer).setName(missingPath).setDesc("This folder does not exist in the vault.").addButton(
          (btn) => btn.setButtonText("Remove").onClick(async () => {
            const next = new Set(
              (this.plugin.settings.retrievalExcludedFolders || []).map((p) => p.replace(/\\/g, "/"))
            );
            next.delete(missingPath);
            this.plugin.settings.retrievalExcludedFolders = Array.from(next).sort((a, b) => a.localeCompare(b));
            await this.plugin.saveSettings();
            this.display();
          })
        );
      }
    }
    new import_obsidian11.Setting(containerEl).setName("Smart Connections").setHeading();
    const templateSetting = new import_obsidian11.Setting(containerEl).setName("Smart Connections template").setDesc("Template file that uses {{smart-connections:similar:128}} to surface semantic matches. Executed automatically before each generation.").addText((text2) => {
      text2.setPlaceholder("Writing Dashboard Templates/SC-Template.md").setValue(this.plugin.settings.smartConnectionsTemplatePath || "").setDisabled(true);
      text2.inputEl.style.opacity = "0.7";
    }).addButton((btn) => {
      btn.setButtonText("Auto-generate").setCta().onClick(async () => {
        btn.setButtonText("Generating...").setDisabled(true);
        try {
          const templatePath = await this.plugin.ensureSmartConnectionsTemplate();
          new import_obsidian11.Notice(`Template created: ${templatePath}`, 3e3);
          this.display();
        } catch (error2) {
          new import_obsidian11.Notice(`Failed to create template: ${error2 instanceof Error ? error2.message : String(error2)}`, 5e3);
          btn.setButtonText("Auto-generate").setDisabled(false);
        }
      });
    }).addButton((btn) => {
      btn.setButtonText("Browse").onClick(async () => {
        const files = this.app.vault.getMarkdownFiles();
        const modal = new FilePickerModal({
          app: this.app,
          files,
          placeholder: "Select template file...",
          onPick: async (file) => {
            this.plugin.settings.smartConnectionsTemplatePath = file.path;
            await this.plugin.saveSettings();
            this.display();
          }
        });
        modal.open();
      });
    });
    if (this.plugin.settings.smartConnectionsTemplatePath) {
      const templateFile = this.app.vault.getAbstractFileByPath(this.plugin.settings.smartConnectionsTemplatePath);
      const statusDesc = templateFile instanceof import_obsidian11.TFile ? `Template file exists and is configured. Contains: {{smart-connections:similar:128}}` : `Template path configured but file not found: ${this.plugin.settings.smartConnectionsTemplatePath}`;
      const infoBox = containerEl.createDiv({ cls: "writing-dashboard-info-box" });
      infoBox.createEl("p", { text: statusDesc });
    } else {
      const infoBox = containerEl.createDiv({ cls: "writing-dashboard-info-box" });
      infoBox.createEl("p", {
        text: 'Click "Auto-generate" to create the template file automatically. The template will be created at Writing Dashboard Templates/SC-Template.md in your vault root.'
      });
    }
    new import_obsidian11.Setting(containerEl).setName("Generation logs").setHeading();
    new import_obsidian11.Setting(containerEl).setName("Save generation logs").setDesc("Writes a log note per generation run with inputs, retrieved context, and output. Logs are excluded from retrieval.").addToggle(
      (toggle) => toggle.setValue(Boolean(this.plugin.settings.generationLogsEnabled)).onChange(async (value) => {
        this.plugin.settings.generationLogsEnabled = value;
        await this.plugin.saveSettings();
        if (value) {
          const folderPath = this.plugin.settings.generationLogsFolder || "";
          const folder = this.app.vault.getAbstractFileByPath(folderPath);
          if (!folderPath || !(folder instanceof import_obsidian11.TFolder)) {
            const modal = new FolderTreePickerModal(this.plugin, {
              currentPath: folderPath || void 0,
              title: "Select or create generation logs folder",
              onPick: async (selectedPath) => {
                this.plugin.settings.generationLogsFolder = selectedPath;
                await this.plugin.saveSettings();
                this.display();
              }
            });
            modal.open();
          }
        }
      })
    );
    const generationLogsFolderSetting = new import_obsidian11.Setting(containerEl).setName("Generation logs folder").setDesc(`Current: ${this.plugin.settings.generationLogsFolder || "(none selected)"}`).addButton((button) => button.setButtonText(this.plugin.settings.generationLogsFolder ? this.plugin.settings.generationLogsFolder.split("/").pop() || "Select folder" : "Select folder").onClick(() => {
      const modal = new FolderTreePickerModal(this.plugin, {
        currentPath: this.plugin.settings.generationLogsFolder || void 0,
        title: "Select or create generation logs folder",
        onPick: async (folderPath) => {
          this.plugin.settings.generationLogsFolder = folderPath;
          await this.plugin.saveSettings();
          this.display();
        }
      });
      modal.open();
    }));
    new import_obsidian11.Setting(containerEl).setName("Include full prompt in logs").setDesc("If enabled, logs include the full prompt text that was sent to the model.").addToggle(
      (toggle) => toggle.setValue(Boolean(this.plugin.settings.generationLogsIncludePrompt)).onChange(async (value) => {
        this.plugin.settings.generationLogsIncludePrompt = value;
        await this.plugin.saveSettings();
      })
    );
    if (this.plugin.settings.generationMode === "multi") {
      new import_obsidian11.Setting(containerEl).setName("Multi-mode strategy").setDesc("Draft + revision: fast draft + quality revision. Consensus + multi-stage: maximum quality (slower, more expensive).").addDropdown((dropdown) => dropdown.addOption("draft-revision", "Draft + revision").addOption("consensus-multistage", "Consensus + multi-stage (maximum quality)").setValue(this.plugin.settings.multiStrategy).onChange(async (value) => {
        this.plugin.settings.multiStrategy = value;
        await this.plugin.saveSettings();
        this.display();
      }));
      if (this.plugin.settings.multiStrategy === "draft-revision") {
        new import_obsidian11.Setting(containerEl).setName("Draft model").setDesc("Fast model for initial draft").addDropdown((dropdown) => {
          const models = getModelsForProvider(this.plugin.settings.apiProvider);
          models.forEach((model) => {
            dropdown.addOption(model.value, model.label);
          });
          dropdown.setValue(this.plugin.settings.draftModel || models[0].value);
          dropdown.onChange(async (value) => {
            this.plugin.settings.draftModel = value;
            await this.plugin.saveSettings();
          });
        });
        new import_obsidian11.Setting(containerEl).setName("Revision model").setDesc("Quality model for refinement").addDropdown((dropdown) => {
          const models = getModelsForProvider(this.plugin.settings.apiProvider);
          models.forEach((model) => {
            dropdown.addOption(model.value, model.label);
          });
          dropdown.setValue(this.plugin.settings.revisionModel || models[0].value);
          dropdown.onChange(async (value) => {
            this.plugin.settings.revisionModel = value;
            await this.plugin.saveSettings();
          });
        });
      } else {
        new import_obsidian11.Setting(containerEl).setName("Consensus model 1").setDesc("Primary model for consensus generation").addDropdown((dropdown) => {
          const models = getModelsForProvider(this.plugin.settings.apiProvider);
          models.forEach((model) => {
            dropdown.addOption(model.value, model.label);
          });
          dropdown.setValue(this.plugin.settings.consensusModel1 || models[0].value);
          dropdown.onChange(async (value) => {
            this.plugin.settings.consensusModel1 = value;
            await this.plugin.saveSettings();
          });
        });
        new import_obsidian11.Setting(containerEl).setName("Consensus model 2").setDesc("Second model for consensus generation").addDropdown((dropdown) => {
          const models = getModelsForProvider(this.plugin.settings.apiProvider);
          models.forEach((model) => {
            dropdown.addOption(model.value, model.label);
          });
          dropdown.setValue(this.plugin.settings.consensusModel2 || (models.length > 1 ? models[1].value : models[0].value));
          dropdown.onChange(async (value) => {
            this.plugin.settings.consensusModel2 = value;
            await this.plugin.saveSettings();
          });
        });
        new import_obsidian11.Setting(containerEl).setName("Consensus model 3 (optional)").setDesc("Third model for stronger consensus (optional)").addDropdown((dropdown) => {
          dropdown.addOption("", "None");
          const models = getModelsForProvider(this.plugin.settings.apiProvider);
          models.forEach((model) => {
            dropdown.addOption(model.value, model.label);
          });
          dropdown.setValue(this.plugin.settings.consensusModel3 || "");
          dropdown.onChange(async (value) => {
            this.plugin.settings.consensusModel3 = value || void 0;
            await this.plugin.saveSettings();
          });
        });
        new import_obsidian11.Setting(containerEl).setName("Synthesis model").setDesc("Model to synthesize final output from consensus").addDropdown((dropdown) => {
          const models = getModelsForProvider(this.plugin.settings.apiProvider);
          models.forEach((model) => {
            dropdown.addOption(model.value, model.label);
          });
          dropdown.setValue(this.plugin.settings.synthesisModel || models[0].value);
          dropdown.onChange(async (value) => {
            this.plugin.settings.synthesisModel = value;
            await this.plugin.saveSettings();
          });
        });
      }
    }
    new import_obsidian11.Setting(containerEl).setName("Vault path").setDesc("Path to your Obsidian vault (auto-detected)").addText((text2) => text2.setPlaceholder("Vault path").setValue(this.plugin.settings.vaultPath).onChange(async (value) => {
      this.plugin.settings.vaultPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian11.Setting(containerEl).setName("Setup wizard").setDesc("Create default files and folders for your writing workspace").addButton((button) => button.setButtonText("Run setup wizard").onClick(() => {
      const modal = new SetupWizardModal(this.plugin);
      modal.open();
    }));
    new import_obsidian11.Setting(containerEl).setName("Guided demo").setDesc("Generate demo-only text to learn the workflow (chapter \u2192 micro edit \u2192 character update).").addButton(
      (button) => button.setButtonText("Run guided demo").onClick(() => {
        this.plugin.requestGuidedDemoStart();
      })
    );
    const characterFolderSetting = new import_obsidian11.Setting(containerEl).setName("Character folder").setDesc(`Current: ${this.plugin.settings.characterFolder || "(none selected)"}`).addButton((button) => button.setButtonText(this.plugin.settings.characterFolder ? this.plugin.settings.characterFolder.split("/").pop() || "Select folder" : "Select folder").onClick(() => {
      const modal = new FolderTreePickerModal(this.plugin, {
        currentPath: this.plugin.settings.characterFolder || void 0,
        title: "Select or create character folder",
        onPick: async (folderPath) => {
          this.plugin.settings.characterFolder = folderPath;
          await this.plugin.saveSettings();
          this.display();
        }
      });
      modal.open();
    }));
    new import_obsidian11.Setting(containerEl).setName("Book main file").setDesc(`Current: ${this.plugin.settings.book2Path || "(none selected)"}`).addButton((button) => button.setButtonText(this.plugin.settings.book2Path ? this.plugin.settings.book2Path.split("/").pop() || "Select book file" : "Select book file").onClick(() => {
      const modal = new FileTreePickerModal(this.plugin, {
        currentPath: this.plugin.settings.book2Path,
        onPick: async (filePath) => {
          this.plugin.settings.book2Path = filePath;
          await this.plugin.saveSettings();
          this.display();
        }
      });
      modal.open();
    }));
    const storyBibleSetting = new import_obsidian11.Setting(containerEl).setName("Story bible path").setDesc(`Current: ${this.plugin.settings.storyBiblePath || "(none selected)"}`).addButton((button) => button.setButtonText(this.plugin.settings.storyBiblePath ? this.plugin.settings.storyBiblePath.split("/").pop() || "Select story bible" : "Select story bible").onClick(() => {
      const modal = new FileTreePickerModal(this.plugin, {
        currentPath: this.plugin.settings.storyBiblePath,
        onPick: async (filePath) => {
          this.plugin.settings.storyBiblePath = filePath;
          await this.plugin.saveSettings();
          this.display();
        }
      });
      modal.open();
    }));
    new import_obsidian11.Setting(containerEl).setName("Character extraction chunk size (words)").setDesc('Used by "process entire book" to batch character extraction. Larger chunks (e.g., 2000\u20133000) tend to improve character context.').addText((text2) => text2.setPlaceholder("2500").setValue(String(this.plugin.settings.characterExtractionChunkSize ?? 2500)).onChange(async (value) => {
      const parsed = parseInt(value, 10);
      const clamped = Number.isFinite(parsed) ? Math.min(1e4, Math.max(250, parsed)) : 2500;
      this.plugin.settings.characterExtractionChunkSize = clamped;
      await this.plugin.saveSettings();
    }));
    new import_obsidian11.Setting(containerEl).setName("Default character extraction instructions").setDesc("Used by character update (selected text). If the extraction instructions box is empty/invalid, this default is used instead.").addTextArea((text2) => text2.setPlaceholder("Character update instructions...").setValue(this.plugin.settings.defaultCharacterExtractionInstructions || "").onChange(async (value) => {
      this.plugin.settings.defaultCharacterExtractionInstructions = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian11.Setting(containerEl).setName("Context token limit (warning)").setDesc("Shows a warning before generating if the estimated prompt tokens exceed this limit. Default: 128000.").addText((text2) => text2.setPlaceholder("128000").setValue(String(this.plugin.settings.contextTokenLimit ?? 128e3)).onChange(async (value) => {
      const parsed = parseInt(value, 10);
      const clamped = Number.isFinite(parsed) ? Math.min(2e6, Math.max(1e3, parsed)) : 128e3;
      this.plugin.settings.contextTokenLimit = clamped;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "Developer Tools" });
    new import_obsidian11.Setting(containerEl).setName("Run Stress Test").setDesc("Comprehensive test of all plugin features. Creates temporary test files, runs all operations, then cleans up automatically. Log is saved as a note in your vault.").addButton((button) => button.setButtonText("Start Stress Test").setCta().onClick(async () => {
      button.setDisabled(true);
      button.setButtonText("Running...");
      try {
        const stressTest = new StressTestService(this.plugin);
        const logContent = await stressTest.runFullStressTest();
        const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, -5);
        const logFileName = `Stress Test Log - ${timestamp}.md`;
        const logPath = logFileName;
        await this.plugin.app.vault.create(logPath, logContent);
        new import_obsidian11.Notice(`Stress test completed! Log saved to: ${logFileName}`);
        const logFile = this.plugin.app.vault.getAbstractFileByPath(logPath);
        if (logFile instanceof import_obsidian11.TFile) {
          await this.app.workspace.openLinkText(logPath, "", true);
        }
      } catch (error2) {
        new import_obsidian11.Notice(`Stress test failed: ${error2 instanceof Error ? error2.message : String(error2)}`);
        console.error("Stress test error:", error2);
      } finally {
        button.setDisabled(false);
        button.setButtonText("Start Stress Test");
      }
    }));
  }
};

// services/VaultService.ts
var import_obsidian14 = require("obsidian");

// services/CharacterNameResolver.ts
var import_obsidian12 = require("obsidian");
function normalizeForMatch(name2) {
  return (name2 || "").toLowerCase().trim().replace(/[-_]+/g, " ").replace(/[^\p{L}\p{N}\s]/gu, "").replace(/\s+/g, " ").trim();
}
function levenshtein(a, b) {
  if (a === b)
    return 0;
  if (!a)
    return b.length;
  if (!b)
    return a.length;
  const m = a.length;
  const n = b.length;
  const dp = new Array(n + 1);
  for (let j = 0; j <= n; j++)
    dp[j] = j;
  for (let i = 1; i <= m; i++) {
    let prev = dp[0];
    dp[0] = i;
    for (let j = 1; j <= n; j++) {
      const tmp = dp[j];
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      dp[j] = Math.min(
        dp[j] + 1,
        // delete
        dp[j - 1] + 1,
        // insert
        prev + cost
        // substitute
      );
      prev = tmp;
    }
  }
  return dp[n];
}
function similarityScore(a, b) {
  const na = normalizeForMatch(a);
  const nb = normalizeForMatch(b);
  if (!na || !nb)
    return 0;
  if (na === nb)
    return 1;
  const dist = levenshtein(na, nb);
  const maxLen = Math.max(na.length, nb.length) || 1;
  return 1 - dist / maxLen;
}
function listCharacterBasenames(vault, folderPath) {
  const folder = vault.getAbstractFileByPath(folderPath);
  if (!(folder instanceof import_obsidian12.TFolder))
    return [];
  const names = [];
  for (const child of folder.children) {
    if (child instanceof import_obsidian12.TFile && child.extension === "md") {
      names.push(child.basename);
    }
  }
  return names;
}
var CharacterNameResolver = class {
  constructor(vault, characterFolder) {
    this.vault = vault;
    this.characterFolder = characterFolder;
  }
  resolve(proposedName) {
    const proposed = (proposedName || "").trim();
    if (!proposed)
      return { needsConfirmation: { proposedName, candidates: [] } };
    const existing = listCharacterBasenames(this.vault, this.characterFolder);
    if (existing.length === 0) {
      return { needsConfirmation: { proposedName: proposed, candidates: [] } };
    }
    const normalized = normalizeForMatch(proposed);
    const exact = existing.find((e) => normalizeForMatch(e) === normalized);
    if (exact)
      return { resolvedName: exact };
    const ranked = existing.map((e) => ({ name: e, score: similarityScore(proposed, e) })).sort((a, b) => b.score - a.score);
    const best = ranked[0];
    if (best && best.score >= 0.92) {
      return { resolvedName: best.name };
    }
    const candidates = ranked.filter((r) => r.score >= 0.78).slice(0, 5).map((r) => r.name);
    return {
      needsConfirmation: {
        proposedName: proposed,
        candidates
      }
    };
  }
};

// ui/CharacterNameConflictModal.ts
var import_obsidian13 = require("obsidian");
function showCharacterNameConflictModal(app, opts) {
  return new Promise((resolve) => {
    let settled = false;
    const settle = (value) => {
      if (settled)
        return;
      settled = true;
      resolve(value);
    };
    const modal = new class extends import_obsidian13.Modal {
      constructor() {
        super(...arguments);
        this.selected = null;
      }
      onOpen() {
        this.titleEl.setText(opts.title);
        this.contentEl.createEl("p", { text: opts.message });
        this.contentEl.createEl("p", { text: `Proposed name: ${opts.proposedName}` });
        if (opts.candidates.length) {
          this.contentEl.createEl("p", { text: "Select an existing character note:" });
          for (const c of opts.candidates) {
            new import_obsidian13.Setting(this.contentEl).setName(c).addButton((btn) => {
              btn.setButtonText("Use");
              btn.setCta();
              btn.onClick(() => {
                this.selected = c;
                settle({ type: "existing", name: c });
                this.close();
              });
            });
          }
        }
        new import_obsidian13.Setting(this.contentEl).setName("Create a new character note").setDesc("Use the proposed name as a new file in your character folder.").addButton((btn) => {
          btn.setButtonText("Create new");
          btn.onClick(() => {
            settle({ type: "create", name: opts.proposedName });
            this.close();
          });
        });
        new import_obsidian13.Setting(this.contentEl).addButton((btn) => {
          btn.setButtonText("Cancel");
          btn.onClick(() => {
            settle(null);
            this.close();
          });
        });
      }
      onClose() {
        settle(null);
        this.contentEl.empty();
      }
    }(app);
    modal.open();
  });
}

// services/VaultService.ts
var VaultService = class {
  constructor(vault, plugin) {
    this.vault = vault;
    this.plugin = plugin;
  }
  async readFile(path) {
    const file = this.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian14.TFile) {
      return await this.vault.read(file);
    }
    throw new Error(`File not found: ${path}`);
  }
  async writeFile(path, content) {
    await this.vault.adapter.write(path, content);
  }
  async createFileIfNotExists(path, content) {
    const file = this.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian14.TFile) {
      return false;
    }
    await this.vault.create(path, content);
    return true;
  }
  async createFolderIfNotExists(path) {
    const folder = this.vault.getAbstractFileByPath(path);
    if (folder instanceof import_obsidian14.TFolder) {
      return false;
    }
    await this.vault.createFolder(path);
    return true;
  }
  /**
   * Ensure the parent folder of a file path exists. Creates it if missing.
   * Handles root-level files (no parent folder needed).
   */
  async ensureParentFolder(filePath) {
    const normalized = filePath.replace(/\\/g, "/");
    const lastSlash = normalized.lastIndexOf("/");
    if (lastSlash === -1) {
      return;
    }
    const parentPath = normalized.substring(0, lastSlash);
    if (parentPath) {
      await this.createFolderIfNotExists(parentPath);
    }
  }
  /**
   * Find the latest story bible file in a folder matching the pattern "Story bible - *.md"
   * Returns the path of the latest file by modification time, or null if none found.
   */
  findLatestStoryBible(folderPath) {
    const folder = this.vault.getAbstractFileByPath(folderPath);
    if (!(folder instanceof import_obsidian14.TFolder)) {
      return null;
    }
    const storyBibleFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian14.TFile && child.extension === "md") {
        if (child.basename.match(/^Story bible/i)) {
          storyBibleFiles.push(child);
        }
      }
    }
    if (storyBibleFiles.length === 0) {
      return null;
    }
    storyBibleFiles.sort((a, b) => {
      const aTime = a.stat?.mtime || 0;
      const bTime = b.stat?.mtime || 0;
      return bTime - aTime;
    });
    return storyBibleFiles[0].path;
  }
  async setupDefaultStructure(items) {
    const created = [];
    const skipped = [];
    for (const item of items) {
      if (item.type === "file") {
        const wasCreated = await this.createFileIfNotExists(item.path, item.content || "");
        if (wasCreated) {
          created.push(item.path);
        } else {
          skipped.push(item.path);
        }
      } else {
        const wasCreated = await this.createFolderIfNotExists(item.path);
        if (wasCreated) {
          created.push(item.path);
        } else {
          skipped.push(item.path);
        }
      }
    }
    return { created, skipped };
  }
  /**
   * Chunk a file into 500-word chunks and save them in a chunked folder
   * @param sourceFilePath Path to the source file (e.g., "Book-Main.md")
   * @param text Text content to chunk
   * @param wordsPerChunk Number of words per chunk (default: 500)
   * @param overwrite If true, overwrites existing chunk files and deletes extra old chunks
   * @returns Stats about what was written/skipped/deleted
   */
  async chunkFile(sourceFilePath, text2, wordsPerChunk = 500, overwrite = false) {
    const baseName = sourceFilePath.replace(/\.md$/, "").replace(/\.\w+$/, "");
    const chunkedFolderName = `${baseName}-Chunked`;
    const chunks = TextChunker.chunkText(text2, wordsPerChunk);
    await this.createFolderIfNotExists(chunkedFolderName);
    const filePaths = [];
    let created = 0;
    let overwrittenCount = 0;
    let skipped = 0;
    for (let i = 0; i < chunks.length; i++) {
      const chunkNumber = String(i + 1).padStart(3, "0");
      const chunkFileName = `${baseName}-CHUNK-${chunkNumber}.md`;
      const chunkFilePath = `${chunkedFolderName}/${chunkFileName}`;
      const existing = this.vault.getAbstractFileByPath(chunkFilePath);
      if (overwrite) {
        if (existing instanceof import_obsidian14.TFile) {
          await this.vault.modify(existing, chunks[i]);
          overwrittenCount++;
        } else {
          const wasCreated = await this.createFileIfNotExists(chunkFilePath, chunks[i]);
          if (wasCreated)
            created++;
        }
      } else {
        if (existing instanceof import_obsidian14.TFile) {
          skipped++;
        } else {
          const wasCreated = await this.createFileIfNotExists(chunkFilePath, chunks[i]);
          if (wasCreated)
            created++;
        }
      }
      filePaths.push(chunkFilePath);
    }
    let deletedExtra = 0;
    if (overwrite) {
      const folder = this.vault.getAbstractFileByPath(chunkedFolderName);
      if (folder instanceof import_obsidian14.TFolder) {
        const maxIndex = chunks.length;
        const regex = new RegExp(`^${this._escapeRegExp(baseName)}-CHUNK-(\\d{3})\\.md$`);
        for (const child of folder.children) {
          if (!(child instanceof import_obsidian14.TFile) || child.extension !== "md")
            continue;
          const match2 = child.name.match(regex);
          if (!match2)
            continue;
          const idx = parseInt(match2[1], 10);
          if (Number.isFinite(idx) && idx > maxIndex) {
            await this.vault.delete(child);
            deletedExtra++;
          }
        }
      }
    }
    return {
      folder: chunkedFolderName,
      totalChunks: chunks.length,
      created,
      overwritten: overwrittenCount,
      skipped,
      deletedExtra,
      filePaths
    };
  }
  _escapeRegExp(value) {
    return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  async updateCharacterNotes(updates, folderOverride) {
    const characterFolder = folderOverride || this.plugin.settings.characterFolder;
    const resolver = new CharacterNameResolver(this.vault, characterFolder);
    const sessionResolutions = /* @__PURE__ */ new Map();
    await this.createFolderIfNotExists(characterFolder);
    for (const { character, update } of updates) {
      const proposed = (character || "").trim();
      if (!proposed)
        continue;
      const cached = sessionResolutions.get(proposed);
      let resolvedName = cached;
      if (!resolvedName) {
        const res = resolver.resolve(proposed);
        if (res.resolvedName) {
          resolvedName = res.resolvedName;
        } else if (res.needsConfirmation) {
          const choice = await showCharacterNameConflictModal(this.plugin.app, {
            title: "Confirm character note",
            message: "Choose an existing character note to update, or create a new one.",
            proposedName: res.needsConfirmation.proposedName,
            candidates: res.needsConfirmation.candidates
          });
          if (!choice)
            continue;
          resolvedName = choice.name;
        } else {
          resolvedName = proposed;
        }
        sessionResolutions.set(proposed, resolvedName);
      }
      const characterPath = `${characterFolder}/${resolvedName}.md`;
      let existingContent = "";
      try {
        existingContent = await this.readFile(characterPath);
      } catch {
      }
      const now = new Date();
      const timestamp = now.toLocaleString("en-US", {
        month: "long",
        day: "numeric",
        year: "numeric",
        hour: "numeric",
        minute: "2-digit",
        hour12: true
      });
      const newContent = existingContent ? `${existingContent}

## ${timestamp} - Update

${update}
` : `# ${resolvedName}

## ${timestamp} - Update

${update}
`;
      await this.writeFile(characterPath, newContent);
    }
  }
  getVaultStructure() {
    const structure = [];
    const root = this.vault.getRoot();
    this._traverseFolder(root, structure, "");
    return structure;
  }
  /**
   * List all folder paths in the vault (relative paths). Sorted for stable UI.
   */
  getAllFolderPaths() {
    const folders = [];
    const root = this.vault.getRoot();
    this._collectFolders(root, folders, "");
    return folders.sort((a, b) => a.localeCompare(b));
  }
  /**
   * `.obsidian/` is always excluded from retrieval/indexing.
   */
  isExcludedPath(path) {
    const normalized = path.replace(/\\/g, "/");
    const configDir = this.vault.configDir.replace(/\\/g, "/");
    if (normalized === configDir || normalized.startsWith(`${configDir}/`))
      return true;
    const logsFolder = (this.plugin.settings.generationLogsFolder || "").replace(/\\/g, "/").replace(/\/+$/, "");
    if (logsFolder) {
      if (normalized === logsFolder || normalized.startsWith(`${logsFolder}/`))
        return true;
    }
    const profiles = this.plugin.settings.retrievalProfiles || [];
    const activeId = this.plugin.settings.retrievalActiveProfileId;
    const active = profiles.find((p) => p.id === activeId);
    const includes = (active?.includedFolders || []).map((p) => (p || "").replace(/\\/g, "/").replace(/\/+$/, "")).filter((p) => p.length > 0);
    if (includes.length > 0) {
      const allowed = includes.some((inc) => {
        return normalized === inc || normalized.startsWith(`${inc}/`);
      });
      if (!allowed)
        return true;
    }
    const excluded = this.plugin.settings.retrievalExcludedFolders || [];
    for (const folder of excluded) {
      const f = folder.replace(/\\/g, "/").replace(/\/+$/, "");
      if (!f)
        continue;
      if (normalized === f || normalized.startsWith(`${f}/`))
        return true;
    }
    return false;
  }
  getIncludedMarkdownFiles() {
    return this.vault.getMarkdownFiles().filter((f) => !this.isExcludedPath(f.path));
  }
  _traverseFolder(folder, structure, basePath) {
    for (const child of folder.children) {
      const path = basePath ? `${basePath}/${child.name}` : child.name;
      if (child instanceof import_obsidian14.TFolder) {
        structure.push({ name: child.name, path, type: "folder" });
        this._traverseFolder(child, structure, path);
      } else if (child instanceof import_obsidian14.TFile) {
        structure.push({ name: child.name, path, type: "file" });
      }
    }
  }
  _collectFolders(folder, folders, basePath) {
    for (const child of folder.children) {
      if (!(child instanceof import_obsidian14.TFolder))
        continue;
      const path = basePath ? `${basePath}/${child.name}` : child.name;
      folders.push(path);
      this._collectFolders(child, folders, path);
    }
  }
};

// services/ContextAggregator.ts
var import_obsidian16 = require("obsidian");

// services/TemplateExecutor.ts
var import_obsidian15 = require("obsidian");
var TemplateInsertPrompt = class extends import_obsidian15.Modal {
  constructor(app, onRun) {
    super(app);
    this.onRun = onRun;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h3", { text: "Run Smart Connections template" });
    contentEl.createEl("p", {
      text: "Click below to run Templates: Insert Template so Smart Connections can process {{smart-connections:similar:#}}."
    });
    new import_obsidian15.Setting(contentEl).addButton((btn) => btn.setButtonText("Run Templates: Insert Template").setCta().onClick(async () => {
      try {
        await this.onRun();
      } finally {
        this.close();
      }
    })).addExtraButton((btn) => btn.setIcon("cross").setTooltip("Cancel").onClick(() => this.close()));
  }
};
var TemplateExecutor = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
  }
  /**
   * Execute a template file and return the rendered output.
   * Tries multiple approaches:
   * 1. Native Obsidian template insertion (for Smart Connections compatibility)
   * 2. Custom TemplateProcessor (fallback)
   */
  async executeTemplate(templatePath, activeFile) {
    const templateFile = this.app.vault.getAbstractFileByPath(templatePath);
    if (!(templateFile instanceof import_obsidian15.TFile)) {
      throw new Error(`Template file not found: ${templatePath}`);
    }
    console.log(`[TemplateExecutor] \u{1F680} Executing template: ${templatePath}`);
    console.log("[TemplateExecutor] \u{1F4DD} Prompting user to run Templates: Insert Template...");
    try {
      const userResult = await this.executeNativeTemplateWithPrompt(templateFile);
      if (userResult) {
        const hasUnprocessedSC = /\{\{smart-connections:similar:(\d+)\}\}/g.test(userResult);
        if (!hasUnprocessedSC) {
          console.log("[TemplateExecutor] \u2705 User-driven template insertion succeeded and Smart Connections processed it!");
          return userResult;
        } else {
          const scMatches = userResult.match(/\{\{smart-connections:similar:(\d+)\}\}/g);
          console.log("[TemplateExecutor] \u26A0\uFE0F User-driven insertion succeeded but Smart Connections syntax still present");
          console.log(`[TemplateExecutor] \u{1F50D} Diagnostic: Found ${scMatches?.length || 0} unprocessed Smart Connections placeholders`);
          console.log("[TemplateExecutor] \u{1F504} Trying automated native insertion next...");
        }
      } else {
        console.log("[TemplateExecutor] \u26A0\uFE0F User-driven insertion returned empty result");
        console.log("[TemplateExecutor] \u{1F504} Trying automated native insertion next...");
      }
    } catch (error2) {
      const errorMsg = error2 instanceof Error ? error2.message : String(error2);
      console.warn(`[TemplateExecutor] \u26A0\uFE0F User-driven insertion failed: ${errorMsg}`);
      console.log("[TemplateExecutor] \u{1F504} Trying automated native insertion next...");
    }
    console.log("[TemplateExecutor] \u{1F4DD} Attempting automated native template insertion...");
    try {
      const nativeResult = await this.executeNativeTemplate(templateFile, activeFile);
      if (nativeResult) {
        const hasUnprocessedSC = /\{\{smart-connections:similar:(\d+)\}\}/g.test(nativeResult);
        if (!hasUnprocessedSC) {
          console.log("[TemplateExecutor] \u2705 Automated native insertion succeeded and Smart Connections processed it!");
          return nativeResult;
        } else {
          const scMatches = nativeResult.match(/\{\{smart-connections:similar:(\d+)\}\}/g);
          console.log("[TemplateExecutor] \u26A0\uFE0F Automated native insertion succeeded but Smart Connections syntax still present");
          console.log(`[TemplateExecutor] \u{1F50D} Diagnostic: Found ${scMatches?.length || 0} unprocessed Smart Connections placeholders`);
          console.log("[TemplateExecutor] \u{1F504} Falling back to custom processor...");
        }
      } else {
        console.log("[TemplateExecutor] \u26A0\uFE0F Automated native insertion returned empty result");
        console.log("[TemplateExecutor] \u{1F50D} Diagnostic: Template may not have been inserted or file was empty");
        console.log("[TemplateExecutor] \u{1F504} Falling back to custom processor...");
      }
    } catch (error2) {
      const errorMsg = error2 instanceof Error ? error2.message : String(error2);
      console.warn(`[TemplateExecutor] \u26A0\uFE0F Automated native insertion failed: ${errorMsg}`);
      console.log(`[TemplateExecutor] \u{1F50D} Diagnostic: ${this.diagnoseNativeTemplateFailure(error2)}`);
      console.log("[TemplateExecutor] \u{1F504} Falling back to custom processor...");
    }
    console.log("[TemplateExecutor] \u{1F504} Using custom TemplateProcessor...");
    const processor = this.plugin.templateProcessorInstance;
    if (!processor) {
      throw new Error("TemplateProcessor not initialized. Please ensure the plugin has loaded.");
    }
    const templateContent = await this.app.vault.read(templateFile);
    console.log(`[TemplateExecutor] \u{1F4C4} Template content: ${templateContent.substring(0, 200)}...`);
    console.debug(`[TemplateExecutor] Template content: ${templateContent.substring(0, 200)}...`);
    const rendered = await processor.processTemplate(templateContent, { file: activeFile });
    const hookStatus = processor.getHookStatus();
    console.log("[TemplateExecutor] \u{1F4CA} Hook registration status:", hookStatus);
    console.debug("[TemplateExecutor] Hook registration status:", hookStatus);
    const testPath = `Template-Render-Test.md`;
    const existingFile = this.app.vault.getAbstractFileByPath(testPath);
    if (existingFile instanceof import_obsidian15.TFile) {
      await this.app.vault.delete(existingFile);
    }
    const testFile = await this.app.vault.create(testPath, rendered);
    await this.app.workspace.openLinkText(testPath, "", true);
    console.log(`[TemplateExecutor] \u2705 Template rendered: ${rendered.length} chars`);
    console.log(`[TemplateExecutor] \u{1F4C4} Rendered preview: ${rendered.substring(0, 500)}...`);
    console.debug(`[TemplateExecutor] Template rendered: ${rendered.length} chars`);
    console.debug(`[TemplateExecutor] Rendered content preview: ${rendered.substring(0, 500)}...`);
    return rendered;
  }
  /**
   * Diagnose why native template insertion failed
   * Returns detailed explanation of what happened and why
   */
  diagnoseNativeTemplateFailure(error2) {
    const errorMsg = error2 instanceof Error ? error2.message : String(error2);
    const appWithPlugins = this.app;
    const diagnostics = [];
    diagnostics.push(`EVENT: Native template insertion failed with error: "${errorMsg}"`);
    const templatesPlugin = appWithPlugins.internalPlugins?.plugins?.templates;
    if (!templatesPlugin) {
      diagnostics.push("ROOT CAUSE: Templates plugin not found in internalPlugins");
      diagnostics.push("WHY THIS FAILED: Cannot insert templates without the Templates core plugin");
      diagnostics.push("SOLUTION: Templates is a core plugin - if missing, this may be an Obsidian installation issue");
    } else if (!templatesPlugin.enabled) {
      diagnostics.push("ROOT CAUSE: Templates plugin exists but is not enabled");
      diagnostics.push("WHY THIS FAILED: Disabled core plugins do not provide their functionality");
      diagnostics.push("SOLUTION: Enable Templates plugin in Settings > Core plugins");
    } else if (!templatesPlugin.instance) {
      diagnostics.push("ROOT CAUSE: Templates plugin enabled but instance not available");
      diagnostics.push("WHY THIS FAILED: Plugin instance is required to call insertTemplate method");
      diagnostics.push("SOLUTION: This may be a timing issue - plugin may not be fully initialized yet");
    } else if (!templatesPlugin.instance.insertTemplate) {
      diagnostics.push("ROOT CAUSE: Templates plugin instance exists but insertTemplate method not found");
      diagnostics.push("WHY THIS FAILED: The method we need to call does not exist on the plugin instance");
      diagnostics.push("SOLUTION: Obsidian version may be incompatible or plugin API changed");
    } else {
      diagnostics.push("\u2713 Templates plugin is available and has insertTemplate method");
    }
    if (!appWithPlugins.commands) {
      diagnostics.push("\u26A0\uFE0F App commands API not available (fallback method unavailable)");
    } else if (!appWithPlugins.commands.executeCommandById) {
      diagnostics.push("\u26A0\uFE0F Command execution method not available (fallback method unavailable)");
    }
    const scPlugin = appWithPlugins.plugins?.plugins?.["smart-connections"];
    if (!scPlugin) {
      diagnostics.push("\u26A0\uFE0F Smart Connections plugin not detected (may not be installed)");
    } else if (!scPlugin.enabled) {
      diagnostics.push("\u26A0\uFE0F Smart Connections plugin found but not enabled");
    } else {
      diagnostics.push("\u2713 Smart Connections plugin is installed and enabled");
    }
    if (errorMsg.includes("not available")) {
      diagnostics.push("WHY THIS FAILED: Required API or method is not available in current Obsidian version");
    } else if (errorMsg.includes("not enabled")) {
      diagnostics.push("WHY THIS FAILED: Required plugin is not enabled in settings");
    } else if (errorMsg.includes("not found")) {
      diagnostics.push("WHY THIS FAILED: Required plugin or component not found");
    }
    return diagnostics.length > 0 ? diagnostics.join(" | ") : `Unknown error: ${errorMsg}`;
  }
  /**
   * Diagnose why template insertion method failed
   * Returns detailed explanation of what happened and why
   */
  diagnoseTemplateInsertionFailure(error2, templatesPlugin) {
    const errorMsg = error2 instanceof Error ? error2.message : String(error2);
    const diagnostics = [];
    diagnostics.push(`EVENT: Template insertion method failed with error: "${errorMsg}"`);
    if (!templatesPlugin.instance) {
      diagnostics.push("ROOT CAUSE: Templates plugin instance is null or undefined");
      diagnostics.push("WHY THIS FAILED: Cannot call methods on a null/undefined instance");
      diagnostics.push("SOLUTION: Plugin may not be fully initialized - try again or check plugin status");
    } else {
      const instanceMethods = Object.keys(templatesPlugin.instance).filter(
        (k) => typeof templatesPlugin.instance[k] === "function"
      );
      diagnostics.push(`\u2713 Available instance methods: ${instanceMethods.join(", ") || "none"}`);
      if (!templatesPlugin.instance.insertTemplate) {
        diagnostics.push("ROOT CAUSE: insertTemplate method not found on instance");
        diagnostics.push("WHY THIS FAILED: The method we need does not exist on the plugin instance");
        diagnostics.push("SOLUTION: Obsidian version may be incompatible or plugin API changed");
      } else {
        diagnostics.push("\u2713 insertTemplate method exists but call failed");
        diagnostics.push("WHY THIS FAILED: Method exists but threw an error when called");
        diagnostics.push("POSSIBLE REASONS: Invalid parameters, file permissions, or internal plugin error");
      }
    }
    if (errorMsg.includes("user interaction")) {
      diagnostics.push("ROOT CAUSE: Command requires manual user selection of template");
      diagnostics.push("WHY THIS FAILED: Templates command opens a modal that requires user input");
      diagnostics.push("SOLUTION: This approach cannot be automated - use direct insertTemplate method instead");
    }
    return diagnostics.length > 0 ? diagnostics.join(" | ") : `Error: ${errorMsg}`;
  }
  /**
   * User-driven native template insertion: prompts user to run the Templates command,
   * then reads the rendered file.
   */
  async executeNativeTemplateWithPrompt(templateFile) {
    const testPath = `Template-Render-Test.md`;
    const existingFile = this.app.vault.getAbstractFileByPath(testPath);
    if (existingFile instanceof import_obsidian15.TFile) {
      await this.app.vault.delete(existingFile);
    }
    const testFile = await this.app.vault.create(testPath, "");
    await this.app.workspace.openLinkText(testPath, "", true);
    await new Promise((resolve) => setTimeout(resolve, 300));
    const runTemplatesCommand = async () => {
      const appWithCommands = this.app;
      if (appWithCommands.commands?.executeCommandById) {
        await appWithCommands.commands.executeCommandById("templates:insert-template");
      } else {
        throw new Error("Commands API not available");
      }
    };
    await new Promise((resolve, reject) => {
      const modal = new TemplateInsertPrompt(this.app, async () => {
        try {
          await runTemplatesCommand();
          resolve();
        } catch (e) {
          reject(e);
        }
      });
      modal.open();
    });
    console.log("[TemplateExecutor] \u23F3 Waiting 5 seconds for Smart Connections to process (user-driven)...");
    await new Promise((resolve) => setTimeout(resolve, 5e3));
    const rendered = await this.app.vault.read(testFile);
    console.log("[TemplateExecutor] \u{1F4C4} User-driven native template rendered:", rendered.length, "chars");
    if (rendered.length > 0) {
      console.log("[TemplateExecutor] \u{1F4C4} Preview:", rendered.substring(0, 300));
    }
    return rendered;
  }
  /**
   * Execute template using Obsidian's native template insertion command.
   * This is how Text Generator likely does it, and Smart Connections hooks into this.
   */
  async executeNativeTemplate(templateFile, activeFile) {
    const testPath = `Template-Render-Test.md`;
    const existingFile = this.app.vault.getAbstractFileByPath(testPath);
    if (existingFile instanceof import_obsidian15.TFile) {
      await this.app.vault.delete(existingFile);
    }
    const testFile = await this.app.vault.create(testPath, "");
    const leaf = await this.app.workspace.openLinkText(testPath, "", true);
    await new Promise((resolve) => setTimeout(resolve, 500));
    const templatesPlugin = this.app.internalPlugins?.plugins?.templates;
    if (!templatesPlugin) {
      throw new Error("Templates plugin not found in internalPlugins");
    }
    if (!templatesPlugin.enabled) {
      throw new Error("Templates plugin is not enabled (enable it in Settings > Core plugins)");
    }
    if (!templatesPlugin.instance) {
      throw new Error("Templates plugin instance not available");
    }
    console.log("[TemplateExecutor] \u{1F4DD} Inserting template via Templates plugin...");
    console.log(`[TemplateExecutor] \u{1F50D} Diagnostic: Template file: ${templateFile.path}`);
    console.log(`[TemplateExecutor] \u{1F50D} Diagnostic: Target file: ${testFile.path}`);
    try {
      if (templatesPlugin.instance.insertTemplate) {
        console.log("[TemplateExecutor] \u{1F527} Using insertTemplate method...");
        console.log(`[TemplateExecutor] \u{1F50D} Diagnostic: insertTemplate method signature: ${typeof templatesPlugin.instance.insertTemplate}`);
        await templatesPlugin.instance.insertTemplate(testFile, templateFile.path);
        console.log("[TemplateExecutor] \u2705 Template inserted via insertTemplate method");
      } else if (this.app.commands?.executeCommandById) {
        console.log("[TemplateExecutor] \u{1F527} Attempting via command palette...");
        console.log("[TemplateExecutor] \u{1F50D} Diagnostic: insertTemplate method not found, trying command approach");
        await this.app.commands.executeCommandById("templates:insert-template");
        await new Promise((resolve) => setTimeout(resolve, 1e3));
        console.log("[TemplateExecutor] \u26A0\uFE0F Command executed (may require user interaction)");
        console.log("[TemplateExecutor] \u{1F50D} Diagnostic: Command-based insertion requires user to select template manually");
      } else {
        const availableMethods = Object.keys(templatesPlugin.instance || {}).filter(
          (k) => k.toLowerCase().includes("template") || k.toLowerCase().includes("insert")
        );
        throw new Error(`No template insertion method available. Available methods: ${availableMethods.join(", ") || "none found"}`);
      }
    } catch (error2) {
      const errorMsg = error2 instanceof Error ? error2.message : String(error2);
      console.warn(`[TemplateExecutor] \u26A0\uFE0F Template insertion method failed: ${errorMsg}`);
      console.log(`[TemplateExecutor] \u{1F50D} Diagnostic: ${this.diagnoseTemplateInsertionFailure(error2, templatesPlugin)}`);
      throw error2;
    }
    console.log("[TemplateExecutor] \u23F3 Waiting 5 seconds for Smart Connections to process...");
    await new Promise((resolve) => setTimeout(resolve, 5e3));
    const rendered = await this.app.vault.read(testFile);
    console.log("[TemplateExecutor] \u{1F4C4} Native template rendered:", rendered.length, "chars");
    if (rendered.length > 0) {
      console.log("[TemplateExecutor] \u{1F4C4} Preview:", rendered.substring(0, 300));
    }
    return rendered;
  }
  /**
   * Parse template output to extract file paths from Smart Connections results.
   * Smart Connections typically outputs markdown links like [[Note Name]] or [Note Name](path).
   */
  parseTemplateOutput(output) {
    const paths = [];
    const wikiLinkRegex = /\[\[([^\]]+)\]\]/g;
    let match2;
    while ((match2 = wikiLinkRegex.exec(output)) !== null) {
      const linkText = match2[1];
      const cleanLink = linkText.split("#")[0];
      const file = this.app.metadataCache.getFirstLinkpathDest(cleanLink, "");
      if (file) {
        paths.push(file.path);
      }
    }
    const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
    while ((match2 = markdownLinkRegex.exec(output)) !== null) {
      const linkPath = match2[2];
      const cleanPath = linkPath.split("#")[0];
      if (cleanPath && !cleanPath.startsWith("http")) {
        const file = this.app.vault.getAbstractFileByPath(cleanPath);
        if (file instanceof import_obsidian15.TFile) {
          paths.push(file.path);
        }
      }
    }
    return Array.from(new Set(paths));
  }
};

// services/ContextAggregator.ts
var ContextAggregator = class {
  budgetToChars(tokens) {
    return Math.max(0, Math.floor(tokens * 4));
  }
  trimHeadToBudget(text2, maxTokens, label) {
    if (!text2)
      return "";
    const maxChars = this.budgetToChars(maxTokens);
    if (text2.length <= maxChars)
      return text2;
    const trimmed = text2.slice(0, maxChars);
    return `${trimmed}

[${label}: truncated to ~${maxTokens.toLocaleString()} tokens]`;
  }
  trimTailToBudget(text2, maxTokens, label) {
    if (!text2)
      return "";
    const maxChars = this.budgetToChars(maxTokens);
    if (text2.length <= maxChars)
      return text2;
    const trimmed = text2.slice(-maxChars);
    return `[${label}: showing last ~${maxTokens.toLocaleString()} tokens]

` + trimmed;
  }
  computeContextBudgetTokens() {
    const limit = this.plugin.settings.contextTokenLimit ?? 128e3;
    const reserveForOutput = Math.min(2e4, Math.max(6e3, Math.floor(limit * 0.02)));
    const reserveForNonContext = Math.min(2e4, Math.max(4e3, Math.floor(limit * 0.02)));
    return { limit, reserveForOutput, reserveForNonContext };
  }
  constructor(vault, plugin, vaultService) {
    this.vault = vault;
    this.plugin = plugin;
    this.vaultService = vaultService;
    this.templateExecutor = new TemplateExecutor(plugin.app, plugin);
  }
  async getChapterContext(retrievalQuery) {
    const settings = this.plugin.settings;
    let scTemplatePaths = [];
    if (settings.smartConnectionsTemplatePath) {
      try {
        const activeFile = this.plugin.app.workspace.getActiveFile();
        const templateOutput = await this.templateExecutor.executeTemplate(
          settings.smartConnectionsTemplatePath,
          activeFile
        );
        scTemplatePaths = this.templateExecutor.parseTemplateOutput(templateOutput);
        console.debug(`[ContextAggregator] Smart Connections template returned ${scTemplatePaths.length} paths`);
      } catch (error2) {
        console.warn(`[ContextAggregator] Template execution failed:`, error2);
      }
    }
    const { limit, reserveForOutput, reserveForNonContext } = this.computeContextBudgetTokens();
    const contextBudget = Math.max(1e3, limit - reserveForOutput - reserveForNonContext);
    const retrievedLimit = Math.min(200, Math.max(24, Math.floor(contextBudget / 12e3)));
    const retrievedContext = await this.getRetrievedContext(retrievalQuery, retrievedLimit, scTemplatePaths);
    const book2Full = await this.readFile(settings.book2Path);
    const slidingWindow = this.extractWordsFromEnd(book2Full, 2e4);
    const storyBible = await this.readFile(settings.storyBiblePath);
    const smartBudget = Math.floor(contextBudget * 0.45);
    const bibleBudget = Math.floor(contextBudget * 0.25);
    const slidingBudget = Math.floor(contextBudget * 0.1);
    const result = {
      smart_connections: this.trimHeadToBudget(retrievedContext, smartBudget, "Retrieved context"),
      story_bible: this.trimHeadToBudget(storyBible, bibleBudget, "Story bible"),
      sliding_window: this.trimHeadToBudget(slidingWindow, slidingBudget, "Sliding window")
    };
    return result;
  }
  async getMicroEditContext(selectedText, retrievalQuery) {
    const settings = this.plugin.settings;
    const surrounding = await this.getSurroundingContext(selectedText, 500, 500);
    let scTemplatePaths = [];
    if (settings.smartConnectionsTemplatePath) {
      try {
        const activeFile = this.plugin.app.workspace.getActiveFile();
        const templateOutput = await this.templateExecutor.executeTemplate(
          settings.smartConnectionsTemplatePath,
          activeFile
        );
        scTemplatePaths = this.templateExecutor.parseTemplateOutput(templateOutput);
        console.debug(`[ContextAggregator] Smart Connections template returned ${scTemplatePaths.length} paths`);
      } catch (error2) {
        console.warn(`[ContextAggregator] Template execution failed:`, error2);
      }
    }
    const { limit, reserveForOutput, reserveForNonContext } = this.computeContextBudgetTokens();
    const contextBudget = Math.max(1e3, limit - reserveForOutput - reserveForNonContext);
    const book2Full = await this.readFile(settings.book2Path);
    const slidingWindow = this.extractWordsFromEnd(book2Full, 2e4);
    const storyBible = await this.readFile(settings.storyBiblePath);
    const characterNotes = this.formatCharacterNotes(await this.getAllCharacterNotes());
    const retrievedLimit = Math.min(80, Math.max(12, Math.floor(contextBudget / 2e4)));
    const retrievedContext = await this.getRetrievedContext(retrievalQuery, retrievedLimit, scTemplatePaths);
    const slidingBudget = Math.floor(contextBudget * 0.03);
    const bibleBudget = Math.floor(contextBudget * 0.25);
    const characterBudget = Math.floor(contextBudget * 0.37);
    const smartBudget = Math.floor(contextBudget * 0.2);
    const result = {
      sliding_window: this.trimHeadToBudget(slidingWindow, slidingBudget, "Sliding window"),
      story_bible: this.trimHeadToBudget(storyBible, bibleBudget, "Story bible"),
      character_notes: this.trimHeadToBudget(characterNotes, characterBudget, "Character notes"),
      smart_connections: this.trimHeadToBudget(retrievedContext, smartBudget, "Retrieved context"),
      surrounding_before: surrounding.before,
      surrounding_after: surrounding.after
    };
    return result;
  }
  async getCharacterNotes() {
    return await this.getAllCharacterNotes();
  }
  async readFile(path) {
    try {
      const file = this.vault.getAbstractFileByPath(path);
      if (file instanceof import_obsidian16.TFile) {
        return await this.vault.read(file);
      }
      return `[File not found: ${path}]`;
    } catch (error2) {
      const message = error2 instanceof Error ? error2.message : (() => {
        try {
          return JSON.stringify(error2);
        } catch {
          return "[unserializable error]";
        }
      })();
      return `[Error reading file ${path}: ${message}]`;
    }
  }
  formatRetrievedItems(items) {
    if (!items.length)
      return "[No retrieved context]";
    const lines = [];
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      lines.push(
        `[${i + 1}] ${item.path}
Score: ${item.score.toFixed(3)} (${item.source})
` + `${item.excerpt}`.trim()
      );
    }
    return lines.join("\n\n---\n\n");
  }
  async getRetrievedContext(query, limit, scTemplatePaths) {
    try {
      let results = await this.plugin.retrievalService.search(query, {
        limit: Math.max(1, Math.min(200, limit))
      }, scTemplatePaths);
      if (this.plugin.settings.retrievalEnableReranker) {
        try {
          results = await this.plugin.cpuReranker.rerank(query.text || "", results, { limit: Math.max(1, Math.min(200, limit)) });
        } catch {
        }
      }
      return this.formatRetrievedItems(results);
    } catch {
      return "[Retrieved context unavailable]";
    }
  }
  async getAllCharacterNotes() {
    const notes = {};
    const characterFolder = this.plugin.settings.characterFolder;
    try {
      const folder = this.vault.getAbstractFileByPath(characterFolder);
      if (folder instanceof import_obsidian16.TFolder) {
        for (const child of folder.children) {
          if (child instanceof import_obsidian16.TFile && child.extension === "md") {
            const characterName = child.basename;
            notes[characterName] = await this.vault.read(child);
          }
        }
      }
    } catch {
    }
    return notes;
  }
  formatCharacterNotes(characterNotes) {
    if (Object.keys(characterNotes).length === 0) {
      return "[No character notes found]";
    }
    const formatted = [];
    for (const [name2, content] of Object.entries(characterNotes)) {
      formatted.push(`## ${name2}
${content}
`);
    }
    return formatted.join("\n---\n\n");
  }
  // Helper method to extract words from text
  extractWords(text2, count) {
    const words = text2.trim().split(/\s+/);
    if (words.length <= count)
      return text2;
    return words.slice(0, count).join(" ");
  }
  // Helper method to extract words from the end of text
  extractWordsFromEnd(text2, count) {
    const words = text2.trim().split(/\s+/);
    if (words.length <= count)
      return text2;
    return words.slice(-count).join(" ");
  }
  // Get surrounding context (words before and after selected text)
  async getSurroundingContext(selectedText, wordsBefore = 500, wordsAfter = 500) {
    const settings = this.plugin.settings;
    let sourceText = "";
    try {
      sourceText = await this.readFile(settings.book2Path);
    } catch {
      return { before: "", after: "" };
    }
    const selectedIndex = sourceText.indexOf(selectedText);
    if (selectedIndex === -1) {
      return { before: "", after: "" };
    }
    const textBefore = sourceText.substring(0, selectedIndex);
    const beforeWords = this.extractWordsFromEnd(textBefore, wordsBefore);
    const textAfter = sourceText.substring(selectedIndex + selectedText.length);
    const afterWords = this.extractWords(textAfter, wordsAfter);
    return { before: beforeWords, after: afterWords };
  }
};

// services/PromptEngine.ts
var PromptEngine = class {
  buildChapterPrompt(context, rewriteInstructions, sceneSummary, minWords, maxWords) {
    return `SYSTEM INSTRUCTION FOR AI (1M CONTEXT):

You are working on a multi-book narrative. Interpret the following file contents as directed:

-------------------------------------------------------------
RETRIEVED CONTEXT \u2014 RELEVANT NOTES (WHOLE VAULT)
-------------------------------------------------------------
${context.smart_connections || ""}

Use these excerpts to maintain continuity, tone, and world consistency.

-------------------------------------------------------------
STORY BIBLE \u2014 WORLD + RULESET
-------------------------------------------------------------
${context.story_bible || ""}

These define rules of the world, character arcs, faction details, timelines, technology, tone, themes, motifs, and relationship structure.

-------------------------------------------------------------
SLIDING WINDOW \u2014 IMMEDIATE CONTEXT (LAST 20K WORDS)
-------------------------------------------------------------
${context.sliding_window || ""}

Continue directly from this. This is the most recent portion of your active manuscript.

-------------------------------------------------------------
REWRITE INSTRUCTIONS
-------------------------------------------------------------
${rewriteInstructions}

-------------------------------------------------------------
SCENE SUMMARY / DIRECTIONS
-------------------------------------------------------------
${sceneSummary}

-------------------------------------------------------------
TARGET LENGTH RANGE
-------------------------------------------------------------
Between ${minWords} and ${maxWords} words (aim for the middle unless the scene requires otherwise).

-------------------------------------------------------------
SUMMARY OF YOUR ROLE
-------------------------------------------------------------
- Retrieved context = continuity references from whole vault (including previous books)
- Sliding Window = direct lead-in (last 20k words of active manuscript)
- Story Bible = world + theme rules
- Rewrite Instructions = style and constraints
- Scene Summary = outline to be rewritten into full prose

Continue writing using the sliding window context and retrieved references for continuity.
Maintain perfect continuity and match the author's voice.`;
  }
  buildMicroEditPrompt(selectedText, directorNotes, context) {
    return `SYSTEM INSTRUCTION FOR AI (1M CONTEXT):

You are a line editor working on a specific passage that needs refinement.

-------------------------------------------------------------
CONTEXT BEFORE SELECTED PASSAGE (500 words)
-------------------------------------------------------------
${context.surrounding_before || "[No preceding context available]"}

This is the text immediately before the passage to be edited. Use this to ensure smooth narrative flow and continuity.

-------------------------------------------------------------
SELECTED PASSAGE TO EDIT
-------------------------------------------------------------
${selectedText}

This is the passage the author wants revised.

-------------------------------------------------------------
CONTEXT AFTER SELECTED PASSAGE (500 words)
-------------------------------------------------------------
${context.surrounding_after || "[No following context available]"}

This is the text immediately after the passage to be edited. Use this to ensure smooth narrative flow and continuity.

-------------------------------------------------------------
AUTHOR GRIEVANCES + DIRECTIVES
-------------------------------------------------------------
${directorNotes}

The author's specific concerns, plot disagreements, style issues, or desired changes for this passage.

-------------------------------------------------------------
IMMEDIATE CONTEXT \u2014 SLIDING WINDOW
-------------------------------------------------------------
${context.sliding_window || ""}

This provides immediate narrative context around the selected passage.

-------------------------------------------------------------
STORY BIBLE \u2014 CANON CONSTRAINTS
-------------------------------------------------------------
${context.story_bible || ""}

Maintain consistency with world rules, character arcs, and established canon.

-------------------------------------------------------------
CHARACTER NOTES \u2014 VOICE + CONTINUITY
-------------------------------------------------------------
${context.character_notes || ""}

Use these to maintain character voice, relationships, and arc progression.

-------------------------------------------------------------
RETRIEVED CONTEXT \u2014 STYLE ECHOES
-------------------------------------------------------------
${context.smart_connections || ""}

Similar passages for tone and style reference.

-------------------------------------------------------------
YOUR TASK
-------------------------------------------------------------
Generate a SINGLE refined alternative to the selected passage that:
1. Addresses all author grievances/directives
2. Maintains perfect continuity with surrounding context (especially the 500 words before and after)
3. Preserves character voice and established canon
4. Matches the author's writing style
5. Flows seamlessly when inserted into the manuscript, creating smooth transitions with the text before and after

Output ONLY the revised passage, ready to be copy-pasted into the manuscript.`;
  }
  buildContinuityCheckPrompt(params) {
    const focusLines = [];
    if (params.focus.knowledge)
      focusLines.push("- Character knowledge state");
    if (params.focus.timeline)
      focusLines.push("- Timeline / injuries / locations");
    if (params.focus.pov)
      focusLines.push("- POV drift and voice consistency");
    if (params.focus.naming)
      focusLines.push("- Naming consistency / aliases");
    return `SYSTEM INSTRUCTION FOR AI:

You are a continuity QA editor for a long-form fiction project.

You will audit the provided draft against canon and context, then produce a concise report of continuity issues and suggested patches.

Focus areas:
${focusLines.length ? focusLines.join("\n") : "- General continuity"}

Rules:
- Evidence-based only: cite exact quotes from the draft and from context when possible.
- Do not invent canon. If something is unknown, mark it as "Needs confirmation".
- Keep the report short and actionable.

-------------------------------------------------------------
STORY BIBLE (CANON)
-------------------------------------------------------------
${params.context.story_bible || ""}

-------------------------------------------------------------
CHARACTER NOTES (VOICE + STATE)
-------------------------------------------------------------
${params.context.character_notes || ""}

-------------------------------------------------------------
RETRIEVED CONTEXT (WHOLE VAULT)
-------------------------------------------------------------
${params.context.smart_connections || ""}

-------------------------------------------------------------
SLIDING WINDOW \u2014 IMMEDIATE CONTEXT (LAST 20K WORDS)
-------------------------------------------------------------
${params.context.sliding_window || ""}

-------------------------------------------------------------
DRAFT TO CHECK
-------------------------------------------------------------
${params.draft}

-------------------------------------------------------------
OUTPUT FORMAT (required)
-------------------------------------------------------------
## Continuity report
- Severity: Low | Medium | High
- Issue: ...
- Evidence (draft): "..."
- Evidence (canon/context): "..." (or [none found])
- Suggested fix: ...

## Suggested patches (optional)
- Provide small replacement blocks only when you are confident.
- If a patch is risky, do not provide it; keep it as a suggested fix instead.`;
  }
  buildCharacterExtractionPrompt(selectedText, characterNotes, storyBible, instructions, retrievedContext) {
    const characterNotesText = Object.entries(characterNotes).map(([name2, content]) => `## ${name2}
${content}`).join("\n\n");
    return `SYSTEM INSTRUCTION FOR AI:

-------------------------------------------------------------
EXTRACTION INSTRUCTIONS
-------------------------------------------------------------
${instructions}

-------------------------------------------------------------
PASSAGE TO ANALYZE
-------------------------------------------------------------
${selectedText}

-------------------------------------------------------------
EXISTING CHARACTER NOTES (IF ANY)
-------------------------------------------------------------
${characterNotesText || "[No existing character notes]"}

Current state of character files. Update these with new information.

-------------------------------------------------------------
RETRIEVED CONTEXT \u2014 RELEVANT NOTES (WHOLE VAULT)
-------------------------------------------------------------
${retrievedContext || "[No retrieved context]"}

Use this for continuity. Do not invent facts.

-------------------------------------------------------------
STORY BIBLE \u2014 CONTEXT
-------------------------------------------------------------
${storyBible}

Use for world context and relationship structures.

-------------------------------------------------------------
OUTPUT FORMAT (required)
-------------------------------------------------------------
## Character Name
- Bullet updates only (no extra headings)

Only include characters with meaningful new information supported by the passage.
Do not invent facts.
Do not output any other sections.`;
  }
  buildCharacterRosterPrompt(passage, storyBible) {
    return `SYSTEM INSTRUCTION FOR AI:

You are building a comprehensive character roster from a narrative text.

-------------------------------------------------------------
PASSAGE
-------------------------------------------------------------
${passage}

-------------------------------------------------------------
STORY BIBLE (context)
-------------------------------------------------------------
${storyBible || "[No story bible provided]"}

-------------------------------------------------------------
TASK
-------------------------------------------------------------
Extract ALL characters referenced in the passage, including:
- main characters
- side characters
- one-off named characters
- characters referenced by title or alias

Output one character per line in this exact format:
- Name | aliases: Alias1, Alias2

If no aliases are known, omit the aliases portion:
- Name

Only output the list. No extra commentary.`;
  }
  buildCharacterExtractionPromptWithRoster(params) {
    const characterNotesText = Object.entries(params.characterNotes).map(([name2, content]) => `## ${name2}
${content}`).join("\n\n");
    return `SYSTEM INSTRUCTION FOR AI:

You are extracting character information from a narrative passage.

-------------------------------------------------------------
GLOBAL CHARACTER ROSTER (from full manuscript scan)
-------------------------------------------------------------
${params.roster}

Use this roster to recognize characters even when only referred to by alias/title/pronoun.

-------------------------------------------------------------
PASSAGE TO ANALYZE
-------------------------------------------------------------
${params.passage}

-------------------------------------------------------------
EXISTING CHARACTER NOTES (IF ANY)
-------------------------------------------------------------
${characterNotesText || "[No existing character notes]"}

-------------------------------------------------------------
RETRIEVED CONTEXT \u2014 RELEVANT NOTES (WHOLE VAULT)
-------------------------------------------------------------
${params.retrievedContext || "[No retrieved context]"}

Use this for continuity. Do not invent facts.

-------------------------------------------------------------
STORY BIBLE \u2014 CONTEXT
-------------------------------------------------------------
${params.storyBible}

-------------------------------------------------------------
STRICT OUTPUT FORMAT
-------------------------------------------------------------
1) First output a section:

### Characters Mentioned
- Name
- Name

Only include names that appear in the passage (including aliases mapping to roster entries).

2) Then output ONE section per mentioned character (must use H2 headings exactly):

## CharacterName

**Voice Evidence:**
[quotes or narration evidence]

**New Traits:**
- [trait]: [evidence]

**Relationships:**
- **OtherCharacter**: [relationship change/evidence]

**Arc Progression:**
[what changed in this passage]

**Spoiler Notes:**
[any sensitive information]

If no new info is present for a mentioned character, still output the character section and write:
"No new character-relevant information in this passage."

Do not output any other sections.`;
  }
  buildStoryBibleDeltaPrompt(passage) {
    return `SYSTEM INSTRUCTION FOR AI:

You are extracting story bible updates from a narrative passage.

Rules:
- Evidence-based only: do not invent facts.
- Prefer exact wording from the passage when possible.
- Only output new/changed information. If nothing new exists, output: [No new story bible updates]

Output format:
## Section
- Bullet updates only

Suggested sections:
- Characters
- Locations
- Factions
- Timeline
- World rules
- Technology or magic
- Terminology
- Open questions

-------------------------------------------------------------
PASSAGE
-------------------------------------------------------------
${passage}`;
  }
  buildStoryBibleMergePrompt(params) {
    return `SYSTEM INSTRUCTION FOR AI:

You are updating a story bible with a set of new evidence-based updates.

Goals:
- Preserve existing canon.
- Merge new information cleanly into the appropriate sections.
- If the delta conflicts with existing canon, do NOT guess. Add a "Conflicts to resolve" section listing the conflict.

Rules:
- Do not invent facts.
- Keep the story bible structured and readable.
- Maintain a consistent heading hierarchy.

-------------------------------------------------------------
EXISTING STORY BIBLE
-------------------------------------------------------------
${params.existingStoryBible}

-------------------------------------------------------------
NEW UPDATES (DELTA)
-------------------------------------------------------------
${params.delta}

-------------------------------------------------------------
OUTPUT
-------------------------------------------------------------
Return the full updated story bible markdown only.`;
  }
};

// services/AIClient.ts
var import_obsidian17 = require("obsidian");
var AIClient = class {
  _formatUnknown(value) {
    if (value instanceof Error)
      return value.message;
    if (typeof value === "string")
      return value;
    if (typeof value === "number" || typeof value === "boolean") {
      return value.toString();
    }
    if (typeof value === "bigint") {
      return "bigint";
    }
    if (value === null)
      return "null";
    if (value === void 0)
      return "undefined";
    try {
      return JSON.stringify(value);
    } catch {
      return "[unserializable value]";
    }
  }
  _getJson(resp) {
    const anyResp = resp;
    if (anyResp.json !== void 0)
      return anyResp.json;
    if (typeof anyResp.text === "string" && anyResp.text.trim().length > 0) {
      try {
        return JSON.parse(anyResp.text);
      } catch {
        return { text: anyResp.text };
      }
    }
    return void 0;
  }
  _getNestedErrorMessage(payload) {
    if (!payload || typeof payload !== "object")
      return void 0;
    const obj = payload;
    const err = obj.error;
    if (err && typeof err === "object") {
      const errObj = err;
      const msg2 = errObj.message;
      if (typeof msg2 === "string" && msg2.trim().length > 0)
        return msg2;
    }
    const msg = obj.message;
    if (typeof msg === "string" && msg.trim().length > 0)
      return msg;
    if (typeof err === "string" && err.trim().length > 0)
      return err;
    return void 0;
  }
  _getOpenAIStyleContent(payload) {
    if (!payload || typeof payload !== "object")
      return void 0;
    const obj = payload;
    const choices = obj.choices;
    if (!Array.isArray(choices) || choices.length === 0)
      return void 0;
    const first = choices[0];
    if (!first || typeof first !== "object")
      return void 0;
    const message = first.message;
    if (!message || typeof message !== "object")
      return void 0;
    const content = message.content;
    return typeof content === "string" ? content : void 0;
  }
  _safeJsonPreview(value, maxLen = 1200) {
    try {
      const text2 = JSON.stringify(value);
      if (!text2)
        return "";
      return text2.length > maxLen ? `${text2.slice(0, maxLen)}\u2026` : text2;
    } catch {
      return "";
    }
  }
  async generate(prompt, settings) {
    if (settings.generationMode === "multi") {
      return await this.generateMulti(prompt, settings);
    } else {
      return await this.generateSingle(prompt, settings);
    }
  }
  async generateSingle(prompt, settings) {
    const provider = settings.apiProvider;
    if (settings.apiProvider === "openrouter") {
      return await this._generateOpenRouter(prompt, settings);
    } else if (settings.apiProvider === "openai") {
      return await this._generateOpenAI(prompt, settings);
    } else if (settings.apiProvider === "anthropic") {
      return await this._generateAnthropic(prompt, settings);
    } else if (settings.apiProvider === "gemini") {
      return await this._generateGemini(prompt, settings);
    } else {
      throw new Error(`Unsupported provider: ${provider}`);
    }
  }
  async generateMulti(prompt, settings) {
    const strategy = settings.multiStrategy;
    if (settings.multiStrategy === "draft-revision") {
      return await this.generateDraftRevision(prompt, settings);
    } else if (settings.multiStrategy === "consensus-multistage") {
      return await this.generateConsensusMultiStage(prompt, settings);
    } else {
      throw new Error(`Unsupported multi-strategy: ${strategy}`);
    }
  }
  async generateDraftRevision(prompt, settings) {
    if (!settings.draftModel || !settings.revisionModel) {
      throw new Error("Draft and revision models must be configured for draft-revision strategy");
    }
    const draftSettings = {
      ...settings,
      model: settings.draftModel
    };
    const draft = await this.generateSingle(prompt, draftSettings);
    const revisionPrompt = `Refine the following draft to improve prose quality, maintain character voice consistency, enhance narrative flow, and ensure stylistic coherence:

${draft}`;
    const revisionSettings = {
      ...settings,
      model: settings.revisionModel
    };
    const revision = await this.generateSingle(revisionPrompt, revisionSettings);
    return {
      primary: revision,
      revision,
      stages: {
        draft,
        final: revision
      }
    };
  }
  async generateConsensusMultiStage(prompt, settings) {
    if (!settings.consensusModel1 || !settings.consensusModel2) {
      throw new Error("At least 2 consensus models must be configured");
    }
    const consensusModels = [
      settings.consensusModel1,
      settings.consensusModel2,
      settings.consensusModel3
    ].filter((m) => typeof m === "string" && m.length > 0);
    const consensusPromises = consensusModels.map((model) => {
      const modelSettings = { ...settings, model };
      return this.generateSingle(prompt, modelSettings);
    });
    const consensusResults = await Promise.all(consensusPromises);
    const primaryDraft = consensusResults[0];
    const characterCheckPrompt = `Review this passage for character voice consistency, dialogue authenticity, and character trait alignment. Maintain all character personalities and ensure dialogue matches each character's established voice:

${primaryDraft}`;
    const characterSettings = {
      ...settings,
      model: settings.consensusModel1
    };
    const characterChecked = await this.generateSingle(characterCheckPrompt, characterSettings);
    const stylePrompt = `Refine this passage to match the author's unique style and narrative voice. Ensure prose quality, pacing, and stylistic coherence throughout:

${characterChecked}`;
    const styleSettings = {
      ...settings,
      model: settings.consensusModel1
    };
    const styleRefined = await this.generateSingle(stylePrompt, styleSettings);
    let final = styleRefined;
    if (settings.synthesisModel && consensusResults.length > 1) {
      const synthesisPrompt = `Combine the best elements from these alternative versions into a single refined passage. Prioritize quality, coherence, and the most compelling narrative elements:

${consensusResults.map((alt, i) => `Version ${i + 1}:
${alt}`).join("\n\n---\n\n")}`;
      const synthesisSettings = {
        ...settings,
        model: settings.synthesisModel
      };
      final = await this.generateSingle(synthesisPrompt, synthesisSettings);
    }
    return {
      primary: final,
      alternatives: consensusResults.slice(1),
      revision: final,
      stages: {
        draft: primaryDraft,
        characterChecked,
        styleRefined,
        final
      }
    };
  }
  async _generateOpenRouter(prompt, settings) {
    const response = await (0, import_obsidian17.requestUrl)({
      url: "https://openrouter.ai/api/v1/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${settings.apiKey}`,
        "HTTP-Referer": "https://github.com/JHarp199345/Gwriter",
        "X-Title": "Writing Dashboard"
      },
      body: JSON.stringify({
        model: settings.model,
        messages: [
          { role: "system", content: "You are a professional writing assistant." },
          { role: "user", content: prompt }
        ],
        max_tokens: 4e3,
        temperature: 0.7
      })
    });
    if (response.status >= 400) {
      const error2 = this._getJson(response);
      throw new Error(`OpenRouter API error: ${this._getNestedErrorMessage(error2) || response.status}`);
    }
    const data = this._getJson(response);
    const content = this._getOpenAIStyleContent(data);
    if (typeof content !== "string" || content.trim().length === 0) {
      throw new Error(
        `OpenRouter response missing message content. Preview: ${this._safeJsonPreview(data)}`
      );
    }
    return content;
  }
  async _generateOpenAI(prompt, settings) {
    const response = await (0, import_obsidian17.requestUrl)({
      url: "https://api.openai.com/v1/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${settings.apiKey}`
      },
      body: JSON.stringify({
        model: settings.model,
        messages: [
          { role: "system", content: "You are a professional writing assistant." },
          { role: "user", content: prompt }
        ],
        max_tokens: 4e3,
        temperature: 0.7
      })
    });
    if (response.status >= 400) {
      const error2 = this._getJson(response);
      throw new Error(`OpenAI API error: ${this._getNestedErrorMessage(error2) || response.status}`);
    }
    const data = this._getJson(response);
    const content = this._getOpenAIStyleContent(data);
    if (typeof content !== "string" || content.trim().length === 0) {
      throw new Error(
        `OpenAI response missing message content. Preview: ${this._safeJsonPreview(data)}`
      );
    }
    return content;
  }
  async _generateAnthropic(prompt, settings) {
    const response = await (0, import_obsidian17.requestUrl)({
      url: "https://api.anthropic.com/v1/messages",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": settings.apiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify({
        model: settings.model,
        max_tokens: 4e3,
        messages: [{ role: "user", content: prompt }]
      })
    });
    if (response.status >= 400) {
      const error2 = this._getJson(response);
      throw new Error(`Anthropic API error: ${this._getNestedErrorMessage(error2) || response.status}`);
    }
    const data = this._getJson(response);
    let text2;
    if (data && typeof data === "object") {
      const obj = data;
      const content = obj.content;
      if (Array.isArray(content) && content[0] && typeof content[0] === "object") {
        const first = content[0];
        const t = first.text;
        if (typeof t === "string")
          text2 = t;
      }
    }
    if (typeof text2 !== "string" || text2.trim().length === 0) {
      throw new Error(
        `Anthropic response missing content text. Preview: ${this._safeJsonPreview(data)}`
      );
    }
    return text2;
  }
  async _generateGemini(prompt, settings) {
    const promptTokens = estimateTokens(prompt);
    const limit = settings.contextTokenLimit ?? 128e3;
    const reservedForOutput = 6e3;
    if (promptTokens > limit - reservedForOutput) {
      throw new Error(
        `Prompt too large for configured context limit. Estimated input ~${promptTokens.toLocaleString()} tokens (limit: ${limit.toLocaleString()}). Reduce context (story bible/character notes/Smart Connections) or increase the warning limit.`
      );
    }
    const maxOutputTokens = Math.max(
      512,
      Math.min(8192, limit - promptTokens - 1024)
    );
    const response = await (0, import_obsidian17.requestUrl)({
      url: `https://generativelanguage.googleapis.com/v1beta/models/${settings.model}:generateContent?key=${settings.apiKey}`,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        contents: [
          {
            parts: [{ text: prompt }]
          }
        ],
        generationConfig: {
          maxOutputTokens,
          temperature: 0.7
        }
      })
    });
    if (response.status >= 400) {
      const error2 = this._getJson(response);
      throw new Error(`Gemini API error: ${this._getNestedErrorMessage(error2) || response.status}`);
    }
    const data = this._getJson(response);
    const candidates = data && typeof data === "object" ? data.candidates : void 0;
    if (!Array.isArray(candidates) || candidates.length === 0) {
      let blockReason;
      let promptFeedback;
      if (data && typeof data === "object") {
        promptFeedback = data.promptFeedback;
        if (promptFeedback && typeof promptFeedback === "object") {
          blockReason = promptFeedback.blockReason;
        }
      }
      const details = blockReason ? ` blockReason=${this._formatUnknown(blockReason)}` : "";
      const preview = this._safeJsonPreview(
        promptFeedback || data
      );
      throw new Error(
        `Gemini returned no candidates.${details} Preview: ${preview}`
      );
    }
    const firstCandidate = candidates[0];
    let parts;
    if (firstCandidate && typeof firstCandidate === "object") {
      const content = firstCandidate.content;
      if (content && typeof content === "object") {
        parts = content.parts;
      }
    }
    const partText = (p) => {
      if (!p || typeof p !== "object")
        return null;
      if (!("text" in p))
        return null;
      const t = p.text;
      return typeof t === "string" ? t : null;
    };
    const text2 = Array.isArray(parts) ? parts.map(partText).filter((t) => Boolean(t)).join("\n") : void 0;
    if (typeof text2 !== "string" || text2.trim().length === 0) {
      let finishReason;
      if (firstCandidate && typeof firstCandidate === "object") {
        finishReason = firstCandidate.finishReason;
      }
      const preview = this._safeJsonPreview(firstCandidate || data);
      throw new Error(
        `Gemini candidate missing text. finishReason=${this._formatUnknown(finishReason)} Preview: ${preview}`
      );
    }
    return text2;
  }
};

// services/CharacterExtractor.ts
var CharacterExtractor = class {
  /**
   * Process multiple text chunks and aggregate character updates
   */
  processChunks(chunks, parseExtractionFn) {
    const allUpdates = /* @__PURE__ */ new Map();
    for (const chunk of chunks) {
      const updates = parseExtractionFn(chunk);
      for (const update of updates) {
        const existing = allUpdates.get(update.character) ?? [];
        existing.push(update.update);
        allUpdates.set(update.character, existing);
      }
    }
    const aggregatedUpdates = [];
    for (const [character, updates] of allUpdates.entries()) {
      const combinedUpdate = updates.join("\n\n---\n\n");
      aggregatedUpdates.push({
        character,
        update: combinedUpdate
      });
    }
    return aggregatedUpdates;
  }
  parseExtraction(extractionText, opts) {
    const updates = [];
    const strict = opts?.strict ?? false;
    const characterSections = extractionText.split(/^##\s+(.+)$/m);
    for (let i = 1; i < characterSections.length; i += 2) {
      if (i + 1 < characterSections.length) {
        const characterName = characterSections[i].trim();
        let content = characterSections[i + 1].trim();
        if (characterName && content) {
          content = content.replace(/^###\s+.*?Update\s*\n/m, "").trim();
          if (content) {
            updates.push({
              character: characterName,
              update: content
            });
          }
        }
      }
    }
    if (!strict && updates.length === 0) {
      const characterPattern = /\b([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\b/g;
      const potentialCharacters = /* @__PURE__ */ new Set();
      let match2;
      while ((match2 = characterPattern.exec(extractionText)) !== null) {
        const name2 = match2[1];
        if (name2.split(" ").length <= 3) {
          potentialCharacters.add(name2);
        }
      }
      for (const charName of potentialCharacters) {
        updates.push({
          character: charName,
          update: extractionText
        });
      }
    }
    return updates;
  }
};

// services/retrieval/Fusion.ts
function mergeReasonTags(a, b) {
  if (!a?.length && !b?.length)
    return void 0;
  const set2 = /* @__PURE__ */ new Set();
  a?.forEach((t) => set2.add(t));
  b?.forEach((t) => set2.add(t));
  return Array.from(set2);
}
function fuseRrf(batches, opts) {
  const k = opts?.k ?? 60;
  const limit = opts?.limit ?? 200;
  const acc = /* @__PURE__ */ new Map();
  for (const batch of batches) {
    const sorted = (batch.items || []).slice().sort((a, b) => b.score - a.score);
    for (let i = 0; i < sorted.length; i++) {
      const it = sorted[i];
      const key = it.key || `${it.path}${it.anchor ? `#${it.anchor}` : ""}`;
      const add2 = 1 / (k + (i + 1));
      const existing = acc.get(key);
      if (!existing) {
        acc.set(key, { item: { ...it, key }, score: add2 });
      } else {
        acc.set(key, {
          item: {
            ...existing.item,
            // keep highest base score among providers but include tags from both
            score: Math.max(existing.item.score, it.score),
            reasonTags: mergeReasonTags(existing.item.reasonTags, it.reasonTags)
          },
          score: existing.score + add2
        });
      }
    }
  }
  const fused = Array.from(acc.values()).sort((a, b) => b.score - a.score).slice(0, Math.max(1, Math.min(1e3, limit)));
  let max = 0;
  for (const f of fused)
    if (f.score > max)
      max = f.score;
  const denom = max || 1;
  return fused.map((f) => ({
    ...f.item,
    score: Math.max(0, Math.min(1, f.score / denom)),
    source: "fused",
    reasonTags: mergeReasonTags(f.item.reasonTags, ["fused"])
  }));
}

// services/retrieval/Mmr.ts
function dot(a, b) {
  const n = Math.min(a.length, b.length);
  let s = 0;
  for (let i = 0; i < n; i++)
    s += a[i] * b[i];
  return s;
}
function tokenizeLoose(value) {
  const toks = (value || "").toLowerCase().split(/[^\p{L}\p{N}]+/gu).map((t) => t.trim()).filter((t) => t.length >= 3);
  return new Set(toks);
}
function jaccard(a, b) {
  if (a.size === 0 && b.size === 0)
    return 0;
  let inter = 0;
  for (const t of a)
    if (b.has(t))
      inter++;
  const union = a.size + b.size - inter;
  return union ? inter / union : 0;
}
function mmrSelect(items, opts) {
  const limit = Math.max(1, Math.min(200, Math.floor(opts.limit)));
  const lambda = Math.max(0, Math.min(1, opts.lambda ?? 0.72));
  const candidates = (items || []).slice(0, 400);
  if (candidates.length <= limit)
    return candidates.slice(0, limit);
  const selected = [];
  const selectedKeys = /* @__PURE__ */ new Set();
  const lex = /* @__PURE__ */ new Map();
  for (const it of candidates) {
    lex.set(it.key, tokenizeLoose(`${it.path} ${it.title ?? ""} ${it.excerpt}`));
  }
  const sim = (a, b) => {
    const va = opts.getVector?.(a.key) ?? null;
    const vb = opts.getVector?.(b.key) ?? null;
    if (va && vb) {
      return Math.max(0, Math.min(1, (dot(va, vb) + 1) / 2));
    }
    return jaccard(lex.get(a.key) ?? /* @__PURE__ */ new Set(), lex.get(b.key) ?? /* @__PURE__ */ new Set());
  };
  while (selected.length < limit) {
    let best = null;
    let bestScore = -Infinity;
    for (const cand of candidates) {
      if (selectedKeys.has(cand.key))
        continue;
      const relevance = cand.score;
      let redundancy = 0;
      for (const s of selected) {
        redundancy = Math.max(redundancy, sim(cand, s));
        if (redundancy >= 0.95)
          break;
      }
      const score = lambda * relevance - (1 - lambda) * redundancy;
      if (score > bestScore) {
        bestScore = score;
        best = cand;
      }
    }
    if (!best)
      break;
    selected.push(best);
    selectedKeys.add(best.key);
  }
  return selected;
}

// services/RetrievalService.ts
function normalizeLimit(limit) {
  if (!Number.isFinite(limit))
    return 20;
  return Math.max(1, Math.min(200, Math.floor(limit)));
}
var RetrievalService = class {
  constructor(providers, opts) {
    this.providers = providers;
    this.getVector = opts?.getVector;
  }
  async search(query, opts, scTemplatePaths) {
    const limit = normalizeLimit(opts.limit);
    const candidateLimit = Math.max(limit, Math.min(500, limit * 8));
    const localProviders = this.providers.filter(
      (p) => p.id === "local-embeddings" || p.id === "hash" || p.id === "bm25" || p.id === "heuristic"
    );
    const externalProviders = this.providers.filter(
      (p) => p.id === "external-embeddings"
    );
    const scProvider = this.providers.find((p) => p.id === "smart-connections");
    const scPaths = /* @__PURE__ */ new Set();
    if (scTemplatePaths && scTemplatePaths.length > 0) {
      scTemplatePaths.forEach((path) => scPaths.add(path));
      console.debug(`[RetrievalService] Using ${scTemplatePaths.length} paths from SC template`);
    } else {
      if (scProvider && "getCachePaths" in scProvider) {
        try {
          const paths = await scProvider.getCachePaths();
          paths.forEach((path) => scPaths.add(path));
        } catch {
        }
      }
    }
    const localResults = await Promise.all(
      localProviders.map(async (p) => {
        try {
          return { providerId: p.id, items: await p.search(query, { limit: candidateLimit }) };
        } catch {
          return { providerId: p.id, items: [] };
        }
      })
    );
    let finalResults = localResults;
    if (scPaths.size > 0) {
      finalResults = localResults.map(({ providerId, items }) => ({
        providerId,
        items: items.filter((item) => scPaths.has(item.path)).map((item) => ({ ...item, score: item.score * 2 }))
        // Boost intersection items
      }));
      const intersectionCount = finalResults.reduce((sum, r) => sum + r.items.length, 0);
      console.debug(`[RetrievalService] SC template intersection: ${scPaths.size} SC paths, ${intersectionCount} matches with hash results`);
    } else {
      finalResults = localResults;
    }
    const externalResults = await Promise.all(
      externalProviders.map(async (p) => {
        try {
          return { providerId: p.id, items: await p.search(query, { limit: candidateLimit }) };
        } catch {
          return { providerId: p.id, items: [] };
        }
      })
    );
    const allResults = [...finalResults, ...externalResults];
    const nonEmpty = allResults.filter((b) => b.items.length > 0);
    if (nonEmpty.length === 0)
      return [];
    if (nonEmpty.length === 1) {
      return nonEmpty[0].items.slice().sort((a, b) => b.score - a.score).slice(0, limit);
    }
    const fused = fuseRrf(nonEmpty, { limit: candidateLimit });
    const diverse = mmrSelect(fused, { limit, getVector: this.getVector });
    return diverse.sort((a, b) => b.score - a.score).slice(0, limit);
  }
};

// services/QueryBuilder.ts
var QueryBuilder = class {
  build(input) {
    const parts = [];
    const push = (label, value) => {
      const v = (value ?? "").trim();
      if (!v)
        return;
      parts.push(`${label}:
${v}`);
    };
    push("Primary text", input.primaryText);
    push("Director notes", input.directorNotes);
    push("Scene summary", input.sceneSummary);
    return {
      text: parts.join("\n\n"),
      activeFilePath: input.activeFilePath,
      mode: input.mode,
      hints: {
        characters: input.characterNames?.filter((n) => typeof n === "string" && n.trim().length > 0)
      }
    };
  }
};

// services/retrieval/HeuristicProvider.ts
var STOPWORDS = /* @__PURE__ */ new Set([
  "the",
  "a",
  "an",
  "and",
  "or",
  "but",
  "to",
  "of",
  "in",
  "on",
  "for",
  "with",
  "at",
  "from",
  "by",
  "as",
  "is",
  "are",
  "was",
  "were",
  "be",
  "been",
  "it",
  "that",
  "this",
  "these",
  "those"
]);
function tokenize(value) {
  return value.toLowerCase().split(/[^a-z0-9]+/g).map((t) => t.trim()).filter((t) => t.length >= 3 && !STOPWORDS.has(t));
}
function findSnippet(content, term, maxLen) {
  const lower = content.toLowerCase();
  const idx = lower.indexOf(term.toLowerCase());
  if (idx < 0)
    return content.slice(0, maxLen);
  const start = Math.max(0, idx - Math.floor(maxLen / 3));
  const end = Math.min(content.length, start + maxLen);
  const prefix = start > 0 ? "\u2026" : "";
  const suffix = end < content.length ? "\u2026" : "";
  return `${prefix}${content.slice(start, end)}${suffix}`.trim();
}
var HeuristicProvider = class {
  constructor(vault, vaultService) {
    this.id = "heuristic";
    this.cache = /* @__PURE__ */ new Map();
    this.cacheTtlMs = 3e4;
    this.vault = vault;
    this.vaultService = vaultService;
  }
  async search(query, opts) {
    const q = (query.text ?? "").trim();
    if (!q)
      return [];
    const cacheKey = fnv1a32(
      [
        "q:" + q,
        "active:" + (query.activeFilePath ?? ""),
        "mode:" + (query.mode ?? ""),
        "k:" + String(opts.limit)
      ].join("\n")
    );
    const cached = this.cache.get(cacheKey);
    if (cached && Date.now() - cached.at <= this.cacheTtlMs) {
      return cached.results.slice(0, opts.limit);
    }
    const terms = tokenize(q).slice(0, 24);
    if (terms.length === 0)
      return [];
    const files = this.vaultService.getIncludedMarkdownFiles();
    if (files.length === 0)
      return [];
    const now = Date.now();
    const scored = files.map((f) => {
      const base2 = `${f.basename} ${f.path}`.toLowerCase();
      let score = 0;
      let titleHits = 0;
      for (const t of terms) {
        if (base2.includes(t)) {
          score += 1;
          titleHits++;
        }
      }
      const ageMs = Math.max(0, now - (f.stat?.mtime ?? now));
      const recency = 1 / (1 + ageMs / (1e3 * 60 * 60 * 24 * 30));
      score += recency * 0.5;
      if (query.activeFilePath && f.path === query.activeFilePath)
        score += 0.75;
      if (query.activeFilePath && f.path.startsWith(query.activeFilePath.split("/").slice(0, -1).join("/")))
        score += 0.15;
      return { file: f, score, titleHits };
    }).sort((a, b) => b.score - a.score).slice(0, 200);
    const results = [];
    const maxRead = Math.min(scored.length, 120);
    for (let i = 0; i < maxRead; i++) {
      const { file, score: baseScore, titleHits } = scored[i];
      let content = "";
      try {
        content = await this.vault.read(file);
      } catch {
        continue;
      }
      const lower = content.toLowerCase();
      let tf = 0;
      let firstTerm = null;
      for (const t of terms) {
        const hits = lower.split(t).length - 1;
        if (hits > 0 && !firstTerm)
          firstTerm = t;
        tf += hits;
      }
      if (tf === 0 && titleHits === 0)
        continue;
      const normalizedTf = Math.min(1, tf / 24);
      const score = Math.min(1, baseScore / 6 + normalizedTf * 0.7);
      const reasonTags = [];
      if (titleHits > 0)
        reasonTags.push("titleMatch");
      if (tf > 0)
        reasonTags.push("textMatch");
      const excerpt = firstTerm ? findSnippet(content, firstTerm, 2500) : content.slice(0, 2500);
      results.push({
        key: `file:${file.path}`,
        path: file.path,
        title: file.basename,
        excerpt,
        score,
        source: this.id,
        reasonTags
      });
    }
    const finalResults = results.sort((a, b) => b.score - a.score).slice(0, opts.limit);
    this.cache.set(cacheKey, { at: Date.now(), results: finalResults });
    return finalResults;
  }
};

// services/retrieval/EmbeddingsIndex.ts
var import_obsidian18 = require("obsidian");

// services/retrieval/Chunking.ts
function clampInt(value, min, max) {
  if (!Number.isFinite(value))
    return min;
  return Math.max(min, Math.min(max, Math.floor(value)));
}
function splitWords(text2) {
  return (text2 || "").split(/\s+/g).filter(Boolean);
}
function isHeadingLine(line, level) {
  const t = (line || "").trimStart();
  if (level === "h1")
    return /^#(?!#)\s+/.test(t);
  if (level === "h2")
    return /^##(?!#)\s+/.test(t);
  if (level === "h3")
    return /^###(?!#)\s+/.test(t);
  return false;
}
function splitByHeadingLevel(text2, level) {
  if (level === "none")
    return [];
  const normalized = (text2 || "").replace(/\r\n/g, "\n");
  const lines = normalized.split("\n");
  const sections = [];
  let current = [];
  let seenHeading = false;
  const flush = () => {
    const body = current.join("\n").trim();
    if (body)
      sections.push(body);
  };
  for (const line of lines) {
    if (isHeadingLine(line, level)) {
      if (seenHeading)
        flush();
      seenHeading = true;
      current = [line.trimEnd()];
      continue;
    }
    current.push(line);
  }
  if (seenHeading) {
    flush();
    return sections;
  }
  return [];
}
function chunkWordsWindow(text2, globalStartWord, targetWords, overlapWords) {
  const words = splitWords(text2);
  if (words.length === 0)
    return [];
  const size = clampInt(targetWords, 200, 2e3);
  const overlap = clampInt(overlapWords, 0, Math.max(0, size - 1));
  const step = Math.max(1, size - overlap);
  const out = [];
  for (let start = 0; start < words.length; start += step) {
    const end = Math.min(words.length, start + size);
    out.push({
      startWord: globalStartWord + start,
      endWord: globalStartWord + end,
      text: words.slice(start, end).join(" ")
    });
    if (end >= words.length)
      break;
  }
  return out;
}
function mergeSmallSections(sections, minWords) {
  const min = Math.max(1, Math.floor(minWords));
  const out = [];
  let buf = [];
  let bufWords = 0;
  const flush = () => {
    const merged = buf.join("\n\n").trim();
    if (merged)
      out.push(merged);
    buf = [];
    bufWords = 0;
  };
  for (const s of sections) {
    const words = splitWords(s).length;
    if (bufWords === 0) {
      buf = [s];
      bufWords = words;
    } else if (bufWords < min) {
      buf.push(s);
      bufWords += words;
    } else {
      flush();
      buf = [s];
      bufWords = words;
    }
  }
  if (bufWords > 0)
    flush();
  return out;
}
function buildIndexChunks(params) {
  const level = params.headingLevel;
  const target = clampInt(params.targetWords, 200, 2e3);
  const overlap = clampInt(params.overlapWords, 0, 500);
  const sections = splitByHeadingLevel(params.text, level);
  if (sections.length > 0) {
    const minWords = Math.max(200, Math.floor(target * 0.5));
    const merged = mergeSmallSections(sections, minWords);
    const out = [];
    let cursor = 0;
    for (const sec of merged) {
      const words = splitWords(sec).length;
      if (words <= target) {
        out.push({ startWord: cursor, endWord: cursor + words, text: sec });
        cursor += words;
        continue;
      }
      const sub = chunkWordsWindow(sec, cursor, target, overlap);
      out.push(...sub);
      cursor += words;
    }
    return out;
  }
  return chunkWordsWindow(params.text, 0, target, overlap);
}

// services/retrieval/EmbeddingsIndex.ts
function clampInt2(value, min, max) {
  if (!Number.isFinite(value))
    return min;
  return Math.max(min, Math.min(max, Math.floor(value)));
}
function tokenize2(value) {
  return value.toLowerCase().split(/[^a-z0-9]+/g).map((t) => t.trim()).filter((t) => t.length >= 2);
}
function buildVector(text2, dim) {
  const vec = new Array(dim).fill(0);
  const tokens = tokenize2(text2);
  for (const tok of tokens) {
    const h = parseInt(fnv1a32(tok), 16);
    const idx = h % dim;
    const sign = (h & 1) === 0 ? 1 : -1;
    vec[idx] += sign;
  }
  let sumSq = 0;
  for (let i = 0; i < dim; i++)
    sumSq += vec[i] * vec[i];
  const norm = Math.sqrt(sumSq) || 1;
  for (let i = 0; i < dim; i++)
    vec[i] = vec[i] / norm;
  return vec;
}
function chunkingKey(plugin) {
  return {
    headingLevel: plugin.settings.retrievalChunkHeadingLevel ?? "h1",
    targetWords: clampInt2(plugin.settings.retrievalChunkWords ?? 500, 200, 2e3),
    overlapWords: clampInt2(plugin.settings.retrievalChunkOverlapWords ?? 100, 0, 500)
  };
}
function excerptOf(text2, maxChars) {
  const trimmed = text2.trim().replace(/\s+/g, " ");
  if (trimmed.length <= maxChars)
    return trimmed;
  return `${trimmed.slice(0, maxChars)}\u2026`;
}
var EmbeddingsIndex = class {
  constructor(vault, plugin, dim = 256) {
    this.loaded = false;
    this.chunksByKey = /* @__PURE__ */ new Map();
    this.chunkKeysByPath = /* @__PURE__ */ new Map();
    this.queue = /* @__PURE__ */ new Set();
    this.workerRunning = false;
    this.persistTimer = null;
    this.settingsSaveTimer = null;
    // Error tracking
    this.errorLog = [];
    this.maxStoredErrors = 100;
    this.vault = vault;
    this.plugin = plugin;
    this.backend = "hash";
    this.dim = dim;
  }
  getIndexFilePath() {
    return `${this.vault.configDir}/plugins/${this.plugin.manifest.id}/rag-index/index.json`;
  }
  async ensureLoaded() {
    if (this.loaded)
      return;
    this.loaded = true;
    try {
      const path = this.getIndexFilePath();
      if (!await this.vault.adapter.exists(path))
        return;
      const raw = await this.vault.adapter.read(path);
      const parsed = JSON.parse(raw);
      if (parsed?.version !== 1 || !Array.isArray(parsed.chunks))
        return;
      if (parsed.backend && parsed.backend !== this.backend) {
        this.enqueueFullRescan();
        return;
      }
      if (typeof parsed.dim === "number" && parsed.dim !== this.dim) {
        this.enqueueFullRescan();
        return;
      }
      const expectedChunking = chunkingKey(this.plugin);
      if (parsed.chunking && (parsed.chunking.headingLevel !== expectedChunking.headingLevel || parsed.chunking.targetWords !== expectedChunking.targetWords || parsed.chunking.overlapWords !== expectedChunking.overlapWords)) {
        this.enqueueFullRescan();
        return;
      }
      for (const chunk of parsed.chunks) {
        if (!chunk?.key || !chunk?.path || !Array.isArray(chunk.vector))
          continue;
        this._setChunk(chunk);
      }
    } catch {
      this.chunksByKey.clear();
      this.chunkKeysByPath.clear();
    }
  }
  getStatus() {
    return {
      indexedFiles: this.chunkKeysByPath.size,
      indexedChunks: this.chunksByKey.size,
      paused: Boolean(this.plugin.settings.retrievalIndexPaused),
      queued: this.queue.size
    };
  }
  getRecentErrors(limit = 20) {
    return this.errorLog.slice(-limit);
  }
  getErrorSummary() {
    const byLocation = {};
    for (const err of this.errorLog) {
      byLocation[err.location] = (byLocation[err.location] || 0) + 1;
    }
    return {
      total: this.errorLog.length,
      byLocation,
      recent: this.errorLog.slice(-10)
    };
  }
  logError(location, context, error2) {
    const errorMsg = error2 instanceof Error ? error2.message : String(error2);
    const errorStack = error2 instanceof Error ? error2.stack : void 0;
    const errorType = error2 instanceof Error ? error2.constructor.name : typeof error2;
    const entry = {
      timestamp: new Date().toISOString(),
      location,
      context,
      message: errorMsg,
      stack: errorStack,
      errorType
    };
    this.errorLog.push(entry);
    if (this.errorLog.length > this.maxStoredErrors) {
      this.errorLog.shift();
    }
    console.error(`[EmbeddingsIndex] ERROR [${location}] ${context}:`, errorMsg);
    if (errorStack) {
      console.error(`[EmbeddingsIndex] Stack:`, errorStack.split("\n").slice(0, 3).join("\n"));
    }
  }
  enqueueFullRescan() {
    const files = this.plugin.vaultService.getIncludedMarkdownFiles();
    for (const f of files)
      this.queue.add(f.path);
    this._kickWorker();
  }
  queueUpdateFile(path) {
    if (!path)
      return;
    this.queue.add(path);
    this._kickWorker();
  }
  queueRemoveFile(path) {
    if (!path)
      return;
    this._removePath(path);
    this._schedulePersist();
    this._scheduleSettingsSave();
  }
  _kickWorker() {
    if (this.workerRunning)
      return;
    this.workerRunning = true;
    void this._runWorker().catch(() => {
      this.workerRunning = false;
    });
  }
  async _runWorker() {
    await this.ensureLoaded();
    let processedCount = 0;
    let skippedExcluded = 0;
    let skippedNotMarkdown = 0;
    let skippedHashMatch = 0;
    let indexedCount = 0;
    while (this.queue.size > 0) {
      if (this.plugin.settings.retrievalIndexPaused)
        break;
      const next = this.queue.values().next().value;
      this.queue.delete(next);
      processedCount++;
      if (this.plugin.vaultService.isExcludedPath(next)) {
        skippedExcluded++;
        this._removePath(next);
        this._schedulePersist();
        this._scheduleSettingsSave();
        continue;
      }
      const file = this.vault.getAbstractFileByPath(next);
      if (!(file instanceof import_obsidian18.TFile) || file.extension !== "md") {
        skippedNotMarkdown++;
        this._removePath(next);
        this._schedulePersist();
        this._scheduleSettingsSave();
        continue;
      }
      try {
        const content = await this.vault.read(file);
        const fileHash = fnv1a32(content);
        const prev = this.plugin.settings.retrievalIndexState?.[next];
        const isCurrentlyIndexed = this.chunkKeysByPath.has(next);
        if (prev?.hash === fileHash && isCurrentlyIndexed) {
          skippedHashMatch++;
          continue;
        }
        await this._reindexFile(next, content);
        indexedCount++;
        this.plugin.settings.retrievalIndexState = {
          ...this.plugin.settings.retrievalIndexState || {},
          [next]: {
            hash: fileHash,
            chunkCount: this.chunkKeysByPath.get(next)?.size ?? 0,
            updatedAt: new Date().toISOString()
          }
        };
        this._schedulePersist();
        this._scheduleSettingsSave();
      } catch (err) {
        this.logError("_runWorker", `Processing file: ${next}`, err);
      }
      await new Promise((r) => setTimeout(r, 10));
    }
    if (processedCount > 0) {
      console.log(`[EmbeddingsIndex] Processed ${processedCount} files: ${indexedCount} indexed, ${skippedExcluded} excluded, ${skippedNotMarkdown} not markdown, ${skippedHashMatch} hash match (already indexed)`);
    }
    this.workerRunning = false;
  }
  async _reindexFile(path, content) {
    this._removePath(path);
    if (!content || content.trim().length === 0) {
      console.warn(`[EmbeddingsIndex] Skipping empty file: ${path}`);
      return;
    }
    const cfg = chunkingKey(this.plugin);
    console.log(`[EmbeddingsIndex] Processing file: ${path}`);
    console.log(`  - Backend: ${this.backend}`);
    console.log(`  - Content length: ${content.length} chars, ${content.split(/\s+/).length} words`);
    console.log(`  - Chunking config: headingLevel=${cfg.headingLevel}, targetWords=${cfg.targetWords}, overlapWords=${cfg.overlapWords}`);
    const chunks = buildIndexChunks({
      text: content,
      headingLevel: cfg.headingLevel,
      targetWords: cfg.targetWords,
      overlapWords: cfg.overlapWords
    });
    console.log(`  - Chunks created: ${chunks.length}`);
    if (chunks.length > 0) {
      console.log(`  - First chunk preview: ${chunks[0].text.substring(0, 100)}...`);
    }
    if (chunks.length === 0) {
      console.warn(`[EmbeddingsIndex] No chunks created for ${path} - file too short or no headings match chunking config`);
      return;
    }
    let successfulChunks = 0;
    let firstError = null;
    for (let i = 0; i < chunks.length; i++) {
      const ch = chunks[i];
      const textHash = fnv1a32(ch.text);
      const key = `chunk:${path}:${i}`;
      let vector;
      try {
        console.log(`  - Generating embedding for chunk ${i + 1}/${chunks.length} (${ch.text.split(/\s+/).length} words)...`);
        const embedStart = Date.now();
        vector = buildVector(ch.text, this.dim);
        const embedDuration = Date.now() - embedStart;
        console.log(`  - \u2713 Hash-based vector generated in ${embedDuration}ms: ${vector.length} dimensions`);
      } catch (err) {
        const errorMsg = err instanceof Error ? err.message : String(err);
        const errorStack = err instanceof Error ? err.stack : void 0;
        const context = `File: ${path}, Chunk ${i + 1}/${chunks.length} (${ch.text.split(/\s+/).length} words, ${ch.text.length} chars)`;
        this.logError("_reindexFile.embedChunk", context, err);
        console.error(`  - \u2717 Embedding generation failed for chunk ${i + 1}/${chunks.length}:`, errorMsg);
        if (errorStack) {
          console.error(`    Stack: ${errorStack.split("\n").slice(0, 3).join("\n    ")}`);
        }
        if (err instanceof Error) {
          console.error(`    Error type: ${err.constructor.name}`);
          if ("cause" in err) {
            console.error(`    Cause: ${err.cause}`);
          }
        }
        if (i === 0) {
          console.error(`  - CRITICAL: First chunk failed for ${path} - file will not be indexed`);
          firstError = err instanceof Error ? err : new Error(String(err));
        }
        continue;
      }
      const excerpt = excerptOf(ch.text, 2500);
      this._setChunk({
        key,
        path,
        chunkIndex: i,
        startWord: ch.startWord,
        endWord: ch.endWord,
        textHash,
        vector,
        excerpt
      });
      successfulChunks++;
    }
    if (successfulChunks === 0 && chunks.length > 0) {
      const criticalContext = `File: ${path}, All ${chunks.length} chunks failed`;
      if (firstError) {
        this.logError("_reindexFile.allChunksFailed", criticalContext, firstError);
        console.error(`[EmbeddingsIndex] CRITICAL: All ${chunks.length} chunks failed for ${path} - file not indexed`);
        console.error(`  Root cause: ${firstError.message}`);
      } else {
        this.logError("_reindexFile.allChunksFailed", criticalContext, new Error("All chunks failed but no first error captured"));
      }
    } else if (successfulChunks < chunks.length) {
      console.warn(`[EmbeddingsIndex] Partial success for ${path}: ${successfulChunks}/${chunks.length} chunks indexed`);
    } else {
      console.log(`[EmbeddingsIndex] \u2713 Successfully indexed ${path}: ${successfulChunks} chunks`);
    }
  }
  _setChunk(chunk) {
    this.chunksByKey.set(chunk.key, chunk);
    const set2 = this.chunkKeysByPath.get(chunk.path) ?? /* @__PURE__ */ new Set();
    set2.add(chunk.key);
    this.chunkKeysByPath.set(chunk.path, set2);
  }
  _removePath(path) {
    const keys = this.chunkKeysByPath.get(path);
    if (keys) {
      for (const k of keys)
        this.chunksByKey.delete(k);
    }
    this.chunkKeysByPath.delete(path);
    if (this.plugin.settings.retrievalIndexState?.[path]) {
      const next = { ...this.plugin.settings.retrievalIndexState || {} };
      delete next[path];
      this.plugin.settings.retrievalIndexState = next;
    }
  }
  getAllChunks() {
    return Array.from(this.chunksByKey.values());
  }
  getIndexedPaths() {
    return Array.from(this.chunkKeysByPath.keys());
  }
  /**
   * Queue all currently indexed paths for re-checking. This is useful when exclusions/profiles change.
   */
  queueRecheckAllIndexed() {
    for (const p of this.getIndexedPaths())
      this.queue.add(p);
    this._kickWorker();
  }
  getVectorForKey(key) {
    const ch = this.chunksByKey.get(key);
    return ch?.vector ?? null;
  }
  buildQueryVector(queryText) {
    return buildVector(queryText, this.dim);
  }
  async embedQueryVector(queryText) {
    return buildVector(queryText, this.dim);
  }
  _schedulePersist() {
    if (this.persistTimer)
      window.clearTimeout(this.persistTimer);
    this.persistTimer = window.setTimeout(() => {
      this.persistTimer = null;
      void this._persistNow().catch(() => {
      });
    }, 1e3);
  }
  async _persistNow() {
    const dir = `${this.vault.configDir}/plugins/${this.plugin.manifest.id}/rag-index`;
    try {
      if (!await this.vault.adapter.exists(dir)) {
        await this.vault.adapter.mkdir(dir);
      }
    } catch {
    }
    const payload = {
      version: 1,
      dim: this.dim,
      backend: this.backend,
      chunking: chunkingKey(this.plugin),
      chunks: this.getAllChunks()
    };
    await this.vault.adapter.write(this.getIndexFilePath(), JSON.stringify(payload));
  }
  _scheduleSettingsSave() {
    if (this.settingsSaveTimer)
      window.clearTimeout(this.settingsSaveTimer);
    this.settingsSaveTimer = window.setTimeout(() => {
      this.settingsSaveTimer = null;
      void this.plugin.saveSettings().catch(() => {
      });
    }, 1e3);
  }
};

// services/retrieval/LocalEmbeddingsProvider.ts
function dot2(a, b) {
  const n = Math.min(a.length, b.length);
  let s = 0;
  for (let i = 0; i < n; i++)
    s += a[i] * b[i];
  return s;
}
var LocalEmbeddingsProvider = class {
  constructor(index, isEnabled, isAllowedPath) {
    this.id = "semantic";
    this.index = index;
    this.isEnabled = isEnabled;
    this.isAllowedPath = isAllowedPath;
  }
  async search(query, opts) {
    if (!this.isEnabled())
      return [];
    const q = (query.text ?? "").trim();
    if (!q)
      return [];
    await this.index.ensureLoaded();
    let qVec;
    try {
      qVec = await this.index.embedQueryVector(q);
    } catch {
      return [];
    }
    const chunks = this.index.getAllChunks().filter((c) => this.isAllowedPath(c.path));
    if (chunks.length === 0)
      return [];
    const scored = chunks.map((c) => ({ chunk: c, score: dot2(qVec, c.vector) })).sort((a, b) => b.score - a.score).slice(0, Math.max(1, Math.min(200, opts.limit * 6)));
    const results = [];
    for (const { chunk, score } of scored) {
      results.push({
        key: chunk.key,
        path: chunk.path,
        title: chunk.path.split("/").pop(),
        excerpt: chunk.excerpt,
        score: Math.max(0, Math.min(1, (score + 1) / 2)),
        source: this.id,
        reasonTags: ["semantic"]
      });
    }
    return results.slice(0, opts.limit);
  }
};

// services/retrieval/ExternalEmbeddingsProvider.ts
var import_obsidian19 = require("obsidian");
function dot3(a, b) {
  const n = Math.min(a.length, b.length);
  let s = 0;
  for (let i = 0; i < n; i++)
    s += a[i] * b[i];
  return s;
}
var ExternalEmbeddingsProvider = class {
  constructor(plugin, embeddingsIndex, bm25Index, isEnabled, isAllowedPath) {
    this.id = "external-embeddings";
    // Cache for embedding vectors (query text -> vector)
    this.embeddingCache = /* @__PURE__ */ new Map();
    this.cacheTtl = 36e5;
    // 1 hour
    // Rate limiting infrastructure
    this.requestQueue = [];
    this.requestInFlight = false;
    this.maxConcurrentRequests = 1;
    // Serialize requests to avoid bursts
    this.minRequestInterval = 100;
    // Minimum 100ms between requests
    this.lastRequestTime = 0;
    this.retryConfig = {
      maxRetries: 3,
      baseDelay: 1e3,
      // 1 second
      maxDelay: 1e4,
      // 10 seconds
      backoffMultiplier: 2
    };
    this.plugin = plugin;
    this.embeddingsIndex = embeddingsIndex;
    this.bm25Index = bm25Index;
    this.isEnabled = isEnabled;
    this.isAllowedPath = isAllowedPath;
  }
  async getQueryEmbedding(query) {
    const cached = this.embeddingCache.get(query);
    if (cached && Date.now() - cached.timestamp < this.cacheTtl) {
      return cached.vector;
    }
    const now = Date.now();
    const timeSinceLastRequest = now - this.lastRequestTime;
    if (timeSinceLastRequest < this.minRequestInterval) {
      await new Promise((resolve) => setTimeout(resolve, this.minRequestInterval - timeSinceLastRequest));
    }
    const settings = this.plugin.settings;
    const provider = settings.externalEmbeddingProvider;
    const apiKey = settings.externalEmbeddingApiKey;
    const model = settings.externalEmbeddingModel || this.getDefaultModel(provider);
    const apiUrl = settings.externalEmbeddingApiUrl;
    if (!provider || !apiKey) {
      throw new Error("External embedding provider or API key not configured");
    }
    let lastError = null;
    for (let attempt = 0; attempt <= this.retryConfig.maxRetries; attempt++) {
      try {
        this.lastRequestTime = Date.now();
        let vector;
        if (provider === "openai") {
          vector = await this.callOpenAIEmbedding(apiKey, model, query);
        } else if (provider === "cohere") {
          vector = await this.callCohereEmbedding(apiKey, model, query);
        } else if (provider === "google") {
          vector = await this.callGoogleEmbedding(apiKey, model, query, settings.externalEmbeddingUseBatch || false);
        } else if (provider === "custom" && apiUrl) {
          vector = await this.callCustomEmbedding(apiUrl, query);
        } else {
          throw new Error(`Unsupported embedding provider: ${provider}`);
        }
        this.embeddingCache.set(query, { vector, timestamp: Date.now() });
        return vector;
      } catch (error2) {
        lastError = error2 instanceof Error ? error2 : new Error(String(error2));
        const isRateLimit = lastError.message.includes("429") || lastError.message.includes("rate limit") || lastError.message.includes("too many requests");
        if (isRateLimit && attempt < this.retryConfig.maxRetries) {
          const delay = Math.min(
            this.retryConfig.baseDelay * Math.pow(this.retryConfig.backoffMultiplier, attempt),
            this.retryConfig.maxDelay
          );
          console.warn(`[ExternalEmbeddingsProvider] Rate limited (429), retrying in ${delay}ms (attempt ${attempt + 1}/${this.retryConfig.maxRetries + 1})`);
          await new Promise((resolve) => setTimeout(resolve, delay));
          continue;
        }
        if (!isRateLimit || attempt >= this.retryConfig.maxRetries) {
          break;
        }
      }
    }
    console.error(`[ExternalEmbeddingsProvider] Failed to get embedding after ${this.retryConfig.maxRetries + 1} attempts:`, lastError);
    throw lastError || new Error("Failed to get embedding");
  }
  getDefaultModel(provider) {
    switch (provider) {
      case "openai":
        return "text-embedding-3-small";
      case "cohere":
        return "embed-english-v3.0";
      case "google":
        return "gemini-embedding-001";
      default:
        return "";
    }
  }
  async callOpenAIEmbedding(apiKey, model, query) {
    const response = await (0, import_obsidian19.requestUrl)({
      url: "https://api.openai.com/v1/embeddings",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model,
        input: query
      })
    });
    if (response.status !== 200) {
      const errorText = response.text || "";
      if (response.status === 429) {
        const retryAfter = response.headers["retry-after"] || response.headers["Retry-After"];
        throw new Error(`OpenAI rate limit (429). ${retryAfter ? `Retry after ${retryAfter} seconds.` : "Please wait before retrying."}`);
      }
      throw new Error(`OpenAI embedding API error: ${response.status} ${errorText}`);
    }
    const data = typeof response.json === "object" ? response.json : JSON.parse(response.text);
    if (data.data && data.data[0] && data.data[0].embedding) {
      return data.data[0].embedding;
    }
    throw new Error("Invalid OpenAI embedding response format");
  }
  async callCohereEmbedding(apiKey, model, query) {
    const response = await (0, import_obsidian19.requestUrl)({
      url: "https://api.cohere.ai/v1/embed",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model,
        texts: [query]
      })
    });
    if (response.status !== 200) {
      const errorText = response.text || "";
      if (response.status === 429) {
        const retryAfter = response.headers["retry-after"] || response.headers["Retry-After"];
        throw new Error(`Cohere rate limit (429). ${retryAfter ? `Retry after ${retryAfter} seconds.` : "Please wait before retrying."}`);
      }
      throw new Error(`Cohere embedding API error: ${response.status} ${errorText}`);
    }
    const data = typeof response.json === "object" ? response.json : JSON.parse(response.text);
    if (data.embeddings && data.embeddings[0]) {
      return data.embeddings[0];
    }
    throw new Error("Invalid Cohere embedding response format");
  }
  async callGoogleEmbedding(apiKey, model, query, useBatch) {
    if (useBatch) {
      const response = await (0, import_obsidian19.requestUrl)({
        url: `https://generativelanguage.googleapis.com/v1beta/models/${model}:batchEmbedContents?key=${apiKey}`,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          requests: [{
            content: {
              parts: [{ text: query }]
            }
          }]
        })
      });
      if (response.status !== 200) {
        const errorText = response.text || "";
        if (response.status === 429) {
          const retryAfter = response.headers["retry-after"] || response.headers["Retry-After"];
          throw new Error(`Google Gemini rate limit (429). ${retryAfter ? `Retry after ${retryAfter} seconds.` : "Please wait before retrying."}`);
        }
        throw new Error(`Google Gemini batch embedding API error: ${response.status} ${errorText}`);
      }
      const data = typeof response.json === "object" ? response.json : JSON.parse(response.text);
      if (data.embeddings && data.embeddings[0] && data.embeddings[0].values) {
        return data.embeddings[0].values;
      }
      throw new Error("Invalid Google Gemini batch embedding response format");
    } else {
      const response = await (0, import_obsidian19.requestUrl)({
        url: `https://generativelanguage.googleapis.com/v1beta/models/${model}:embedContent?key=${apiKey}`,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          content: {
            parts: [{ text: query }]
          }
        })
      });
      if (response.status !== 200) {
        const errorText = response.text || "";
        if (response.status === 429) {
          const retryAfter = response.headers["retry-after"] || response.headers["Retry-After"];
          throw new Error(`Google Gemini rate limit (429). ${retryAfter ? `Retry after ${retryAfter} seconds.` : "Please wait before retrying."}`);
        }
        throw new Error(`Google Gemini embedding API error: ${response.status} ${errorText}`);
      }
      const data = typeof response.json === "object" ? response.json : JSON.parse(response.text);
      if (data.embedding && data.embedding.values) {
        return data.embedding.values;
      }
      throw new Error("Invalid Google Gemini embedding response format");
    }
  }
  async callCustomEmbedding(apiUrl, query) {
    const response = await (0, import_obsidian19.requestUrl)({
      url: apiUrl,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        text: query
      })
    });
    if (response.status !== 200) {
      const errorText = response.text || "";
      if (response.status === 429) {
        const retryAfter = response.headers["retry-after"] || response.headers["Retry-After"];
        throw new Error(`Custom embedding API rate limit (429). ${retryAfter ? `Retry after ${retryAfter} seconds.` : "Please wait before retrying."}`);
      }
      throw new Error(`Custom embedding API error: ${response.status} ${errorText}`);
    }
    const data = typeof response.json === "object" ? response.json : JSON.parse(response.text);
    if (Array.isArray(data)) {
      return data;
    }
    if (data.embedding && Array.isArray(data.embedding)) {
      return data.embedding;
    }
    if (data.vector && Array.isArray(data.vector)) {
      return data.vector;
    }
    if (data.values && Array.isArray(data.values)) {
      return data.values;
    }
    throw new Error("Invalid custom embedding API response format");
  }
  async search(query, opts) {
    if (!this.isEnabled())
      return [];
    const q = (query.text ?? "").trim();
    if (!q)
      return [];
    await this.embeddingsIndex.ensureLoaded();
    let qVec;
    try {
      qVec = await this.getQueryEmbedding(q);
    } catch (error2) {
      console.error(`[ExternalEmbeddingsProvider] Failed to get query embedding:`, error2);
      return [];
    }
    const chunks = this.embeddingsIndex.getAllChunks().filter((c) => this.isAllowedPath(c.path));
    if (chunks.length === 0)
      return [];
    const scored = chunks.map((c) => {
      const localVec = c.vector;
      const qNorm = Math.sqrt(qVec.reduce((sum, v) => sum + v * v, 0)) || 1;
      const localNorm = Math.sqrt(localVec.reduce((sum, v) => sum + v * v, 0)) || 1;
      const normalizedQ = qVec.map((v) => v / qNorm);
      const normalizedLocal = localVec.map((v) => v / localNorm);
      const score = dot3(normalizedQ, normalizedLocal);
      return { chunk: c, score };
    }).sort((a, b) => b.score - a.score).slice(0, Math.max(1, Math.min(200, opts.limit * 6)));
    const results = [];
    for (const { chunk, score } of scored) {
      results.push({
        key: chunk.key,
        path: chunk.path,
        title: chunk.path.split("/").pop(),
        excerpt: chunk.excerpt,
        score: Math.max(0, Math.min(1, (score + 1) / 2)),
        source: this.id,
        reasonTags: ["external-embeddings"]
      });
    }
    return results.slice(0, opts.limit);
  }
};

// services/retrieval/SmartConnectionsProvider.ts
var import_obsidian20 = require("obsidian");
var SmartConnectionsProvider = class {
  constructor(app, plugin, vault, isAllowedPath) {
    this.id = "smart-connections";
    this.currentSessionId = "";
    this.app = app;
    this.plugin = plugin;
    this.vault = vault;
    this.isAllowedPath = isAllowedPath;
    this.initializeSession();
    this.logInitialization();
  }
  /**
   * Generate a new session ID for logging grouping.
   */
  generateSessionId() {
    return Math.random().toString(36).substring(2, 8);
  }
  /**
   * Initialize session ID for this instance.
   */
  initializeSession() {
    this.currentSessionId = this.generateSessionId();
  }
  /**
   * Structured logging helper with session ID support.
   */
  log(level, message, context, details) {
    const timestamp = new Date().toISOString();
    const methodName = new Error().stack?.split("\n")[2]?.match(/at \w+\.(\w+)/)?.[1] || "unknown";
    const sessionId = this.currentSessionId;
    const contextStr = context ? ` | Context: ${JSON.stringify(context)}` : "";
    const detailsStr = details ? ` | Details: ${JSON.stringify(details)}` : "";
    const logMessage = `[SmartConnectionsProvider:${methodName}][sid=${sessionId}] ${level.toUpperCase()}: ${message}${contextStr}${detailsStr}`;
    if (level === "error") {
      console.error(logMessage);
    } else if (level === "warn") {
      console.warn(logMessage);
    } else {
      console.debug(logMessage);
    }
  }
  /**
   * Log initialization status.
   */
  logInitialization() {
    const cache = this.plugin.settings.smartConnectionsCache;
    const enabled = this.plugin.settings.smartConnectionsCacheEnabled ?? false;
    if (cache) {
      const age = Date.now() - cache.capturedAt;
      const ageHours = Math.floor(age / (1e3 * 60 * 60));
      const ageMinutes = Math.floor(age % (1e3 * 60 * 60) / (1e3 * 60));
      const ageStr = ageHours > 0 ? `${ageHours}h ${ageMinutes}m` : `${ageMinutes}m`;
      const isFresh = this.isCacheFresh(cache);
      this.log("info", "Initialization complete", {
        cacheEnabled: enabled,
        cacheExists: true,
        cacheAge: ageStr,
        cacheResults: cache.results.length,
        cacheMethod: cache.method,
        cacheFresh: isFresh,
        sourceNote: cache.sourceNotePath,
        vaultId: cache.vaultId
      });
    } else {
      this.log("info", "Initialization complete", {
        cacheEnabled: enabled,
        cacheExists: false
      });
    }
  }
  /**
   * Get vault ID (name + optional basePath).
   */
  getVaultId() {
    const vaultName = this.app.vault.getName();
    const adapter = this.app.vault.adapter;
    const basePath = adapter.basePath || "";
    const vaultId = vaultName + (basePath ? `:${basePath}` : "");
    this.log("info", "Vault ID generated", {
      vaultName,
      basePath: basePath || "(not available)",
      vaultId
    });
    return vaultId;
  }
  /**
   * Check if cache is fresh (within TTL if set).
   */
  isCacheFresh(cache) {
    const ttl = this.plugin.settings.smartConnectionsCacheTTL;
    if (!ttl) {
      return true;
    }
    const age = Date.now() - cache.capturedAt;
    const ttlMs = ttl * 60 * 60 * 1e3;
    const fresh = age < ttlMs;
    this.log("info", "Cache freshness check", {
      age: `${Math.floor(age / (1e3 * 60 * 60))}h`,
      ttl: `${ttl}h`,
      fresh
    });
    return fresh;
  }
  /**
   * Normalize folder path for comparison (remove leading slash, ensure trailing slash).
   */
  normalizeFolderPath(path) {
    let normalized = path.replace(/^\/+/, "");
    if (normalized && !normalized.endsWith("/")) {
      normalized += "/";
    }
    return normalized;
  }
  /**
   * Check if path is allowed based on folder filters.
   */
  isPathAllowed(path) {
    const allowed = this.plugin.settings.smartConnectionsAllowedFolders || [];
    const blocked = this.plugin.settings.smartConnectionsBlockedFolders || [];
    const normalizedPath = this.normalizeFolderPath(path);
    for (const blockedFolder of blocked) {
      const normalizedBlocked = this.normalizeFolderPath(blockedFolder);
      if (normalizedPath === normalizedBlocked || normalizedPath.startsWith(normalizedBlocked)) {
        this.log("info", "Path blocked by filter", {
          path,
          blockedFolder,
          normalizedPath,
          normalizedBlocked
        });
        return false;
      }
    }
    if (allowed.length > 0) {
      const isAllowed = allowed.some((allowedFolder) => {
        const normalizedAllowed = this.normalizeFolderPath(allowedFolder);
        return normalizedPath === normalizedAllowed || normalizedPath.startsWith(normalizedAllowed);
      });
      if (!isAllowed) {
        this.log("info", "Path not in allowed folders", {
          path,
          allowedFolders: allowed,
          normalizedPath
        });
        return false;
      }
    }
    return true;
  }
  /**
   * Check cache keying match (soft/strict mode).
   */
  checkCacheKeying(cache, currentNotePath) {
    if (!cache.sourceNotePath) {
      return { match: true };
    }
    if (!currentNotePath) {
      return { match: true };
    }
    const match2 = cache.sourceNotePath === currentNotePath;
    if (!match2) {
      const mode = this.plugin.settings.smartConnectionsKeyingMode || "soft";
      this.log("warn", "Cache keying mismatch", {
        currentNote: currentNotePath,
        cacheNote: cache.sourceNotePath,
        mode
      });
    }
    return { match: match2, currentNote: currentNotePath, cacheNote: cache.sourceNotePath };
  }
  /**
   * Validate and clean cache (remove missing files, in-memory only).
   */
  validateAndCleanCache(cache) {
    const originalCount = cache.results.length;
    const validResults = cache.results.filter((result) => {
      const file = this.vault.getAbstractFileByPath(result.path);
      return file instanceof import_obsidian20.TFile;
    });
    const wasModified = validResults.length !== originalCount;
    if (wasModified) {
      const dropped = originalCount - validResults.length;
      this.log("warn", "Cache invalidation", {
        dropped,
        originalCount,
        valid: validResults.length
      });
      cache.results = validResults;
    }
    return { cache, wasModified };
  }
  /**
   * Save cache to settings (with sanity guard).
   */
  async saveCache(cache) {
    if (cache.results.length === 0) {
      this.log("warn", "Capture returned 0 results, preserving existing cache", {
        sessionId: cache.sessionId,
        method: cache.method
      });
      return;
    }
    this.plugin.settings.smartConnectionsCache = cache;
    await this.plugin.saveSettings();
    this.log("info", "Cache saved", {
      results: cache.results.length,
      method: cache.method,
      sourceNote: cache.sourceNotePath,
      vaultId: cache.vaultId
    });
  }
  /**
   * Get cache from settings.
   */
  getCache() {
    return this.plugin.settings.smartConnectionsCache || null;
  }
  /**
   * Find Smart Connections view using heuristic detection.
   */
  findSmartConnectionsView() {
    const leaves = [];
    this.app.workspace.iterateAllLeaves((leaf) => {
      leaves.push(leaf);
    });
    this.log("info", "Scanning workspace leaves", {
      totalLeaves: leaves.length
    });
    for (let i = 0; i < leaves.length; i++) {
      const leaf = leaves[i];
      const viewType = leaf.view.getViewType?.() || "unknown";
      const containerEl = leaf.view.containerEl;
      this.log("info", "Checking leaf", {
        index: i,
        viewType,
        containerClasses: Array.from(containerEl.classList || []).join(", ")
      });
      let confidence = "none";
      let marker = "";
      if (containerEl.classList.contains("smart-connections") || Array.from(containerEl.classList).some((c) => c.includes("smart-connections"))) {
        confidence = "high";
        marker = "class contains smart-connections";
      } else if (containerEl.textContent?.includes("Connections")) {
        confidence = "medium";
        marker = "contains text Connections";
      } else if (containerEl.querySelectorAll("a.internal-link[data-href]").length > 0) {
        confidence = "high";
        marker = "results list has internal links";
      }
      if (confidence !== "none") {
        this.log("info", "SC view detected", {
          leafIndex: i,
          viewType,
          marker,
          confidence
        });
        return leaf;
      }
    }
    this.log("info", "SC view not found", {
      leavesChecked: leaves.length
    });
    return null;
  }
  /**
   * Capture results from Smart Connections DOM.
   */
  async captureFromDom(sourceNotePath) {
    const sessionId = this.generateSessionId();
    this.currentSessionId = sessionId;
    await Promise.resolve();
    this.log("info", "Starting DOM capture", {
      sourceNotePath: sourceNotePath || "(not provided)",
      sessionId
    });
    const scView = this.findSmartConnectionsView();
    if (!scView) {
      this.log("warn", "SC view not found for DOM capture", {
        sessionId
      });
      return [];
    }
    const internalLinks = scView.view.containerEl.querySelectorAll("a.internal-link[data-href]");
    const resultsCount = internalLinks.length;
    this.log("info", "Results detection", {
      viewFound: true,
      selector: "a.internal-link[data-href]",
      count: resultsCount,
      sessionId
    });
    if (resultsCount === 0) {
      this.log("info", "View found, results missing", {
        viewFound: true,
        resultsFound: false,
        selector: "a.internal-link[data-href]",
        sessionId
      });
      return [];
    }
    const results = [];
    const maxCapture = this.plugin.settings.smartConnectionsMaxCaptureFiles ?? 200;
    for (let i = 0; i < Math.min(resultsCount, maxCapture); i++) {
      const link2 = internalLinks[i];
      const dataHref = link2.getAttribute("data-href");
      const href = link2.getAttribute("href");
      const path = dataHref || href || "";
      if (!path) {
        this.log("warn", "Link missing path", {
          index: i,
          dataHref,
          href,
          sessionId
        });
        continue;
      }
      let normalizedPath = path.replace(/\.md$/, "");
      if (normalizedPath.startsWith("#")) {
        continue;
      }
      const file = this.vault.getAbstractFileByPath(normalizedPath);
      if (!(file instanceof import_obsidian20.TFile)) {
        this.log("warn", "Link resolves to non-file", {
          path: normalizedPath,
          index: i,
          sessionId
        });
        continue;
      }
      if (!this.isPathAllowed(normalizedPath)) {
        this.log("info", "Link filtered out", {
          path: normalizedPath,
          index: i,
          sessionId
        });
        continue;
      }
      const rankScore = Math.max(0.5, 1 - i * 0.02);
      results.push({
        path: normalizedPath,
        score: rankScore
      });
      this.log("info", "Link captured", {
        index: i,
        path: normalizedPath,
        score: rankScore,
        sessionId
      });
    }
    this.log("info", "DOM capture complete", {
      results: results.length,
      time: "N/A",
      // Could add timing if needed
      sessionId
    });
    return results;
  }
  /**
   * Capture results from clipboard.
   */
  async captureFromClipboard(sourceNotePath) {
    const sessionId = this.generateSessionId();
    this.currentSessionId = sessionId;
    this.log("info", "Starting clipboard capture", {
      sourceNotePath: sourceNotePath || "(not provided)",
      sessionId
    });
    try {
      const clipboardText = await navigator.clipboard.readText();
      this.log("info", "Clipboard read", {
        length: clipboardText.length,
        preview: clipboardText.substring(0, 200),
        sessionId
      });
      const markdownLinkPattern = /\[\[([^\]]+)\]\]|\[([^\]]+)\]\(([^)]+\.md)\)/g;
      const links = [];
      let match2;
      while ((match2 = markdownLinkPattern.exec(clipboardText)) !== null) {
        const link2 = match2[1] || match2[3] || "";
        if (link2) {
          links.push(link2.replace(/\.md$/, ""));
        }
      }
      this.log("info", "Links parsed from clipboard", {
        found: links.length,
        links: links.slice(0, 10),
        // Log first 10
        sessionId
      });
      const results = [];
      const maxCapture = this.plugin.settings.smartConnectionsMaxCaptureFiles ?? 200;
      for (let i = 0; i < Math.min(links.length, maxCapture); i++) {
        const link2 = links[i];
        const file = this.vault.getAbstractFileByPath(link2);
        if (!(file instanceof import_obsidian20.TFile)) {
          this.log("warn", "Clipboard link resolves to non-file", {
            link: link2,
            index: i,
            sessionId
          });
          continue;
        }
        if (!this.isPathAllowed(link2)) {
          this.log("info", "Clipboard link filtered out", {
            link: link2,
            index: i,
            sessionId
          });
          continue;
        }
        const rankScore = Math.max(0.5, 1 - i * 0.02);
        results.push({
          path: link2,
          score: rankScore
        });
        this.log("info", "Clipboard link captured", {
          index: i,
          link: link2,
          score: rankScore,
          sessionId
        });
      }
      this.log("info", "Clipboard capture complete", {
        results: results.length,
        sessionId
      });
      return results;
    } catch (error2) {
      this.log("error", "Clipboard capture failed", {
        error: error2 instanceof Error ? error2.message : String(error2),
        stack: error2 instanceof Error ? error2.stack : void 0,
        sessionId
      });
      return [];
    }
  }
  /**
   * Tokenize text (simple word splitting, lowercase).
   */
  tokenize(text2) {
    return text2.toLowerCase().split(/[^a-z0-9]+/g).map((t) => t.trim()).filter((t) => t.length >= 2);
  }
  /**
   * Score cached items using metadata cache (fast path).
   */
  async scoreCachedItemsWithMetadata(cache, query, limit) {
    await Promise.resolve();
    const queryTokens = this.tokenize(query);
    const maxScoreFiles = this.plugin.settings.smartConnectionsMaxScoreFiles ?? 50;
    const itemsToScore = cache.results.slice(0, Math.min(cache.results.length, maxScoreFiles));
    this.log("info", "Starting metadata scoring", {
      queryTokens: queryTokens.slice(0, 10),
      // Log first 10 tokens
      itemsToScore: itemsToScore.length,
      maxScoreFiles,
      sessionId: this.currentSessionId
    });
    const scored = [];
    for (let i = 0; i < itemsToScore.length; i++) {
      const item = itemsToScore[i];
      const file = this.vault.getAbstractFileByPath(item.path);
      if (!(file instanceof import_obsidian20.TFile)) {
        continue;
      }
      const metadata = this.app.metadataCache.getFileCache(file);
      if (!metadata) {
        scored.push({
          path: item.path,
          rankScore: item.score ?? 0.5,
          metadataScore: 0,
          finalScore: item.score ?? 0.5,
          capturedAt: item.capturedAt
        });
        continue;
      }
      const metadataText = [];
      if (metadata.frontmatter?.tags) {
        const tags = Array.isArray(metadata.frontmatter.tags) ? metadata.frontmatter.tags : [metadata.frontmatter.tags];
        metadataText.push(...tags.map((t) => t.toString().toLowerCase()));
      }
      if (metadata.headings) {
        metadataText.push(...metadata.headings.map((h) => h.heading.toLowerCase()));
      }
      if (metadata.tags) {
        metadataText.push(...metadata.tags.map((t) => t.tag.toLowerCase()));
      }
      const metadataTokens = this.tokenize(metadataText.join(" "));
      const overlap = queryTokens.filter((t) => metadataTokens.includes(t)).length;
      const metadataScore = queryTokens.length > 0 ? overlap / queryTokens.length : 0;
      const rankScore = item.score ?? Math.max(0.5, 1 - i * 0.02);
      const finalScore = metadataScore * 0.7 + rankScore * 0.3;
      scored.push({
        path: item.path,
        rankScore,
        metadataScore,
        finalScore,
        capturedAt: item.capturedAt
      });
      this.log("info", "Item scored with metadata", {
        index: i,
        path: item.path,
        metadataScore: metadataScore.toFixed(3),
        rankScore: rankScore.toFixed(3),
        finalScore: finalScore.toFixed(3),
        sessionId: this.currentSessionId
      });
    }
    const sorted = scored.sort((a, b) => b.finalScore - a.finalScore);
    const topN = Math.min(10, limit * 2);
    this.log("info", "Metadata scoring complete", {
      scored: sorted.length,
      topN,
      sessionId: this.currentSessionId
    });
    return sorted.slice(0, topN);
  }
  /**
   * Load full content and re-score top items.
   */
  async loadAndScoreTopItems(topItems, query) {
    const queryTokens = this.tokenize(query);
    this.log("info", "Loading full content for top items", {
      count: topItems.length,
      sessionId: this.currentSessionId
    });
    for (let i = 0; i < topItems.length; i++) {
      const item = topItems[i];
      const file = this.vault.getAbstractFileByPath(item.path);
      if (!(file instanceof import_obsidian20.TFile)) {
        continue;
      }
      try {
        const content = await this.vault.read(file);
        const contentTokens = this.tokenize(content);
        const overlap = queryTokens.filter((t) => contentTokens.includes(t)).length;
        const fullContentScore = queryTokens.length > 0 ? overlap / queryTokens.length : 0;
        item.fullContentScore = fullContentScore;
        item.finalScore = fullContentScore * 0.7 + item.rankScore * 0.3;
        this.log("info", "Item re-scored with full content", {
          index: i,
          path: item.path,
          fullContentScore: fullContentScore.toFixed(3),
          finalScore: item.finalScore.toFixed(3),
          contentLength: content.length,
          sessionId: this.currentSessionId
        });
      } catch (error2) {
        this.log("warn", "Failed to read file for scoring", {
          path: item.path,
          error: error2 instanceof Error ? error2.message : String(error2),
          sessionId: this.currentSessionId
        });
      }
    }
    return topItems.sort((a, b) => b.finalScore - a.finalScore);
  }
  /**
   * Generate best-matching paragraph excerpt.
   */
  async generateBestMatchingExcerpt(path, query) {
    const file = this.vault.getAbstractFileByPath(path);
    if (!(file instanceof import_obsidian20.TFile)) {
      return "[File not found]";
    }
    try {
      const content = await this.vault.read(file);
      const queryTokens = this.tokenize(query);
      const paragraphs = content.split("\n\n");
      this.log("info", "Generating excerpt", {
        path,
        paragraphs: paragraphs.length,
        queryTokens: queryTokens.slice(0, 5),
        sessionId: this.currentSessionId
      });
      if (paragraphs.length === 0) {
        return content.trim().slice(0, 500) + (content.length > 500 ? "\u2026" : "");
      }
      let bestParagraph = paragraphs[0];
      let bestScore = 0;
      for (const paragraph2 of paragraphs) {
        const paraTokens = this.tokenize(paragraph2);
        const overlap = queryTokens.filter((t) => paraTokens.includes(t)).length;
        const score = queryTokens.length > 0 ? overlap / queryTokens.length : 0;
        if (score > bestScore) {
          bestScore = score;
          bestParagraph = paragraph2;
        }
      }
      let excerpt = bestParagraph.trim();
      const targetLength = 1e3;
      const minLength = 800;
      const maxLength = 1200;
      if (excerpt.length > maxLength) {
        const trimmed = excerpt.slice(0, maxLength);
        const lastPeriod = trimmed.lastIndexOf(".");
        if (lastPeriod > minLength) {
          excerpt = trimmed.slice(0, lastPeriod + 1);
        } else {
          excerpt = trimmed + "\u2026";
        }
      } else if (excerpt.length < minLength && paragraphs.length > 1) {
        const paraIndex = paragraphs.indexOf(bestParagraph);
        if (paraIndex < paragraphs.length - 1) {
          const combined = bestParagraph + "\n\n" + paragraphs[paraIndex + 1];
          excerpt = combined.trim().slice(0, maxLength);
          if (combined.length > maxLength) {
            excerpt += "\u2026";
          }
        }
      }
      this.log("info", "Excerpt generated", {
        path,
        excerptLength: excerpt.length,
        bestScore: bestScore.toFixed(3),
        method: bestScore > 0 ? "best-matching" : "first-paragraph",
        sessionId: this.currentSessionId
      });
      return excerpt;
    } catch (error2) {
      this.log("warn", "Failed to generate excerpt", {
        path,
        error: error2 instanceof Error ? error2.message : String(error2),
        sessionId: this.currentSessionId
      });
      return "[Error reading file]";
    }
  }
  async search(query, opts) {
    const sessionId = this.generateSessionId();
    this.currentSessionId = sessionId;
    const q = (query.text ?? "").trim();
    if (!q) {
      return [];
    }
    this.log("info", "Starting search", {
      query: q,
      limit: opts.limit,
      sessionId
    });
    const enabled = this.plugin.settings.smartConnectionsCacheEnabled ?? false;
    if (!enabled) {
      this.log("info", "Cache disabled, returning empty", {
        sessionId
      });
      return [];
    }
    const cache = this.getCache();
    if (!cache) {
      this.log("info", "No cache available, returning empty", {
        sessionId
      });
      return [];
    }
    if (!this.isCacheFresh(cache)) {
      this.log("warn", "Cache expired, returning empty", {
        sessionId
      });
      return [];
    }
    const currentNotePath = query.activeFilePath;
    const keyingCheck = this.checkCacheKeying(cache, currentNotePath);
    const keyingMode = this.plugin.settings.smartConnectionsKeyingMode || "soft";
    if (!keyingCheck.match && keyingMode === "strict") {
      this.log("warn", "Cache keying mismatch in strict mode, returning empty", {
        currentNote: currentNotePath,
        cacheNote: keyingCheck.cacheNote,
        sessionId
      });
      return [];
    }
    if (!keyingCheck.match) {
      this.log("warn", "Cache keying mismatch in soft mode, allowing use", {
        currentNote: currentNotePath,
        cacheNote: keyingCheck.cacheNote,
        sessionId
      });
    }
    const { cache: cleanedCache, wasModified } = this.validateAndCleanCache(cache);
    const topItems = await this.scoreCachedItemsWithMetadata(cleanedCache, q, opts.limit);
    const rescoredItems = await this.loadAndScoreTopItems(topItems, q);
    const results = [];
    const maxContextChars = this.plugin.settings.smartConnectionsMaxContextChars ?? 3e4;
    let totalContextChars = 0;
    let truncatedCount = 0;
    for (const item of rescoredItems) {
      if (results.length >= opts.limit) {
        break;
      }
      const excerpt = await this.generateBestMatchingExcerpt(item.path, q);
      let finalExcerpt = excerpt;
      if (totalContextChars + excerpt.length > maxContextChars) {
        const remaining = maxContextChars - totalContextChars;
        finalExcerpt = excerpt.slice(0, remaining) + "\u2026";
        truncatedCount++;
        this.log("info", "Context cap reached, truncating excerpt", {
          totalChars: totalContextChars + finalExcerpt.length,
          remaining,
          truncated: true,
          sessionId
        });
      }
      totalContextChars += finalExcerpt.length;
      results.push({
        key: item.path,
        path: item.path,
        title: item.path.split("/").pop() || item.path,
        excerpt: finalExcerpt,
        score: item.finalScore,
        source: this.id,
        reasonTags: ["smart-connections-cached"]
      });
    }
    if (truncatedCount > 0) {
      this.log("info", "Context cap summary", {
        totalChars: totalContextChars,
        maxChars: maxContextChars,
        truncated: truncatedCount,
        sessionId
      });
    }
    if (wasModified) {
      await this.saveCache(cleanedCache);
    }
    this.log("info", "Search complete", {
      results: results.length,
      method: "cached",
      sessionId
    });
    return results;
  }
  /**
   * Public method to capture from DOM and save to cache.
   */
  async captureAndSaveFromDom(sourceNotePath) {
    const results = await this.captureFromDom(sourceNotePath);
    if (results.length === 0) {
      return {
        success: false,
        count: 0,
        message: "Smart Connections view is open but no results found. Try running a search in Smart Connections first."
      };
    }
    const vaultId = this.getVaultId();
    const sessionId = this.generateSessionId();
    const cache = {
      sourceNotePath,
      vaultId,
      results: results.map((r, i) => ({
        path: r.path,
        score: r.score,
        capturedAt: Date.now()
      })),
      capturedAt: Date.now(),
      method: "dom",
      sessionId
    };
    await this.saveCache(cache);
    return {
      success: true,
      count: results.length
    };
  }
  /**
   * Public method to capture from clipboard and save to cache.
   */
  async captureAndSaveFromClipboard(sourceNotePath) {
    const results = await this.captureFromClipboard(sourceNotePath);
    if (results.length === 0) {
      return {
        success: false,
        count: 0,
        message: "No valid links found in clipboard. Ensure clipboard contains Smart Connections results with markdown links."
      };
    }
    const vaultId = this.getVaultId();
    const sessionId = this.generateSessionId();
    const cache = {
      sourceNotePath,
      vaultId,
      results: results.map((r, i) => ({
        path: r.path,
        score: r.score,
        capturedAt: Date.now()
      })),
      capturedAt: Date.now(),
      method: "clipboard",
      sessionId
    };
    await this.saveCache(cache);
    return {
      success: true,
      count: results.length
    };
  }
  /**
   * Public method to clear cache.
   */
  async clearCache() {
    this.plugin.settings.smartConnectionsCache = void 0;
    await this.plugin.saveSettings();
    this.log("info", "Cache cleared", {
      sessionId: this.currentSessionId
    });
  }
  /**
   * Public method to get cache status.
   */
  getCacheStatus() {
    const enabled = this.plugin.settings.smartConnectionsCacheEnabled ?? false;
    const cache = this.getCache();
    if (!cache) {
      return {
        exists: false,
        enabled,
        count: 0,
        fresh: false
      };
    }
    const age = Date.now() - cache.capturedAt;
    const ageHours = Math.floor(age / (1e3 * 60 * 60));
    const ageMinutes = Math.floor(age % (1e3 * 60 * 60) / (1e3 * 60));
    const ageStr = ageHours > 0 ? `${ageHours}h ${ageMinutes}m` : `${ageMinutes}m`;
    return {
      exists: true,
      enabled,
      count: cache.results.length,
      age: ageStr,
      method: cache.method,
      sourceNote: cache.sourceNotePath,
      fresh: this.isCacheFresh(cache)
    };
  }
  /**
   * Public method to check if Smart Connections view is available for capture.
   */
  checkViewAvailable() {
    const scView = this.findSmartConnectionsView();
    if (!scView) {
      return {
        available: false,
        message: "Smart Connections view not found. Open Smart Connections in a pane first."
      };
    }
    const internalLinks = scView.view.containerEl.querySelectorAll("a.internal-link[data-href]");
    if (internalLinks.length === 0) {
      return {
        available: false,
        message: "Smart Connections view is open but no results found. Try running a search in Smart Connections first."
      };
    }
    return {
      available: true
    };
  }
  /**
   * Get cached file paths directly (no search, no API calls).
   * Used for pure boost/filter operations in hybrid retrieval.
   */
  async getCachePaths() {
    const cache = this.getCache();
    if (!cache)
      return [];
    const enabled = this.plugin.settings.smartConnectionsCacheEnabled ?? false;
    if (!enabled)
      return [];
    if (!this.isCacheFresh(cache))
      return [];
    return cache.results.map((r) => r.path);
  }
};

// services/retrieval/Bm25Index.ts
var import_obsidian21 = require("obsidian");
function clampInt3(value, min, max) {
  if (!Number.isFinite(value))
    return min;
  return Math.max(min, Math.min(max, Math.floor(value)));
}
function excerptOf2(text2, maxChars) {
  const trimmed = text2.trim().replace(/\s+/g, " ");
  if (trimmed.length <= maxChars)
    return trimmed;
  return `${trimmed.slice(0, maxChars)}\u2026`;
}
function chunkingKey2(plugin) {
  return {
    headingLevel: plugin.settings.retrievalChunkHeadingLevel ?? "h1",
    targetWords: clampInt3(plugin.settings.retrievalChunkWords ?? 500, 200, 2e3),
    overlapWords: clampInt3(plugin.settings.retrievalChunkOverlapWords ?? 100, 0, 500)
  };
}
var STOPWORDS2 = /* @__PURE__ */ new Set([
  "the",
  "a",
  "an",
  "and",
  "or",
  "but",
  "to",
  "of",
  "in",
  "on",
  "for",
  "with",
  "at",
  "from",
  "by",
  "as",
  "is",
  "are",
  "was",
  "were",
  "be",
  "been",
  "it",
  "that",
  "this",
  "these",
  "those"
]);
function tokenize3(value) {
  return (value || "").toLowerCase().split(/[^\p{L}\p{N}]+/gu).map((t) => t.trim()).filter((t) => t.length >= 3 && !STOPWORDS2.has(t));
}
function tfMap(tokens) {
  const m = /* @__PURE__ */ new Map();
  for (const t of tokens)
    m.set(t, (m.get(t) ?? 0) + 1);
  return m;
}
var Bm25Index = class {
  constructor(vault, plugin) {
    this.loaded = false;
    this.chunksByKey = /* @__PURE__ */ new Map();
    this.chunkKeysByPath = /* @__PURE__ */ new Map();
    this.postings = /* @__PURE__ */ new Map();
    this.fileState = {};
    this.sumLen = 0;
    this.queue = /* @__PURE__ */ new Set();
    this.workerRunning = false;
    this.persistTimer = null;
    this.vault = vault;
    this.plugin = plugin;
  }
  getIndexFilePath() {
    return `${this.vault.configDir}/plugins/${this.plugin.manifest.id}/rag-index/bm25.json`;
  }
  getStatus() {
    return {
      indexedFiles: this.chunkKeysByPath.size,
      indexedChunks: this.chunksByKey.size,
      queued: this.queue.size
    };
  }
  getIndexedPaths() {
    return Array.from(this.chunkKeysByPath.keys());
  }
  /**
   * Queue all currently indexed paths for re-checking. This is useful when exclusions/profiles change.
   */
  queueRecheckAllIndexed() {
    for (const p of this.getIndexedPaths())
      this.queue.add(p);
    this._kickWorker();
  }
  async ensureLoaded() {
    if (this.loaded)
      return;
    this.loaded = true;
    try {
      const path = this.getIndexFilePath();
      if (!await this.vault.adapter.exists(path))
        return;
      const raw = await this.vault.adapter.read(path);
      const parsed = JSON.parse(raw);
      if (parsed?.version !== 1)
        return;
      const expectedChunking = chunkingKey2(this.plugin);
      if (parsed.chunking && (parsed.chunking.headingLevel !== expectedChunking.headingLevel || parsed.chunking.targetWords !== expectedChunking.targetWords || parsed.chunking.overlapWords !== expectedChunking.overlapWords)) {
        this.enqueueFullRescan();
        return;
      }
      this.fileState = parsed.fileState || {};
      this.sumLen = 0;
      this.chunksByKey.clear();
      this.chunkKeysByPath.clear();
      this.postings.clear();
      const chunks = parsed.chunks || {};
      for (const [key, ch] of Object.entries(chunks)) {
        if (!ch?.key || !ch?.path)
          continue;
        this.chunksByKey.set(key, ch);
        this.sumLen += ch.len || 0;
        const set2 = this.chunkKeysByPath.get(ch.path) ?? /* @__PURE__ */ new Set();
        set2.add(key);
        this.chunkKeysByPath.set(ch.path, set2);
      }
      const postings = parsed.postings || {};
      for (const [term, list2] of Object.entries(postings)) {
        if (!Array.isArray(list2))
          continue;
        this.postings.set(term, list2.filter((e) => Array.isArray(e) && typeof e[0] === "string" && typeof e[1] === "number"));
      }
    } catch {
      this.chunksByKey.clear();
      this.chunkKeysByPath.clear();
      this.postings.clear();
      this.fileState = {};
      this.sumLen = 0;
    }
  }
  enqueueFullRescan() {
    const files = this.plugin.vaultService.getIncludedMarkdownFiles();
    for (const f of files)
      this.queue.add(f.path);
    this._kickWorker();
  }
  queueUpdateFile(path) {
    if (!path)
      return;
    this.queue.add(path);
    this._kickWorker();
  }
  queueRemoveFile(path) {
    if (!path)
      return;
    this._removePath(path);
    this._schedulePersist();
  }
  _kickWorker() {
    if (this.workerRunning)
      return;
    this.workerRunning = true;
    void this._runWorker().catch(() => {
      this.workerRunning = false;
    });
  }
  async _runWorker() {
    await this.ensureLoaded();
    while (this.queue.size > 0) {
      if (this.plugin.settings.retrievalIndexPaused)
        break;
      const next = this.queue.values().next().value;
      this.queue.delete(next);
      if (this.plugin.vaultService.isExcludedPath(next)) {
        this._removePath(next);
        this._schedulePersist();
        continue;
      }
      const file = this.vault.getAbstractFileByPath(next);
      if (!(file instanceof import_obsidian21.TFile) || file.extension !== "md") {
        this._removePath(next);
        this._schedulePersist();
        continue;
      }
      try {
        const content = await this.vault.read(file);
        const fileHash = fnv1a32(content);
        const prev = this.fileState[next];
        if (prev?.hash === fileHash)
          continue;
        this._reindexFile(next, content);
        this.fileState[next] = {
          hash: fileHash,
          chunkCount: this.chunkKeysByPath.get(next)?.size ?? 0,
          updatedAt: new Date().toISOString()
        };
        this._schedulePersist();
      } catch {
      }
      await new Promise((r) => setTimeout(r, 10));
    }
    this.workerRunning = false;
  }
  _removePath(path) {
    const keys = this.chunkKeysByPath.get(path);
    if (keys) {
      for (const k of keys) {
        const ch = this.chunksByKey.get(k);
        if (ch)
          this.sumLen -= ch.len || 0;
        this.chunksByKey.delete(k);
      }
    }
    this.chunkKeysByPath.delete(path);
    delete this.fileState[path];
  }
  _reindexFile(path, content) {
    this._removePath(path);
    const cfg = chunkingKey2(this.plugin);
    const chunks = buildIndexChunks({
      text: content,
      headingLevel: cfg.headingLevel,
      targetWords: cfg.targetWords,
      overlapWords: cfg.overlapWords
    });
    for (let i = 0; i < chunks.length; i++) {
      const ch = chunks[i];
      const toks = tokenize3(ch.text);
      if (toks.length === 0)
        continue;
      const key = `chunk:${path}:${i}`;
      const tf = tfMap(toks);
      this.sumLen += toks.length;
      const meta = {
        key,
        path,
        chunkIndex: i,
        startWord: ch.startWord,
        endWord: ch.endWord,
        excerpt: excerptOf2(ch.text, 2500),
        len: toks.length
      };
      this.chunksByKey.set(key, meta);
      const set2 = this.chunkKeysByPath.get(path) ?? /* @__PURE__ */ new Set();
      set2.add(key);
      this.chunkKeysByPath.set(path, set2);
      for (const [term, count] of tf.entries()) {
        const list2 = this.postings.get(term) ?? [];
        list2.push([key, count]);
        this.postings.set(term, list2);
      }
    }
  }
  _schedulePersist() {
    if (this.persistTimer)
      window.clearTimeout(this.persistTimer);
    this.persistTimer = window.setTimeout(() => {
      this.persistTimer = null;
      void this._persistNow().catch(() => {
      });
    }, 1e3);
  }
  async _persistNow() {
    const dir = `${this.vault.configDir}/plugins/${this.plugin.manifest.id}/rag-index`;
    try {
      if (!await this.vault.adapter.exists(dir)) {
        await this.vault.adapter.mkdir(dir);
      }
    } catch {
    }
    const postingsObj = {};
    for (const [term, list2] of this.postings.entries())
      postingsObj[term] = list2;
    const chunksObj = {};
    for (const [key, ch] of this.chunksByKey.entries())
      chunksObj[key] = ch;
    const avgdl = this.chunksByKey.size ? this.sumLen / this.chunksByKey.size : 0;
    const payload = {
      version: 1,
      avgdl,
      totalChunks: this.chunksByKey.size,
      fileState: this.fileState,
      chunking: chunkingKey2(this.plugin),
      chunks: chunksObj,
      postings: postingsObj
    };
    await this.vault.adapter.write(this.getIndexFilePath(), JSON.stringify(payload));
  }
  search(queryText, limit) {
    const qTokens = tokenize3(queryText).slice(0, 24);
    const terms = Array.from(new Set(qTokens));
    if (terms.length === 0)
      return [];
    const N = this.chunksByKey.size;
    if (N === 0)
      return [];
    const avgdl = N ? this.sumLen / N : 0;
    const k1 = 1.2;
    const b = 0.75;
    const scores = /* @__PURE__ */ new Map();
    for (const term of terms) {
      const posting = this.postings.get(term);
      if (!posting || posting.length === 0)
        continue;
      let df = 0;
      for (const [key] of posting) {
        if (this.chunksByKey.has(key))
          df++;
      }
      if (df === 0)
        continue;
      const idf = Math.log(1 + (N - df + 0.5) / (df + 0.5));
      for (const [key, tf] of posting) {
        const ch = this.chunksByKey.get(key);
        if (!ch)
          continue;
        const dl = ch.len || 0;
        const denom = tf + k1 * (1 - b + b * dl / (avgdl || 1));
        const s = idf * (tf * (k1 + 1)) / (denom || 1);
        scores.set(key, (scores.get(key) ?? 0) + s);
      }
    }
    const ranked = Array.from(scores.entries()).map(([key, rawScore]) => {
      const ch = this.chunksByKey.get(key);
      if (!ch)
        return null;
      return { chunk: ch, rawScore, terms };
    }).filter((x) => Boolean(x)).sort((a, b2) => b2.rawScore - a.rawScore).slice(0, Math.max(1, Math.min(400, limit)));
    return ranked;
  }
};

// services/retrieval/Bm25Provider.ts
var Bm25Provider = class {
  constructor(index, isEnabled, isAllowedPath) {
    this.id = "bm25";
    this.index = index;
    this.isEnabled = isEnabled;
    this.isAllowedPath = isAllowedPath;
  }
  async search(query, opts) {
    if (!this.isEnabled())
      return [];
    const q = (query.text ?? "").trim();
    if (!q)
      return [];
    await this.index.ensureLoaded();
    const ranked = this.index.search(q, Math.max(1, Math.min(400, opts.limit * 8)));
    if (ranked.length === 0)
      return [];
    let max = 0;
    for (const r of ranked)
      if (r.rawScore > max)
        max = r.rawScore;
    const denom = max || 1;
    const results = [];
    for (const r of ranked) {
      if (!this.isAllowedPath(r.chunk.path))
        continue;
      results.push({
        key: r.chunk.key,
        path: r.chunk.path,
        title: r.chunk.path.split("/").pop(),
        excerpt: r.chunk.excerpt,
        score: Math.max(0, Math.min(1, r.rawScore / denom)),
        source: this.id,
        reasonTags: ["bm25"]
      });
      if (results.length >= opts.limit)
        break;
    }
    return results;
  }
};

// services/retrieval/CpuReranker.ts
function clamp01(x) {
  if (!Number.isFinite(x))
    return 0;
  return Math.max(0, Math.min(1, x));
}
function normalizeText(s) {
  return (s || "").replace(/\s+/g, " ").trim();
}
var TransformersCrossEncoder = class {
  constructor() {
    this.id = "cross-encoder-msmarco-minilm";
    this.pipeline = null;
    this.loading = null;
  }
  async ensureLoaded() {
    if (this.pipeline)
      return;
    if (this.loading !== null)
      return this.loading;
    this.loading = (async () => {
      console.log(`[CpuReranker] === STARTING RERANKER LOAD ===`);
      console.log(`[CpuReranker] Timestamp: ${new Date().toISOString()}`);
      console.log(`[CpuReranker] [STEP 1] Importing transformers.js module...`);
      let transformersModule;
      try {
        transformersModule = await Promise.resolve().then(() => (init_transformers(), transformers_exports));
        console.log(`[CpuReranker] [STEP 1] \u2713 Module imported successfully`);
      } catch (importErr) {
        console.error(`[CpuReranker] [STEP 1] \u2717 Module import failed:`, importErr);
        throw new Error(`Failed to import transformers.js: ${importErr instanceof Error ? importErr.message : String(importErr)}`);
      }
      console.log(`[CpuReranker] [STEP 2] Locating environment structure...`);
      let env = null;
      let envSource = "none";
      if (transformersModule.env) {
        console.log(`[CpuReranker] [STEP 2] \u2713 Found env via transformersModule.env`);
        env = transformersModule.env;
        envSource = "transformersModule.env";
      } else if (transformersModule.default?.env) {
        console.log(`[CpuReranker] [STEP 2] \u2713 Found env via transformersModule.default.env`);
        env = transformersModule.default.env;
        envSource = "transformersModule.default.env";
      }
      if (env) {
        console.log(`[CpuReranker] [STEP 2] env.backends exists:`, "backends" in env);
        console.log(`[CpuReranker] [STEP 2] env.backends.onnx exists:`, env.backends?.onnx !== void 0);
        console.log(`[CpuReranker] [STEP 2] env.useWasm exists:`, typeof env.useWasm === "function");
      } else {
        console.warn(`[CpuReranker] [STEP 2] \u2717 Could not find env structure`);
      }
      console.log(`[CpuReranker] [STEP 3] Attempting to configure WASM paths...`);
      const wasmBasePath = "./lib/";
      if (env) {
        let onnxBackendEnv = null;
        let onnxBackendPath = "none";
        if (transformersModule?.ONNX) {
          console.log(`[CpuReranker] [STEP 3] \u2713 Found ONNX export in module`);
          const onnx = transformersModule.ONNX;
          if (onnx?.env?.wasm) {
            onnxBackendEnv = onnx.env.wasm;
            onnxBackendPath = "transformersModule.ONNX.env.wasm";
            console.log(`[CpuReranker] [STEP 3] \u2713 Found ONNX env.wasm via transformersModule.ONNX`);
          } else if (onnx?.env) {
            onnxBackendEnv = onnx.env;
            onnxBackendPath = "transformersModule.ONNX.env";
            console.log(`[CpuReranker] [STEP 3] \u2713 Found ONNX env via transformersModule.ONNX`);
          }
        }
        if (!onnxBackendEnv && env.backends?.onnx) {
          const onnxBackend = env.backends.onnx;
          console.log(`[CpuReranker] [STEP 3] \u2713 ONNX backend found via env.backends.onnx`);
          if (onnxBackend.env?.wasm) {
            onnxBackendEnv = onnxBackend.env.wasm;
            onnxBackendPath = "env.backends.onnx.env.wasm";
          } else if (onnxBackend.wasm) {
            onnxBackendEnv = onnxBackend.wasm;
            onnxBackendPath = "onnxBackend.wasm";
          } else if (onnxBackend.env) {
            onnxBackendEnv = onnxBackend.env;
            onnxBackendPath = "onnxBackend.env";
          }
        }
        if (onnxBackendEnv) {
          console.log(`[CpuReranker] [STEP 3] Configuring WASM paths at: ${onnxBackendPath}`);
          try {
            if ("wasmPaths" in onnxBackendEnv) {
              onnxBackendEnv.wasmPaths = wasmBasePath;
              console.log(`[CpuReranker] [STEP 3] \u2713 Updated wasmPaths to: ${wasmBasePath}`);
            } else {
              Object.defineProperty(onnxBackendEnv, "wasmPaths", {
                value: wasmBasePath,
                writable: true,
                enumerable: true,
                configurable: true
              });
              console.log(`[CpuReranker] [STEP 3] \u2713 Created and set wasmPaths to: ${wasmBasePath}`);
            }
          } catch (pathErr) {
            console.warn(`[CpuReranker] [STEP 3] Failed to set wasmPaths at ${onnxBackendPath}:`, pathErr);
          }
        } else {
          console.warn(`[CpuReranker] [STEP 3] \u26A0 ONNX backend environment not found - may initialize lazily`);
        }
        try {
          if ("wasmPaths" in env) {
            env.wasmPaths = wasmBasePath;
            console.log(`[CpuReranker] [STEP 3] \u2713 Also set env.wasmPaths to: ${wasmBasePath}`);
          }
        } catch (envPathErr) {
          console.warn(`[CpuReranker] [STEP 3] Failed to set top-level env.wasmPaths:`, envPathErr);
        }
      } else {
        console.warn(`[CpuReranker] [STEP 3] \u2717 Cannot configure WASM paths - env not found`);
      }
      console.log(`[CpuReranker] [STEP 4] Locating pipeline function...`);
      const pipeline = transformersModule.pipeline || transformersModule.default?.pipeline;
      console.log(`[CpuReranker] [STEP 4] Pipeline found:`, pipeline !== void 0 && pipeline !== null);
      console.log(`[CpuReranker] [STEP 4] Pipeline type:`, typeof pipeline);
      if (!pipeline || typeof pipeline !== "function") {
        console.error(`[CpuReranker] [STEP 4] \u2717 Pipeline not found or not a function`);
        throw new Error("Transformers pipeline is unavailable");
      }
      console.log(`[CpuReranker] [STEP 4] \u2713 Pipeline function found`);
      console.log(`[CpuReranker] [STEP 5] Creating cross-encoder pipeline...`);
      console.log(`[CpuReranker] [STEP 5] Model: Xenova/cross-encoder-ms-marco-MiniLM-L-6-v2`);
      try {
        const pipeUnknown = await pipeline(
          "text-classification",
          "Xenova/cross-encoder-ms-marco-MiniLM-L-6-v2",
          { quantized: true }
        );
        const pipe = pipeUnknown;
        this.pipeline = async (input) => await pipe(input);
        console.log(`[CpuReranker] [STEP 5] \u2713 Pipeline created successfully`);
        console.log(`[CpuReranker] === RERANKER LOAD COMPLETE ===`);
      } catch (pipeErr) {
        console.error(`[CpuReranker] [STEP 5] \u2717 Pipeline creation failed:`, pipeErr);
        throw pipeErr;
      }
    })().finally(() => {
      this.loading = null;
    });
    return this.loading;
  }
  async rerankPair(query, document2) {
    const q = normalizeText(query);
    const d = normalizeText(document2);
    if (!q || !d)
      return { score: 0 };
    await this.ensureLoaded();
    if (!this.pipeline)
      throw new Error("Reranker pipeline unavailable");
    let out;
    try {
      out = await this.pipeline([{ text: q, text_pair: d }]);
    } catch {
      out = await this.pipeline(`${q}

${d}`);
    }
    const first = Array.isArray(out) ? out[0] : out;
    const obj = first;
    const score = typeof obj?.score === "number" ? obj.score : 0;
    return { score: clamp01(score) };
  }
};
var CpuReranker = class {
  constructor(model) {
    // queryHash -> itemKey -> score
    this.cache = /* @__PURE__ */ new Map();
    this.model = model ?? new TransformersCrossEncoder();
  }
  hashQuery(q) {
    return fnv1a32(normalizeText(q));
  }
  warm(query, items, opts) {
    const shortlist = Math.max(1, Math.min(120, Math.floor(opts?.shortlist ?? 40)));
    const qh = this.hashQuery(query);
    const map2 = this.cache.get(qh) ?? /* @__PURE__ */ new Map();
    this.cache.set(qh, map2);
    const toScore = items.slice(0, shortlist).filter((it) => !map2.has(it.key));
    if (toScore.length === 0)
      return;
    void (async () => {
      for (const it of toScore) {
        try {
          const doc = `${it.path}
${it.excerpt}`;
          const res = await this.model.rerankPair(query, doc);
          map2.set(it.key, res.score);
        } catch {
          break;
        }
      }
    })().catch(() => {
    });
  }
  async rerank(query, items, opts) {
    try {
      const limit = Math.max(1, Math.min(200, Math.floor(opts.limit)));
      const shortlist = Math.max(limit, Math.min(120, Math.floor(opts.shortlist ?? 60)));
      const qh = this.hashQuery(query);
      const map2 = this.cache.get(qh) ?? /* @__PURE__ */ new Map();
      this.cache.set(qh, map2);
      const scored = [];
      const slice = items.slice(0, shortlist);
      for (const it of slice) {
        const cached = map2.get(it.key);
        if (typeof cached === "number") {
          scored.push({ item: it, score: cached });
          continue;
        }
        try {
          const doc = `${it.path}
${it.excerpt}`;
          const res = await this.model.rerankPair(query, doc);
          map2.set(it.key, res.score);
          scored.push({ item: it, score: res.score });
        } catch (err) {
          console.warn(`[CpuReranker] Failed to rerank item ${it.key}, using original score:`, err);
          scored.push({ item: it, score: it.score });
        }
      }
      const out = scored.sort((a, b) => b.score - a.score || b.item.score - a.item.score).slice(0, limit).map((s) => ({
        ...s.item,
        // Keep the score field as the rerank score so formatting reflects true order.
        score: s.score,
        source: "rerank",
        reasonTags: Array.from(/* @__PURE__ */ new Set([...s.item.reasonTags ?? [], "rerank"]))
      }));
      return out;
    } catch (err) {
      console.warn("[CpuReranker] Reranking failed, returning original results:", err);
      return items.slice(0, opts.limit);
    }
  }
};

// services/GenerationLogService.ts
var import_obsidian22 = require("obsidian");
function normalizeFolder(folder) {
  const f = (folder || "").replace(/\\/g, "/").replace(/^\/+/, "").replace(/\/+$/, "");
  return f.length ? f : "Generation logs";
}
function pad2(n) {
  return String(n).padStart(2, "0");
}
function timestampForFile(d) {
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())} ${pad2(d.getHours())}-${pad2(d.getMinutes())}-${pad2(d.getSeconds())}`;
}
function escapeFenceContent(s) {
  return (s || "").replace(/```/g, "``\\`");
}
var GenerationLogService = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
  }
  getFolderPath() {
    return normalizeFolder(this.plugin.settings.generationLogsFolder);
  }
  async ensureFolder() {
    const folderPath = this.getFolderPath();
    if (!folderPath) {
      return false;
    }
    const existing = this.app.vault.getAbstractFileByPath(folderPath);
    if (existing instanceof import_obsidian22.TFolder)
      return true;
    try {
      await this.app.vault.createFolder(folderPath);
      return true;
    } catch {
      return false;
    }
  }
  async startLog(params) {
    if (!this.plugin.settings.generationLogsEnabled)
      return null;
    const folderExists = await this.ensureFolder();
    if (!folderExists) {
      console.warn("Generation logs folder not set or does not exist. Skipping log creation.");
      return null;
    }
    const now = new Date();
    const folder = this.getFolderPath();
    const stamp = timestampForFile(now);
    const safeTitle = (params.title || "Run").trim().slice(0, 80) || "Run";
    const fileName = `${stamp} ${safeTitle}.md`;
    const path = `${folder}/${fileName}`.replace(/\/+/g, "/");
    const inputsLines = Object.entries(params.userInputs).map(([k, v]) => `- ${k}: ${v ? `${v.length} chars` : "0 chars"}`).join("\n");
    const body = `# Generation log

- Mode: ${params.mode}
- Provider: ${params.provider}
- Model: ${params.model}
- Time: ${now.toISOString()}
- Query hash: ${fnv1a32(params.queryText || "")}

## Inputs

${inputsLines}

## Query

\`\`\`text
${escapeFenceContent(params.queryText || "")}
\`\`\`

## Retrieved context

\`\`\`text
${escapeFenceContent(params.retrievedContext || "")}
\`\`\`

` + (params.finalPrompt ? `## Final prompt

\`\`\`text
${escapeFenceContent(params.finalPrompt)}
\`\`\`

` : "");
    try {
      await this.app.vault.create(path, body);
      return path;
    } catch {
      new import_obsidian22.Notice("Failed to write generation log.");
      return null;
    }
  }
  async finishLog(path, params) {
    if (!path)
      return;
    const file = this.app.vault.getAbstractFileByPath(path);
    if (!(file instanceof import_obsidian22.TFile))
      return;
    const appendix = `## Result

` + (params.error ? `Error: ${params.error}

` : "Status: Success\n\n") + (params.outputText ? `\`\`\`text
${escapeFenceContent(params.outputText)}
\`\`\`
` : "");
    try {
      const existing = await this.app.vault.read(file);
      await this.app.vault.modify(file, `${existing}
${appendix}`);
    } catch {
    }
  }
};

// ui/BookMainSelectorModal.ts
var import_obsidian23 = require("obsidian");
var BookMainSelectorModal = class extends import_obsidian23.Modal {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
  }
  onOpen() {
    const modal = new FileTreePickerModal(this.plugin, {
      currentPath: this.plugin.settings.book2Path,
      title: "Select your main book file",
      onPick: async (filePath) => {
        this.plugin.settings.book2Path = filePath;
        this.plugin.settings.setupCompleted = true;
        await this.plugin.saveSettings();
        this.close();
      }
    });
    modal.open();
    this.close();
  }
};

// ui/PublishWizardModal.tsx
var import_react11 = __toESM(require_react());
var import_client6 = __toESM(require_client());
var import_obsidian27 = require("obsidian");

// ui/FolderPickerModal.ts
var import_obsidian24 = require("obsidian");
var FolderPickerModal = class extends import_obsidian24.FuzzySuggestModal {
  constructor(opts) {
    super(opts.app);
    this.folders = opts.folders;
    this.placeholderText = opts.placeholder;
    this.onPick = opts.onPick;
    this.setPlaceholder(this.placeholderText);
  }
  getItems() {
    return this.folders.slice().sort((a, b) => a.path.localeCompare(b.path));
  }
  getItemText(item) {
    return item.path;
  }
  onChooseItem(item) {
    void this.onPick(item);
  }
};

// ui/BinaryFilePickerModal.ts
var import_obsidian25 = require("obsidian");
var BinaryFilePickerModal = class extends import_obsidian25.FuzzySuggestModal {
  constructor(opts) {
    super(opts.app);
    this.files = opts.files;
    this.placeholderText = opts.placeholder;
    this.onPick = opts.onPick;
    this.setPlaceholder(this.placeholderText);
  }
  getItems() {
    return this.files.slice().sort((a, b) => a.path.localeCompare(b.path));
  }
  getItemText(item) {
    return item.path;
  }
  onChooseItem(item) {
    void this.onPick(item);
  }
};

// services/publish/MarkdownCompile.ts
var import_obsidian26 = require("obsidian");
function trimBom(s) {
  return s.charCodeAt(0) === 65279 ? s.slice(1) : s;
}
function parseH1Chapters(markdown, sourcePath) {
  const text2 = trimBom(markdown);
  const lines = text2.split(/\r?\n/);
  const chapters = [];
  let currentTitle = "";
  let currentBody = [];
  const flush = () => {
    const body = currentBody.join("\n").trim();
    if (!currentTitle && !body)
      return;
    const title = currentTitle || "Chapter";
    chapters.push({ title, sourcePath, markdown: body });
  };
  for (const line of lines) {
    const m = /^#\s+(.+?)\s*$/.exec(line);
    if (m) {
      if (currentTitle || currentBody.length)
        flush();
      currentTitle = m[1].trim();
      currentBody = [];
      continue;
    }
    currentBody.push(line);
  }
  flush();
  if (chapters.length === 0) {
    return [{ title: "Book", sourcePath, markdown: text2.trim() }];
  }
  return chapters;
}
function extractTocBlock(markdown) {
  const lines = trimBom(markdown).split(/\r?\n/);
  const startIdx = lines.findIndex((l) => /^#\s+toc\s*$/i.test(l.trim()));
  if (startIdx < 0)
    return null;
  const block2 = [];
  for (let i = startIdx + 1; i < lines.length; i++) {
    const line = lines[i];
    if (/^#\s+/.test(line.trim()))
      break;
    block2.push(line);
  }
  return block2;
}
function extractListLinks(lines) {
  const links = [];
  for (const line of lines) {
    if (!/^\s*(?:[-*+]\s+|\d+\.\s+)/.test(line))
      continue;
    const wikiMatches = Array.from(line.matchAll(/\[\[([^\]|#]+)(?:#[^\]]+)?(?:\|[^\]]+)?\]\]/g));
    for (const m of wikiMatches)
      links.push(m[1].trim());
    const mdMatches = Array.from(line.matchAll(/\[[^\]]*\]\(([^)]+)\)/g));
    for (const m of mdMatches)
      links.push(m[1].trim());
  }
  return links.filter(Boolean);
}
function uniquePreserveOrder(items) {
  const out = [];
  const seen = /* @__PURE__ */ new Set();
  for (const it of items) {
    const key = it;
    if (seen.has(key))
      continue;
    seen.add(key);
    out.push(it);
  }
  return out;
}
function normalizeLinkTarget(raw) {
  const noFrag = raw.split("#")[0].trim();
  if (!noFrag)
    return "";
  return noFrag.replace(/^<|>$/g, "").trim();
}
function resolveLinkToFilePath(app, linkTarget, fromPath) {
  const t = normalizeLinkTarget(linkTarget);
  if (!t)
    return null;
  const direct = app.vault.getAbstractFileByPath(t);
  if (direct instanceof import_obsidian26.TFile)
    return direct.path;
  const directMd = app.vault.getAbstractFileByPath(`${t}.md`);
  if (directMd instanceof import_obsidian26.TFile)
    return directMd.path;
  const dest = app.metadataCache.getFirstLinkpathDest(t, fromPath);
  if (dest instanceof import_obsidian26.TFile)
    return dest.path;
  return null;
}
var MarkdownCompile = class {
  constructor(app) {
    this.app = app;
  }
  async compileFromBookMain(sourcePath) {
    const file = this.app.vault.getAbstractFileByPath(sourcePath);
    if (!(file instanceof import_obsidian26.TFile)) {
      throw new Error(`Book main file not found: ${sourcePath}`);
    }
    const text2 = await this.app.vault.read(file);
    const chapters = parseH1Chapters(text2, file.path);
    return { titleGuess: file.basename, chapters };
  }
  async compileFromTocNote(tocPath) {
    const file = this.app.vault.getAbstractFileByPath(tocPath);
    if (!(file instanceof import_obsidian26.TFile))
      throw new Error(`TOC note not found: ${tocPath}`);
    const text2 = await this.app.vault.read(file);
    const lines = trimBom(text2).split(/\r?\n/);
    const tocBlock = extractTocBlock(text2);
    const linkTargets = tocBlock ? extractListLinks(tocBlock) : extractListLinks(lines);
    const ordered = uniquePreserveOrder(linkTargets);
    if (ordered.length === 0) {
      throw new Error("No chapter links found in the TOC note.");
    }
    const chapters = [];
    for (const target of ordered) {
      const destPath = resolveLinkToFilePath(this.app, target, file.path);
      if (!destPath)
        continue;
      const dest = this.app.vault.getAbstractFileByPath(destPath);
      if (!(dest instanceof import_obsidian26.TFile))
        continue;
      const md2 = await this.app.vault.read(dest);
      const title = (() => {
        const m = /^#\s+(.+?)\s*$/m.exec(md2);
        return m ? m[1].trim() : dest.basename;
      })();
      chapters.push({ title, sourcePath: dest.path, markdown: md2 });
    }
    if (chapters.length === 0) {
      throw new Error("No linked chapter files could be resolved.");
    }
    return { titleGuess: file.basename, chapters };
  }
};

// services/publish/EpubExportService.ts
var import_jszip = __toESM(require_jszip_min());

// node_modules/markdown-it/lib/common/utils.mjs
var utils_exports = {};
__export(utils_exports, {
  arrayReplaceAt: () => arrayReplaceAt,
  assign: () => assign,
  escapeHtml: () => escapeHtml,
  escapeRE: () => escapeRE,
  fromCodePoint: () => fromCodePoint2,
  has: () => has,
  isMdAsciiPunct: () => isMdAsciiPunct,
  isPunctChar: () => isPunctChar,
  isSpace: () => isSpace,
  isString: () => isString,
  isValidEntityCode: () => isValidEntityCode,
  isWhiteSpace: () => isWhiteSpace,
  lib: () => lib,
  normalizeReference: () => normalizeReference,
  unescapeAll: () => unescapeAll,
  unescapeMd: () => unescapeMd
});

// node_modules/mdurl/index.mjs
var mdurl_exports = {};
__export(mdurl_exports, {
  decode: () => decode_default,
  encode: () => encode_default,
  format: () => format,
  parse: () => parse_default
});

// node_modules/mdurl/lib/decode.mjs
var decodeCache = {};
function getDecodeCache(exclude) {
  let cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = decodeCache[exclude] = [];
  for (let i = 0; i < 128; i++) {
    const ch = String.fromCharCode(i);
    cache.push(ch);
  }
  for (let i = 0; i < exclude.length; i++) {
    const ch = exclude.charCodeAt(i);
    cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
  }
  return cache;
}
function decode(string, exclude) {
  if (typeof exclude !== "string") {
    exclude = decode.defaultChars;
  }
  const cache = getDecodeCache(exclude);
  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
    let result = "";
    for (let i = 0, l = seq.length; i < l; i += 3) {
      const b1 = parseInt(seq.slice(i + 1, i + 3), 16);
      if (b1 < 128) {
        result += cache[b1];
        continue;
      }
      if ((b1 & 224) === 192 && i + 3 < l) {
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        if ((b2 & 192) === 128) {
          const chr = b1 << 6 & 1984 | b2 & 63;
          if (chr < 128) {
            result += "\uFFFD\uFFFD";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 3;
          continue;
        }
      }
      if ((b1 & 240) === 224 && i + 6 < l) {
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128) {
          const chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
          if (chr < 2048 || chr >= 55296 && chr <= 57343) {
            result += "\uFFFD\uFFFD\uFFFD";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 6;
          continue;
        }
      }
      if ((b1 & 248) === 240 && i + 9 < l) {
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        const b4 = parseInt(seq.slice(i + 10, i + 12), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
          let chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
          if (chr < 65536 || chr > 1114111) {
            result += "\uFFFD\uFFFD\uFFFD\uFFFD";
          } else {
            chr -= 65536;
            result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
          }
          i += 9;
          continue;
        }
      }
      result += "\uFFFD";
    }
    return result;
  });
}
decode.defaultChars = ";/?:@&=+$,#";
decode.componentChars = "";
var decode_default = decode;

// node_modules/mdurl/lib/encode.mjs
var encodeCache = {};
function getEncodeCache(exclude) {
  let cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = encodeCache[exclude] = [];
  for (let i = 0; i < 128; i++) {
    const ch = String.fromCharCode(i);
    if (/^[0-9a-z]$/i.test(ch)) {
      cache.push(ch);
    } else {
      cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
    }
  }
  for (let i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }
  return cache;
}
function encode(string, exclude, keepEscaped) {
  if (typeof exclude !== "string") {
    keepEscaped = exclude;
    exclude = encode.defaultChars;
  }
  if (typeof keepEscaped === "undefined") {
    keepEscaped = true;
  }
  const cache = getEncodeCache(exclude);
  let result = "";
  for (let i = 0, l = string.length; i < l; i++) {
    const code2 = string.charCodeAt(i);
    if (keepEscaped && code2 === 37 && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }
    if (code2 < 128) {
      result += cache[code2];
      continue;
    }
    if (code2 >= 55296 && code2 <= 57343) {
      if (code2 >= 55296 && code2 <= 56319 && i + 1 < l) {
        const nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 56320 && nextCode <= 57343) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += "%EF%BF%BD";
      continue;
    }
    result += encodeURIComponent(string[i]);
  }
  return result;
}
encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";
var encode_default = encode;

// node_modules/mdurl/lib/format.mjs
function format(url) {
  let result = "";
  result += url.protocol || "";
  result += url.slashes ? "//" : "";
  result += url.auth ? url.auth + "@" : "";
  if (url.hostname && url.hostname.indexOf(":") !== -1) {
    result += "[" + url.hostname + "]";
  } else {
    result += url.hostname || "";
  }
  result += url.port ? ":" + url.port : "";
  result += url.pathname || "";
  result += url.search || "";
  result += url.hash || "";
  return result;
}

// node_modules/mdurl/lib/parse.mjs
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i;
var portPattern = /:[0-9]*$/;
var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
var autoEscape = ["'"].concat(unwise);
var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
var hostEndingChars = ["/", "?", "#"];
var hostnameMaxLen = 255;
var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
var hostlessProtocol = {
  javascript: true,
  "javascript:": true
};
var slashedProtocol = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url)
    return url;
  const u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}
Url.prototype.parse = function(url, slashesDenoteHost) {
  let lowerProto, hec, slashes;
  let rest = url;
  rest = rest.trim();
  if (!slashesDenoteHost && url.split("#").length === 1) {
    const simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }
  let proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    let hostEnd = -1;
    for (let i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    let auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }
    hostEnd = -1;
    for (let i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    if (rest[hostEnd - 1] === ":") {
      hostEnd--;
    }
    const host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost(host);
    this.hostname = this.hostname || "";
    const ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      const hostparts = this.hostname.split(/\./);
      for (let i = 0, l = hostparts.length; i < l; i++) {
        const part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          let newpart = "";
          for (let j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              newpart += "x";
            } else {
              newpart += part[j];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            const validParts = hostparts.slice(0, i);
            const notHost = hostparts.slice(i + 1);
            const bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    }
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }
  const hash = rest.indexOf("#");
  if (hash !== -1) {
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  const qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "";
  }
  return this;
};
Url.prototype.parseHost = function(host) {
  let port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};
var parse_default = urlParse;

// node_modules/uc.micro/index.mjs
var uc_exports = {};
__export(uc_exports, {
  Any: () => regex_default,
  Cc: () => regex_default2,
  Cf: () => regex_default3,
  P: () => regex_default4,
  S: () => regex_default5,
  Z: () => regex_default6
});

// node_modules/uc.micro/properties/Any/regex.mjs
var regex_default = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

// node_modules/uc.micro/categories/Cc/regex.mjs
var regex_default2 = /[\0-\x1F\x7F-\x9F]/;

// node_modules/uc.micro/categories/Cf/regex.mjs
var regex_default3 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

// node_modules/uc.micro/categories/P/regex.mjs
var regex_default4 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

// node_modules/uc.micro/categories/S/regex.mjs
var regex_default5 = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/;

// node_modules/uc.micro/categories/Z/regex.mjs
var regex_default6 = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;

// node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array(
  // prettier-ignore
  '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c) => c.charCodeAt(0))
);

// node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array(
  // prettier-ignore
  "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c) => c.charCodeAt(0))
);

// node_modules/entities/lib/esm/decode_codepoint.js
var _a;
var decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a2;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
}

// node_modules/entities/lib/esm/decode.js
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
  CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
  CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code2) {
  return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
}
function isHexadecimalCharacter(code2) {
  return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code2) {
  return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber(code2);
}
function isEntityInAttributeInvalidEnd(code2) {
  return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric(code2);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
  constructor(decodeTree, emitCodePoint, errors2) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors2;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base2) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start, digitCount), base2);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a2;
    if (this.consumed <= expectedLength) {
      (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a2;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a2;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
};
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str,
        // Skip the "&"
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);
function decodeHTML(str, mode = DecodingMode.Legacy) {
  return htmlDecoder(str, mode);
}

// node_modules/entities/lib/esm/generated/encode-html.js
function restoreDiff(arr) {
  for (let i = 1; i < arr.length; i++) {
    arr[i][0] += arr[i - 1][0] + 1;
  }
  return arr;
}
var encode_html_default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));

// node_modules/entities/lib/esm/escape.js
var xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (c, index) => (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index)
  )
);
function getEscaper(regex, map2) {
  return function escape3(data) {
    let match2;
    let lastIdx = 0;
    let result = "";
    while (match2 = regex.exec(data)) {
      if (lastIdx !== match2.index) {
        result += data.substring(lastIdx, match2.index);
      }
      result += map2.get(match2[0].charCodeAt(0));
      lastIdx = match2.index + 1;
    }
    return result + data.substring(lastIdx);
  };
}
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));

// node_modules/entities/lib/esm/index.js
var EntityLevel;
(function(EntityLevel2) {
  EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
  EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function(EncodingMode2) {
  EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
  EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
  EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
  EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
  EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));

// node_modules/markdown-it/lib/common/utils.mjs
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === "[object String]";
}
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function has(object, key) {
  return _hasOwnProperty.call(object, key);
}
function assign(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be object");
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}
function isValidEntityCode(c) {
  if (c >= 55296 && c <= 57343) {
    return false;
  }
  if (c >= 64976 && c <= 65007) {
    return false;
  }
  if ((c & 65535) === 65535 || (c & 65535) === 65534) {
    return false;
  }
  if (c >= 0 && c <= 8) {
    return false;
  }
  if (c === 11) {
    return false;
  }
  if (c >= 14 && c <= 31) {
    return false;
  }
  if (c >= 127 && c <= 159) {
    return false;
  }
  if (c > 1114111) {
    return false;
  }
  return true;
}
function fromCodePoint2(c) {
  if (c > 65535) {
    c -= 65536;
    const surrogate1 = 55296 + (c >> 10);
    const surrogate2 = 56320 + (c & 1023);
    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}
var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function replaceEntityPattern(match2, name2) {
  if (name2.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name2)) {
    const code2 = name2[1].toLowerCase() === "x" ? parseInt(name2.slice(2), 16) : parseInt(name2.slice(1), 10);
    if (isValidEntityCode(code2)) {
      return fromCodePoint2(code2);
    }
    return match2;
  }
  const decoded = decodeHTML(match2);
  if (decoded !== match2) {
    return decoded;
  }
  return match2;
}
function unescapeMd(str) {
  if (str.indexOf("\\") < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, "$1");
}
function unescapeAll(str) {
  if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
    return str;
  }
  return str.replace(UNESCAPE_ALL_RE, function(match2, escaped, entity2) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match2, entity2);
  });
}
var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}
function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}
var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, "\\$&");
}
function isSpace(code2) {
  switch (code2) {
    case 9:
    case 32:
      return true;
  }
  return false;
}
function isWhiteSpace(code2) {
  if (code2 >= 8192 && code2 <= 8202) {
    return true;
  }
  switch (code2) {
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return true;
  }
  return false;
}
function isPunctChar(ch) {
  return regex_default4.test(ch) || regex_default5.test(ch);
}
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function normalizeReference(str) {
  str = str.trim().replace(/\s+/g, " ");
  if ("\u1E9E".toLowerCase() === "\u1E7E") {
    str = str.replace(//g, "\xDF");
  }
  return str.toLowerCase().toUpperCase();
}
var lib = { mdurl: mdurl_exports, ucmicro: uc_exports };

// node_modules/markdown-it/lib/helpers/index.mjs
var helpers_exports = {};
__export(helpers_exports, {
  parseLinkDestination: () => parseLinkDestination,
  parseLinkLabel: () => parseLinkLabel,
  parseLinkTitle: () => parseLinkTitle
});

// node_modules/markdown-it/lib/helpers/parse_link_label.mjs
function parseLinkLabel(state, start, disableNested) {
  let level, found, marker, prevPos;
  const max = state.posMax;
  const oldPos = state.pos;
  state.pos = start + 1;
  level = 1;
  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 93) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }
    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 91) {
      if (prevPos === state.pos - 1) {
        level++;
      } else if (disableNested) {
        state.pos = oldPos;
        return -1;
      }
    }
  }
  let labelEnd = -1;
  if (found) {
    labelEnd = state.pos;
  }
  state.pos = oldPos;
  return labelEnd;
}

// node_modules/markdown-it/lib/helpers/parse_link_destination.mjs
function parseLinkDestination(str, start, max) {
  let code2;
  let pos = start;
  const result = {
    ok: false,
    pos: 0,
    str: ""
  };
  if (str.charCodeAt(pos) === 60) {
    pos++;
    while (pos < max) {
      code2 = str.charCodeAt(pos);
      if (code2 === 10) {
        return result;
      }
      if (code2 === 60) {
        return result;
      }
      if (code2 === 62) {
        result.pos = pos + 1;
        result.str = unescapeAll(str.slice(start + 1, pos));
        result.ok = true;
        return result;
      }
      if (code2 === 92 && pos + 1 < max) {
        pos += 2;
        continue;
      }
      pos++;
    }
    return result;
  }
  let level = 0;
  while (pos < max) {
    code2 = str.charCodeAt(pos);
    if (code2 === 32) {
      break;
    }
    if (code2 < 32 || code2 === 127) {
      break;
    }
    if (code2 === 92 && pos + 1 < max) {
      if (str.charCodeAt(pos + 1) === 32) {
        break;
      }
      pos += 2;
      continue;
    }
    if (code2 === 40) {
      level++;
      if (level > 32) {
        return result;
      }
    }
    if (code2 === 41) {
      if (level === 0) {
        break;
      }
      level--;
    }
    pos++;
  }
  if (start === pos) {
    return result;
  }
  if (level !== 0) {
    return result;
  }
  result.str = unescapeAll(str.slice(start, pos));
  result.pos = pos;
  result.ok = true;
  return result;
}

// node_modules/markdown-it/lib/helpers/parse_link_title.mjs
function parseLinkTitle(str, start, max, prev_state) {
  let code2;
  let pos = start;
  const state = {
    // if `true`, this is a valid link title
    ok: false,
    // if `true`, this link can be continued on the next line
    can_continue: false,
    // if `ok`, it's the position of the first character after the closing marker
    pos: 0,
    // if `ok`, it's the unescaped title
    str: "",
    // expected closing marker character code
    marker: 0
  };
  if (prev_state) {
    state.str = prev_state.str;
    state.marker = prev_state.marker;
  } else {
    if (pos >= max) {
      return state;
    }
    let marker = str.charCodeAt(pos);
    if (marker !== 34 && marker !== 39 && marker !== 40) {
      return state;
    }
    start++;
    pos++;
    if (marker === 40) {
      marker = 41;
    }
    state.marker = marker;
  }
  while (pos < max) {
    code2 = str.charCodeAt(pos);
    if (code2 === state.marker) {
      state.pos = pos + 1;
      state.str += unescapeAll(str.slice(start, pos));
      state.ok = true;
      return state;
    } else if (code2 === 40 && state.marker === 41) {
      return state;
    } else if (code2 === 92 && pos + 1 < max) {
      pos++;
    }
    pos++;
  }
  state.can_continue = true;
  state.str += unescapeAll(str.slice(start, pos));
  return state;
}

// node_modules/markdown-it/lib/renderer.mjs
var default_rules = {};
default_rules.code_inline = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(token.content) + "</code>";
};
default_rules.code_block = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
};
default_rules.fence = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  const info = token.info ? unescapeAll(token.info).trim() : "";
  let langName = "";
  let langAttrs = "";
  if (info) {
    const arr = info.split(/(\s+)/g);
    langName = arr[0];
    langAttrs = arr.slice(2).join("");
  }
  let highlighted;
  if (options.highlight) {
    highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }
  if (highlighted.indexOf("<pre") === 0) {
    return highlighted + "\n";
  }
  if (info) {
    const i = token.attrIndex("class");
    const tmpAttrs = token.attrs ? token.attrs.slice() : [];
    if (i < 0) {
      tmpAttrs.push(["class", options.langPrefix + langName]);
    } else {
      tmpAttrs[i] = tmpAttrs[i].slice();
      tmpAttrs[i][1] += " " + options.langPrefix + langName;
    }
    const tmpToken = {
      attrs: tmpAttrs
    };
    return `<pre><code${slf.renderAttrs(tmpToken)}>${highlighted}</code></pre>
`;
  }
  return `<pre><code${slf.renderAttrs(token)}>${highlighted}</code></pre>
`;
};
default_rules.image = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
  return slf.renderToken(tokens, idx, options);
};
default_rules.hardbreak = function(tokens, idx, options) {
  return options.xhtmlOut ? "<br />\n" : "<br>\n";
};
default_rules.softbreak = function(tokens, idx, options) {
  return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
};
default_rules.text = function(tokens, idx) {
  return escapeHtml(tokens[idx].content);
};
default_rules.html_block = function(tokens, idx) {
  return tokens[idx].content;
};
default_rules.html_inline = function(tokens, idx) {
  return tokens[idx].content;
};
function Renderer() {
  this.rules = assign({}, default_rules);
}
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  let i, l, result;
  if (!token.attrs) {
    return "";
  }
  result = "";
  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += " " + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }
  return result;
};
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  const token = tokens[idx];
  let result = "";
  if (token.hidden) {
    return "";
  }
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += "\n";
  }
  result += (token.nesting === -1 ? "</" : "<") + token.tag;
  result += this.renderAttrs(token);
  if (token.nesting === 0 && options.xhtmlOut) {
    result += " /";
  }
  let needLf = false;
  if (token.block) {
    needLf = true;
    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        const nextToken = tokens[idx + 1];
        if (nextToken.type === "inline" || nextToken.hidden) {
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          needLf = false;
        }
      }
    }
  }
  result += needLf ? ">\n" : ">";
  return result;
};
Renderer.prototype.renderInline = function(tokens, options, env) {
  let result = "";
  const rules = this.rules;
  for (let i = 0, len = tokens.length; i < len; i++) {
    const type = tokens[i].type;
    if (typeof rules[type] !== "undefined") {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }
  return result;
};
Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
  let result = "";
  for (let i = 0, len = tokens.length; i < len; i++) {
    switch (tokens[i].type) {
      case "text":
        result += tokens[i].content;
        break;
      case "image":
        result += this.renderInlineAsText(tokens[i].children, options, env);
        break;
      case "html_inline":
      case "html_block":
        result += tokens[i].content;
        break;
      case "softbreak":
      case "hardbreak":
        result += "\n";
        break;
      default:
    }
  }
  return result;
};
Renderer.prototype.render = function(tokens, options, env) {
  let result = "";
  const rules = this.rules;
  for (let i = 0, len = tokens.length; i < len; i++) {
    const type = tokens[i].type;
    if (type === "inline") {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== "undefined") {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }
  return result;
};
var renderer_default = Renderer;

// node_modules/markdown-it/lib/ruler.mjs
function Ruler() {
  this.__rules__ = [];
  this.__cache__ = null;
}
Ruler.prototype.__find__ = function(name2) {
  for (let i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name2) {
      return i;
    }
  }
  return -1;
};
Ruler.prototype.__compile__ = function() {
  const self2 = this;
  const chains = [""];
  self2.__rules__.forEach(function(rule) {
    if (!rule.enabled) {
      return;
    }
    rule.alt.forEach(function(altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });
  self2.__cache__ = {};
  chains.forEach(function(chain) {
    self2.__cache__[chain] = [];
    self2.__rules__.forEach(function(rule) {
      if (!rule.enabled) {
        return;
      }
      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }
      self2.__cache__[chain].push(rule.fn);
    });
  });
};
Ruler.prototype.at = function(name2, fn, options) {
  const index = this.__find__(name2);
  const opt = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + name2);
  }
  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};
Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
  const index = this.__find__(beforeName);
  const opt = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + beforeName);
  }
  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.after = function(afterName, ruleName, fn, options) {
  const index = this.__find__(afterName);
  const opt = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + afterName);
  }
  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.push = function(ruleName, fn, options) {
  const opt = options || {};
  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.enable = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  const result = [];
  list2.forEach(function(name2) {
    const idx = this.__find__(name2);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name2);
    }
    this.__rules__[idx].enabled = true;
    result.push(name2);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler.prototype.enableOnly = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  this.__rules__.forEach(function(rule) {
    rule.enabled = false;
  });
  this.enable(list2, ignoreInvalid);
};
Ruler.prototype.disable = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  const result = [];
  list2.forEach(function(name2) {
    const idx = this.__find__(name2);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name2);
    }
    this.__rules__[idx].enabled = false;
    result.push(name2);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler.prototype.getRules = function(chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }
  return this.__cache__[chainName] || [];
};
var ruler_default = Ruler;

// node_modules/markdown-it/lib/token.mjs
function Token(type, tag, nesting) {
  this.type = type;
  this.tag = tag;
  this.attrs = null;
  this.map = null;
  this.nesting = nesting;
  this.level = 0;
  this.children = null;
  this.content = "";
  this.markup = "";
  this.info = "";
  this.meta = null;
  this.block = false;
  this.hidden = false;
}
Token.prototype.attrIndex = function attrIndex(name2) {
  if (!this.attrs) {
    return -1;
  }
  const attrs = this.attrs;
  for (let i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name2) {
      return i;
    }
  }
  return -1;
};
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};
Token.prototype.attrSet = function attrSet(name2, value) {
  const idx = this.attrIndex(name2);
  const attrData = [name2, value];
  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};
Token.prototype.attrGet = function attrGet(name2) {
  const idx = this.attrIndex(name2);
  let value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};
Token.prototype.attrJoin = function attrJoin(name2, value) {
  const idx = this.attrIndex(name2);
  if (idx < 0) {
    this.attrPush([name2, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
  }
};
var token_default = Token;

// node_modules/markdown-it/lib/rules_core/state_core.mjs
function StateCore(src, md2, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md2;
}
StateCore.prototype.Token = token_default;
var state_core_default = StateCore;

// node_modules/markdown-it/lib/rules_core/normalize.mjs
var NEWLINES_RE = /\r\n?|\n/g;
var NULL_RE = /\0/g;
function normalize(state) {
  let str;
  str = state.src.replace(NEWLINES_RE, "\n");
  str = str.replace(NULL_RE, "\uFFFD");
  state.src = str;
}

// node_modules/markdown-it/lib/rules_core/block.mjs
function block(state) {
  let token;
  if (state.inlineMode) {
    token = new state.Token("inline", "", 0);
    token.content = state.src;
    token.map = [0, 1];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
}

// node_modules/markdown-it/lib/rules_core/inline.mjs
function inline(state) {
  const tokens = state.tokens;
  for (let i = 0, l = tokens.length; i < l; i++) {
    const tok = tokens[i];
    if (tok.type === "inline") {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
}

// node_modules/markdown-it/lib/rules_core/linkify.mjs
function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}
function linkify(state) {
  const blockTokens = state.tokens;
  if (!state.md.options.linkify) {
    return;
  }
  for (let j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }
    let tokens = blockTokens[j].children;
    let htmlLinkLevel = 0;
    for (let i = tokens.length - 1; i >= 0; i--) {
      const currentToken = tokens[i];
      if (currentToken.type === "link_close") {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
          i--;
        }
        continue;
      }
      if (currentToken.type === "html_inline") {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }
      if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
        const text2 = currentToken.content;
        let links = state.md.linkify.match(text2);
        const nodes = [];
        let level = currentToken.level;
        let lastPos = 0;
        if (links.length > 0 && links[0].index === 0 && i > 0 && tokens[i - 1].type === "text_special") {
          links = links.slice(1);
        }
        for (let ln = 0; ln < links.length; ln++) {
          const url = links[ln].url;
          const fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }
          let urlText = links[ln].text;
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
          } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }
          const pos = links[ln].index;
          if (pos > lastPos) {
            const token = new state.Token("text", "", 0);
            token.content = text2.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }
          const token_o = new state.Token("link_open", "a", 1);
          token_o.attrs = [["href", fullUrl]];
          token_o.level = level++;
          token_o.markup = "linkify";
          token_o.info = "auto";
          nodes.push(token_o);
          const token_t = new state.Token("text", "", 0);
          token_t.content = urlText;
          token_t.level = level;
          nodes.push(token_t);
          const token_c = new state.Token("link_close", "a", -1);
          token_c.level = --level;
          token_c.markup = "linkify";
          token_c.info = "auto";
          nodes.push(token_c);
          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text2.length) {
          const token = new state.Token("text", "", 0);
          token.content = text2.slice(lastPos);
          token.level = level;
          nodes.push(token);
        }
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
}

// node_modules/markdown-it/lib/rules_core/replacements.mjs
var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
var SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
var SCOPED_ABBR = {
  c: "\xA9",
  r: "\xAE",
  tm: "\u2122"
};
function replaceFn(match2, name2) {
  return SCOPED_ABBR[name2.toLowerCase()];
}
function replace_scoped(inlineTokens) {
  let inside_autolink = 0;
  for (let i = inlineTokens.length - 1; i >= 0; i--) {
    const token = inlineTokens[i];
    if (token.type === "text" && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }
    if (token.type === "link_open" && token.info === "auto") {
      inside_autolink--;
    }
    if (token.type === "link_close" && token.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace_rare(inlineTokens) {
  let inside_autolink = 0;
  for (let i = inlineTokens.length - 1; i >= 0; i--) {
    const token = inlineTokens[i];
    if (token.type === "text" && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013");
      }
    }
    if (token.type === "link_open" && token.info === "auto") {
      inside_autolink--;
    }
    if (token.type === "link_close" && token.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace(state) {
  let blkIdx;
  if (!state.md.options.typographer) {
    return;
  }
  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline") {
      continue;
    }
    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }
    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
}

// node_modules/markdown-it/lib/rules_core/smartquotes.mjs
var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = "\u2019";
function replaceAt(str, index, ch) {
  return str.slice(0, index) + ch + str.slice(index + 1);
}
function process_inlines(tokens, state) {
  let j;
  const stack = [];
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    const thisLevel = tokens[i].level;
    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;
    if (token.type !== "text") {
      continue;
    }
    let text2 = token.content;
    let pos = 0;
    let max = text2.length;
    OUTER:
      while (pos < max) {
        QUOTE_RE.lastIndex = pos;
        const t = QUOTE_RE.exec(text2);
        if (!t) {
          break;
        }
        let canOpen = true;
        let canClose = true;
        pos = t.index + 1;
        const isSingle = t[0] === "'";
        let lastChar = 32;
        if (t.index - 1 >= 0) {
          lastChar = text2.charCodeAt(t.index - 1);
        } else {
          for (j = i - 1; j >= 0; j--) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
              break;
            if (!tokens[j].content)
              continue;
            lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
            break;
          }
        }
        let nextChar = 32;
        if (pos < max) {
          nextChar = text2.charCodeAt(pos);
        } else {
          for (j = i + 1; j < tokens.length; j++) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
              break;
            if (!tokens[j].content)
              continue;
            nextChar = tokens[j].content.charCodeAt(0);
            break;
          }
        }
        const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
        const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
        const isLastWhiteSpace = isWhiteSpace(lastChar);
        const isNextWhiteSpace = isWhiteSpace(nextChar);
        if (isNextWhiteSpace) {
          canOpen = false;
        } else if (isNextPunctChar) {
          if (!(isLastWhiteSpace || isLastPunctChar)) {
            canOpen = false;
          }
        }
        if (isLastWhiteSpace) {
          canClose = false;
        } else if (isLastPunctChar) {
          if (!(isNextWhiteSpace || isNextPunctChar)) {
            canClose = false;
          }
        }
        if (nextChar === 34 && t[0] === '"') {
          if (lastChar >= 48 && lastChar <= 57) {
            canClose = canOpen = false;
          }
        }
        if (canOpen && canClose) {
          canOpen = isLastPunctChar;
          canClose = isNextPunctChar;
        }
        if (!canOpen && !canClose) {
          if (isSingle) {
            token.content = replaceAt(token.content, t.index, APOSTROPHE);
          }
          continue;
        }
        if (canClose) {
          for (j = stack.length - 1; j >= 0; j--) {
            let item = stack[j];
            if (stack[j].level < thisLevel) {
              break;
            }
            if (item.single === isSingle && stack[j].level === thisLevel) {
              item = stack[j];
              let openQuote;
              let closeQuote;
              if (isSingle) {
                openQuote = state.md.options.quotes[2];
                closeQuote = state.md.options.quotes[3];
              } else {
                openQuote = state.md.options.quotes[0];
                closeQuote = state.md.options.quotes[1];
              }
              token.content = replaceAt(token.content, t.index, closeQuote);
              tokens[item.token].content = replaceAt(
                tokens[item.token].content,
                item.pos,
                openQuote
              );
              pos += closeQuote.length - 1;
              if (item.token === i) {
                pos += openQuote.length - 1;
              }
              text2 = token.content;
              max = text2.length;
              stack.length = j;
              continue OUTER;
            }
          }
        }
        if (canOpen) {
          stack.push({
            token: i,
            pos: t.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
      }
  }
}
function smartquotes(state) {
  if (!state.md.options.typographer) {
    return;
  }
  for (let blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }
    process_inlines(state.tokens[blkIdx].children, state);
  }
}

// node_modules/markdown-it/lib/rules_core/text_join.mjs
function text_join(state) {
  let curr, last;
  const blockTokens = state.tokens;
  const l = blockTokens.length;
  for (let j = 0; j < l; j++) {
    if (blockTokens[j].type !== "inline")
      continue;
    const tokens = blockTokens[j].children;
    const max = tokens.length;
    for (curr = 0; curr < max; curr++) {
      if (tokens[curr].type === "text_special") {
        tokens[curr].type = "text";
      }
    }
    for (curr = last = 0; curr < max; curr++) {
      if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
      } else {
        if (curr !== last) {
          tokens[last] = tokens[curr];
        }
        last++;
      }
    }
    if (curr !== last) {
      tokens.length = last;
    }
  }
}

// node_modules/markdown-it/lib/parser_core.mjs
var _rules = [
  ["normalize", normalize],
  ["block", block],
  ["inline", inline],
  ["linkify", linkify],
  ["replacements", replace],
  ["smartquotes", smartquotes],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", text_join]
];
function Core() {
  this.ruler = new ruler_default();
  for (let i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}
Core.prototype.process = function(state) {
  const rules = this.ruler.getRules("");
  for (let i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};
Core.prototype.State = state_core_default;
var parser_core_default = Core;

// node_modules/markdown-it/lib/rules_block/state_block.mjs
function StateBlock(src, md2, env, tokens) {
  this.src = src;
  this.md = md2;
  this.env = env;
  this.tokens = tokens;
  this.bMarks = [];
  this.eMarks = [];
  this.tShift = [];
  this.sCount = [];
  this.bsCount = [];
  this.blkIndent = 0;
  this.line = 0;
  this.lineMax = 0;
  this.tight = false;
  this.ddIndent = -1;
  this.listIndent = -1;
  this.parentType = "root";
  this.level = 0;
  const s = this.src;
  for (let start = 0, pos = 0, indent = 0, offset = 0, len = s.length, indent_found = false; pos < len; pos++) {
    const ch = s.charCodeAt(pos);
    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;
        if (ch === 9) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }
    if (ch === 10 || pos === len - 1) {
      if (ch !== 10) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);
      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);
  this.lineMax = this.bMarks.length - 1;
}
StateBlock.prototype.push = function(type, tag, nesting) {
  const token = new token_default(type, tag, nesting);
  token.block = true;
  if (nesting < 0)
    this.level--;
  token.level = this.level;
  if (nesting > 0)
    this.level++;
  this.tokens.push(token);
  return token;
};
StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};
StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (let max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  for (let max = this.src.length; pos < max; pos++) {
    const ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.skipChars = function skipChars(pos, code2) {
  for (let max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code2) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (code2 !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  if (begin >= end) {
    return "";
  }
  const queue = new Array(end - begin);
  for (let i = 0, line = begin; line < end; line++, i++) {
    let lineIndent = 0;
    const lineStart = this.bMarks[line];
    let first = lineStart;
    let last;
    if (line + 1 < end || keepLastLF) {
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }
    while (first < last && lineIndent < indent) {
      const ch = this.src.charCodeAt(first);
      if (isSpace(ch)) {
        if (ch === 9) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        lineIndent++;
      } else {
        break;
      }
      first++;
    }
    if (lineIndent > indent) {
      queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }
  return queue.join("");
};
StateBlock.prototype.Token = token_default;
var state_block_default = StateBlock;

// node_modules/markdown-it/lib/rules_block/table.mjs
var MAX_AUTOCOMPLETED_CELLS = 65536;
function getLine(state, line) {
  const pos = state.bMarks[line] + state.tShift[line];
  const max = state.eMarks[line];
  return state.src.slice(pos, max);
}
function escapedSplit(str) {
  const result = [];
  const max = str.length;
  let pos = 0;
  let ch = str.charCodeAt(pos);
  let isEscaped = false;
  let lastPos = 0;
  let current = "";
  while (pos < max) {
    if (ch === 124) {
      if (!isEscaped) {
        result.push(current + str.substring(lastPos, pos));
        current = "";
        lastPos = pos + 1;
      } else {
        current += str.substring(lastPos, pos - 1);
        lastPos = pos;
      }
    }
    isEscaped = ch === 92;
    pos++;
    ch = str.charCodeAt(pos);
  }
  result.push(current + str.substring(lastPos));
  return result;
}
function table(state, startLine, endLine, silent) {
  if (startLine + 2 > endLine) {
    return false;
  }
  let nextLine = startLine + 1;
  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }
  let pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  const firstCh = state.src.charCodeAt(pos++);
  if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
    return false;
  }
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  const secondCh = state.src.charCodeAt(pos++);
  if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
    return false;
  }
  if (firstCh === 45 && isSpace(secondCh)) {
    return false;
  }
  while (pos < state.eMarks[nextLine]) {
    const ch = state.src.charCodeAt(pos);
    if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
      return false;
    }
    pos++;
  }
  let lineText = getLine(state, startLine + 1);
  let columns = lineText.split("|");
  const aligns = [];
  for (let i = 0; i < columns.length; i++) {
    const t = columns[i].trim();
    if (!t) {
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }
    if (!/^:?-+:?$/.test(t)) {
      return false;
    }
    if (t.charCodeAt(t.length - 1) === 58) {
      aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
    } else if (t.charCodeAt(0) === 58) {
      aligns.push("left");
    } else {
      aligns.push("");
    }
  }
  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf("|") === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText);
  if (columns.length && columns[0] === "")
    columns.shift();
  if (columns.length && columns[columns.length - 1] === "")
    columns.pop();
  const columnCount = columns.length;
  if (columnCount === 0 || columnCount !== aligns.length) {
    return false;
  }
  if (silent) {
    return true;
  }
  const oldParentType = state.parentType;
  state.parentType = "table";
  const terminatorRules = state.md.block.ruler.getRules("blockquote");
  const token_to = state.push("table_open", "table", 1);
  const tableLines = [startLine, 0];
  token_to.map = tableLines;
  const token_tho = state.push("thead_open", "thead", 1);
  token_tho.map = [startLine, startLine + 1];
  const token_htro = state.push("tr_open", "tr", 1);
  token_htro.map = [startLine, startLine + 1];
  for (let i = 0; i < columns.length; i++) {
    const token_ho = state.push("th_open", "th", 1);
    if (aligns[i]) {
      token_ho.attrs = [["style", "text-align:" + aligns[i]]];
    }
    const token_il = state.push("inline", "", 0);
    token_il.content = columns[i].trim();
    token_il.children = [];
    state.push("th_close", "th", -1);
  }
  state.push("tr_close", "tr", -1);
  state.push("thead_close", "thead", -1);
  let tbodyLines;
  let autocompletedCells = 0;
  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    lineText = getLine(state, nextLine).trim();
    if (!lineText) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === "")
      columns.shift();
    if (columns.length && columns[columns.length - 1] === "")
      columns.pop();
    autocompletedCells += columnCount - columns.length;
    if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) {
      break;
    }
    if (nextLine === startLine + 2) {
      const token_tbo = state.push("tbody_open", "tbody", 1);
      token_tbo.map = tbodyLines = [startLine + 2, 0];
    }
    const token_tro = state.push("tr_open", "tr", 1);
    token_tro.map = [nextLine, nextLine + 1];
    for (let i = 0; i < columnCount; i++) {
      const token_tdo = state.push("td_open", "td", 1);
      if (aligns[i]) {
        token_tdo.attrs = [["style", "text-align:" + aligns[i]]];
      }
      const token_il = state.push("inline", "", 0);
      token_il.content = columns[i] ? columns[i].trim() : "";
      token_il.children = [];
      state.push("td_close", "td", -1);
    }
    state.push("tr_close", "tr", -1);
  }
  if (tbodyLines) {
    state.push("tbody_close", "tbody", -1);
    tbodyLines[1] = nextLine;
  }
  state.push("table_close", "table", -1);
  tableLines[1] = nextLine;
  state.parentType = oldParentType;
  state.line = nextLine;
  return true;
}

// node_modules/markdown-it/lib/rules_block/code.mjs
function code(state, startLine, endLine) {
  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }
  let nextLine = startLine + 1;
  let last = nextLine;
  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }
  state.line = last;
  const token = state.push("code_block", "code", 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
  token.map = [startLine, state.line];
  return true;
}

// node_modules/markdown-it/lib/rules_block/fence.mjs
function fence(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (pos + 3 > max) {
    return false;
  }
  const marker = state.src.charCodeAt(pos);
  if (marker !== 126 && marker !== 96) {
    return false;
  }
  let mem = pos;
  pos = state.skipChars(pos, marker);
  let len = pos - mem;
  if (len < 3) {
    return false;
  }
  const markup = state.src.slice(mem, pos);
  const params = state.src.slice(pos, max);
  if (marker === 96) {
    if (params.indexOf(String.fromCharCode(marker)) >= 0) {
      return false;
    }
  }
  if (silent) {
    return true;
  }
  let nextLine = startLine;
  let haveEndMarker = false;
  for (; ; ) {
    nextLine++;
    if (nextLine >= endLine) {
      break;
    }
    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];
    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      continue;
    }
    pos = state.skipChars(pos, marker);
    if (pos - mem < len) {
      continue;
    }
    pos = state.skipSpaces(pos);
    if (pos < max) {
      continue;
    }
    haveEndMarker = true;
    break;
  }
  len = state.sCount[startLine];
  state.line = nextLine + (haveEndMarker ? 1 : 0);
  const token = state.push("fence", "code", 0);
  token.info = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state.line];
  return true;
}

// node_modules/markdown-it/lib/rules_block/blockquote.mjs
function blockquote(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  const oldLineMax = state.lineMax;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 62) {
    return false;
  }
  if (silent) {
    return true;
  }
  const oldBMarks = [];
  const oldBSCount = [];
  const oldSCount = [];
  const oldTShift = [];
  const terminatorRules = state.md.block.ruler.getRules("blockquote");
  const oldParentType = state.parentType;
  state.parentType = "blockquote";
  let lastLineEmpty = false;
  let nextLine;
  for (nextLine = startLine; nextLine < endLine; nextLine++) {
    const isOutdented = state.sCount[nextLine] < state.blkIndent;
    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];
    if (pos >= max) {
      break;
    }
    if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
      let initial = state.sCount[nextLine] + 1;
      let spaceAfterMarker;
      let adjustTab;
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[nextLine] + initial) % 4 === 3) {
          pos++;
          initial++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      let offset = initial;
      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;
      while (pos < max) {
        const ch = state.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      lastLineEmpty = pos >= max;
      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;
      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }
    if (lastLineEmpty) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      state.lineMax = nextLine;
      if (state.blkIndent !== 0) {
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }
      break;
    }
    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);
    state.sCount[nextLine] = -1;
  }
  const oldIndent = state.blkIndent;
  state.blkIndent = 0;
  const token_o = state.push("blockquote_open", "blockquote", 1);
  token_o.markup = ">";
  const lines = [startLine, 0];
  token_o.map = lines;
  state.md.block.tokenize(state, startLine, nextLine);
  const token_c = state.push("blockquote_close", "blockquote", -1);
  token_c.markup = ">";
  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;
  for (let i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;
  return true;
}

// node_modules/markdown-it/lib/rules_block/hr.mjs
function hr(state, startLine, endLine, silent) {
  const max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  const marker = state.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 95) {
    return false;
  }
  let cnt = 1;
  while (pos < max) {
    const ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }
  if (cnt < 3) {
    return false;
  }
  if (silent) {
    return true;
  }
  state.line = startLine + 1;
  const token = state.push("hr", "hr", 0);
  token.map = [startLine, state.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
  return true;
}

// node_modules/markdown-it/lib/rules_block/list.mjs
function skipBulletListMarker(state, startLine) {
  const max = state.eMarks[startLine];
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  const marker = state.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 43) {
    return -1;
  }
  if (pos < max) {
    const ch = state.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      return -1;
    }
  }
  return pos;
}
function skipOrderedListMarker(state, startLine) {
  const start = state.bMarks[startLine] + state.tShift[startLine];
  const max = state.eMarks[startLine];
  let pos = start;
  if (pos + 1 >= max) {
    return -1;
  }
  let ch = state.src.charCodeAt(pos++);
  if (ch < 48 || ch > 57) {
    return -1;
  }
  for (; ; ) {
    if (pos >= max) {
      return -1;
    }
    ch = state.src.charCodeAt(pos++);
    if (ch >= 48 && ch <= 57) {
      if (pos - start >= 10) {
        return -1;
      }
      continue;
    }
    if (ch === 41 || ch === 46) {
      break;
    }
    return -1;
  }
  if (pos < max) {
    ch = state.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      return -1;
    }
  }
  return pos;
}
function markTightParagraphs(state, idx) {
  const level = state.level + 2;
  for (let i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}
function list(state, startLine, endLine, silent) {
  let max, pos, start, token;
  let nextLine = startLine;
  let tight = true;
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.listIndent >= 0 && state.sCount[nextLine] - state.listIndent >= 4 && state.sCount[nextLine] < state.blkIndent) {
    return false;
  }
  let isTerminatingParagraph = false;
  if (silent && state.parentType === "paragraph") {
    if (state.sCount[nextLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }
  let isOrdered;
  let markerValue;
  let posAfterMarker;
  if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[nextLine] + state.tShift[nextLine];
    markerValue = Number(state.src.slice(start, posAfterMarker - 1));
    if (isTerminatingParagraph && markerValue !== 1)
      return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine])
      return false;
  }
  if (silent) {
    return true;
  }
  const markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
  const listTokIdx = state.tokens.length;
  if (isOrdered) {
    token = state.push("ordered_list_open", "ol", 1);
    if (markerValue !== 1) {
      token.attrs = [["start", markerValue]];
    }
  } else {
    token = state.push("bullet_list_open", "ul", 1);
  }
  const listLines = [nextLine, 0];
  token.map = listLines;
  token.markup = String.fromCharCode(markerCharCode);
  let prevEmptyEnd = false;
  const terminatorRules = state.md.block.ruler.getRules("list");
  const oldParentType = state.parentType;
  state.parentType = "list";
  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];
    const initial = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine]);
    let offset = initial;
    while (pos < max) {
      const ch = state.src.charCodeAt(pos);
      if (ch === 9) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch === 32) {
        offset++;
      } else {
        break;
      }
      pos++;
    }
    const contentStart = pos;
    let indentAfterMarker;
    if (contentStart >= max) {
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }
    const indent = initial + indentAfterMarker;
    token = state.push("list_item_open", "li", 1);
    token.markup = String.fromCharCode(markerCharCode);
    const itemLines = [nextLine, 0];
    token.map = itemLines;
    if (isOrdered) {
      token.info = state.src.slice(start, posAfterMarker - 1);
    }
    const oldTight = state.tight;
    const oldTShift = state.tShift[nextLine];
    const oldSCount = state.sCount[nextLine];
    const oldListIndent = state.listIndent;
    state.listIndent = state.blkIndent;
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[nextLine] = contentStart - state.bMarks[nextLine];
    state.sCount[nextLine] = offset;
    if (contentStart >= max && state.isEmpty(nextLine + 1)) {
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, nextLine, endLine, true);
    }
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    prevEmptyEnd = state.line - nextLine > 1 && state.isEmpty(state.line - 1);
    state.blkIndent = state.listIndent;
    state.listIndent = oldListIndent;
    state.tShift[nextLine] = oldTShift;
    state.sCount[nextLine] = oldSCount;
    state.tight = oldTight;
    token = state.push("list_item_close", "li", -1);
    token.markup = String.fromCharCode(markerCharCode);
    nextLine = state.line;
    itemLines[1] = nextLine;
    if (nextLine >= endLine) {
      break;
    }
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
      start = state.bMarks[nextLine] + state.tShift[nextLine];
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }
    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }
  if (isOrdered) {
    token = state.push("ordered_list_close", "ol", -1);
  } else {
    token = state.push("bullet_list_close", "ul", -1);
  }
  token.markup = String.fromCharCode(markerCharCode);
  listLines[1] = nextLine;
  state.line = nextLine;
  state.parentType = oldParentType;
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }
  return true;
}

// node_modules/markdown-it/lib/rules_block/reference.mjs
function reference(state, startLine, _endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  let nextLine = startLine + 1;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 91) {
    return false;
  }
  function getNextLine(nextLine2) {
    const endLine = state.lineMax;
    if (nextLine2 >= endLine || state.isEmpty(nextLine2)) {
      return null;
    }
    let isContinuation = false;
    if (state.sCount[nextLine2] - state.blkIndent > 3) {
      isContinuation = true;
    }
    if (state.sCount[nextLine2] < 0) {
      isContinuation = true;
    }
    if (!isContinuation) {
      const terminatorRules = state.md.block.ruler.getRules("reference");
      const oldParentType = state.parentType;
      state.parentType = "reference";
      let terminate = false;
      for (let i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine2, endLine, true)) {
          terminate = true;
          break;
        }
      }
      state.parentType = oldParentType;
      if (terminate) {
        return null;
      }
    }
    const pos2 = state.bMarks[nextLine2] + state.tShift[nextLine2];
    const max2 = state.eMarks[nextLine2];
    return state.src.slice(pos2, max2 + 1);
  }
  let str = state.src.slice(pos, max + 1);
  max = str.length;
  let labelEnd = -1;
  for (pos = 1; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 91) {
      return false;
    } else if (ch === 93) {
      labelEnd = pos;
      break;
    } else if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (ch === 92) {
      pos++;
      if (pos < max && str.charCodeAt(pos) === 10) {
        const lineContent = getNextLine(nextLine);
        if (lineContent !== null) {
          str += lineContent;
          max = str.length;
          nextLine++;
        }
      }
    }
  }
  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
    return false;
  }
  for (pos = labelEnd + 2; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (isSpace(ch)) {
    } else {
      break;
    }
  }
  const destRes = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!destRes.ok) {
    return false;
  }
  const href = state.md.normalizeLink(destRes.str);
  if (!state.md.validateLink(href)) {
    return false;
  }
  pos = destRes.pos;
  const destEndPos = pos;
  const destEndLineNo = nextLine;
  const start = pos;
  for (; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (isSpace(ch)) {
    } else {
      break;
    }
  }
  let titleRes = state.md.helpers.parseLinkTitle(str, pos, max);
  while (titleRes.can_continue) {
    const lineContent = getNextLine(nextLine);
    if (lineContent === null)
      break;
    str += lineContent;
    pos = max;
    max = str.length;
    nextLine++;
    titleRes = state.md.helpers.parseLinkTitle(str, pos, max, titleRes);
  }
  let title;
  if (pos < max && start !== pos && titleRes.ok) {
    title = titleRes.str;
    pos = titleRes.pos;
  } else {
    title = "";
    pos = destEndPos;
    nextLine = destEndLineNo;
  }
  while (pos < max) {
    const ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    if (title) {
      title = "";
      pos = destEndPos;
      nextLine = destEndLineNo;
      while (pos < max) {
        const ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    return false;
  }
  const label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    return false;
  }
  if (silent) {
    return true;
  }
  if (typeof state.env.references === "undefined") {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === "undefined") {
    state.env.references[label] = { title, href };
  }
  state.line = nextLine;
  return true;
}

// node_modules/markdown-it/lib/common/html_blocks.mjs
var html_blocks_default = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];

// node_modules/markdown-it/lib/common/html_re.mjs
var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var unquoted = "[^\"'=<>`\\x00-\\x20]+";
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';
var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var comment = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->";
var processing = "<[?][\\s\\S]*?[?]>";
var declaration = "<![A-Za-z][^>]*>";
var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");

// node_modules/markdown-it/lib/rules_block/html_block.mjs
var HTML_SEQUENCES = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
  [/^<!--/, /-->/, true],
  [/^<\?/, /\?>/, true],
  [/^<![A-Z]/, />/, true],
  [/^<!\[CDATA\[/, /\]\]>/, true],
  [new RegExp("^</?(" + html_blocks_default.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
  [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
];
function html_block(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (!state.md.options.html) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  let lineText = state.src.slice(pos, max);
  let i = 0;
  for (; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }
  if (i === HTML_SEQUENCES.length) {
    return false;
  }
  if (silent) {
    return HTML_SEQUENCES[i][2];
  }
  let nextLine = startLine + 1;
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);
      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }
  state.line = nextLine;
  const token = state.push("html_block", "", 0);
  token.map = [startLine, nextLine];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
  return true;
}

// node_modules/markdown-it/lib/rules_block/heading.mjs
function heading(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  let ch = state.src.charCodeAt(pos);
  if (ch !== 35 || pos >= max) {
    return false;
  }
  let level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 35 && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }
  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }
  if (silent) {
    return true;
  }
  max = state.skipSpacesBack(max, pos);
  const tmp = state.skipCharsBack(max, 35, pos);
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }
  state.line = startLine + 1;
  const token_o = state.push("heading_open", "h" + String(level), 1);
  token_o.markup = "########".slice(0, level);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = state.src.slice(pos, max).trim();
  token_i.map = [startLine, state.line];
  token_i.children = [];
  const token_c = state.push("heading_close", "h" + String(level), -1);
  token_c.markup = "########".slice(0, level);
  return true;
}

// node_modules/markdown-it/lib/rules_block/lheading.mjs
function lheading(state, startLine, endLine) {
  const terminatorRules = state.md.block.ruler.getRules("paragraph");
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  const oldParentType = state.parentType;
  state.parentType = "paragraph";
  let level = 0;
  let marker;
  let nextLine = startLine + 1;
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] >= state.blkIndent) {
      let pos = state.bMarks[nextLine] + state.tShift[nextLine];
      const max = state.eMarks[nextLine];
      if (pos < max) {
        marker = state.src.charCodeAt(pos);
        if (marker === 45 || marker === 61) {
          pos = state.skipChars(pos, marker);
          pos = state.skipSpaces(pos);
          if (pos >= max) {
            level = marker === 61 ? 1 : 2;
            break;
          }
        }
      }
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  if (!level) {
    return false;
  }
  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine + 1;
  const token_o = state.push("heading_open", "h" + String(level), 1);
  token_o.markup = String.fromCharCode(marker);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = content;
  token_i.map = [startLine, state.line - 1];
  token_i.children = [];
  const token_c = state.push("heading_close", "h" + String(level), -1);
  token_c.markup = String.fromCharCode(marker);
  state.parentType = oldParentType;
  return true;
}

// node_modules/markdown-it/lib/rules_block/paragraph.mjs
function paragraph(state, startLine, endLine) {
  const terminatorRules = state.md.block.ruler.getRules("paragraph");
  const oldParentType = state.parentType;
  let nextLine = startLine + 1;
  state.parentType = "paragraph";
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine;
  const token_o = state.push("paragraph_open", "p", 1);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = content;
  token_i.map = [startLine, state.line];
  token_i.children = [];
  state.push("paragraph_close", "p", -1);
  state.parentType = oldParentType;
  return true;
}

// node_modules/markdown-it/lib/parser_block.mjs
var _rules2 = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", table, ["paragraph", "reference"]],
  ["code", code],
  ["fence", fence, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", blockquote, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", hr, ["paragraph", "reference", "blockquote", "list"]],
  ["list", list, ["paragraph", "reference", "blockquote"]],
  ["reference", reference],
  ["html_block", html_block, ["paragraph", "reference", "blockquote"]],
  ["heading", heading, ["paragraph", "reference", "blockquote"]],
  ["lheading", lheading],
  ["paragraph", paragraph]
];
function ParserBlock() {
  this.ruler = new ruler_default();
  for (let i = 0; i < _rules2.length; i++) {
    this.ruler.push(_rules2[i][0], _rules2[i][1], { alt: (_rules2[i][2] || []).slice() });
  }
}
ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const maxNesting = state.md.options.maxNesting;
  let line = startLine;
  let hasEmptyLines = false;
  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }
    if (state.sCount[line] < state.blkIndent) {
      break;
    }
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }
    const prevLine = state.line;
    let ok = false;
    for (let i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        if (prevLine >= state.line) {
          throw new Error("block rule didn't increment state.line");
        }
        break;
      }
    }
    if (!ok)
      throw new Error("none of the block rules matched");
    state.tight = !hasEmptyLines;
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }
    line = state.line;
    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};
ParserBlock.prototype.parse = function(src, md2, env, outTokens) {
  if (!src) {
    return;
  }
  const state = new this.State(src, md2, env, outTokens);
  this.tokenize(state, state.line, state.lineMax);
};
ParserBlock.prototype.State = state_block_default;
var parser_block_default = ParserBlock;

// node_modules/markdown-it/lib/rules_inline/state_inline.mjs
function StateInline(src, md2, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md2;
  this.tokens = outTokens;
  this.tokens_meta = Array(outTokens.length);
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = "";
  this.pendingLevel = 0;
  this.cache = {};
  this.delimiters = [];
  this._prev_delimiters = [];
  this.backticks = {};
  this.backticksScanned = false;
  this.linkLevel = 0;
}
StateInline.prototype.pushPending = function() {
  const token = new token_default("text", "", 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = "";
  return token;
};
StateInline.prototype.push = function(type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }
  const token = new token_default(type, tag, nesting);
  let token_meta = null;
  if (nesting < 0) {
    this.level--;
    this.delimiters = this._prev_delimiters.pop();
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
    this._prev_delimiters.push(this.delimiters);
    this.delimiters = [];
    token_meta = { delimiters: this.delimiters };
  }
  this.pendingLevel = this.level;
  this.tokens.push(token);
  this.tokens_meta.push(token_meta);
  return token;
};
StateInline.prototype.scanDelims = function(start, canSplitWord) {
  const max = this.posMax;
  const marker = this.src.charCodeAt(start);
  const lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
  let pos = start;
  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }
  const count = pos - start;
  const nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
  const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
  const isLastWhiteSpace = isWhiteSpace(lastChar);
  const isNextWhiteSpace = isWhiteSpace(nextChar);
  const left_flanking = !isNextWhiteSpace && (!isNextPunctChar || isLastWhiteSpace || isLastPunctChar);
  const right_flanking = !isLastWhiteSpace && (!isLastPunctChar || isNextWhiteSpace || isNextPunctChar);
  const can_open = left_flanking && (canSplitWord || !right_flanking || isLastPunctChar);
  const can_close = right_flanking && (canSplitWord || !left_flanking || isNextPunctChar);
  return { can_open, can_close, length: count };
};
StateInline.prototype.Token = token_default;
var state_inline_default = StateInline;

// node_modules/markdown-it/lib/rules_inline/text.mjs
function isTerminatorChar(ch) {
  switch (ch) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function text(state, silent) {
  let pos = state.pos;
  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }
  if (pos === state.pos) {
    return false;
  }
  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }
  state.pos = pos;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/linkify.mjs
var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function linkify2(state, silent) {
  if (!state.md.options.linkify)
    return false;
  if (state.linkLevel > 0)
    return false;
  const pos = state.pos;
  const max = state.posMax;
  if (pos + 3 > max)
    return false;
  if (state.src.charCodeAt(pos) !== 58)
    return false;
  if (state.src.charCodeAt(pos + 1) !== 47)
    return false;
  if (state.src.charCodeAt(pos + 2) !== 47)
    return false;
  const match2 = state.pending.match(SCHEME_RE);
  if (!match2)
    return false;
  const proto = match2[1];
  const link2 = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
  if (!link2)
    return false;
  let url = link2.url;
  if (url.length <= proto.length)
    return false;
  url = url.replace(/\*+$/, "");
  const fullUrl = state.md.normalizeLink(url);
  if (!state.md.validateLink(fullUrl))
    return false;
  if (!silent) {
    state.pending = state.pending.slice(0, -proto.length);
    const token_o = state.push("link_open", "a", 1);
    token_o.attrs = [["href", fullUrl]];
    token_o.markup = "linkify";
    token_o.info = "auto";
    const token_t = state.push("text", "", 0);
    token_t.content = state.md.normalizeLinkText(url);
    const token_c = state.push("link_close", "a", -1);
    token_c.markup = "linkify";
    token_c.info = "auto";
  }
  state.pos += url.length - proto.length;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/newline.mjs
function newline(state, silent) {
  let pos = state.pos;
  if (state.src.charCodeAt(pos) !== 10) {
    return false;
  }
  const pmax = state.pending.length - 1;
  const max = state.posMax;
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
        let ws = pmax - 1;
        while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
          ws--;
        state.pending = state.pending.slice(0, ws);
        state.push("hardbreak", "br", 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push("softbreak", "br", 0);
      }
    } else {
      state.push("softbreak", "br", 0);
    }
  }
  pos++;
  while (pos < max && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }
  state.pos = pos;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/escape.mjs
var ESCAPED = [];
for (let i = 0; i < 256; i++) {
  ESCAPED.push(0);
}
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});
function escape2(state, silent) {
  let pos = state.pos;
  const max = state.posMax;
  if (state.src.charCodeAt(pos) !== 92)
    return false;
  pos++;
  if (pos >= max)
    return false;
  let ch1 = state.src.charCodeAt(pos);
  if (ch1 === 10) {
    if (!silent) {
      state.push("hardbreak", "br", 0);
    }
    pos++;
    while (pos < max) {
      ch1 = state.src.charCodeAt(pos);
      if (!isSpace(ch1))
        break;
      pos++;
    }
    state.pos = pos;
    return true;
  }
  let escapedStr = state.src[pos];
  if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
    const ch2 = state.src.charCodeAt(pos + 1);
    if (ch2 >= 56320 && ch2 <= 57343) {
      escapedStr += state.src[pos + 1];
      pos++;
    }
  }
  const origStr = "\\" + escapedStr;
  if (!silent) {
    const token = state.push("text_special", "", 0);
    if (ch1 < 256 && ESCAPED[ch1] !== 0) {
      token.content = escapedStr;
    } else {
      token.content = origStr;
    }
    token.markup = origStr;
    token.info = "escape";
  }
  state.pos = pos + 1;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/backticks.mjs
function backtick(state, silent) {
  let pos = state.pos;
  const ch = state.src.charCodeAt(pos);
  if (ch !== 96) {
    return false;
  }
  const start = pos;
  pos++;
  const max = state.posMax;
  while (pos < max && state.src.charCodeAt(pos) === 96) {
    pos++;
  }
  const marker = state.src.slice(start, pos);
  const openerLength = marker.length;
  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
    if (!silent)
      state.pending += marker;
    state.pos += openerLength;
    return true;
  }
  let matchEnd = pos;
  let matchStart;
  while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
    matchEnd = matchStart + 1;
    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
      matchEnd++;
    }
    const closerLength = matchEnd - matchStart;
    if (closerLength === openerLength) {
      if (!silent) {
        const token = state.push("code_inline", "code", 0);
        token.markup = marker;
        token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      state.pos = matchEnd;
      return true;
    }
    state.backticks[closerLength] = matchStart;
  }
  state.backticksScanned = true;
  if (!silent)
    state.pending += marker;
  state.pos += openerLength;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/strikethrough.mjs
function strikethrough_tokenize(state, silent) {
  const start = state.pos;
  const marker = state.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker !== 126) {
    return false;
  }
  const scanned = state.scanDelims(state.pos, true);
  let len = scanned.length;
  const ch = String.fromCharCode(marker);
  if (len < 2) {
    return false;
  }
  let token;
  if (len % 2) {
    token = state.push("text", "", 0);
    token.content = ch;
    len--;
  }
  for (let i = 0; i < len; i += 2) {
    token = state.push("text", "", 0);
    token.content = ch + ch;
    state.delimiters.push({
      marker,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: state.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
}
function postProcess(state, delimiters) {
  let token;
  const loneMarkers = [];
  const max = delimiters.length;
  for (let i = 0; i < max; i++) {
    const startDelim = delimiters[i];
    if (startDelim.marker !== 126) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    const endDelim = delimiters[startDelim.end];
    token = state.tokens[startDelim.token];
    token.type = "s_open";
    token.tag = "s";
    token.nesting = 1;
    token.markup = "~~";
    token.content = "";
    token = state.tokens[endDelim.token];
    token.type = "s_close";
    token.tag = "s";
    token.nesting = -1;
    token.markup = "~~";
    token.content = "";
    if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
      loneMarkers.push(endDelim.token - 1);
    }
  }
  while (loneMarkers.length) {
    const i = loneMarkers.pop();
    let j = i + 1;
    while (j < state.tokens.length && state.tokens[j].type === "s_close") {
      j++;
    }
    j--;
    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
}
function strikethrough_postProcess(state) {
  const tokens_meta = state.tokens_meta;
  const max = state.tokens_meta.length;
  postProcess(state, state.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state, tokens_meta[curr].delimiters);
    }
  }
}
var strikethrough_default = {
  tokenize: strikethrough_tokenize,
  postProcess: strikethrough_postProcess
};

// node_modules/markdown-it/lib/rules_inline/emphasis.mjs
function emphasis_tokenize(state, silent) {
  const start = state.pos;
  const marker = state.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker !== 95 && marker !== 42) {
    return false;
  }
  const scanned = state.scanDelims(state.pos, marker === 42);
  for (let i = 0; i < scanned.length; i++) {
    const token = state.push("text", "", 0);
    token.content = String.fromCharCode(marker);
    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker,
      // Total length of these series of delimiters.
      //
      length: scanned.length,
      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
}
function postProcess2(state, delimiters) {
  const max = delimiters.length;
  for (let i = max - 1; i >= 0; i--) {
    const startDelim = delimiters[i];
    if (startDelim.marker !== 95 && startDelim.marker !== 42) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    const endDelim = delimiters[startDelim.end];
    const isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
    delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    delimiters[startDelim.end + 1].token === endDelim.token + 1;
    const ch = String.fromCharCode(startDelim.marker);
    const token_o = state.tokens[startDelim.token];
    token_o.type = isStrong ? "strong_open" : "em_open";
    token_o.tag = isStrong ? "strong" : "em";
    token_o.nesting = 1;
    token_o.markup = isStrong ? ch + ch : ch;
    token_o.content = "";
    const token_c = state.tokens[endDelim.token];
    token_c.type = isStrong ? "strong_close" : "em_close";
    token_c.tag = isStrong ? "strong" : "em";
    token_c.nesting = -1;
    token_c.markup = isStrong ? ch + ch : ch;
    token_c.content = "";
    if (isStrong) {
      state.tokens[delimiters[i - 1].token].content = "";
      state.tokens[delimiters[startDelim.end + 1].token].content = "";
      i--;
    }
  }
}
function emphasis_post_process(state) {
  const tokens_meta = state.tokens_meta;
  const max = state.tokens_meta.length;
  postProcess2(state, state.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess2(state, tokens_meta[curr].delimiters);
    }
  }
}
var emphasis_default = {
  tokenize: emphasis_tokenize,
  postProcess: emphasis_post_process
};

// node_modules/markdown-it/lib/rules_inline/link.mjs
function link(state, silent) {
  let code2, label, res, ref;
  let href = "";
  let title = "";
  let start = state.pos;
  let parseReference = true;
  if (state.src.charCodeAt(state.pos) !== 91) {
    return false;
  }
  const oldPos = state.pos;
  const max = state.posMax;
  const labelStart = state.pos + 1;
  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
  if (labelEnd < 0) {
    return false;
  }
  let pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 40) {
    parseReference = false;
    pos++;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
      start = pos;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
      }
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 41) {
      parseReference = true;
    }
    pos++;
  }
  if (parseReference) {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max && state.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;
    const token_o = state.push("link_open", "a", 1);
    const attrs = [["href", href]];
    token_o.attrs = attrs;
    if (title) {
      attrs.push(["title", title]);
    }
    state.linkLevel++;
    state.md.inline.tokenize(state);
    state.linkLevel--;
    state.push("link_close", "a", -1);
  }
  state.pos = pos;
  state.posMax = max;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/image.mjs
function image(state, silent) {
  let code2, content, label, pos, ref, res, title, start;
  let href = "";
  const oldPos = state.pos;
  const max = state.posMax;
  if (state.src.charCodeAt(state.pos) !== 33) {
    return false;
  }
  if (state.src.charCodeAt(state.pos + 1) !== 91) {
    return false;
  }
  const labelStart = state.pos + 2;
  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 40) {
    pos++;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
    }
    start = pos;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
    } else {
      title = "";
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 41) {
      state.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max && state.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);
    const tokens = [];
    state.md.inline.parse(
      content,
      state.md,
      state.env,
      tokens
    );
    const token = state.push("image", "img", 0);
    const attrs = [["src", href], ["alt", ""]];
    token.attrs = attrs;
    token.children = tokens;
    token.content = content;
    if (title) {
      attrs.push(["title", title]);
    }
  }
  state.pos = pos;
  state.posMax = max;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/autolink.mjs
var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function autolink(state, silent) {
  let pos = state.pos;
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  const start = state.pos;
  const max = state.posMax;
  for (; ; ) {
    if (++pos >= max)
      return false;
    const ch = state.src.charCodeAt(pos);
    if (ch === 60)
      return false;
    if (ch === 62)
      break;
  }
  const url = state.src.slice(start + 1, pos);
  if (AUTOLINK_RE.test(url)) {
    const fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      const token_o = state.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "autolink";
      token_o.info = "auto";
      const token_t = state.push("text", "", 0);
      token_t.content = state.md.normalizeLinkText(url);
      const token_c = state.push("link_close", "a", -1);
      token_c.markup = "autolink";
      token_c.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  if (EMAIL_RE.test(url)) {
    const fullUrl = state.md.normalizeLink("mailto:" + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      const token_o = state.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "autolink";
      token_o.info = "auto";
      const token_t = state.push("text", "", 0);
      token_t.content = state.md.normalizeLinkText(url);
      const token_c = state.push("link_close", "a", -1);
      token_c.markup = "autolink";
      token_c.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  return false;
}

// node_modules/markdown-it/lib/rules_inline/html_inline.mjs
function isLinkOpen2(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose2(str) {
  return /^<\/a\s*>/i.test(str);
}
function isLetter(ch) {
  const lc = ch | 32;
  return lc >= 97 && lc <= 122;
}
function html_inline(state, silent) {
  if (!state.md.options.html) {
    return false;
  }
  const max = state.posMax;
  const pos = state.pos;
  if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
    return false;
  }
  const ch = state.src.charCodeAt(pos + 1);
  if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
    return false;
  }
  const match2 = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match2) {
    return false;
  }
  if (!silent) {
    const token = state.push("html_inline", "", 0);
    token.content = match2[0];
    if (isLinkOpen2(token.content))
      state.linkLevel++;
    if (isLinkClose2(token.content))
      state.linkLevel--;
  }
  state.pos += match2[0].length;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/entity.mjs
var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
function entity(state, silent) {
  const pos = state.pos;
  const max = state.posMax;
  if (state.src.charCodeAt(pos) !== 38)
    return false;
  if (pos + 1 >= max)
    return false;
  const ch = state.src.charCodeAt(pos + 1);
  if (ch === 35) {
    const match2 = state.src.slice(pos).match(DIGITAL_RE);
    if (match2) {
      if (!silent) {
        const code2 = match2[1][0].toLowerCase() === "x" ? parseInt(match2[1].slice(1), 16) : parseInt(match2[1], 10);
        const token = state.push("text_special", "", 0);
        token.content = isValidEntityCode(code2) ? fromCodePoint2(code2) : fromCodePoint2(65533);
        token.markup = match2[0];
        token.info = "entity";
      }
      state.pos += match2[0].length;
      return true;
    }
  } else {
    const match2 = state.src.slice(pos).match(NAMED_RE);
    if (match2) {
      const decoded = decodeHTML(match2[0]);
      if (decoded !== match2[0]) {
        if (!silent) {
          const token = state.push("text_special", "", 0);
          token.content = decoded;
          token.markup = match2[0];
          token.info = "entity";
        }
        state.pos += match2[0].length;
        return true;
      }
    }
  }
  return false;
}

// node_modules/markdown-it/lib/rules_inline/balance_pairs.mjs
function processDelimiters(delimiters) {
  const openersBottom = {};
  const max = delimiters.length;
  if (!max)
    return;
  let headerIdx = 0;
  let lastTokenIdx = -2;
  const jumps = [];
  for (let closerIdx = 0; closerIdx < max; closerIdx++) {
    const closer = delimiters[closerIdx];
    jumps.push(0);
    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
      headerIdx = closerIdx;
    }
    lastTokenIdx = closer.token;
    closer.length = closer.length || 0;
    if (!closer.close)
      continue;
    if (!openersBottom.hasOwnProperty(closer.marker)) {
      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
    }
    const minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
    let openerIdx = headerIdx - jumps[headerIdx] - 1;
    let newMinOpenerIdx = openerIdx;
    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
      const opener = delimiters[openerIdx];
      if (opener.marker !== closer.marker)
        continue;
      if (opener.open && opener.end < 0) {
        let isOddMatch = false;
        if (opener.close || closer.open) {
          if ((opener.length + closer.length) % 3 === 0) {
            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
              isOddMatch = true;
            }
          }
        }
        if (!isOddMatch) {
          const lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
          jumps[closerIdx] = closerIdx - openerIdx + lastJump;
          jumps[openerIdx] = lastJump;
          closer.open = false;
          opener.end = closerIdx;
          opener.close = false;
          newMinOpenerIdx = -1;
          lastTokenIdx = -2;
          break;
        }
      }
    }
    if (newMinOpenerIdx !== -1) {
      openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
    }
  }
}
function link_pairs(state) {
  const tokens_meta = state.tokens_meta;
  const max = state.tokens_meta.length;
  processDelimiters(state.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      processDelimiters(tokens_meta[curr].delimiters);
    }
  }
}

// node_modules/markdown-it/lib/rules_inline/fragments_join.mjs
function fragments_join(state) {
  let curr, last;
  let level = 0;
  const tokens = state.tokens;
  const max = state.tokens.length;
  for (curr = last = 0; curr < max; curr++) {
    if (tokens[curr].nesting < 0)
      level--;
    tokens[curr].level = level;
    if (tokens[curr].nesting > 0)
      level++;
    if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }
      last++;
    }
  }
  if (curr !== last) {
    tokens.length = last;
  }
}

// node_modules/markdown-it/lib/parser_inline.mjs
var _rules3 = [
  ["text", text],
  ["linkify", linkify2],
  ["newline", newline],
  ["escape", escape2],
  ["backticks", backtick],
  ["strikethrough", strikethrough_default.tokenize],
  ["emphasis", emphasis_default.tokenize],
  ["link", link],
  ["image", image],
  ["autolink", autolink],
  ["html_inline", html_inline],
  ["entity", entity]
];
var _rules22 = [
  ["balance_pairs", link_pairs],
  ["strikethrough", strikethrough_default.postProcess],
  ["emphasis", emphasis_default.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", fragments_join]
];
function ParserInline() {
  this.ruler = new ruler_default();
  for (let i = 0; i < _rules3.length; i++) {
    this.ruler.push(_rules3[i][0], _rules3[i][1]);
  }
  this.ruler2 = new ruler_default();
  for (let i = 0; i < _rules22.length; i++) {
    this.ruler2.push(_rules22[i][0], _rules22[i][1]);
  }
}
ParserInline.prototype.skipToken = function(state) {
  const pos = state.pos;
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const maxNesting = state.md.options.maxNesting;
  const cache = state.cache;
  if (typeof cache[pos] !== "undefined") {
    state.pos = cache[pos];
    return;
  }
  let ok = false;
  if (state.level < maxNesting) {
    for (let i = 0; i < len; i++) {
      state.level++;
      ok = rules[i](state, true);
      state.level--;
      if (ok) {
        if (pos >= state.pos) {
          throw new Error("inline rule didn't increment state.pos");
        }
        break;
      }
    }
  } else {
    state.pos = state.posMax;
  }
  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};
ParserInline.prototype.tokenize = function(state) {
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const end = state.posMax;
  const maxNesting = state.md.options.maxNesting;
  while (state.pos < end) {
    const prevPos = state.pos;
    let ok = false;
    if (state.level < maxNesting) {
      for (let i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) {
          if (prevPos >= state.pos) {
            throw new Error("inline rule didn't increment state.pos");
          }
          break;
        }
      }
    }
    if (ok) {
      if (state.pos >= end) {
        break;
      }
      continue;
    }
    state.pending += state.src[state.pos++];
  }
  if (state.pending) {
    state.pushPending();
  }
};
ParserInline.prototype.parse = function(str, md2, env, outTokens) {
  const state = new this.State(str, md2, env, outTokens);
  this.tokenize(state);
  const rules = this.ruler2.getRules("");
  const len = rules.length;
  for (let i = 0; i < len; i++) {
    rules[i](state);
  }
};
ParserInline.prototype.State = state_inline_default;
var parser_inline_default = ParserInline;

// node_modules/linkify-it/lib/re.mjs
function re_default(opts) {
  const re = {};
  opts = opts || {};
  re.src_Any = regex_default.source;
  re.src_Cc = regex_default2.source;
  re.src_Z = regex_default6.source;
  re.src_P = regex_default4.source;
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
  re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
  const text_separators = "[><\uFF5C]";
  re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
  re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
  re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
  re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
  re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
  re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
  ",(?!" + re.src_ZCc + "|$)|;(?!" + re.src_ZCc + "|$)|\\!+(?!" + re.src_ZCc + "|[!]|$)|\\?(?!" + re.src_ZCc + "|[?]|$))+|\\/)?";
  re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
  re.src_xn = "xn--[a-z0-9\\-]{1,59}";
  re.src_domain_root = // Allow letters & digits (http://test1)
  "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
  re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
  re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
  re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
  re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
  re.src_host_strict = re.src_host + re.src_host_terminator;
  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
  re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
  re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
  re.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
  re.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
  return re;
}

// node_modules/linkify-it/index.mjs
function assign2(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function _class2(obj) {
  return Object.prototype.toString.call(obj);
}
function isString2(obj) {
  return _class2(obj) === "[object String]";
}
function isObject(obj) {
  return _class2(obj) === "[object Object]";
}
function isRegExp(obj) {
  return _class2(obj) === "[object RegExp]";
}
function isFunction(obj) {
  return _class2(obj) === "[object Function]";
}
function escapeRE2(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function(acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}
var defaultSchemas = {
  "http:": {
    validate: function(text2, pos, self2) {
      const tail = text2.slice(pos);
      if (!self2.re.http) {
        self2.re.http = new RegExp(
          "^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path,
          "i"
        );
      }
      if (self2.re.http.test(tail)) {
        return tail.match(self2.re.http)[0].length;
      }
      return 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(text2, pos, self2) {
      const tail = text2.slice(pos);
      if (!self2.re.no_http) {
        self2.re.no_http = new RegExp(
          "^" + self2.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
          // with code comments
          "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path,
          "i"
        );
      }
      if (self2.re.no_http.test(tail)) {
        if (pos >= 3 && text2[pos - 3] === ":") {
          return 0;
        }
        if (pos >= 3 && text2[pos - 3] === "/") {
          return 0;
        }
        return tail.match(self2.re.no_http)[0].length;
      }
      return 0;
    }
  },
  "mailto:": {
    validate: function(text2, pos, self2) {
      const tail = text2.slice(pos);
      if (!self2.re.mailto) {
        self2.re.mailto = new RegExp(
          "^" + self2.re.src_email_name + "@" + self2.re.src_host_strict,
          "i"
        );
      }
      if (self2.re.mailto.test(tail)) {
        return tail.match(self2.re.mailto)[0].length;
      }
      return 0;
    }
  }
};
var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
function resetScanCache(self2) {
  self2.__index__ = -1;
  self2.__text_cache__ = "";
}
function createValidator(re) {
  return function(text2, pos) {
    const tail = text2.slice(pos);
    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}
function createNormalizer() {
  return function(match2, self2) {
    self2.normalize(match2);
  };
}
function compile(self2) {
  const re = self2.re = re_default(self2.__opts__);
  const tlds2 = self2.__tlds__.slice();
  self2.onCompile();
  if (!self2.__tlds_replaced__) {
    tlds2.push(tlds_2ch_src_re);
  }
  tlds2.push(re.src_xn);
  re.src_tlds = tlds2.join("|");
  function untpl(tpl) {
    return tpl.replace("%TLDS%", re.src_tlds);
  }
  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
  const aliases = [];
  self2.__compiled__ = {};
  function schemaError(name2, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name2 + '": ' + val);
  }
  Object.keys(self2.__schemas__).forEach(function(name2) {
    const val = self2.__schemas__[name2];
    if (val === null) {
      return;
    }
    const compiled = { validate: null, link: null };
    self2.__compiled__[name2] = compiled;
    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name2, val);
      }
      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name2, val);
      }
      return;
    }
    if (isString2(val)) {
      aliases.push(name2);
      return;
    }
    schemaError(name2, val);
  });
  aliases.forEach(function(alias) {
    if (!self2.__compiled__[self2.__schemas__[alias]]) {
      return;
    }
    self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
    self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
  });
  self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
  const slist = Object.keys(self2.__compiled__).filter(function(name2) {
    return name2.length > 0 && self2.__compiled__[name2];
  }).map(escapeRE2).join("|");
  self2.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "i");
  self2.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
  self2.re.schema_at_start = RegExp("^" + self2.re.schema_search.source, "i");
  self2.re.pretest = RegExp(
    "(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@",
    "i"
  );
  resetScanCache(self2);
}
function Match(self2, shift) {
  const start = self2.__index__;
  const end = self2.__last_index__;
  const text2 = self2.__text_cache__.slice(start, end);
  this.schema = self2.__schema__.toLowerCase();
  this.index = start + shift;
  this.lastIndex = end + shift;
  this.raw = text2;
  this.text = text2;
  this.url = text2;
}
function createMatch(self2, shift) {
  const match2 = new Match(self2, shift);
  self2.__compiled__[match2.schema].normalize(match2, self2);
  return match2;
}
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }
  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }
  this.__opts__ = assign2({}, defaultOptions, options);
  this.__index__ = -1;
  this.__last_index__ = -1;
  this.__schema__ = "";
  this.__text_cache__ = "";
  this.__schemas__ = assign2({}, defaultSchemas, schemas);
  this.__compiled__ = {};
  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;
  this.re = {};
  compile(this);
}
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign2(this.__opts__, options);
  return this;
};
LinkifyIt.prototype.test = function test(text2) {
  this.__text_cache__ = text2;
  this.__index__ = -1;
  if (!text2.length) {
    return false;
  }
  let m, ml, me, len, shift, next, re, tld_pos, at_pos;
  if (this.re.schema_test.test(text2)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text2)) !== null) {
      len = this.testSchemaAt(text2, m[2], re.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }
  if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
    tld_pos = text2.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text2.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
          shift = ml.index + ml[1].length;
          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = "";
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }
  if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
    at_pos = text2.indexOf("@");
    if (at_pos >= 0) {
      if ((me = text2.match(this.re.email_fuzzy)) !== null) {
        shift = me.index + me[1].length;
        next = me.index + me[0].length;
        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = "mailto:";
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }
  return this.__index__ >= 0;
};
LinkifyIt.prototype.pretest = function pretest(text2) {
  return this.re.pretest.test(text2);
};
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text2, schema, pos) {
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text2, pos, this);
};
LinkifyIt.prototype.match = function match(text2) {
  const result = [];
  let shift = 0;
  if (this.__index__ >= 0 && this.__text_cache__ === text2) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }
  let tail = shift ? text2.slice(shift) : text2;
  while (this.test(tail)) {
    result.push(createMatch(this, shift));
    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }
  if (result.length) {
    return result;
  }
  return null;
};
LinkifyIt.prototype.matchAtStart = function matchAtStart(text2) {
  this.__text_cache__ = text2;
  this.__index__ = -1;
  if (!text2.length)
    return null;
  const m = this.re.schema_at_start.exec(text2);
  if (!m)
    return null;
  const len = this.testSchemaAt(text2, m[2], m[0].length);
  if (!len)
    return null;
  this.__schema__ = m[2];
  this.__index__ = m.index + m[1].length;
  this.__last_index__ = m.index + m[0].length + len;
  return createMatch(this, 0);
};
LinkifyIt.prototype.tlds = function tlds(list2, keepOld) {
  list2 = Array.isArray(list2) ? list2 : [list2];
  if (!keepOld) {
    this.__tlds__ = list2.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }
  this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();
  compile(this);
  return this;
};
LinkifyIt.prototype.normalize = function normalize2(match2) {
  if (!match2.schema) {
    match2.url = "http://" + match2.url;
  }
  if (match2.schema === "mailto:" && !/^mailto:/i.test(match2.url)) {
    match2.url = "mailto:" + match2.url;
  }
};
LinkifyIt.prototype.onCompile = function onCompile() {
};
var linkify_it_default = LinkifyIt;

// node_modules/punycode.js/punycode.es6.js
var maxInt = 2147483647;
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128;
var delimiter = "-";
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7F]/;
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
var errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;
function error(type) {
  throw new RangeError(errors[type]);
}
function map(array, callback) {
  const result = [];
  let length = array.length;
  while (length--) {
    result[length] = callback(array[length]);
  }
  return result;
}
function mapDomain(domain, callback) {
  const parts = domain.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    domain = parts[1];
  }
  domain = domain.replace(regexSeparators, ".");
  const labels = domain.split(".");
  const encoded = map(labels, callback).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
var ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
var basicToDigit = function(codePoint) {
  if (codePoint >= 48 && codePoint < 58) {
    return 26 + (codePoint - 48);
  }
  if (codePoint >= 65 && codePoint < 91) {
    return codePoint - 65;
  }
  if (codePoint >= 97 && codePoint < 123) {
    return codePoint - 97;
  }
  return base;
};
var digitToBasic = function(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};
var adapt = function(delta, numPoints, firstTime) {
  let k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};
var decode2 = function(input) {
  const output = [];
  const inputLength = input.length;
  let i = 0;
  let n = initialN;
  let bias = initialBias;
  let basic = input.lastIndexOf(delimiter);
  if (basic < 0) {
    basic = 0;
  }
  for (let j = 0; j < basic; ++j) {
    if (input.charCodeAt(j) >= 128) {
      error("not-basic");
    }
    output.push(input.charCodeAt(j));
  }
  for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
    const oldi = i;
    for (let w = 1, k = base; ; k += base) {
      if (index >= inputLength) {
        error("invalid-input");
      }
      const digit = basicToDigit(input.charCodeAt(index++));
      if (digit >= base) {
        error("invalid-input");
      }
      if (digit > floor((maxInt - i) / w)) {
        error("overflow");
      }
      i += digit * w;
      const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
      if (digit < t) {
        break;
      }
      const baseMinusT = base - t;
      if (w > floor(maxInt / baseMinusT)) {
        error("overflow");
      }
      w *= baseMinusT;
    }
    const out = output.length + 1;
    bias = adapt(i - oldi, out, oldi == 0);
    if (floor(i / out) > maxInt - n) {
      error("overflow");
    }
    n += floor(i / out);
    i %= out;
    output.splice(i++, 0, n);
  }
  return String.fromCodePoint(...output);
};
var encode2 = function(input) {
  const output = [];
  input = ucs2decode(input);
  const inputLength = input.length;
  let n = initialN;
  let delta = 0;
  let bias = initialBias;
  for (const currentValue of input) {
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  const basicLength = output.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    let m = maxInt;
    for (const currentValue of input) {
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta += (m - n) * handledCPCountPlusOne;
    n = m;
    for (const currentValue of input) {
      if (currentValue < n && ++delta > maxInt) {
        error("overflow");
      }
      if (currentValue === n) {
        let q = delta;
        for (let k = base; ; k += base) {
          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (q < t) {
            break;
          }
          const qMinusT = q - t;
          const baseMinusT = base - t;
          output.push(
            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
          );
          q = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n;
  }
  return output.join("");
};
var toUnicode = function(input) {
  return mapDomain(input, function(string) {
    return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
  });
};
var toASCII = function(input) {
  return mapDomain(input, function(string) {
    return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
  });
};
var punycode = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  "version": "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  "ucs2": {
    "decode": ucs2decode,
    "encode": ucs2encode
  },
  "decode": decode2,
  "encode": encode2,
  "toASCII": toASCII,
  "toUnicode": toUnicode
};
var punycode_es6_default = punycode;

// node_modules/markdown-it/lib/presets/default.mjs
var default_default = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: "\u201C\u201D\u2018\u2019",
    /*  */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
};

// node_modules/markdown-it/lib/presets/zero.mjs
var zero_default = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: "\u201C\u201D\u2018\u2019",
    /*  */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
};

// node_modules/markdown-it/lib/presets/commonmark.mjs
var commonmark_default = {
  options: {
    // Enable HTML tags in source
    html: true,
    // Use '/' to close single tags (<br />)
    xhtmlOut: true,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: "\u201C\u201D\u2018\u2019",
    /*  */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
};

// node_modules/markdown-it/lib/index.mjs
var config = {
  default: default_default,
  zero: zero_default,
  commonmark: commonmark_default
};
var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
function validateLink(url) {
  const str = url.trim().toLowerCase();
  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) : true;
}
var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
function normalizeLink(url) {
  const parsed = parse_default(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode_es6_default.toASCII(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return encode_default(format(parsed));
}
function normalizeLinkText(url) {
  const parsed = parse_default(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode_es6_default.toUnicode(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return decode_default(format(parsed), decode_default.defaultChars + "%");
}
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }
  if (!options) {
    if (!isString(presetName)) {
      options = presetName || {};
      presetName = "default";
    }
  }
  this.inline = new parser_inline_default();
  this.block = new parser_block_default();
  this.core = new parser_core_default();
  this.renderer = new renderer_default();
  this.linkify = new linkify_it_default();
  this.validateLink = validateLink;
  this.normalizeLink = normalizeLink;
  this.normalizeLinkText = normalizeLinkText;
  this.utils = utils_exports;
  this.helpers = assign({}, helpers_exports);
  this.options = {};
  this.configure(presetName);
  if (options) {
    this.set(options);
  }
}
MarkdownIt.prototype.set = function(options) {
  assign(this.options, options);
  return this;
};
MarkdownIt.prototype.configure = function(presets) {
  const self2 = this;
  if (isString(presets)) {
    const presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }
  if (!presets) {
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  }
  if (presets.options) {
    self2.set(presets.options);
  }
  if (presets.components) {
    Object.keys(presets.components).forEach(function(name2) {
      if (presets.components[name2].rules) {
        self2[name2].ruler.enableOnly(presets.components[name2].rules);
      }
      if (presets.components[name2].rules2) {
        self2[name2].ruler2.enableOnly(presets.components[name2].rules2);
      }
    });
  }
  return this;
};
MarkdownIt.prototype.enable = function(list2, ignoreInvalid) {
  let result = [];
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.enable(list2, true));
  }, this);
  result = result.concat(this.inline.ruler2.enable(list2, true));
  const missed = list2.filter(function(name2) {
    return result.indexOf(name2) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.disable = function(list2, ignoreInvalid) {
  let result = [];
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.disable(list2, true));
  }, this);
  result = result.concat(this.inline.ruler2.disable(list2, true));
  const missed = list2.filter(function(name2) {
    return result.indexOf(name2) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.use = function(plugin) {
  const args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};
MarkdownIt.prototype.parse = function(src, env) {
  if (typeof src !== "string") {
    throw new Error("Input data should be a String");
  }
  const state = new this.core.State(src, this, env);
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.render = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parse(src, env), this.options, env);
};
MarkdownIt.prototype.parseInline = function(src, env) {
  const state = new this.core.State(src, this, env);
  state.inlineMode = true;
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.renderInline = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parseInline(src, env), this.options, env);
};
var lib_default = MarkdownIt;

// services/publish/LicenseTemplates.ts
function escapeXml(value) {
  return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
function pageTemplate(title, bodyInner) {
  return `<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>${escapeXml(title)}</title>
  <meta charset="utf-8" />
  <link rel="stylesheet" type="text/css" href="../Styles/style.css" />
</head>
<body>
<section class="front-matter">
` + bodyInner + `
</section>
</body>
</html>
`;
}
function renderAllRightsReserved(params) {
  const title = escapeXml(params.title);
  const author = escapeXml(params.author);
  const year = escapeXml(params.year);
  const holder = escapeXml(params.holder);
  return pageTemplate("Copyright", [
    `<h1>Copyright</h1>`,
    `<p><strong>${title}</strong></p>`,
    author ? `<p>${author}</p>` : "",
    year && holder ? `<p>Copyright \xA9 ${year} ${holder}</p>` : "",
    `<p>All rights reserved.</p>`,
    `<p>No part of this book may be reproduced, stored in a retrieval system, or transmitted in any form or by any means without prior written permission, except as permitted by law.</p>`
  ].filter(Boolean).join("\n"));
}
function renderCc(params, name2, url) {
  const title = escapeXml(params.title);
  const author = escapeXml(params.author);
  const year = escapeXml(params.year);
  const holder = escapeXml(params.holder);
  return pageTemplate("License", [
    `<h1>License</h1>`,
    `<p><strong>${title}</strong></p>`,
    author ? `<p>${author}</p>` : "",
    year && holder ? `<p>Copyright \xA9 ${year} ${holder}</p>` : "",
    `<p>This work is licensed under <strong>${escapeXml(name2)}</strong>.</p>`,
    `<p>License URL: <a href="${escapeXml(url)}">${escapeXml(url)}</a></p>`
  ].filter(Boolean).join("\n"));
}
function renderCc0(params) {
  return renderCc(params, "CC0 1.0 Universal", "https://creativecommons.org/publicdomain/zero/1.0/");
}
function renderPublicDomain(params) {
  const title = escapeXml(params.title);
  const author = escapeXml(params.author);
  return pageTemplate("Public domain", [
    `<h1>Public domain</h1>`,
    `<p><strong>${title}</strong></p>`,
    author ? `<p>${author}</p>` : "",
    `<p>This work is dedicated to the public domain.</p>`
  ].filter(Boolean).join("\n"));
}
var LICENSE_TEMPLATES = [
  {
    id: "all-rights-reserved",
    label: "All rights reserved",
    description: "Standard copyright notice for traditional publishing.",
    renderXhtml: renderAllRightsReserved
  },
  {
    id: "cc-by",
    label: "Creative Commons Attribution (CC BY 4.0)",
    description: "Others can distribute and build upon your work, including commercially, with attribution.",
    renderXhtml: (p) => renderCc(p, "Creative Commons Attribution 4.0 International", "https://creativecommons.org/licenses/by/4.0/")
  },
  {
    id: "cc-by-sa",
    label: "Creative Commons Attribution-ShareAlike (CC BY-SA 4.0)",
    description: "Derivatives must be licensed under identical terms.",
    renderXhtml: (p) => renderCc(p, "Creative Commons Attribution-ShareAlike 4.0 International", "https://creativecommons.org/licenses/by-sa/4.0/")
  },
  {
    id: "cc-by-nc",
    label: "Creative Commons Attribution-NonCommercial (CC BY-NC 4.0)",
    description: "Reuse allowed with attribution for non-commercial purposes.",
    renderXhtml: (p) => renderCc(p, "Creative Commons Attribution-NonCommercial 4.0 International", "https://creativecommons.org/licenses/by-nc/4.0/")
  },
  {
    id: "cc-by-nc-sa",
    label: "Creative Commons Attribution-NonCommercial-ShareAlike (CC BY-NC-SA 4.0)",
    description: "Non-commercial reuse; derivatives must use identical terms.",
    renderXhtml: (p) => renderCc(p, "Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International", "https://creativecommons.org/licenses/by-nc-sa/4.0/")
  },
  {
    id: "cc0",
    label: "CC0 (No rights reserved)",
    description: "Waives rights to the extent allowed by law.",
    renderXhtml: renderCc0
  },
  {
    id: "public-domain",
    label: "Public domain dedication",
    description: "Simple public domain dedication text.",
    renderXhtml: renderPublicDomain
  }
];
function getLicenseTemplate(id) {
  return LICENSE_TEMPLATES.find((t) => t.id === id) ?? LICENSE_TEMPLATES[0];
}

// services/publish/EpubExportService.ts
function escapeXml2(value) {
  return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
function sanitizeFileName(name2) {
  const trimmed = name2.trim();
  if (!trimmed)
    return "book";
  const forbidden = '<>:"/\\\\|?*';
  let out = "";
  for (const ch of trimmed) {
    const code2 = ch.charCodeAt(0);
    if (code2 < 32) {
      out += "_";
      continue;
    }
    out += forbidden.includes(ch) ? "_" : ch;
  }
  return out.length ? out : "book";
}
function normalizeFolder2(folder) {
  const f = folder.replace(/\\/g, "/").replace(/^\/+/, "").replace(/\/+$/, "");
  return f.length ? f : "Exports";
}
function ensureEpubExt(name2) {
  return name2.toLowerCase().endsWith(".epub") ? name2 : `${name2}.epub`;
}
function nowIsoUtc() {
  return new Date().toISOString();
}
function uuidLike() {
  try {
    const c = globalThis.crypto;
    if (c?.randomUUID)
      return c.randomUUID();
  } catch {
  }
  return `wd-${Math.random().toString(16).slice(2)}-${Date.now().toString(16)}`;
}
function xhtmlDocument(title, bodyInner) {
  return `<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <title>${escapeXml2(title)}</title>
  <meta charset="utf-8" />
  <link rel="stylesheet" type="text/css" href="../Styles/style.css" />
</head>
<body>
` + bodyInner + `
</body>
</html>
`;
}
function buildNavXhtml(chapters, bookTitle) {
  const items = chapters.map((c) => `<li><a href="${escapeXml2(c.href)}">${escapeXml2(c.title)}</a></li>`).join("\n");
  return `<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en">
<head>
  <title>${escapeXml2(bookTitle)}</title>
  <meta charset="utf-8" />
  <link rel="stylesheet" type="text/css" href="Styles/style.css" />
</head>
<body>
  <nav epub:type="toc" id="toc">
    <h1>Contents</h1>
    <ol>
` + items + `
    </ol>
  </nav>
</body>
</html>
`;
}
function buildTocNcx(uuid, chapters, bookTitle) {
  const navPoints = chapters.map((c, idx) => {
    const order = idx + 1;
    return `<navPoint id="navPoint-${order}" playOrder="${order}">
  <navLabel><text>${escapeXml2(c.title)}</text></navLabel>
  <content src="${escapeXml2(c.href)}"/>
</navPoint>`;
  }).join("\n");
  return `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE ncx PUBLIC "-//NISO//DTD ncx 2005-1//EN" "http://www.daisy.org/z3986/2005/ncx-2005-1.dtd">
<ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1">
<head>
  <meta name="dtb:uid" content="${escapeXml2(uuid)}"/>
  <meta name="dtb:depth" content="1"/>
  <meta name="dtb:totalPageCount" content="0"/>
  <meta name="dtb:maxPageNumber" content="0"/>
</head>
<docTitle><text>${escapeXml2(bookTitle)}</text></docTitle>
<navMap>
` + navPoints + `
</navMap>
</ncx>
`;
}
function inferMediaType(path) {
  const ext = path.split(".").pop()?.toLowerCase();
  switch (ext) {
    case "xhtml":
    case "html":
      return "application/xhtml+xml";
    case "css":
      return "text/css";
    case "ncx":
      return "application/x-dtbncx+xml";
    case "ttf":
      return "font/ttf";
    case "otf":
      return "font/otf";
    case "woff":
      return "font/woff";
    case "woff2":
      return "font/woff2";
    default:
      return "application/octet-stream";
  }
}
function buildDefaultCss(fontFamily, embedFonts, fontFileNames) {
  const base2 = [
    `html, body { margin: 0; padding: 0; }`,
    `body { font-family: ${fontFamily}; font-size: 1em; line-height: 1.55; padding: 0 0.8em; }`,
    `h1, h2, h3 { font-family: ${fontFamily}; line-height: 1.2; }`,
    `h1 { font-size: 1.6em; margin: 1.1em 0 0.6em; }`,
    `p { margin: 0.9em 0; }`,
    `.chapter-title { page-break-before: always; }`,
    `.front-matter { page-break-before: always; }`,
    `a { color: inherit; }`
  ];
  if (!embedFonts || !fontFileNames?.regularPath)
    return base2.join("\n");
  const faces = [];
  const addFace = (key, weight, style) => {
    const file = fontFileNames[key];
    if (!file)
      return;
    faces.push(
      `@font-face { font-family: "CustomSerif"; src: url("../Fonts/${file}"); font-weight: ${weight}; font-style: ${style}; }`
    );
  };
  addFace("regularPath", 400, "normal");
  addFace("boldPath", 700, "normal");
  addFace("italicPath", 400, "italic");
  addFace("boldItalicPath", 700, "italic");
  return [...faces, ``, ...base2.map((l) => l.replace(fontFamily, `"CustomSerif", serif`))].join("\n");
}
var EpubExportService = class {
  constructor(vault) {
    this.vault = vault;
    this.md = new lib_default({
      html: false,
      linkify: true,
      typographer: true
    });
  }
  async exportEpub(params) {
    const bookTitle = params.bookTitle.trim() || "Untitled";
    const author = params.author.trim();
    const language = params.language.trim() || "en";
    const subtitle = (params.subtitle || "").trim();
    const folder = normalizeFolder2(params.outputFolder);
    const fileName = ensureEpubExt(sanitizeFileName(params.outputFileName || bookTitle));
    const outputPath = `${folder}/${fileName}`.replace(/\\/g, "/");
    await this.ensureFolder(folder);
    const uuid = uuidLike();
    const modified = nowIsoUtc();
    const zip = new import_jszip.default();
    zip.file("mimetype", "application/epub+zip", { compression: "STORE" });
    zip.folder("META-INF")?.file(
      "container.xml",
      `<?xml version="1.0" encoding="UTF-8"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
  <rootfiles>
    <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
  </rootfiles>
</container>
`
    );
    const oebps = zip.folder("OEBPS");
    if (!oebps)
      throw new Error("Failed to initialize EPUB container.");
    const textFolder = oebps.folder("Text");
    const stylesFolder = oebps.folder("Styles");
    const fontsFolder = oebps.folder("Fonts");
    if (!textFolder || !stylesFolder || !fontsFolder)
      throw new Error("Failed to initialize EPUB folders.");
    const manifest = [];
    const spine = [];
    manifest.push({ id: "nav", href: "nav.xhtml", mediaType: "application/xhtml+xml", properties: "nav" });
    manifest.push({ id: "toc", href: "toc.ncx", mediaType: "application/x-dtbncx+xml" });
    const fontFamily = `"Literata", "Georgia", serif`;
    const fontFileNames = {};
    if (params.embedCustomFonts && params.customFonts?.regularPath) {
      fontFileNames.regularPath = this.basename(params.customFonts.regularPath);
      if (params.customFonts.boldPath)
        fontFileNames.boldPath = this.basename(params.customFonts.boldPath);
      if (params.customFonts.italicPath)
        fontFileNames.italicPath = this.basename(params.customFonts.italicPath);
      if (params.customFonts.boldItalicPath)
        fontFileNames.boldItalicPath = this.basename(params.customFonts.boldItalicPath);
    }
    const css = buildDefaultCss(fontFamily, params.embedCustomFonts, fontFileNames);
    stylesFolder.file("style.css", css);
    manifest.push({ id: "css", href: "Styles/style.css", mediaType: "text/css" });
    if (params.includeTitlePage) {
      const inner = `<section class="front-matter">
<h1>${escapeXml2(bookTitle)}</h1>
` + (subtitle ? `<h2>${escapeXml2(subtitle)}</h2>
` : "") + (author ? `<p>${escapeXml2(author)}</p>
` : "") + `</section>`;
      const xhtml = xhtmlDocument("Title", inner);
      textFolder.file("title.xhtml", xhtml);
      manifest.push({ id: "title", href: "Text/title.xhtml", mediaType: "application/xhtml+xml" });
      spine.push("title");
    }
    if (params.includeCopyrightPage) {
      const template = getLicenseTemplate(params.licenseTemplateId);
      const xhtml = template.renderXhtml({
        title: bookTitle,
        author,
        year: params.copyrightYear || "",
        holder: params.copyrightHolder || ""
      });
      textFolder.file("copyright.xhtml", xhtml);
      manifest.push({ id: "copyright", href: "Text/copyright.xhtml", mediaType: "application/xhtml+xml" });
      spine.push("copyright");
    }
    const navChapters = [];
    for (let i = 0; i < params.chapters.length; i++) {
      const ch = params.chapters[i];
      const html = this.md.render(ch.markdown || "");
      const inner = `<section class="chapter">
<h1 class="chapter-title">${escapeXml2(ch.title || `Chapter ${i + 1}`)}</h1>
` + html + `
</section>`;
      const xhtml = xhtmlDocument(ch.title || `Chapter ${i + 1}`, inner);
      const file = `chapter-${String(i + 1).padStart(3, "0")}.xhtml`;
      textFolder.file(file, xhtml);
      const id = `ch${i + 1}`;
      manifest.push({ id, href: `Text/${file}`, mediaType: "application/xhtml+xml" });
      spine.push(id);
      navChapters.push({ title: ch.title || `Chapter ${i + 1}`, href: `Text/${file}` });
    }
    oebps.file("nav.xhtml", buildNavXhtml(navChapters, bookTitle));
    oebps.file("toc.ncx", buildTocNcx(uuid, navChapters, bookTitle));
    if (params.embedCustomFonts && params.customFonts?.regularPath) {
      const fontPaths = [
        ["regularPath", params.customFonts.regularPath],
        ["boldPath", params.customFonts.boldPath],
        ["italicPath", params.customFonts.italicPath],
        ["boldItalicPath", params.customFonts.boldItalicPath]
      ];
      for (const [, p] of fontPaths) {
        if (!p)
          continue;
        const data = await this.vault.adapter.readBinary(p);
        const name2 = this.basename(p);
        fontsFolder.file(name2, data);
        manifest.push({ id: `font-${sanitizeFileName(name2)}`, href: `Fonts/${name2}`, mediaType: inferMediaType(name2) });
      }
    }
    const opf = this.buildOpf({
      uuid,
      title: bookTitle,
      author,
      language,
      modified,
      manifest,
      spine
    });
    oebps.file("content.opf", opf);
    const bytes = await zip.generateAsync({
      type: "uint8array",
      compression: "DEFLATE",
      compressionOptions: { level: 9 }
    });
    const out = this.toArrayBuffer(bytes);
    await this.vault.adapter.writeBinary(outputPath, out);
    return { outputPath };
  }
  buildOpf(params) {
    const manifestXml = params.manifest.map((m) => {
      const props = m.properties ? ` properties="${escapeXml2(m.properties)}"` : "";
      return `<item id="${escapeXml2(m.id)}" href="${escapeXml2(m.href)}" media-type="${escapeXml2(m.mediaType)}"${props}/>`;
    }).join("\n    ");
    const spineXml = params.spine.map((idref) => `<itemref idref="${escapeXml2(idref)}"/>`).join("\n    ");
    return `<?xml version="1.0" encoding="utf-8"?>
<package xmlns="http://www.idpf.org/2007/opf" version="3.0" unique-identifier="pub-id">
  <metadata xmlns:dc="http://purl.org/dc/elements/1.1/">
    <dc:identifier id="pub-id">urn:uuid:${escapeXml2(params.uuid)}</dc:identifier>
    <dc:title>${escapeXml2(params.title)}</dc:title>
` + (params.author ? `    <dc:creator>${escapeXml2(params.author)}</dc:creator>
` : "") + `    <dc:language>${escapeXml2(params.language)}</dc:language>
    <meta property="dcterms:modified">${escapeXml2(params.modified)}</meta>
  </metadata>
  <manifest>
    ${manifestXml}
  </manifest>
  <spine toc="toc">
    ${spineXml}
  </spine>
</package>
`;
  }
  basename(path) {
    const normalized = path.replace(/\\/g, "/");
    return normalized.split("/").pop() || normalized;
  }
  async ensureFolder(folder) {
    const parts = normalizeFolder2(folder).split("/");
    let current = "";
    for (const part of parts) {
      current = current ? `${current}/${part}` : part;
      const exists = await this.vault.adapter.exists(current);
      if (!exists)
        await this.vault.adapter.mkdir(current);
    }
  }
  toArrayBuffer(bytes) {
    const out = new ArrayBuffer(bytes.byteLength);
    new Uint8Array(out).set(bytes);
    return out;
  }
};

// services/publish/DocxExportService.ts
var import_jszip2 = __toESM(require_jszip_min());

// services/publish/ExportTextUtils.ts
var md = new lib_default({ html: false, linkify: false, typographer: false });
function decodeEntities(s) {
  return s.replace(/&nbsp;/g, " ").replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
}
function markdownToPlainText(markdown) {
  const html = md.render(markdown || "");
  const withBreaks = html.replace(/<\/p>\s*<p>/g, "\n\n").replace(/<br\s*\/?>/g, "\n").replace(/<\/h\d>\s*<h\d[^>]*>/g, "\n\n").replace(/<\/li>\s*<li>/g, "\n").replace(/<\/(ul|ol)>/g, "\n\n");
  const stripped = withBreaks.replace(/<[^>]+>/g, "");
  return decodeEntities(stripped).replace(/\n{3,}/g, "\n\n").trim();
}
function sliceFirstNWords(text2, wordLimit) {
  const limit = Math.max(0, Math.floor(wordLimit));
  if (limit <= 0)
    return "";
  const words = (text2 || "").trim().split(/\s+/g).filter(Boolean);
  if (words.length <= limit)
    return words.join(" ");
  return words.slice(0, limit).join(" ");
}
function countWords(text2) {
  return (text2 || "").trim().split(/\s+/g).filter(Boolean).length;
}

// services/publish/DocxExportService.ts
function escapeXml3(value) {
  return (value || "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
function normalizeFolder3(folder) {
  const f = folder.replace(/\\/g, "/").replace(/^\/+/, "").replace(/\/+$/, "");
  return f.length ? f : "Exports";
}
function ensureDocxExt(name2) {
  return name2.toLowerCase().endsWith(".docx") ? name2 : `${name2}.docx`;
}
function wPara(text2, opts) {
  const runs = escapeXml3(text2 || "").split(/\r?\n/).map((line) => {
    const t = line || "";
    return `<w:r><w:t xml:space="preserve">${escapeXml3(t)}</w:t></w:r>`;
  }).join("");
  const pPr = [];
  if (opts?.heading)
    pPr.push('<w:pStyle w:val="Heading1"/>');
  if (opts?.center)
    pPr.push('<w:jc w:val="center"/>');
  const pPrXml = pPr.length ? `<w:pPr>${pPr.join("")}</w:pPr>` : "";
  return `<w:p>${pPrXml}${runs}</w:p>`;
}
function wBlankPara() {
  return '<w:p><w:r><w:t xml:space="preserve"> </w:t></w:r></w:p>';
}
var DocxExportService = class {
  constructor(vault) {
    this.vault = vault;
  }
  async export(params) {
    const folder = normalizeFolder3(params.outputFolder);
    const fileName = ensureDocxExt(params.outputFileName);
    const outPath = `${folder}/${fileName}`.replace(/\/+/g, "/");
    const zip = new import_jszip2.default();
    zip.file("[Content_Types].xml", `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
  <Override PartName="/word/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/>
  <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>
  <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/>
</Types>`);
    zip.folder("_rels")?.file(".rels", `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
  <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>
  <Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/>
</Relationships>`);
    const coreTitle = escapeXml3(params.title || "Untitled");
    const coreCreator = escapeXml3(params.author || "");
    zip.folder("docProps")?.file("core.xml", `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties"
 xmlns:dc="http://purl.org/dc/elements/1.1/"
 xmlns:dcterms="http://purl.org/dc/terms/"
 xmlns:dcmitype="http://purl.org/dc/dcmitype/"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <dc:title>${coreTitle}</dc:title>
  ${coreCreator ? `<dc:creator>${coreCreator}</dc:creator>` : ""}
  <dcterms:created xsi:type="dcterms:W3CDTF">${new Date().toISOString()}</dcterms:created>
</cp:coreProperties>`);
    zip.folder("docProps")?.file("app.xml", `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties"
 xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">
  <Application>Gwriter</Application>
</Properties>`);
    zip.folder("word")?.file("styles.xml", `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:styles xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:style w:type="paragraph" w:default="1" w:styleId="Normal">
    <w:name w:val="Normal"/>
  </w:style>
  <w:style w:type="paragraph" w:styleId="Heading1">
    <w:name w:val="heading 1"/>
    <w:basedOn w:val="Normal"/>
    <w:uiPriority w:val="9"/>
    <w:qFormat/>
    <w:pPr><w:keepNext/><w:keepLines/></w:pPr>
  </w:style>
</w:styles>`);
    const bodyParts = [];
    bodyParts.push(wPara(params.title || "Untitled", { center: true, heading: true }));
    if (params.author)
      bodyParts.push(wPara(params.author, { center: true }));
    bodyParts.push(wBlankPara());
    for (const ch of params.chapters) {
      bodyParts.push(wPara(ch.title || "Chapter", { heading: true }));
      bodyParts.push(wBlankPara());
      const plain = markdownToPlainText(ch.markdown || "");
      for (const p of plain.split(/\n{2,}/g)) {
        const trimmed = p.trim();
        if (!trimmed)
          continue;
        bodyParts.push(wPara(trimmed));
        bodyParts.push(wBlankPara());
      }
    }
    const documentXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:body>
    ${bodyParts.join("\n")}
    <w:sectPr/>
  </w:body>
</w:document>`;
    zip.folder("word")?.file("document.xml", documentXml);
    const ab = await zip.generateAsync({ type: "arraybuffer" });
    await this.vault.adapter.mkdir(folder).catch(() => {
    });
    await this.vault.adapter.writeBinary(outPath, ab);
    return outPath;
  }
};

// services/publish/RtfExportService.ts
function normalizeFolder4(folder) {
  const f = folder.replace(/\\/g, "/").replace(/^\/+/, "").replace(/\/+$/, "");
  return f.length ? f : "Exports";
}
function ensureRtfExt(name2) {
  return name2.toLowerCase().endsWith(".rtf") ? name2 : `${name2}.rtf`;
}
function escapeRtfText(text2) {
  return (text2 || "").replace(/\\/g, "\\\\").replace(/{/g, "\\{").replace(/}/g, "\\}").replace(/\r?\n/g, "\\par\n");
}
var RtfExportService = class {
  constructor(vault) {
    this.vault = vault;
  }
  async export(params) {
    const folder = normalizeFolder4(params.outputFolder);
    const fileName = ensureRtfExt(params.outputFileName);
    const outPath = `${folder}/${fileName}`.replace(/\/+/g, "/");
    const parts = [];
    parts.push("{\\rtf1\\ansi\\deff0");
    parts.push("{\\fonttbl{\\f0 Times New Roman;}}");
    parts.push("\\fs24");
    parts.push("\\sl480\\slmult1");
    const title = escapeRtfText(params.title || "Untitled");
    const author = escapeRtfText(params.author || "");
    parts.push(`\\qc\\b ${title}\\b0\\par`);
    if (author)
      parts.push(`\\qc ${author}\\par`);
    parts.push("\\ql\\par\\par");
    for (const ch of params.chapters) {
      const chTitle = escapeRtfText(ch.title || "Chapter");
      parts.push(`\\qc\\b ${chTitle}\\b0\\par`);
      parts.push("\\ql\\par");
      const body = markdownToPlainText(ch.markdown || "");
      parts.push(escapeRtfText(body));
      parts.push("\\par\\par");
    }
    parts.push("}");
    const rtf = parts.join("\n");
    await this.vault.adapter.mkdir(folder).catch(() => {
    });
    await this.vault.adapter.write(outPath, rtf);
    return outPath;
  }
};

// ui/PublishWizardModal.tsx
var FONT_EXTS = /* @__PURE__ */ new Set(["ttf", "otf", "woff", "woff2"]);
function currentYear() {
  return String(new Date().getFullYear());
}
function sanitizeFileName2(name2) {
  const trimmed = name2.trim();
  if (!trimmed)
    return "book";
  const forbidden = '<>:"/\\\\|?*';
  let out = "";
  for (const ch of trimmed) {
    const code2 = ch.charCodeAt(0);
    if (code2 < 32) {
      out += "_";
      continue;
    }
    out += forbidden.includes(ch) ? "_" : ch;
  }
  return out.length ? out : "book";
}
function ensureEpubExt2(name2) {
  return name2.toLowerCase().endsWith(".epub") ? name2 : `${name2}.epub`;
}
var PublishWizardModal = class extends import_obsidian27.Modal {
  constructor(plugin) {
    super(plugin.app);
    this.reactRoot = null;
    this.plugin = plugin;
  }
  onOpen() {
    this.titleEl.setText("Export to epub");
    this.contentEl.empty();
    const container = this.contentEl.createDiv();
    this.reactRoot = (0, import_client6.createRoot)(container);
    this.reactRoot.render(import_react11.default.createElement(PublishWizardComponent, { plugin: this.plugin, onClose: () => this.close() }));
  }
  onClose() {
    this.reactRoot?.unmount();
    this.reactRoot = null;
    this.contentEl.empty();
  }
};
var PublishWizardComponent = ({
  plugin,
  onClose
}) => {
  const [step, setStep] = (0, import_react11.useState)(1);
  const [mode, setMode] = (0, import_react11.useState)("book-main");
  const [sourcePath, setSourcePath] = (0, import_react11.useState)(plugin.settings.book2Path || "Book-Main.md");
  const [tocPath, setTocPath] = (0, import_react11.useState)("");
  const [title, setTitle] = (0, import_react11.useState)("Untitled");
  const [subtitle, setSubtitle] = (0, import_react11.useState)("");
  const [author, setAuthor] = (0, import_react11.useState)("");
  const [language, setLanguage] = (0, import_react11.useState)("en");
  const [includeTitlePage, setIncludeTitlePage] = (0, import_react11.useState)(true);
  const [includeCopyrightPage, setIncludeCopyrightPage] = (0, import_react11.useState)(true);
  const [licenseTemplateId, setLicenseTemplateId] = (0, import_react11.useState)("all-rights-reserved");
  const [copyrightYear, setCopyrightYear] = (0, import_react11.useState)(currentYear());
  const [copyrightHolder, setCopyrightHolder] = (0, import_react11.useState)("");
  const [embedFonts, setEmbedFonts] = (0, import_react11.useState)(false);
  const [fontRegular, setFontRegular] = (0, import_react11.useState)("");
  const [fontBold, setFontBold] = (0, import_react11.useState)("");
  const [fontItalic, setFontItalic] = (0, import_react11.useState)("");
  const [fontBoldItalic, setFontBoldItalic] = (0, import_react11.useState)("");
  const [outputFolder, setOutputFolder] = (0, import_react11.useState)("Exports");
  const [outputFormat, setOutputFormat] = (0, import_react11.useState)("epub");
  const [subsetMode, setSubsetMode] = (0, import_react11.useState)("all");
  const [subsetChaptersCount, setSubsetChaptersCount] = (0, import_react11.useState)("3");
  const [subsetWordsCount, setSubsetWordsCount] = (0, import_react11.useState)("5000");
  const [outputFileName, setOutputFileName] = (0, import_react11.useState)("Untitled.epub");
  const [isExporting, setIsExporting] = (0, import_react11.useState)(false);
  const [progress, setProgress] = (0, import_react11.useState)("");
  const [error2, setError] = (0, import_react11.useState)(null);
  (0, import_react11.useEffect)(() => {
    const base2 = sanitizeFileName2(title || "Untitled");
    if (outputFormat === "epub")
      setOutputFileName(ensureEpubExt2(base2));
    else if (outputFormat === "docx")
      setOutputFileName(`${base2}.docx`);
    else if (outputFormat === "rtf")
      setOutputFileName(`${base2}.rtf`);
    else
      setOutputFileName(`${base2}.txt`);
  }, [title, outputFormat]);
  const applySubset = (chapters) => {
    if (subsetMode === "all")
      return chapters;
    if (subsetMode === "first-chapters") {
      const n = Math.max(1, Math.min(200, parseInt(subsetChaptersCount, 10) || 1));
      return chapters.slice(0, n);
    }
    const limit = Math.max(1, Math.min(2e6, parseInt(subsetWordsCount, 10) || 1));
    const out = [];
    let remaining = limit;
    for (const ch of chapters) {
      if (remaining <= 0)
        break;
      const plain = markdownToPlainText(ch.markdown || "");
      const words = countWords(plain);
      if (words <= remaining) {
        out.push(ch);
        remaining -= words;
        continue;
      }
      const sliced = sliceFirstNWords(plain, remaining);
      out.push({ ...ch, markdown: sliced });
      break;
    }
    return out;
  };
  const canNext = (0, import_react11.useMemo)(() => {
    if (step === 1) {
      if (mode === "book-main")
        return Boolean(sourcePath.trim());
      return Boolean(tocPath.trim());
    }
    if (step === 4 && embedFonts) {
      return Boolean(fontRegular.trim());
    }
    if (step === 5) {
      return Boolean(outputFolder.trim()) && Boolean(outputFileName.trim());
    }
    return true;
  }, [step, mode, sourcePath, tocPath, embedFonts, fontRegular, outputFolder, outputFileName]);
  const pickMarkdownFile = (title2, onPick, currentPath) => {
    const modal = new FileTreePickerModal(plugin, {
      currentPath,
      title: title2,
      onPick: async (filePath) => {
        await onPick(filePath);
      }
    });
    modal.open();
  };
  const pickFolder = (onPick) => {
    const folders = plugin.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian27.TFolder);
    const modal = new FolderPickerModal({
      app: plugin.app,
      folders,
      placeholder: "Pick an output folder",
      onPick
    });
    modal.open();
  };
  const pickFontFile = (onPick) => {
    const files = plugin.app.vault.getFiles().filter((f) => FONT_EXTS.has(f.extension.toLowerCase()));
    const modal = new BinaryFilePickerModal({
      app: plugin.app,
      files,
      placeholder: "Pick a font file",
      onPick
    });
    modal.open();
  };
  const goNext = () => {
    if (!canNext)
      return;
    setStep((s) => s < 6 ? s + 1 : s);
  };
  const goBack = () => {
    setStep((s) => s > 1 ? s - 1 : s);
  };
  const doExport = async () => {
    setIsExporting(true);
    setError(null);
    setProgress("Compiling chapters\u2026");
    try {
      const compiler = new MarkdownCompile(plugin.app);
      const compileResult = mode === "book-main" ? await compiler.compileFromBookMain(sourcePath) : await compiler.compileFromTocNote(tocPath);
      if (!compileResult.chapters.length) {
        throw new Error("No chapters were found to export.");
      }
      const chapters = applySubset(compileResult.chapters);
      let outputPath = "";
      if (outputFormat === "epub") {
        setProgress(`Building epub (${chapters.length} chapter(s))\u2026`);
        const exporter = new EpubExportService(plugin.app.vault);
        const result = await exporter.exportEpub({
          bookTitle: title,
          subtitle,
          author,
          language,
          chapters,
          includeTitlePage,
          includeCopyrightPage,
          licenseTemplateId,
          copyrightYear,
          copyrightHolder,
          embedCustomFonts: embedFonts,
          customFonts: embedFonts ? {
            regularPath: fontRegular,
            boldPath: fontBold || void 0,
            italicPath: fontItalic || void 0,
            boldItalicPath: fontBoldItalic || void 0
          } : void 0,
          outputFolder,
          outputFileName
        });
        outputPath = result.outputPath;
      } else if (outputFormat === "docx") {
        setProgress(`Building docx (${chapters.length} chapter(s))\u2026`);
        const exporter = new DocxExportService(plugin.app.vault);
        outputPath = await exporter.export({
          title,
          author,
          chapters,
          outputFolder,
          outputFileName
        });
      } else if (outputFormat === "rtf") {
        setProgress(`Building rtf (${chapters.length} chapter(s))\u2026`);
        const exporter = new RtfExportService(plugin.app.vault);
        outputPath = await exporter.export({
          title,
          author,
          chapters,
          outputFolder,
          outputFileName
        });
      } else {
        setProgress("Writing plain text\u2026");
        const folder = outputFolder.replace(/\\/g, "/").replace(/^\/+/, "").replace(/\/+$/, "") || "Exports";
        const out = `${folder}/${outputFileName.trim() || "submission.txt"}`.replace(/\/+/g, "/");
        const text2 = `${title || "Untitled"}
${author ? `${author}
` : ""}
` + chapters.map((c) => `
${c.title}

${markdownToPlainText(c.markdown || "")}
`).join("\n");
        await plugin.app.vault.adapter.mkdir(folder).catch(() => {
        });
        await plugin.app.vault.adapter.write(out, text2);
        outputPath = out;
      }
      setProgress("");
      new import_obsidian27.Notice(`Exported: ${outputPath}`);
      onClose();
    } catch (e) {
      const message = e instanceof Error ? e.message : (() => {
        try {
          return JSON.stringify(e);
        } catch {
          return "[unserializable error]";
        }
      })();
      setError(message || "Export failed");
      setProgress("");
    } finally {
      setIsExporting(false);
    }
  };
  return /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-wizard" }, /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-steps" }, "Step ", step, " of 6"), step === 1 && /* @__PURE__ */ import_react11.default.createElement("div", null, /* @__PURE__ */ import_react11.default.createElement("h2", null, "Source"), /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("label", null, /* @__PURE__ */ import_react11.default.createElement(
    "input",
    {
      type: "radio",
      checked: mode === "book-main",
      onChange: () => setMode("book-main"),
      disabled: isExporting
    }
  ), "Book main (H1 chapters)"), /* @__PURE__ */ import_react11.default.createElement("label", { style: { marginLeft: 12 } }, /* @__PURE__ */ import_react11.default.createElement(
    "input",
    {
      type: "radio",
      checked: mode === "toc-note",
      onChange: () => setMode("toc-note"),
      disabled: isExporting
    }
  ), "TOC note")), mode === "book-main" && /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("div", null, "Book main file"), /* @__PURE__ */ import_react11.default.createElement("div", { style: { display: "flex", gap: 8, alignItems: "center" } }, /* @__PURE__ */ import_react11.default.createElement("input", { value: sourcePath, onChange: (e) => setSourcePath(e.target.value), disabled: isExporting }), /* @__PURE__ */ import_react11.default.createElement(
    "button",
    {
      onClick: () => pickMarkdownFile("Pick your manuscript note", (filePath) => {
        setSourcePath(filePath);
      }, sourcePath),
      disabled: isExporting
    },
    "Browse"
  ))), mode === "toc-note" && /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("div", null, "TOC note"), /* @__PURE__ */ import_react11.default.createElement("div", { style: { display: "flex", gap: 8, alignItems: "center" } }, /* @__PURE__ */ import_react11.default.createElement("input", { value: tocPath, onChange: (e) => setTocPath(e.target.value), disabled: isExporting }), /* @__PURE__ */ import_react11.default.createElement(
    "button",
    {
      onClick: () => pickMarkdownFile("Pick your TOC note", (filePath) => {
        setTocPath(filePath);
      }, tocPath),
      disabled: isExporting
    },
    "Browse"
  )))), step === 2 && /* @__PURE__ */ import_react11.default.createElement("div", null, /* @__PURE__ */ import_react11.default.createElement("h2", null, "Metadata"), /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("div", null, "Title"), /* @__PURE__ */ import_react11.default.createElement("input", { value: title, onChange: (e) => setTitle(e.target.value), disabled: isExporting })), /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("div", null, "Subtitle (optional)"), /* @__PURE__ */ import_react11.default.createElement("input", { value: subtitle, onChange: (e) => setSubtitle(e.target.value), disabled: isExporting })), /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("div", null, "Author"), /* @__PURE__ */ import_react11.default.createElement("input", { value: author, onChange: (e) => setAuthor(e.target.value), disabled: isExporting })), /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("div", null, "Language"), /* @__PURE__ */ import_react11.default.createElement("input", { value: language, onChange: (e) => setLanguage(e.target.value), disabled: isExporting, placeholder: "en" }))), step === 3 && /* @__PURE__ */ import_react11.default.createElement("div", null, /* @__PURE__ */ import_react11.default.createElement("h2", null, "Front matter"), /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("label", null, /* @__PURE__ */ import_react11.default.createElement("input", { type: "checkbox", checked: includeTitlePage, onChange: (e) => setIncludeTitlePage(e.target.checked) }), "Title page")), /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("label", null, /* @__PURE__ */ import_react11.default.createElement(
    "input",
    {
      type: "checkbox",
      checked: includeCopyrightPage,
      onChange: (e) => setIncludeCopyrightPage(e.target.checked)
    }
  ), "Copyright page")), /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("div", null, "License template"), /* @__PURE__ */ import_react11.default.createElement(
    "select",
    {
      value: licenseTemplateId,
      onChange: (e) => setLicenseTemplateId(e.target.value),
      disabled: isExporting
    },
    LICENSE_TEMPLATES.map((t) => /* @__PURE__ */ import_react11.default.createElement("option", { key: t.id, value: t.id }, t.label))
  )), /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("div", null, "Copyright year"), /* @__PURE__ */ import_react11.default.createElement("input", { value: copyrightYear, onChange: (e) => setCopyrightYear(e.target.value), disabled: isExporting })), /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("div", null, "Copyright holder"), /* @__PURE__ */ import_react11.default.createElement("input", { value: copyrightHolder, onChange: (e) => setCopyrightHolder(e.target.value), disabled: isExporting }))), step === 4 && /* @__PURE__ */ import_react11.default.createElement("div", null, /* @__PURE__ */ import_react11.default.createElement("h2", null, "Typography"), /* @__PURE__ */ import_react11.default.createElement("p", null, "Default styling uses Literata if available on the reader device. You can embed your own font files to guarantee the look."), /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("label", null, /* @__PURE__ */ import_react11.default.createElement("input", { type: "checkbox", checked: embedFonts, onChange: (e) => setEmbedFonts(e.target.checked), disabled: isExporting }), "Embed custom fonts")), embedFonts && /* @__PURE__ */ import_react11.default.createElement("div", null, /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("div", null, "Regular (required)"), /* @__PURE__ */ import_react11.default.createElement("div", { style: { display: "flex", gap: 8, alignItems: "center" } }, /* @__PURE__ */ import_react11.default.createElement("input", { value: fontRegular, onChange: (e) => setFontRegular(e.target.value), disabled: isExporting }), /* @__PURE__ */ import_react11.default.createElement("button", { onClick: () => pickFontFile((f) => setFontRegular(f.path)), disabled: isExporting }, "Browse"))), /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("div", null, "Bold"), /* @__PURE__ */ import_react11.default.createElement("div", { style: { display: "flex", gap: 8, alignItems: "center" } }, /* @__PURE__ */ import_react11.default.createElement("input", { value: fontBold, onChange: (e) => setFontBold(e.target.value), disabled: isExporting }), /* @__PURE__ */ import_react11.default.createElement("button", { onClick: () => pickFontFile((f) => setFontBold(f.path)), disabled: isExporting }, "Browse"))), /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("div", null, "Italic"), /* @__PURE__ */ import_react11.default.createElement("div", { style: { display: "flex", gap: 8, alignItems: "center" } }, /* @__PURE__ */ import_react11.default.createElement("input", { value: fontItalic, onChange: (e) => setFontItalic(e.target.value), disabled: isExporting }), /* @__PURE__ */ import_react11.default.createElement("button", { onClick: () => pickFontFile((f) => setFontItalic(f.path)), disabled: isExporting }, "Browse"))), /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("div", null, "Bold italic"), /* @__PURE__ */ import_react11.default.createElement("div", { style: { display: "flex", gap: 8, alignItems: "center" } }, /* @__PURE__ */ import_react11.default.createElement("input", { value: fontBoldItalic, onChange: (e) => setFontBoldItalic(e.target.value), disabled: isExporting }), /* @__PURE__ */ import_react11.default.createElement("button", { onClick: () => pickFontFile((f) => setFontBoldItalic(f.path)), disabled: isExporting }, "Browse"))))), step === 5 && /* @__PURE__ */ import_react11.default.createElement("div", null, /* @__PURE__ */ import_react11.default.createElement("h2", null, "Output"), /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("div", null, "Format"), /* @__PURE__ */ import_react11.default.createElement("select", { value: outputFormat, onChange: (e) => setOutputFormat(e.target.value), disabled: isExporting }, /* @__PURE__ */ import_react11.default.createElement("option", { value: "epub" }, "Epub"), /* @__PURE__ */ import_react11.default.createElement("option", { value: "docx" }, "Docx"), /* @__PURE__ */ import_react11.default.createElement("option", { value: "rtf" }, "Rtf"), /* @__PURE__ */ import_react11.default.createElement("option", { value: "copy" }, "Plain text"))), /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("div", null, "Export subset"), /* @__PURE__ */ import_react11.default.createElement("select", { value: subsetMode, onChange: (e) => setSubsetMode(e.target.value), disabled: isExporting }, /* @__PURE__ */ import_react11.default.createElement("option", { value: "all" }, "All chapters"), /* @__PURE__ */ import_react11.default.createElement("option", { value: "first-chapters" }, "First N chapters"), /* @__PURE__ */ import_react11.default.createElement("option", { value: "first-words" }, "First N words"))), subsetMode === "first-chapters" && /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("div", null, "Chapters"), /* @__PURE__ */ import_react11.default.createElement("input", { value: subsetChaptersCount, onChange: (e) => setSubsetChaptersCount(e.target.value), disabled: isExporting })), subsetMode === "first-words" && /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("div", null, "Words"), /* @__PURE__ */ import_react11.default.createElement("input", { value: subsetWordsCount, onChange: (e) => setSubsetWordsCount(e.target.value), disabled: isExporting })), /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("div", null, "Folder"), /* @__PURE__ */ import_react11.default.createElement("div", { style: { display: "flex", gap: 8, alignItems: "center" } }, /* @__PURE__ */ import_react11.default.createElement("input", { value: outputFolder, onChange: (e) => setOutputFolder(e.target.value), disabled: isExporting }), /* @__PURE__ */ import_react11.default.createElement("button", { onClick: () => pickFolder((f) => setOutputFolder(f.path)), disabled: isExporting }, "Browse"))), /* @__PURE__ */ import_react11.default.createElement("div", { className: "publish-row" }, /* @__PURE__ */ import_react11.default.createElement("div", null, "File name"), /* @__PURE__ */ import_react11.default.createElement("input", { value: outputFileName, onChange: (e) => setOutputFileName(e.target.value), disabled: isExporting }))), step === 6 && /* @__PURE__ */ import_react11.default.createElement("div", null, /* @__PURE__ */ import_react11.default.createElement("h2", null, "Export"), /* @__PURE__ */ import_react11.default.createElement("p", null, "When you click Export, the plugin will compile your notes and write the output into your vault."), progress && /* @__PURE__ */ import_react11.default.createElement("div", { className: "generation-status" }, progress), error2 && /* @__PURE__ */ import_react11.default.createElement("div", { className: "error-message" }, "\u274C ", error2)), /* @__PURE__ */ import_react11.default.createElement("div", { style: { display: "flex", justifyContent: "space-between", marginTop: 16 } }, /* @__PURE__ */ import_react11.default.createElement("div", null, /* @__PURE__ */ import_react11.default.createElement("button", { onClick: onClose, className: "mod-secondary", disabled: isExporting }, "Close")), /* @__PURE__ */ import_react11.default.createElement("div", { style: { display: "flex", gap: 8 } }, /* @__PURE__ */ import_react11.default.createElement("button", { onClick: goBack, disabled: isExporting || step === 1 }, "Back"), step < 6 && /* @__PURE__ */ import_react11.default.createElement("button", { onClick: goNext, disabled: isExporting || !canNext, className: "mod-cta" }, "Next"), step === 6 && /* @__PURE__ */ import_react11.default.createElement("button", { onClick: doExport, disabled: isExporting, className: "mod-cta" }, "Export"))));
};

// services/TemplateProcessor.ts
var import_obsidian28 = require("obsidian");
var TemplateProcessor = class {
  constructor(app, plugin) {
    this.hookAttempts = /* @__PURE__ */ new Map();
    this.app = app;
    this.plugin = plugin;
    this.registerAllPossibleHooks();
  }
  /**
   * Register hooks in every possible way Smart Connections might look for template processors.
   * We'll track which one actually gets used.
   */
  registerAllPossibleHooks() {
    try {
      const appWithPlugins = this.app;
      console.log("[TemplateProcessor] \u{1F527} Starting hook registration...");
      const scPlugin = appWithPlugins.plugins?.plugins?.["smart-connections"];
      console.log(
        `[TemplateProcessor] Plugin system state: app.plugins=${!!appWithPlugins.plugins} | app.plugins.plugins=${!!appWithPlugins.plugins?.plugins} | SC installed=${!!scPlugin} | SC loaded=${!!scPlugin?.instance} | SC enabled=${scPlugin?.enabled === true}`
      );
      const textGeneratorPlugin = appWithPlugins.plugins?.plugins?.["text-generator"];
      if (textGeneratorPlugin) {
        console.log("[TemplateProcessor] \u{1F4E6} Text Generator plugin found!");
        console.log("[TemplateProcessor] \u{1F50D} Inspecting Text Generator template processor...");
        const tgInstance = textGeneratorPlugin.instance || textGeneratorPlugin;
        const tgProcessor = tgInstance?.templateProcessor || tgInstance?.processTemplate || textGeneratorPlugin.templateProcessor || textGeneratorPlugin.processTemplate;
        if (tgProcessor) {
          console.log("[TemplateProcessor] \u2705 Found Text Generator template processor:", typeof tgProcessor);
          if (typeof tgProcessor === "object") {
            console.log("[TemplateProcessor] \u{1F4CB} Text Generator processor keys:", Object.keys(tgProcessor || {}));
          }
          if (appWithPlugins.templateProcessors) {
            const tgInArray = appWithPlugins.templateProcessors.find(
              (p) => p.id === "text-generator" || p.name === "Text Generator" || p.plugin === textGeneratorPlugin
            );
            if (tgInArray) {
              console.log("[TemplateProcessor] \u{1F4CD} Text Generator found in app.templateProcessors array");
              console.log("[TemplateProcessor] \u{1F4CB} Text Generator registration:", Object.keys(tgInArray));
            }
          }
        } else {
          console.log("[TemplateProcessor] \u26A0\uFE0F Text Generator found but no template processor detected");
          console.log("[TemplateProcessor] \u{1F50D} Text Generator plugin structure:", Object.keys(textGeneratorPlugin));
        }
      } else {
        console.log("[TemplateProcessor] \u2139\uFE0F Text Generator plugin not found");
      }
      if (appWithPlugins.templateProcessors && Array.isArray(appWithPlugins.templateProcessors)) {
        appWithPlugins.templateProcessors.push({
          id: "writing-dashboard",
          name: "Writing Dashboard",
          process: this.processTemplate.bind(this),
          processTemplate: this.processTemplate.bind(this),
          renderTemplate: this.processTemplate.bind(this),
          plugin: this.plugin
        });
        this.logHookAttempt("app.templateProcessors array");
      } else {
        console.warn("[TemplateProcessor] \u26A0\uFE0F app.templateProcessors not available or not an array - skipping");
      }
      if (!window.templateProcessors) {
        window.templateProcessors = [];
      }
      window.templateProcessors.push({
        id: "writing-dashboard",
        name: "Writing Dashboard",
        process: this.processTemplate.bind(this),
        processTemplate: this.processTemplate.bind(this)
      });
      this.logHookAttempt("window.templateProcessors array");
      if (!window.templateProcessor) {
        window.templateProcessor = {};
      }
      window.templateProcessor["writing-dashboard"] = this.processTemplate.bind(this);
      this.logHookAttempt("window.templateProcessor object");
      this.plugin.templateProcessor = this.processTemplate.bind(this);
      this.plugin.processTemplate = this.processTemplate.bind(this);
      this.plugin.renderTemplate = this.processTemplate.bind(this);
      this.logHookAttempt("plugin instance methods");
      window.addEventListener("template-process", this.handleTemplateProcess.bind(this));
      window.addEventListener("template-processing", this.handleTemplateProcessing.bind(this));
      this.logHookAttempt("window template-process event listeners");
      if (appWithPlugins.templates && appWithPlugins.templates.processors && Array.isArray(appWithPlugins.templates.processors)) {
        appWithPlugins.templates.processors.push({
          id: "writing-dashboard",
          name: "Writing Dashboard",
          process: this.processTemplate.bind(this),
          processTemplate: this.processTemplate.bind(this)
        });
        this.logHookAttempt("app.templates.processors");
      } else {
        console.warn("[TemplateProcessor] \u26A0\uFE0F app.templates.processors not available or not an array - skipping");
      }
      window.dispatchEvent(new CustomEvent("template-processor-registered", {
        detail: {
          id: "writing-dashboard",
          process: this.processTemplate.bind(this),
          processTemplate: this.processTemplate.bind(this),
          plugin: this.plugin
        }
      }));
      this.logHookAttempt("template-processor-registered event");
      window.writingDashboardProcessTemplate = this.processTemplate.bind(this);
      this.logHookAttempt("window.writingDashboardProcessTemplate function");
    } catch (error2) {
      console.warn("[TemplateProcessor] Error during hook registration:", error2);
    }
  }
  logHookAttempt(method) {
    this.hookAttempts.set(method, false);
    console.debug(`[TemplateProcessor] Registered hook via: ${method}`);
    console.log(`[TemplateProcessor] \u2713 Registered hook via: ${method}`);
  }
  handleTemplateProcess(event) {
    console.debug(`[TemplateProcessor] Template process event received:`, event.type, event.detail);
  }
  handleTemplateProcessing(event) {
    console.debug(`[TemplateProcessor] Template processing event received:`, event.type, event.detail);
  }
  /**
   * Main template processing method that Smart Connections should hook into.
   * This processes our template placeholders and emits events for Smart Connections.
   */
  async processTemplate(templateContent, context) {
    console.log("[TemplateProcessor] \u{1F680} processTemplate called!");
    console.debug("[TemplateProcessor] processTemplate called!");
    console.log("[TemplateProcessor] \u{1F4C4} Template content length:", templateContent.length);
    console.debug("[TemplateProcessor] Template content length:", templateContent.length);
    console.log("[TemplateProcessor] \u{1F4C1} Active file:", context.file?.path || "None");
    console.debug("[TemplateProcessor] Active file:", context.file?.path);
    try {
      const stack = new Error().stack;
      console.log("[TemplateProcessor] \u{1F4DA} Call stack (first 10 lines):");
      const stackLines = stack?.split("\n").slice(0, 10) || [];
      stackLines.forEach((line, i) => {
        console.log(`[TemplateProcessor]   ${i + 1}. ${line.trim()}`);
      });
      console.debug("[TemplateProcessor] Call stack:", stack?.split("\n").slice(0, 10).join("\n"));
    } catch (e) {
      console.warn("[TemplateProcessor] \u26A0\uFE0F Stack trace not available:", e);
    }
    let processed = templateContent;
    console.log("[TemplateProcessor] \u{1F50D} Processing {{read}} placeholders...");
    processed = await this.processReadPlaceholders(processed);
    console.log("[TemplateProcessor] \u{1F4CB} Processing {{clipboard}} placeholder...");
    processed = await this.processClipboardPlaceholder(processed);
    console.log("[TemplateProcessor] \u{1F4CD} Processing {{cursor}} placeholder...");
    processed = this.processCursorPlaceholder(processed, context.file);
    console.log("[TemplateProcessor] \u{1F4E1} Emitting template-processing event for Smart Connections...");
    console.debug("[TemplateProcessor] Emitting template-processing event for Smart Connections");
    window.dispatchEvent(new CustomEvent("template-processing", {
      detail: {
        content: processed,
        context,
        processor: "writing-dashboard",
        originalContent: templateContent
      }
    }));
    console.log("[TemplateProcessor] \u{1F4E1} Emitting template-process event...");
    window.dispatchEvent(new CustomEvent("template-process", {
      detail: {
        content: processed,
        context,
        processor: "writing-dashboard"
      }
    }));
    console.log("[TemplateProcessor] \u23F3 Waiting 2 seconds for Smart Connections to process syntax...");
    console.debug("[TemplateProcessor] Waiting for Smart Connections to process syntax...");
    await new Promise((resolve) => setTimeout(resolve, 2e3));
    const scRegex = /\{\{smart-connections:similar:(\d+)\}\}/g;
    const hasUnprocessedSC = scRegex.test(processed);
    if (hasUnprocessedSC) {
      const matches = processed.match(scRegex);
      console.warn("[TemplateProcessor] \u274C Smart Connections syntax not processed - hooks may not be working");
      console.warn(`[TemplateProcessor] \u26A0\uFE0F Unprocessed syntax found: ${matches?.length || 0} placeholders still present`);
      if (matches) {
        console.warn("[TemplateProcessor] Unprocessed placeholders:", matches);
      }
      const diagnosis = this.diagnoseSmartConnectionsFailure();
      console.warn(`[TemplateProcessor] \u{1F50D} Diagnostic: ${diagnosis}`);
    } else {
      console.log("[TemplateProcessor] \u2705 Smart Connections syntax appears to have been processed");
      console.debug("[TemplateProcessor] Smart Connections syntax appears to have been processed");
    }
    const finalContent = processed;
    console.log("[TemplateProcessor] \u2705 Final processed content length:", finalContent.length);
    console.debug("[TemplateProcessor] Final processed content length:", finalContent.length);
    return finalContent;
  }
  /**
   * Process {{read "file.md"}} placeholders
   */
  async processReadPlaceholders(content) {
    const readRegex = /\{\{read\s+"([^"]+)"\}\}/g;
    let match2;
    const replacements = [];
    while ((match2 = readRegex.exec(content)) !== null) {
      const filePath = match2[1];
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian28.TFile) {
        try {
          const fileContent = await this.app.vault.read(file);
          replacements.push({ placeholder: match2[0], content: fileContent });
          console.debug(`[TemplateProcessor] Processed {{read "${filePath}"}} - ${fileContent.length} chars`);
        } catch (error2) {
          console.warn(`[TemplateProcessor] Failed to read file: ${filePath}`, error2);
          replacements.push({ placeholder: match2[0], content: `[Error reading file: ${filePath}]` });
        }
      } else {
        console.warn(`[TemplateProcessor] File not found: ${filePath}`);
        replacements.push({ placeholder: match2[0], content: `[File not found: ${filePath}]` });
      }
    }
    for (const { placeholder, content: fileContent } of replacements) {
      content = content.replace(placeholder, fileContent);
    }
    return content;
  }
  /**
   * Process {{clipboard}} placeholder
   */
  async processClipboardPlaceholder(content) {
    if (content.includes("{{clipboard}}")) {
      try {
        const clipboardText = await navigator.clipboard.readText();
        content = content.replace(/\{\{clipboard\}\}/g, clipboardText);
        console.debug(`[TemplateProcessor] Processed {{clipboard}} - ${clipboardText.length} chars`);
      } catch (error2) {
        console.warn("[TemplateProcessor] Failed to read clipboard:", error2);
        content = content.replace(/\{\{clipboard\}\}/g, "");
      }
    }
    return content;
  }
  /**
   * Process {{cursor}} placeholder
   */
  processCursorPlaceholder(content, activeFile) {
    if (content.includes("{{cursor}}")) {
      try {
        const activeLeaf = this.app.workspace.getActiveViewOfType(import_obsidian28.MarkdownView);
        if (activeLeaf) {
          const editor = activeLeaf.editor;
          const selection = editor.getSelection();
          const cursorContent = selection || `[Cursor in ${activeFile?.basename || "active file"}]`;
          content = content.replace(/\{\{cursor\}\}/g, cursorContent);
          console.debug(`[TemplateProcessor] Processed {{cursor}} - ${cursorContent.length} chars`);
        } else {
          content = content.replace(/\{\{cursor\}\}/g, "");
        }
      } catch (error2) {
        console.warn("[TemplateProcessor] Failed to process {{cursor}}:", error2);
        content = content.replace(/\{\{cursor\}\}/g, "");
      }
    }
    return content;
  }
  /**
   * Diagnose why Smart Connections didn't process the template
   * Returns a detailed explanation of what happened and why
   */
  diagnoseSmartConnectionsFailure() {
    const appWithPlugins = this.app;
    const diagnostics = [];
    const scPlugin = appWithPlugins.plugins?.plugins?.["smart-connections"];
    if (!scPlugin) {
      diagnostics.push("ROOT CAUSE: Smart Connections plugin not installed or not found in app.plugins.plugins");
      diagnostics.push("WHY THIS FAILED: Smart Connections cannot process templates if the plugin is not installed");
      diagnostics.push("SOLUTION: Install Smart Connections plugin from Community Plugins");
    } else {
      const isLoaded = scPlugin.instance !== void 0 && scPlugin.instance !== null;
      const isEnabled = scPlugin.enabled === true;
      if (!isLoaded) {
        diagnostics.push("ROOT CAUSE: Smart Connections plugin found but instance not loaded yet");
        diagnostics.push("WHY THIS FAILED: Plugin may still be initializing - our hook registration ran too early");
        diagnostics.push("SOLUTION: Plugin needs time to fully load. Try again after a few seconds, or delay our hook registration");
      } else if (!isEnabled) {
        diagnostics.push("ROOT CAUSE: Smart Connections plugin found but not enabled");
        diagnostics.push("WHY THIS FAILED: Disabled plugins do not process templates or respond to events");
        diagnostics.push("SOLUTION: Enable Smart Connections in Settings > Community Plugins");
      } else {
        diagnostics.push("\u2713 Smart Connections plugin is installed, loaded, and enabled");
        const hookStatus = this.getHookStatus();
        const registeredCount = Object.values(hookStatus).length;
        diagnostics.push(`\u2713 ${registeredCount} hook registration methods attempted`);
        diagnostics.push("\u2713 Our template processor WAS called (hook registration succeeded)");
        diagnostics.push("\u2713 Template processing events were emitted (template-processing, template-process)");
        const scInstance = scPlugin.instance;
        if (scInstance) {
          const scMethods = Object.keys(scInstance).filter(
            (k) => k.toLowerCase().includes("template") || k.toLowerCase().includes("process") || k.toLowerCase().includes("similar")
          );
          if (scMethods.length > 0) {
            diagnostics.push(`\u2713 Smart Connections has methods: ${scMethods.join(", ")}`);
          } else {
            diagnostics.push("\u26A0\uFE0F Smart Connections template processing methods not detected");
          }
        }
        diagnostics.push("ROOT CAUSE: Smart Connections is not listening to our template-processing events");
        diagnostics.push("WHY THIS FAILED: Smart Connections likely hooks into Text Generator's template system, not generic events");
        diagnostics.push("WHAT HAPPENED: We emitted events but Smart Connections did not respond because it uses a different hook mechanism");
        diagnostics.push("SOLUTION: Smart Connections may need to be called via Obsidian's native template insertion (which we tried) or Text Generator's API");
      }
    }
    return diagnostics.join(" | ");
  }
  /**
   * Get status of which hooks were registered (for debugging)
   */
  getHookStatus() {
    return Object.fromEntries(this.hookAttempts);
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  apiKey: "",
  apiProvider: "openai",
  model: "gpt-4",
  generationMode: "single",
  multiStrategy: "draft-revision",
  draftModel: "gpt-3.5-turbo",
  revisionModel: "gpt-4",
  consensusModel1: "gpt-4",
  consensusModel2: "claude-3-opus",
  consensusModel3: "gemini-pro",
  synthesisModel: "gpt-4",
  vaultPath: "",
  characterFolder: "",
  book2Path: "Book-Main.md",
  storyBiblePath: "Book - Story Bible.md",
  characterExtractionChunkSize: 2500,
  contextTokenLimit: 128e3,
  defaultCharacterExtractionInstructions: `[CHARACTER UPDATE INSTRUCTIONS]
Goal: Update character notes from the provided passage only. Maintain canon from the story bible and existing character notes. Do not invent facts.

Focus on:
- Psychological/emotional reactions and development
- Motivations, fears, desires, internal conflicts
- Relationship dynamics and shifts
- Voice patterns, verbal tells, coping behaviors
- Arc progression and status changes

Rules:
- Evidence-based only: if it is not supported by the passage, omit it
- If uncertain, omit it
- Prefer concrete observations over summaries
- If no meaningful new info exists for a character, omit that character

Output format (required):
## Character Name
- Bullet updates only (no extra headings)
`,
  retrievalExcludedFolders: ["Templates"],
  retrievalEnableSemanticIndex: true,
  retrievalTopK: 24,
  retrievalChunkWords: 500,
  retrievalChunkOverlapWords: 100,
  retrievalChunkHeadingLevel: "h1",
  retrievalIndexPaused: false,
  retrievalIndexState: {},
  retrievalEmbeddingBackend: "hash",
  retrievalEnableBm25: true,
  retrievalEnableReranker: false,
  retrievalSource: "local",
  externalEmbeddingsEnabled: false,
  // Default: disabled to prevent accidental API usage
  externalEmbeddingProvider: void 0,
  externalEmbeddingApiKey: void 0,
  externalEmbeddingModel: void 0,
  externalEmbeddingApiUrl: void 0,
  externalEmbeddingUseBatch: false,
  generationLogsFolder: "",
  generationLogsEnabled: false,
  generationLogsIncludePrompt: false,
  modeState: {
    chapter: {
      sceneSummary: "",
      rewriteInstructions: "",
      minWords: 2e3,
      maxWords: 6e3
    },
    microEdit: {
      selectedPassage: "",
      grievances: ""
    },
    characterUpdate: {
      selectedText: "",
      extractionInstructions: ""
    },
    continuityCheck: {
      draftText: "",
      focus: { knowledge: true, timeline: true, pov: true, naming: true }
    }
  },
  retrievalProfiles: [],
  retrievalActiveProfileId: "story",
  setupCompleted: false,
  guidedDemoDismissed: false,
  guidedDemoShownOnce: false,
  fileState: {},
  smartConnectionsCacheEnabled: false,
  smartConnectionsCacheTTL: void 0,
  smartConnectionsAllowedFolders: [],
  smartConnectionsBlockedFolders: [],
  smartConnectionsMaxCaptureFiles: 200,
  smartConnectionsMaxScoreFiles: 50,
  smartConnectionsMaxContextChars: 3e4,
  smartConnectionsKeyingMode: "soft",
  smartConnectionsTemplatePath: void 0
  // User must configure template
};
var WritingDashboardPlugin = class extends import_obsidian29.Plugin {
  constructor() {
    super(...arguments);
    /**
     * When true, the next time the dashboard UI mounts it will start the guided demo flow.
     * This avoids wiring additional cross-component state management.
     */
    this.guidedDemoStartRequested = false;
    /**
     * Tracks the last markdown file the user opened in Obsidian.
     * Used for actions like "Chunk Selected File" so users don't need to keep updating settings.
     */
    this.lastOpenedMarkdownPath = null;
  }
  notifyUi(eventName) {
    try {
      window.dispatchEvent(new CustomEvent(eventName));
    } catch {
    }
  }
  async onload() {
    await this.loadSettings();
    this.registerEvent(
      this.app.workspace.on("file-open", (file) => {
        if (file && file.extension === "md") {
          this.lastOpenedMarkdownPath = file.path;
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", async (file, oldPath) => {
        const oldNorm = oldPath.replace(/\\/g, "/");
        const newNorm = file.path.replace(/\\/g, "/");
        let changed = false;
        const logsFolder = (this.settings.generationLogsFolder || "").replace(/\\/g, "/").replace(/\/+$/, "");
        if (logsFolder && file instanceof import_obsidian29.TFolder && oldNorm === logsFolder) {
          this.settings.generationLogsFolder = newNorm;
          changed = true;
        }
        if (!(file instanceof import_obsidian29.TFile) || file.extension !== "md") {
          if (changed)
            await this.saveSettings();
          return;
        }
        if (this.lastOpenedMarkdownPath === oldPath) {
          this.lastOpenedMarkdownPath = file.path;
          changed = true;
        }
        if (this.settings.book2Path === oldPath) {
          this.settings.book2Path = file.path;
          changed = true;
        }
        if (this.settings.fileState?.[oldPath]) {
          this.settings.fileState[file.path] = {
            ...this.settings.fileState[file.path] || {},
            ...this.settings.fileState[oldPath]
          };
          delete this.settings.fileState[oldPath];
          changed = true;
        }
        if (changed)
          await this.saveSettings();
      })
    );
    if (!this.settings.vaultPath) {
      this.settings.vaultPath = this.app.vault.adapter.basePath || "";
      await this.saveSettings();
    }
    this.vaultService = new VaultService(this.app.vault, this);
    this.app.workspace.onLayoutReady(() => {
      setTimeout(() => {
        this.templateProcessorInstance = new TemplateProcessor(this.app, this);
        console.log("[WritingDashboard] \u2705 TemplateProcessor initialized after plugin system");
      }, 2e3);
    });
    this.contextAggregator = new ContextAggregator(this.app.vault, this, this.vaultService);
    this.promptEngine = new PromptEngine();
    this.aiClient = new AIClient();
    this.characterExtractor = new CharacterExtractor();
    this.queryBuilder = new QueryBuilder();
    this.embeddingsIndex = new EmbeddingsIndex(this.app.vault, this);
    this.bm25Index = new Bm25Index(this.app.vault, this);
    this.cpuReranker = new CpuReranker();
    this.generationLogService = new GenerationLogService(this.app, this);
    const scProvider = new SmartConnectionsProvider(this.app, this, this.app.vault, (path) => !this.vaultService.isExcludedPath(path));
    this.smartConnectionsProvider = scProvider;
    const providers = [
      new HeuristicProvider(this.app.vault, this.vaultService),
      new Bm25Provider(this.bm25Index, () => Boolean(this.settings.retrievalEnableBm25), (path) => !this.vaultService.isExcludedPath(path)),
      scProvider
    ];
    if (this.settings.externalEmbeddingsEnabled && this.settings.externalEmbeddingProvider && this.settings.externalEmbeddingApiKey) {
      providers.push(
        new ExternalEmbeddingsProvider(
          this,
          this.embeddingsIndex,
          this.bm25Index,
          () => Boolean(this.settings.externalEmbeddingsEnabled && this.settings.externalEmbeddingProvider && this.settings.externalEmbeddingApiKey),
          (path) => !this.vaultService.isExcludedPath(path)
        )
      );
    } else {
      providers.push(
        new LocalEmbeddingsProvider(
          this.embeddingsIndex,
          () => Boolean(this.settings.retrievalEnableSemanticIndex),
          (path) => !this.vaultService.isExcludedPath(path)
        )
      );
    }
    this.retrievalService = new RetrievalService(providers, { getVector: (key) => this.embeddingsIndex.getVectorForKey(key) });
    const maybeQueueIndex = (path) => {
      if (this.settings.retrievalIndexPaused)
        return;
      if (this.vaultService.isExcludedPath(path))
        return;
      if (this.settings.retrievalEnableSemanticIndex)
        this.embeddingsIndex.queueUpdateFile(path);
      if (this.settings.retrievalEnableBm25)
        this.bm25Index.queueUpdateFile(path);
    };
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (file instanceof import_obsidian29.TFile && file.extension === "md") {
          maybeQueueIndex(file.path);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (file instanceof import_obsidian29.TFile && file.extension === "md") {
          maybeQueueIndex(file.path);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", (file) => {
        if (file instanceof import_obsidian29.TFile && file.extension === "md") {
          this.embeddingsIndex.queueRemoveFile(file.path);
          this.bm25Index.queueRemoveFile(file.path);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (!(file instanceof import_obsidian29.TFile) || file.extension !== "md")
          return;
        this.embeddingsIndex.queueRemoveFile(oldPath);
        this.bm25Index.queueRemoveFile(oldPath);
        maybeQueueIndex(file.path);
      })
    );
    if (this.settings.retrievalEnableSemanticIndex && !this.settings.retrievalIndexPaused) {
      this.embeddingsIndex.enqueueFullRescan();
    }
    if (this.settings.retrievalEnableBm25 && !this.settings.retrievalIndexPaused) {
      this.bm25Index.enqueueFullRescan();
    }
    this.registerView(
      VIEW_TYPE_DASHBOARD,
      (leaf) => new DashboardView(leaf, this)
    );
    this.addRibbonIcon("book-open", "Open dashboard", () => {
      void this.activateView();
    });
    this.addSettingTab(new SettingsTab(this.app, this));
    this.addCommand({
      id: "open-dashboard",
      name: "Open dashboard",
      callback: () => {
        void this.activateView();
      }
    });
    this.addCommand({
      id: "run-setup-wizard",
      name: "Run setup wizard",
      callback: () => {
        this.showSetupWizard();
      }
    });
    this.addCommand({
      id: "run-guided-demo",
      name: "Run guided demo",
      callback: () => {
        this.requestGuidedDemoStart();
      }
    });
    this.addCommand({
      id: "export-to-epub",
      name: "Export to epub",
      callback: () => {
        this.showPublishWizard();
      }
    });
    if (!this.settings.setupCompleted) {
      const bookMainExists = this.app.vault.getAbstractFileByPath(this.settings.book2Path) !== null;
      if (!bookMainExists) {
        const mdFiles = this.app.vault.getMarkdownFiles();
        if (mdFiles.length > 0) {
          const modal = new BookMainSelectorModal(this);
          modal.open();
        } else {
          this.showSetupWizard();
        }
      } else {
        this.settings.setupCompleted = true;
        await this.saveSettings();
      }
    }
  }
  showSetupWizard() {
    const modal = new SetupWizardModal(this);
    modal.open();
  }
  showPublishWizard() {
    const modal = new PublishWizardModal(this);
    modal.open();
  }
  /**
   * Recreate the retrieval service with the current settings.
   * Called when retrievalSource or other retrieval settings change.
   */
  recreateRetrievalService() {
    const scProvider = new SmartConnectionsProvider(this.app, this, this.app.vault, (path) => !this.vaultService.isExcludedPath(path));
    this.smartConnectionsProvider = scProvider;
    const providers = [
      new HeuristicProvider(this.app.vault, this.vaultService),
      new Bm25Provider(this.bm25Index, () => Boolean(this.settings.retrievalEnableBm25), (path) => !this.vaultService.isExcludedPath(path)),
      scProvider
    ];
    if (this.settings.externalEmbeddingsEnabled && this.settings.externalEmbeddingProvider && this.settings.externalEmbeddingApiKey) {
      providers.push(
        new ExternalEmbeddingsProvider(
          this,
          this.embeddingsIndex,
          this.bm25Index,
          () => Boolean(this.settings.externalEmbeddingsEnabled && this.settings.externalEmbeddingProvider && this.settings.externalEmbeddingApiKey),
          (path) => !this.vaultService.isExcludedPath(path)
        )
      );
    }
    if (this.settings.retrievalSource === "external-api") {
    } else {
      providers.push(
        new LocalEmbeddingsProvider(
          this.embeddingsIndex,
          () => Boolean(this.settings.retrievalEnableSemanticIndex),
          (path) => !this.vaultService.isExcludedPath(path)
        )
      );
    }
    this.retrievalService = new RetrievalService(providers, { getVector: (key) => this.embeddingsIndex.getVectorForKey(key) });
  }
  requestGuidedDemoStart() {
    this.guidedDemoStartRequested = true;
    this.notifyUi("writing-dashboard:guided-demo-start");
    void this.activateView();
  }
  async onunload() {
  }
  async loadSettings() {
    const loaded = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loaded || {});
    if (!this.settings.modeState) {
      this.settings.modeState = DEFAULT_SETTINGS.modeState;
    } else {
      this.settings.modeState = {
        ...DEFAULT_SETTINGS.modeState,
        ...this.settings.modeState,
        chapter: { ...DEFAULT_SETTINGS.modeState.chapter, ...this.settings.modeState.chapter || {} },
        microEdit: { ...DEFAULT_SETTINGS.modeState.microEdit, ...this.settings.modeState.microEdit || {} },
        characterUpdate: { ...DEFAULT_SETTINGS.modeState.characterUpdate, ...this.settings.modeState.characterUpdate || {} },
        continuityCheck: {
          ...DEFAULT_SETTINGS.modeState.continuityCheck,
          ...this.settings.modeState.continuityCheck || {},
          focus: {
            ...DEFAULT_SETTINGS.modeState.continuityCheck.focus,
            ...(this.settings.modeState.continuityCheck || {}).focus || {}
          }
        }
      };
    }
    if (!Array.isArray(this.settings.retrievalProfiles) || this.settings.retrievalProfiles.length === 0) {
      const parentOf = (p) => {
        const norm = (p || "").replace(/\\/g, "/");
        const idx = norm.lastIndexOf("/");
        return idx >= 0 ? norm.slice(0, idx) : "";
      };
      const storyFolders = /* @__PURE__ */ new Set();
      if (this.settings.characterFolder)
        storyFolders.add(this.settings.characterFolder);
      const bookParent = parentOf(this.settings.book2Path);
      if (bookParent)
        storyFolders.add(bookParent);
      const bibleParent = parentOf(this.settings.storyBiblePath);
      if (bibleParent)
        storyFolders.add(bibleParent);
      const storyIncluded = Array.from(storyFolders).map((s) => (s || "").replace(/\/+$/, "")).filter((s) => s.length > 0);
      this.settings.retrievalProfiles = [
        { id: "story", name: "Story", includedFolders: storyIncluded.length > 0 ? storyIncluded : [] },
        { id: "research", name: "Research", includedFolders: ["Research", "Worldbuilding"] },
        { id: "manuscript", name: "Manuscript only", includedFolders: bookParent ? [bookParent] : [] }
      ];
      this.settings.retrievalActiveProfileId = "story";
    }
    const hasActive = this.settings.retrievalProfiles.some((p) => p.id === this.settings.retrievalActiveProfileId);
    if (!hasActive)
      this.settings.retrievalActiveProfileId = this.settings.retrievalProfiles[0]?.id || "story";
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.notifyUi("writing-dashboard:settings-changed");
  }
  /**
   * Auto-generate Smart Connections template file if it doesn't exist.
   * Creates the template in a visible root-level folder.
   * Returns the path to the template file.
   */
  async ensureSmartConnectionsTemplate() {
    const templatesFolder = "Writing Dashboard Templates";
    await this.vaultService.createFolderIfNotExists(templatesFolder);
    const templatePath = `${templatesFolder}/SC-Template.md`;
    const templateFile = this.app.vault.getAbstractFileByPath(templatePath);
    if (!(templateFile instanceof import_obsidian29.TFile)) {
      const templateContent = "{{smart-connections:similar:128}}";
      await this.vaultService.writeFile(templatePath, templateContent);
      this.settings.smartConnectionsTemplatePath = templatePath;
      await this.saveSettings();
    }
    return templatePath;
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_DASHBOARD)[0];
    if (!leaf) {
      leaf = workspace.getRightLeaf(false);
      await leaf.setViewState({ type: VIEW_TYPE_DASHBOARD, active: true });
    }
    workspace.revealLeaf(leaf);
  }
};
/*!
* ONNX Runtime Web v1.14.0
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/
/*! Bundled license information:

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   *)

jszip/dist/jszip.min.js:
  (*!
  
  JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  <http://stuartk.com/jszip>
  
  (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  JSZip uses the library pako released under the MIT license :
  https://github.com/nodeca/pako/blob/main/LICENSE
  *)
*/
